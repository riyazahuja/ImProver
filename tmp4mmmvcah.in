{"cmd": "/- Copyright 2023 Daniel J. Velleman -/\n\nimport HTPILib.Chap7\nset_option linter.style.longFile 0\nnamespace HTPI\n\n/- Definitions -/\ndef fnz (n : Nat) : Int := if 2 \u2223 n then \u2191(n / 2) else -\u2191((n + 1) / 2)\n\ndef fzn (a : Int) : Nat := if a \u2265 0 then 2 * Int.toNat a else 2 * Int.toNat (-a) - 1\n\ndef tri (k : Nat) : Nat := k * (k + 1) / 2\n\ndef fnnn (p : Nat \u00d7 Nat) : Nat := tri (p.1 + p.2) + p.1\n\ndef num_elts_below (A : Set Nat) (m s : Nat) : Prop :=\n  match m with\n    | 0 => s = 0\n    | n + 1 => (n \u2208 A \u2227 1 \u2264 s \u2227 num_elts_below A n (s - 1)) \u2228\n                (n \u2209 A \u2227 num_elts_below A n s)\n\ndef enum (A : Set Nat) (s n : Nat) : Prop := n \u2208 A \u2227 num_elts_below A n s\n\ndef unique_val_on_N {U : Type} (R : Rel Nat U) : Prop :=\n  \u2200 \u2983n : Nat\u2984 \u2983x1 x2 : U\u2984, R n x1 \u2192 R n x2 \u2192 x1 = x2\n\ndef nat_rel_onto {U : Type} (R : Rel Nat U) (A : Set U) : Prop :=\n  \u2200 \u2983x : U\u2984, x \u2208 A \u2192 \u2203 (n : Nat), R n x\n\ndef fcnl_onto_from_nat {U : Type} (R : Rel Nat U) (A : Set U) : Prop :=\n  unique_val_on_N R \u2227 nat_rel_onto R A\n\ndef fcnl_one_one_to_nat {U : Type} (R : Rel U Nat) (A : Set U) : Prop :=\n  fcnl_on R A \u2227 \u2200 \u2983x1 x2 : U\u2984 \u2983n : Nat\u2984,\n    (x1 \u2208 A \u2227 R x1 n) \u2192 (x2 \u2208 A \u2227 R x2 n) \u2192 x1 = x2\n\ndef least_rel_to {U : Type} (S : Rel Nat U) (x : U) (n : Nat) : Prop :=\n  S n x \u2227 \u2200 (m : Nat), S m x \u2192 n \u2264 m\n\ndef restrict_to {U V : Type} (S : Rel U V) (A : Set U)\n  (x : U) (y : V) : Prop := x \u2208 A \u2227 S x y\n\ndef fqn (q : Rat) : Nat := fnnn (fzn q.num, q.den)\n\ndef Set_rp_below (m : Nat) : Set Nat := {n : Nat | rel_prime m n \u2227 n < m}\n\ndef Set_prod {U V : Type} (A : Set U) (B : Set V) : Set (U \u00d7 V) :=\n  {(a, b) : U \u00d7 V | a \u2208 A \u2227 b \u2208 B}\n\nnotation:75 A:75 \" \u00d7\u209b \" B:75 => Set_prod A B\n\ndef Rel_prod {U V W X : Type} (R : Rel U V) (S : Rel W X)\n  (p : U \u00d7 W) (q : V \u00d7 X) : Prop := R p.1 q.1 \u2227 S p.2 q.2\n\nnotation:75 R:75 \" \u00d7\u1d63 \" S:75 => Rel_prod R S\n\ndef qr (n a : Nat) : Nat \u00d7 Nat := (a / n, a % n)\n\ndef mod_mod (m n a : Nat) : Nat \u00d7 Nat := (a % m, a % n)\n\ndef enum_union_fam {U : Type}\n  (F : Set (Set U)) (f : Set U \u2192 Rel Nat U) (R : Rel Nat (Set U))\n  (n : Nat) (a : U) : Prop := \u2203 (p : Nat \u00d7 Nat), fnnn p = n \u2227\n    \u2203 A \u2208 F, R p.1 A \u2227 (f A) p.2 a\n\ndef seq {U : Type} (A : Set U) : Set (List U) :=\n  {l : List U | \u2200 x \u2208 l, x \u2208 A}\n\ndef seq_by_length {U : Type} (A : Set U) (n : Nat) : Set (List U) :=\n  {l : List U | l \u2208 seq A \u2227 l.length = n}\n\ndef seq_cons (U : Type) (p : U \u00d7 (List U)) : List U := p.1 :: p.2\n\ndef sbl_set {U : Type} (A : Set U) : Set (Set (List U)) :=\n  {S : Set (List U) | \u2203 (n : Nat), seq_by_length A n = S}\n\ndef rep_common_image\n  {U V : Type} (R S : Rel U V) (X0 : Set U) (n : Nat) : Set U :=\n  match n with\n    | 0 => X0\n    | m + 1 => {a : U | \u2203 x \u2208 rep_common_image R S X0 m,\n                          \u2203 (y : V), R x y \u2227 S a y}\n\ndef cum_rep_image {U V : Type} (R S : Rel U V) (X0 : Set U) : Set U :=\n  {a : U | \u2203 (n : Nat), a \u2208 rep_common_image R S X0 n}\n\ndef csb_match {U V : Type} (R S : Rel U V) (X0 : Set U)\n  (x : U) (y : V) : Prop := x \u2208 cum_rep_image R S X0 \u2227 R x y \u2228\n    x \u2209 cum_rep_image R S X0 \u2227 S x y\n\n/- Section 8.1 -/\n#eval [fnz 0, fnz 1, fnz 2, fnz 3, fnz 4, fnz 5, fnz 6]\n  --Answer: [0, -1, 1, -2, 2, -3, 3]\n\n#eval [fzn 0, fzn (-1), fzn 1, fzn (-2), fzn 2, fzn (-3), fzn 3]\n  --Answer: [0, 1, 2, 3, 4, 5, 6]\n"}

{"cmd": "lemma fnz_even (k : Nat) : fnz (2 * k) = \u2191k := by\n  have h1 : 2 \u2223 2 * k := by\n    apply Exists.intro k\n    rfl\n    done\n  have h2 : fnz (2 * k) = if 2 \u2223 2 * k then \u2191(2 * k / 2)\n    else -\u2191((2 * k + 1) / 2) := by rfl\n  rewrite [if_pos h1] at h2  --h2 : fnz (2 * k) = \u2191(2 * k / 2)\n  have h3 : 0 < 2 := by linarith\n  rewrite [Nat.mul_div_cancel_left k h3] at h2\n  show fnz (2 * k) = \u2191k from h2\n  done\n\nlemma fnz_odd (k : Nat) : fnz (2 * k + 1) = -\u2191(k + 1) := sorry\n\nlemma fzn_nat (k : Nat) : fzn \u2191k = 2 * k := by rfl\n\nlemma fzn_neg_succ_nat (k : Nat) : fzn (-\u2191(k + 1)) = 2 * k + 1 := by rfl\n\n--From exercises of Section 6.1\ntheorem Exercise_6_1_16a1 : \u2200 (n : Nat), nat_even n \u2228 nat_odd n := sorry\n\nlemma fzn_fnz : fzn \u2218 fnz = id := by\n  apply funext        --Goal : \u2200 (x : Nat), (fzn \u2218 fnz) x = id x\n  fix n : Nat\n  rewrite [comp_def]  --Goal : fzn (fnz n) = id n\n  have h1 : nat_even n \u2228 nat_odd n := Exercise_6_1_16a1 n\n  by_cases on h1\n  \u00b7 -- Case 1. h1 : nat_even n\n    obtain (k : Nat) (h2 : n = 2 * k) from h1\n    rewrite [h2, fnz_even, fzn_nat]\n    rfl\n    done\n  \u00b7 -- Case 2. h1 : nat_odd n\n    obtain (k : Nat) (h2 : n = 2 * k + 1) from h1\n    rewrite [h2, fnz_odd, fzn_neg_succ_nat]\n    rfl\n    done\n  done\n\nlemma fnz_fzn : fnz \u2218 fzn = id  := sorry\n\nlemma fzn_one_one : one_to_one fzn := Theorem_5_3_3_1 fzn fnz fnz_fzn\n\nlemma fzn_onto : onto fzn := Theorem_5_3_3_2 fzn fnz fzn_fnz\n\nlemma fnz_one_one : one_to_one fnz := Theorem_5_3_3_1 fnz fzn fzn_fnz\n\nlemma fnz_onto : onto fnz := Theorem_5_3_3_2 fnz fzn fnz_fzn\n\nlemma fnnn_def (a b : Nat) : fnnn (a, b) = tri (a + b) + a := by rfl\n\n#eval [fnnn (0, 0), fnnn (0, 1), fnnn (1, 0), fnnn (0, 2), fnnn (1, 1)]\n  --Answer: [0, 1, 2, 3, 4]\n\nlemma tri_step (k : Nat) : tri (k + 1) = tri k + k + 1 := sorry\n\nlemma tri_incr {j k : Nat} (h1 : j \u2264 k) : tri j \u2264 tri k := sorry\n\nlemma le_of_fnnn_eq {a1 b1 a2 b2 : Nat}\n    (h1 : fnnn (a1, b1) = fnnn (a2, b2)) : a1 + b1 \u2264 a2 + b2 := by\n  by_contra h2\n  have h3 : a2 + b2 + 1 \u2264 a1 + b1 := by linarith\n  have h4 : fnnn (a2, b2) < fnnn (a1, b1) :=\n    calc fnnn (a2, b2)\n      _ = tri (a2 + b2) + a2 := by rfl\n      _ < tri (a2 + b2) + (a2 + b2) + 1 := by linarith\n      _ = tri (a2 + b2 + 1) := (tri_step _).symm\n      _ \u2264 tri (a1 + b1) := tri_incr h3\n      _ \u2264 tri (a1 + b1) + a1 := by linarith\n      _ = fnnn (a1, b1) := by rfl\n  linarith\n  done\n\nlemma fnnn_one_one : one_to_one fnnn := by\n  fix (a1, b1) : Nat \u00d7 Nat\n  fix (a2, b2) : Nat \u00d7 Nat\n  assume h1 : fnnn (a1, b1) = fnnn (a2, b2)  --Goal : (a1, b1) = (a2, b2)\n  have h2 : a1 + b1 \u2264 a2 + b2 := le_of_fnnn_eq h1\n  have h3 : a2 + b2 \u2264 a1 + b1 := le_of_fnnn_eq h1.symm\n  have h4 : a1 + b1 = a2 + b2 := by linarith\n  rewrite [fnnn_def, fnnn_def, h4] at h1\n    --h1 : tri (a2 + b2) + a1 = tri (a2 + b2) + a2\n  have h6 : a1 = a2 := Nat.add_left_cancel h1\n  rewrite [h6] at h4   --h4 : a2 + b1 = a2 + b2\n  have h7 : b1 = b2 := Nat.add_left_cancel h4\n  rewrite [h6, h7]\n  rfl\n  done\n\nlemma fnnn_onto : onto fnnn := by\n  define  --Goal : \u2200 (y : Nat), \u2203 (x : Nat \u00d7 Nat), fnnn x = y\n  by_induc\n  \u00b7 -- Base Case\n    apply Exists.intro (0, 0)\n    rfl\n    done\n  \u00b7 -- Induction Step\n    fix n : Nat\n    assume ih : \u2203 (x : Nat \u00d7 Nat), fnnn x = n\n    obtain ((a, b) : Nat \u00d7 Nat) (h1 : fnnn (a, b) = n) from ih\n    by_cases h2 : b = 0\n    \u00b7 -- Case 1. h2 : b = 0\n      apply Exists.intro (0, a + 1)\n      show fnnn (0, a + 1) = n + 1 from\n        calc fnnn (0, a + 1)\n          _ = tri (0 + (a + 1)) + 0 := by rfl\n          _ = tri (a + 1) := by ring\n          _ = tri a + a + 1 := tri_step a\n          _ = tri (a + 0) + a + 1 := by ring\n          _ = fnnn (a, b) + 1 := by rw [h2, fnnn_def]\n          _ = n + 1 := by rw [h1]\n      done\n    \u00b7 -- Case 2. h2 : b \u2260 0\n      obtain (k : Nat) (h3 : b = k + 1) from\n        exists_eq_add_one_of_ne_zero h2\n      apply Exists.intro (a + 1, k)\n      show fnnn (a + 1, k) = n + 1 from\n        calc fnnn (a + 1, k)\n          _ = tri (a + 1 + k) + (a + 1) := by rfl\n          _ = tri (a + (k + 1)) + a + 1 := by ring\n          _ = tri (a + b) + a + 1 := by rw [h3]\n          _ = fnnn (a, b) + 1 := by rfl\n          _ = n + 1 := by rw [h1]\n      done\n    done\n  done\n\nlemma one_one_on_of_one_one {U V : Type} {f : U \u2192 V}\n    (h : one_to_one f) (A : Set U) : one_one_on f A := by\n  define\n  fix x1 : U; fix x2 : U\n  assume h1 : x1 \u2208 A\n  assume h2 : x2 \u2208 A\n  show f x1 = f x2 \u2192 x1 = x2 from h x1 x2\n  done\n\nlemma elt_Univ {U : Type} (u : U) :\n    u \u2208 Univ U := by trivial\n\ntheorem equinum_Univ {U V : Type} {f : U \u2192 V}\n    (h1 : one_to_one f) (h2 : onto f) : Univ U \u223c Univ V := by\n  have h3 : image f (Univ U) = Univ V := by\n    apply Set.ext\n    fix v : V\n    apply Iff.intro\n    \u00b7 -- (\u2192)\n      assume h3 : v \u2208 image f (Univ U)\n      show v \u2208 Univ V from elt_Univ v\n      done\n    \u00b7 -- (\u2190)\n      assume h3 : v \u2208 Univ V\n      obtain (u : U) (h4 : f u = v) from h2 v\n      apply Exists.intro u\n      apply And.intro _ h4\n      show u \u2208 Univ U from elt_Univ u\n      done\n    done\n  show Univ U \u223c Univ V from\n    equinum_image (one_one_on_of_one_one h1 (Univ U)) h3\n  done\n\ntheorem Z_equinum_N : Univ Int \u223c Univ Nat :=\n  equinum_Univ fzn_one_one fzn_onto\n\ntheorem NxN_equinum_N : Univ (Nat \u00d7 Nat) \u223c Univ Nat :=\n  equinum_Univ fnnn_one_one fnnn_onto\n\nlemma neb_step (A : Set Nat) (n s : Nat) : num_elts_below A (n + 1) s \u2194\n    (n \u2208 A \u2227 1 \u2264 s \u2227 num_elts_below A n (s - 1)) \u2228\n      (n \u2209 A \u2227 num_elts_below A n s) := by rfl\n\n\nlemma neb_step_elt {A : Set Nat} {n : Nat} (h1 : n \u2208 A) (s : Nat) :\n    num_elts_below A (n + 1) s \u2194 1 \u2264 s \u2227 num_elts_below A n (s - 1)  := by\n  rw [neb_step]\n  constructor\n  intro h2; exact h2.resolve_right (not_and_of_not_left _ h1)\n  intro h2; exact Or.inl \u27e8h1, h2\u27e9\n", "allTactics": true, "theorems": true, "env": 0}