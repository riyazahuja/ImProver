{"cmd": "import Carleson.WeakType\nimport Mathlib.Analysis.SpecialFunctions.ImproperIntegrals\n\n/-! This file contains a proof of the Marcinkiewisz real interpolation theorem.\n    The proof roughly follows Folland, Real Analysis. Modern Techniques and Their Applications,\n    section 6.4, theorem 6.28, but a different truncation is used, and some estimates instead\n    follow the technique as e.g. described in [Duoandikoetxea, Fourier Analysis, 2000].\n\n    The file consists of the following sections:\n    - Convenience results for working with (interpolated) exponents\n    - Results about the particular choice of exponent\n    - Interface for using cutoff functions\n    - Results about the particular choice of scale\n    - Some tools for measure theory computations\n    - Results about truncations of a function\n    - Measurability properties of truncations\n    - Truncations and Lp spaces\n    - Some results about the integrals of truncations\n    - Minkowski's integral inequality\n    - Apply Minkowski's integral inequality to truncations\n    - Weaktype estimates applied to truncations\n    - Definitions\n    - Proof of the real interpolation theorem\n-/\n\nnoncomputable section\n\nopen ENNReal Real Set MeasureTheory\n\n-- Note (F): can we make `t : \u211d\u22650\u221e` for a large part of the proof?\nvariable {p\u2080 q\u2080 p\u2081 q\u2081 p q : \u211d\u22650\u221e} {t : \u211d}\n\n/-! ## Convenience results for working with (interpolated) exponents\n-/\nnamespace ComputationsInterpolatedExponents\n\n-- unused\nlemma ofReal_mem_Ioo_0_1 (h : t \u2208 Ioo 0 1) : ENNReal.ofReal t \u2208 Ioo 0 1 :=\n  \u27e8ofReal_pos.mpr h.1, ofReal_lt_one.mpr h.2\u27e9\n"}

{"cmd": "lemma ENNReal_preservation_positivity\u2080 (ht : t \u2208 Ioo 0 1) (hpq : p \u2260 \u22a4 \u2228 q \u2260 \u22a4) :\n    0 < (1 - ENNReal.ofReal t) * p\u207b\u00b9 + ENNReal.ofReal t * q\u207b\u00b9 := by\n  have t_mem : ENNReal.ofReal t \u2208 Ioo 0 1 :=\n    \u27e8ofReal_pos.mpr ht.1, ENNReal.ofReal_one \u25b8 (ofReal_lt_ofReal_iff zero_lt_one).mpr ht.2\u27e9\n  obtain dir|dir := hpq\n  \u00b7 exact Left.add_pos_of_pos_of_nonneg (mul_pos ((tsub_pos_of_lt t_mem.2).ne')\n      (ENNReal.inv_ne_zero.mpr dir)) (zero_le _)\n  \u00b7 exact Right.add_pos_of_nonneg_of_pos (zero_le _)\n      (mul_pos ((ofReal_pos.mpr ht.1).ne') (ENNReal.inv_ne_zero.mpr dir))\n\nlemma ENNReal_preservation_positivity (ht : t \u2208 Ioo 0 1) (hpq : p \u2260 q) :\n    0 < (1 - ENNReal.ofReal t) * p\u207b\u00b9 + ENNReal.ofReal t * q\u207b\u00b9 := by\n  apply ENNReal_preservation_positivity\u2080 ht\n  cases (lt_or_gt_of_ne hpq) <;> exact Ne.ne_or_ne \u22a4 hpq\n\nlemma ENNReal_preservation_positivity' (hp\u2080 : p\u2080 > 0) (hp\u2081 : p\u2081 > 0)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9) : p > 0 := by\n  rw [\u2190 inv_inv p, hp]\n  simp [ENNReal.mul_eq_top, sub_eq_zero, hp\u2080.ne', hp\u2081.ne']\n\nlemma interp_exp_ne_top (hp\u2080p\u2081 : p\u2080 \u2260 p\u2081) (ht : t \u2208 Ioo 0 1)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9) : p \u2260 \u22a4 :=\n  ENNReal.inv_ne_zero.mp <| hp \u25b8 (ENNReal_preservation_positivity ht hp\u2080p\u2081).ne'\n\nlemma interp_exp_ne_top' (hp\u2080p\u2081 : p\u2080 \u2260 \u22a4 \u2228 p\u2081 \u2260 \u22a4) (ht : t \u2208 Ioo 0 1)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9) : p \u2260 \u22a4 :=\n  ENNReal.inv_ne_zero.mp (hp \u25b8 (ENNReal_preservation_positivity\u2080 ht hp\u2080p\u2081).ne')\n\nlemma interp_exp_eq (hp\u2080p\u2081 : p\u2080 = p\u2081)\n    (ht : t \u2208 Ioo 0 1)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9) :\n    p\u2080 = p := by\n  rw [\u2190 inv_inv (a := p), hp, \u2190 hp\u2080p\u2081, \u2190 add_mul,\n    tsub_add_cancel_of_le <| ofReal_lt_one.mpr ht.2 |>.le, one_mul, inv_inv]\n\nlemma interp_exp_lt_top (hp\u2080p\u2081 : p\u2080 \u2260 p\u2081)\n    (ht : t \u2208 Ioo 0 1)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9) : p < \u22a4 :=\n  Ne.lt_top <| interp_exp_ne_top hp\u2080p\u2081 ht hp\n\nlemma interp_exp_lt_top' (hp\u2080p\u2081 : p\u2080 \u2260 \u22a4 \u2228 p\u2081 \u2260 \u22a4)\n    (ht : t \u2208 Ioo 0 1)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9) : p < \u22a4 :=\n  Ne.lt_top <| interp_exp_ne_top' hp\u2080p\u2081 ht hp\n\nlemma interp_exp_between (hp\u2080 : p\u2080 > 0) (hp\u2081 : p\u2081 > 0)\n    (hp\u2080p\u2081 : p\u2080 < p\u2081) (ht : t \u2208 Ioo 0 1)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9) : p \u2208 Ioo p\u2080 p\u2081 := by\n  refine \u27e8?_, ?_\u27e9 <;> apply ENNReal.inv_lt_inv.mp\n  \u00b7 rw [hp]\n    have : p\u2080\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2080\u207b\u00b9 := by\n      rw [\u2190 add_mul, tsub_add_eq_max, max_eq_left_of_lt, one_mul]\n      exact ofReal_lt_one.mpr ht.2\n    nth_rw 2 [this]\n    gcongr\n    \u00b7 exact mul_ne_top (sub_ne_top top_ne_one.symm) (inv_ne_top.mpr hp\u2080.ne')\n    \u00b7 exact (ofReal_pos.mpr ht.1).ne'\n    \u00b7 exact coe_ne_top\n  \u00b7 rw [hp]\n    have : p\u2081\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2081\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9 := by\n      rw [\u2190 add_mul, tsub_add_eq_max, max_eq_left_of_lt, one_mul]\n      exact ofReal_lt_one.mpr ht.2\n    nth_rw 1 [this]\n    gcongr\n    \u00b7 exact mul_ne_top coe_ne_top (inv_ne_top.mpr hp\u2081.ne')\n    \u00b7 exact (tsub_pos_iff_lt.mpr (ofReal_lt_one.mpr ht.2)).ne'\n    \u00b7 exact coe_ne_top\n\nlemma one_le_interp_exp_aux (hp\u2080 : 1 \u2264 p\u2080) (hp\u2081 : 1 \u2264 p\u2081) (hp\u2080p\u2081 : p\u2080 < p\u2081) (ht : t \u2208 Ioo 0 1)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9) : 1 \u2264 p :=\n  hp\u2080.trans_lt\n    (interp_exp_between (zero_lt_one.trans_le hp\u2080) (zero_lt_one.trans_le hp\u2081) hp\u2080p\u2081 ht hp).1 |>.le\n\nlemma switch_exponents (ht : t \u2208 Ioo 0 1)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9) :\n    p\u207b\u00b9 = (1 - ENNReal.ofReal (1 - t)) * p\u2081\u207b\u00b9 + ENNReal.ofReal (1 - t) * p\u2080\u207b\u00b9 := by\n  rw [add_comm, \u2190 ofReal_one, \u2190 ofReal_sub, _root_.sub_sub_cancel, ofReal_sub _ ht.1.le, ofReal_one]\n  \u00b7 exact hp\n  \u00b7 exact (Ioo.one_sub_mem ht).1.le\n\nlemma one_le_toReal {a : \u211d\u22650\u221e} (ha\u2081 : 1 \u2264 a) (ha\u2082 : a < \u22a4) : 1 \u2264 a.toReal :=\n  toReal_mono ha\u2082.ne_top ha\u2081\n\nlemma one_le_interp (hp\u2080 : 1 \u2264 p\u2080) (hp\u2081 : 1 \u2264 p\u2081)\n    (hp\u2080p\u2081 : p\u2080 \u2260 p\u2081) (ht : t \u2208 Ioo 0 1)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9) : 1 \u2264 p := by\n  rcases (lt_or_gt_of_ne hp\u2080p\u2081) with p\u2080lt_p\u2081 | p\u2081lt_p\u2080\n  \u00b7 exact one_le_interp_exp_aux hp\u2080 hp\u2081 p\u2080lt_p\u2081 ht hp\n  \u00b7 exact one_le_interp_exp_aux hp\u2081 hp\u2080 p\u2081lt_p\u2080 (Ioo.one_sub_mem ht) (switch_exponents ht hp)\n\nlemma one_le_interp_toReal (hp\u2080 : 1 \u2264 p\u2080) (hp\u2081 : 1 \u2264 p\u2081)\n    (hp\u2080p\u2081 : p\u2080 \u2260 p\u2081) (ht : t \u2208 Ioo 0 1)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9) : 1 \u2264 p.toReal :=\n  one_le_toReal (one_le_interp hp\u2080 hp\u2081 hp\u2080p\u2081 ht hp) (Ne.lt_top (interp_exp_ne_top hp\u2080p\u2081 ht hp))\n\nlemma coe_rpow_ne_top {a : \u211d} {q : \u211d} (hq : q \u2265 0): ENNReal.ofReal a ^ q \u2260 \u22a4 :=\n  rpow_ne_top_of_nonneg hq coe_ne_top\n\n-- Note this lemma can directly be applied to elements of `\u211d\u22650` as well\nlemma coe_rpow_ne_top' {a : \u211d} {q : \u211d} (hq : 0 < q): ENNReal.ofReal a ^ q \u2260 \u22a4 :=\n  coe_rpow_ne_top hq.le\n\nlemma coe_pow_pos {a : \u211d} {q : \u211d} (ha : a > 0) : ENNReal.ofReal a ^ q > 0 :=\n  ENNReal.rpow_pos (ofReal_pos.mpr ha) coe_ne_top\n\nlemma rpow_ne_top' {a : \u211d\u22650\u221e} {q : \u211d} (ha : a \u2260 0) (ha' : a \u2260 \u22a4)  : a ^ q \u2260 \u22a4 := by\n  intro h\n  rcases ENNReal.rpow_eq_top_iff.mp h with \u27e8a_zero, _\u27e9 | \u27e8a_top, _\u27e9\n  \u00b7 exact (ha a_zero).elim\n  \u00b7 exact (ha' a_top).elim\n\nlemma exp_toReal_pos' {q : \u211d\u22650\u221e} (hq : q \u2265 1) (hq' : q < \u22a4) : q.toReal > 0 :=\n  toReal_pos (lt_of_lt_of_le zero_lt_one hq).ne' hq'.ne_top\n\nlemma ne_top_of_Ico {p q r : \u211d\u22650\u221e} (hq : q \u2208 Ico p r) : q \u2260 \u22a4 := hq.2.ne_top\n\nlemma lt_top_of_Ico {p q r : \u211d\u22650\u221e} (hq : q \u2208 Ico p r) : q < \u22a4 := (ne_top_of_Ico hq).lt_top\n\nlemma ne_top_of_Ioo {p q r : \u211d\u22650\u221e} (hq : q \u2208 Ioo p r) : q \u2260 \u22a4 := hq.2.ne_top\n\nlemma lt_top_of_Ioo {p q r : \u211d\u22650\u221e} (hq : q \u2208 Ioo p r) : q < \u22a4 := (ne_top_of_Ioo hq).lt_top\n\nlemma ne_top_of_Ioc {p q r : \u211d\u22650\u221e} (hq : q \u2208 Ioc p r) (hr : r < \u22a4) : q \u2260 \u22a4 :=\n  hq.2.trans_lt hr |>.ne_top\n\nlemma pos_of_rb_Ioc {p q r : \u211d\u22650\u221e} (hr : q \u2208 Ioc p r) : 0 < r :=\n  zero_le p |>.trans_lt hr.1 |>.trans_le hr.2\n\nlemma exp_toReal_ne_zero {q : \u211d\u22650\u221e} (hq : q \u2265 1) (hq' : q < \u22a4) : q.toReal \u2260 0 :=\n  (exp_toReal_pos' hq hq').ne'\n\n-- TODO: remove the top one?\nlemma exp_toReal_ne_zero' {q : \u211d\u22650\u221e} (hq : q > 0) (hq' : q \u2260 \u22a4) : q.toReal \u2260 0 :=\n  (toReal_pos hq.ne' hq').ne'\n\nlemma exp_toReal_ne_zero_of_Ico {q p : \u211d\u22650\u221e} (hq : q \u2208 Ico 1 p) : q.toReal \u2260 0 :=\n  exp_toReal_ne_zero hq.1 (lt_top_of_Ico hq)\n\nlemma pos_of_Ioo {p q r : \u211d\u22650\u221e} (hq : q \u2208 Ioo p r) : q > 0 := pos_of_gt hq.1\n\nlemma ne_zero_of_Ioo {p q r : \u211d\u22650\u221e} (hq : q \u2208 Ioo p r) : q \u2260 0 := (pos_of_gt hq.1).ne'\n\nlemma pos_of_Icc_1 {p q : \u211d\u22650\u221e} (hp : p \u2208 Icc 1 q) : p > 0 := lt_of_lt_of_le zero_lt_one hp.1\n\nlemma pos_of_ge_1 {p : \u211d\u22650\u221e} (hp : 1 \u2264 p) : p > 0 := lt_of_lt_of_le zero_lt_one hp\n\nlemma pos_rb_of_Icc_1_inh {p q : \u211d\u22650\u221e} (hp : p \u2208 Icc 1 q) : q > 0 :=\n  lt_of_lt_of_le zero_lt_one (le_trans hp.1 hp.2)\n\nlemma toReal_pos_of_Ioo {q p r : \u211d\u22650\u221e} (hp : p \u2208 Ioo q r) : p.toReal > 0 :=\n  toReal_pos (ne_zero_of_lt hp.1) hp.2.ne_top\n\nlemma toReal_ne_zero_of_Ioo {q p r : \u211d\u22650\u221e} (hp : p \u2208 Ioo q r) : p.toReal \u2260 0 :=\n  toReal_ne_zero.mpr \u27e8ne_zero_of_lt hp.1, hp.2.ne_top\u27e9\n\n-- TODO: check which ones are actually used\nlemma eq_of_rpow_eq (a b: \u211d\u22650\u221e) (c : \u211d) (hc : c \u2260 0) (h : a ^ c = b ^ c) : a = b := by\n  rw [\u2190 ENNReal.rpow_rpow_inv hc a, \u2190 ENNReal.rpow_rpow_inv hc b]\n  exact congrFun (congrArg HPow.hPow h) c\u207b\u00b9\n\nlemma le_of_rpow_le {a b: \u211d\u22650\u221e} {c : \u211d} (hc : c > 0) (h : a ^ c \u2264 b ^ c) : a \u2264 b := by\n  rw [\u2190 ENNReal.rpow_rpow_inv hc.ne' a, \u2190 ENNReal.rpow_rpow_inv hc.ne' b]\n  exact (ENNReal.rpow_le_rpow_iff (inv_pos_of_pos hc)).mpr h\n\n-- TODO : decide if this is wanted\n-- local instance : Coe \u211d \u211d\u22650\u221e where\n--   coe x := ENNReal.ofReal x\n\nlemma coe_inv_exponent (hp\u2080 : p\u2080 > 0) : ENNReal.ofReal (p\u2080\u207b\u00b9.toReal) = p\u2080\u207b\u00b9 :=\n  ofReal_toReal_eq_iff.mpr (inv_ne_top.mpr hp\u2080.ne')\n\nlemma inv_of_interpolated_pos' (hp\u2080p\u2081 : p\u2080 \u2260 p\u2081) (ht : t \u2208 Ioo 0 1)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9) : 0 < p\u207b\u00b9 :=\n  ENNReal.inv_pos.mpr (interp_exp_ne_top hp\u2080p\u2081 ht hp)\n\n-- TODO: remove, this is redundant, but for now mirror the development for reals...\nlemma interpolated_pos' (hp\u2080 : p\u2080 > 0) (hp\u2081 : p\u2081 > 0)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9): 0 < p :=\n  ENNReal_preservation_positivity' hp\u2080 hp\u2081 hp\n\nlemma exp_toReal_pos (hp\u2080 : p\u2080 > 0) (hp\u2080' : p\u2080 \u2260 \u22a4) : 0 < p\u2080.toReal :=\n  toReal_pos hp\u2080.ne' hp\u2080'\n\nlemma interp_exp_in_Ioo_zero_top (ht : t \u2208 Ioo 0 1) (hp\u2080 : p\u2080 > 0) (hp\u2081 : p\u2081 > 0)\n    (hp\u2080p\u2081 : p\u2080 \u2260 \u22a4 \u2228 p\u2081 \u2260 \u22a4)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9) : p \u2208 Ioo 0 \u22a4 :=\n  \u27e8interpolated_pos' hp\u2080 hp\u2081 hp, interp_exp_lt_top' hp\u2080p\u2081 ht hp\u27e9\n\nlemma inv_toReal_pos_of_ne_top (hp\u2080 : p\u2080 > 0) (hp' : p\u2080 \u2260 \u22a4) : p\u2080\u207b\u00b9.toReal > 0 :=\n  toReal_inv _ \u25b8 inv_pos_of_pos (exp_toReal_pos hp\u2080 hp')\n\nlemma inv_toReal_ne_zero_of_ne_top (hp\u2080 : p\u2080 > 0) (hp' : p\u2080 \u2260 \u22a4) : p\u2080\u207b\u00b9.toReal \u2260 0 :=\n  (inv_toReal_pos_of_ne_top hp\u2080 hp').ne'\n\nlemma interp_exp_toReal_pos (ht : t \u2208 Ioo 0 1) (hp\u2080 : p\u2080 > 0) (hp\u2081 : p\u2081 > 0) (hp\u2080p\u2081 : p\u2080 \u2260 p\u2081)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9)\n    : 0 < p.toReal :=\n  toReal_pos (interpolated_pos' hp\u2080 hp\u2081 hp).ne' (interp_exp_ne_top hp\u2080p\u2081 ht hp)\n\nlemma interp_exp_toReal_pos' (ht : t \u2208 Ioo 0 1) (hp\u2080 : p\u2080 > 0) (hp\u2081 : p\u2081 > 0)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9)\n    (hp\u2080p\u2081 : p\u2080 \u2260 \u22a4 \u2228 p\u2081 \u2260 \u22a4) : 0 < p.toReal :=\n  toReal_pos (interpolated_pos' hp\u2080 hp\u2081 hp).ne' (interp_exp_ne_top' hp\u2080p\u2081 ht hp)\n\nlemma interp_exp_inv_pos (ht : t \u2208 Ioo 0 1) (hp\u2080 : p\u2080 > 0)\n    (hp\u2081 : p\u2081 > 0) (hp\u2080p\u2081 : p\u2080 \u2260 p\u2081)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9) :\n    0 < p\u207b\u00b9.toReal :=\n  toReal_inv _ \u25b8 inv_pos_of_pos (interp_exp_toReal_pos ht hp\u2080 hp\u2081 hp\u2080p\u2081 hp)\n\nlemma interp_exp_inv_ne_zero (ht : t \u2208 Ioo 0 1) (hp\u2080 : p\u2080 > 0)\n    (hp\u2081 : p\u2081 > 0) (hp\u2080p\u2081 : p\u2080 \u2260 p\u2081)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9) : p\u207b\u00b9.toReal \u2260 0 :=\n  (interp_exp_inv_pos ht hp\u2080 hp\u2081 hp\u2080p\u2081 hp).ne'\n\nlemma preservation_interpolation (ht : t \u2208 Ioo 0 1) (hp\u2080 : p\u2080 > 0)\n    (hp\u2081 : p\u2081 > 0) (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9) :\n    p\u207b\u00b9.toReal = (1 - t) * (p\u2080\u207b\u00b9).toReal + t * (p\u2081\u207b\u00b9).toReal := by\n  rw [\u2190 one_toReal, \u2190 toReal_ofReal ht.1.le, \u2190 ENNReal.toReal_sub_of_le]\n  \u00b7 rw [\u2190 toReal_mul, \u2190 toReal_mul, \u2190 toReal_add]\n    \u00b7 exact congrArg ENNReal.toReal hp\n    \u00b7 exact mul_ne_top (sub_ne_top (top_ne_one.symm)) (inv_ne_top.mpr hp\u2080.ne')\n    \u00b7 exact mul_ne_top coe_ne_top (inv_ne_top.mpr hp\u2081.ne')\n  \u00b7 exact ofReal_le_one.mpr ht.2.le\n  \u00b7 exact top_ne_one.symm\n\nlemma preservation_positivity_inv_toReal (ht : t \u2208 Ioo 0 1) (hp\u2080 : p\u2080 > 0) (hp\u2081 : p\u2081 > 0)\n    (hp\u2080p\u2081 : p\u2080 \u2260 p\u2081) :\n    0 < (1 - t) * (p\u2080\u207b\u00b9).toReal + t * (p\u2081\u207b\u00b9).toReal := by\n  rcases (eq_or_ne p\u2080 \u22a4) with p\u2080eq_top | p\u2080ne_top\n  \u00b7 rw [p\u2080eq_top]\n    simp only [inv_top, zero_toReal, mul_zero, zero_add]\n    apply mul_pos ht.1\n    rw [toReal_inv]\n    refine inv_pos_of_pos (exp_toReal_pos hp\u2081 ?_)\n    rw [p\u2080eq_top] at hp\u2080p\u2081\n    exact hp\u2080p\u2081.symm\n  \u00b7 exact add_pos_of_pos_of_nonneg (mul_pos (Ioo.one_sub_mem ht).1 (toReal_inv _ \u25b8 inv_pos_of_pos\n      (exp_toReal_pos hp\u2080 p\u2080ne_top))) (mul_nonneg ht.1.le toReal_nonneg)\n\nlemma ne_inv_toReal_exponents (hp\u2080 : p\u2080 > 0) (hp\u2081 : p\u2081 > 0) (hp\u2080p\u2081 : p\u2080 \u2260 p\u2081) :\n    (p\u2080\u207b\u00b9.toReal \u2260 p\u2081\u207b\u00b9.toReal) := by\n  refine fun h \u21a6 hp\u2080p\u2081 ?_\n  rw [\u2190 inv_inv p\u2080, \u2190 inv_inv p\u2081]\n  apply congrArg Inv.inv\n  rw [\u2190 ofReal_toReal_eq_iff.mpr (inv_ne_top.mpr hp\u2080.ne'),\n    \u2190 ofReal_toReal_eq_iff.mpr (inv_ne_top.mpr hp\u2081.ne')]\n  exact congrArg ENNReal.ofReal h\n\nlemma ne_inv_toReal_exp_interp_exp (ht : t \u2208 Ioo 0 1) (hp\u2080 : p\u2080 > 0)\n  (hp\u2081 : p\u2081 > 0) (hp\u2080p\u2081 : p\u2080 \u2260 p\u2081)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9) :\n    (p\u2080\u207b\u00b9.toReal \u2260 p\u207b\u00b9.toReal) := by\n  rw [preservation_interpolation ht hp\u2080 hp\u2081 hp,\n    \u2190 sub_ne_zero, _root_.sub_mul, one_mul, add_comm_sub, sub_add_eq_sub_sub, sub_self, zero_sub,\n    neg_sub, \u2190 _root_.mul_sub]\n  exact mul_ne_zero ht.1.ne' (sub_ne_zero_of_ne (ne_inv_toReal_exponents hp\u2080 hp\u2081 hp\u2080p\u2081))\n\nlemma ne_sub_toReal_exp (hp\u2080 : p\u2080 > 0) (hp\u2081 : p\u2081 > 0) (hp\u2080p\u2081 : p\u2080 \u2260 p\u2081) :\n    p\u2081\u207b\u00b9.toReal - p\u2080\u207b\u00b9.toReal \u2260 0 :=\n  sub_ne_zero_of_ne (ne_inv_toReal_exponents hp\u2080 hp\u2081 hp\u2080p\u2081).symm\n\nlemma ne_toReal_exp_interp_exp (ht : t \u2208 Ioo 0 1) (hp\u2080 : p\u2080 > 0) (hp\u2081 : p\u2081 > 0) (hp\u2080p\u2081 : p\u2080 \u2260 p\u2081)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9) :\n    p\u2080.toReal \u2260 p.toReal := by\n  refine fun h \u21a6 ne_inv_toReal_exp_interp_exp ht hp\u2080 hp\u2081 hp\u2080p\u2081 hp ?_\n  repeat rw [toReal_inv _]\n  exact congrArg Inv.inv h\n\nlemma ne_toReal_exp_interp_exp\u2081 (ht : t \u2208 Ioo 0 1) (hp\u2080 : p\u2080 > 0) (hp\u2081 : p\u2081 > 0) (hp\u2080p\u2081 : p\u2080 \u2260 p\u2081)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9) :\n    p.toReal \u2260 p\u2081.toReal :=\n  (ne_toReal_exp_interp_exp (Ioo.one_sub_mem ht) hp\u2081 hp\u2080 (Ne.symm hp\u2080p\u2081)\n    (switch_exponents ht hp)).symm\n\nlemma ofReal_inv_interp_sub_exp_pos\u2081 (ht : t \u2208 Ioo 0 1) (hq\u2080 : q\u2080 > 0) (hq\u2081 : q\u2081 > 0)\n    (hq\u2080q\u2081 : q\u2080 \u2260 q\u2081)\n    (hq : q\u207b\u00b9 = (1 - ENNReal.ofReal t) * q\u2080\u207b\u00b9 + ENNReal.ofReal t * q\u2081\u207b\u00b9) :\n    ENNReal.ofReal |q.toReal - q\u2081.toReal|\u207b\u00b9 > 0 :=\n  ofReal_pos.mpr (inv_pos_of_pos (abs_sub_pos.mpr (ne_toReal_exp_interp_exp\u2081 ht hq\u2080 hq\u2081 hq\u2080q\u2081 hq)))\n\nlemma ofReal_inv_interp_sub_exp_pos\u2080 (ht : t \u2208 Ioo 0 1) (hq\u2080 : q\u2080 > 0) (hq\u2081 : q\u2081 > 0)\n    (hq\u2080q\u2081 : q\u2080 \u2260 q\u2081) (hq : q\u207b\u00b9 = (1 - ENNReal.ofReal t) * q\u2080\u207b\u00b9 + ENNReal.ofReal t * q\u2081\u207b\u00b9) :\n    ENNReal.ofReal |q.toReal - q\u2080.toReal|\u207b\u00b9 > 0 :=\n  ofReal_pos.mpr (inv_pos_of_pos (abs_sub_pos.mpr (Ne.symm\n    (ne_toReal_exp_interp_exp ht hq\u2080 hq\u2081 hq\u2080q\u2081 hq))))\n\nlemma exp_lt_iff (ht : t \u2208 Ioo 0 1) (hp\u2080 : p\u2080 > 0) (hp\u2081 : p\u2081 > 0) (hp\u2080p\u2081 : p\u2080 \u2260 p\u2081)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9) :\n    p < p\u2080 \u2194 p\u2081 < p\u2080 := by\n  rcases lt_or_gt_of_ne hp\u2080p\u2081 with p\u2080lt_p\u2081 | p\u2081lt_p\u2080\n  \u00b7 exact \u27e8fun h \u21a6 (not_le_of_gt h (le_of_lt (interp_exp_between hp\u2080 hp\u2081 p\u2080lt_p\u2081 ht hp).1)).elim,\n      fun h \u21a6 (not_le_of_gt h p\u2080lt_p\u2081.le).elim\u27e9\n  \u00b7 exact \u27e8fun _ \u21a6 p\u2081lt_p\u2080,\n      fun _ \u21a6 (interp_exp_between hp\u2081 hp\u2080 p\u2081lt_p\u2080 (Ioo.one_sub_mem ht) (switch_exponents ht hp)).2\u27e9\n\nlemma exp_gt_iff (ht : t \u2208 Ioo 0 1) (hp\u2080 : p\u2080 > 0) (hp\u2081 : p\u2081 > 0) (hp\u2080p\u2081 : p\u2080 \u2260 p\u2081)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9) :\n    p\u2080 < p \u2194 p\u2080 < p\u2081 := by\n  rcases lt_or_gt_of_ne hp\u2080p\u2081 with p\u2080lt_p\u2081 | p\u2081lt_p\u2080\n  \u00b7 exact \u27e8fun _ \u21a6 p\u2080lt_p\u2081, fun _ \u21a6 (interp_exp_between hp\u2080 hp\u2081 p\u2080lt_p\u2081 ht hp).1\u27e9\n  \u00b7 exact \u27e8fun h \u21a6 (not_le_of_gt h (interp_exp_between hp\u2081 hp\u2080 p\u2081lt_p\u2080\n      (Ioo.one_sub_mem ht) (switch_exponents ht hp)).2.le).elim,\n      fun h \u21a6 (not_le_of_gt h p\u2081lt_p\u2080.le).elim\u27e9\n\nlemma exp_lt_exp_gt_iff (ht : t \u2208 Ioo 0 1) (hp\u2080 : p\u2080 > 0) (hp\u2081 : p\u2081 > 0) (hp\u2080p\u2081 : p\u2080 \u2260 p\u2081)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9) :\n    p < p\u2080 \u2194 p\u2081 < p := by\n  rw [exp_lt_iff ht hp\u2080 hp\u2081 hp\u2080p\u2081 hp, \u2190 exp_gt_iff (Ioo.one_sub_mem ht) hp\u2081 hp\u2080 (Ne.symm hp\u2080p\u2081)\n    (switch_exponents ht hp)]\n\nlemma exp_gt_exp_lt_iff (ht : t \u2208 Ioo 0 1) (hp\u2080 : p\u2080 > 0) (hp\u2081 : p\u2081 > 0) (hp\u2080p\u2081 : p\u2080 \u2260 p\u2081)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9) :\n    p\u2080 < p \u2194 p < p\u2081 := by\n  rw [exp_gt_iff ht hp\u2080 hp\u2081 hp\u2080p\u2081 hp, \u2190 exp_lt_iff (Ioo.one_sub_mem ht) hp\u2081 hp\u2080 (Ne.symm hp\u2080p\u2081)\n    (switch_exponents ht hp)]\n\nlemma exp_lt_iff\u2081 (ht : t \u2208 Ioo 0 1) (hp\u2080 : p\u2080 > 0) (hp\u2081 : p\u2081 > 0) (hp\u2080p\u2081 : p\u2080 \u2260 p\u2081)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9) :\n    p < p\u2081 \u2194 p\u2080 < p\u2081 := by\n  rw [\u2190 exp_gt_exp_lt_iff ht hp\u2080 hp\u2081 hp\u2080p\u2081 hp]\n  exact exp_gt_iff ht hp\u2080 hp\u2081 hp\u2080p\u2081 hp\n\nlemma exp_gt_iff\u2081 (ht : t \u2208 Ioo 0 1) (hp\u2080 : p\u2080 > 0) (hp\u2081 : p\u2081 > 0) (hp\u2080p\u2081 : p\u2080 \u2260 p\u2081)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9) :\n    p\u2081 < p \u2194 p\u2081 < p\u2080 := by\n  rw [\u2190 exp_lt_exp_gt_iff ht hp\u2080 hp\u2081 hp\u2080p\u2081 hp]\n  exact exp_lt_iff ht hp\u2080 hp\u2081 hp\u2080p\u2081 hp\n\nend ComputationsInterpolatedExponents\n\nend\n\nnoncomputable section\n\n/-! ## Results about the particular choice of exponent\n\n    The proof of the real interpolation theorem will estimate\n    `distribution (trunc f A(t)) t` and `distribution (trunc_compl f A(t)) t` for a\n    function `A`. The function `A` can be given a closed-form expression that works for\n    _all_ cases in the real interpolation theorem, because of the computation rules available\n    for elements in `\u211d\u22650\u221e` that avoid the need for a limiting procedure, e.g. `\u22a4\u207b\u00b9 = 0`.\n\n    The function `A` will be of the form `A(t) = (t / d) ^ \u03c3` for particular choices of `d` and\n    `\u03c3`. This section contatins results about the exponents `\u03c3`.\n-/\nnamespace ComputationsChoiceExponent\n\nopen ENNReal Real Set ComputationsInterpolatedExponents\n\nvariable {p\u2080 q\u2080 p\u2081 q\u2081 p q : \u211d\u22650\u221e} {t : \u211d}\n\ndef \u03b6 := (((1 - t) * (p\u2080\u207b\u00b9).toReal + t * (p\u2081\u207b\u00b9).toReal) * ((q\u2081\u207b\u00b9).toReal - (q\u2080\u207b\u00b9).toReal)) /\n        (((1 - t) * (q\u2080\u207b\u00b9).toReal + t * (q\u2081\u207b\u00b9).toReal) * ((p\u2081\u207b\u00b9).toReal - (p\u2080\u207b\u00b9).toReal))\n\nlemma \u03b6_equality\u2081 (ht : t \u2208 Ioo 0 1) :\n    @\u03b6 p\u2080 q\u2080 p\u2081 q\u2081 t =\n    (((1 - t) * p\u2080\u207b\u00b9.toReal + t * p\u2081\u207b\u00b9.toReal) *\n    ((1 - t) * q\u2080\u207b\u00b9.toReal + t * q\u2081\u207b\u00b9.toReal - q\u2080\u207b\u00b9.toReal)) /\n    (((1 - t) * q\u2080\u207b\u00b9.toReal + t * q\u2081\u207b\u00b9.toReal) *\n    ((1 - t) * p\u2080\u207b\u00b9.toReal + t * p\u2081\u207b\u00b9.toReal - p\u2080\u207b\u00b9.toReal)) := by\n  unfold \u03b6\n  rw [\u2190 mul_div_mul_right _ _ ht.1.ne', mul_assoc _ _ t, mul_assoc _ _ t]\n  congr <;> ring\n\nlemma \u03b6_equality\u2082 (ht : t \u2208 Ioo 0 1) :\n    @\u03b6 p\u2080 q\u2080 p\u2081 q\u2081 t =\n    (((1 - t) * p\u2080\u207b\u00b9.toReal + t * p\u2081\u207b\u00b9.toReal) *\n    ((1 - t) * q\u2080\u207b\u00b9.toReal + t * q\u2081\u207b\u00b9.toReal - q\u2081\u207b\u00b9.toReal)) /\n    (((1 - t) * q\u2080\u207b\u00b9.toReal + t * q\u2081\u207b\u00b9.toReal) *\n    ((1 - t) * p\u2080\u207b\u00b9.toReal + t * p\u2081\u207b\u00b9.toReal - p\u2081\u207b\u00b9.toReal)) := by\n  unfold \u03b6\n  have : - (1 - t) < 0 := neg_neg_iff_pos.mpr (sub_pos.mpr ht.2)\n  rw [\u2190 mul_div_mul_right _ _ this.ne, mul_assoc _ _ (-(1 - t)), mul_assoc _ _ (-(1 - t))]\n  congr <;> ring\n\nlemma \u03b6_symm :\n    @\u03b6 p\u2080 q\u2080 p\u2081 q\u2081 t = @\u03b6 p\u2081 q\u2081 p\u2080 q\u2080 (1 - t) := by\n  unfold \u03b6\n  rw [\u2190 mul_div_mul_right (c := - 1), mul_assoc _ _ (-1), mul_assoc _ _ (-1)]; on_goal 2 => positivity\n  simp only [mul_neg, mul_one, neg_sub, _root_.sub_sub_cancel]\n  nth_rewrite 1 [add_comm]; nth_rw 2 [add_comm]\n\nset_option linter.style.multiGoal false in\nset_option linter.flexible false in\nlemma \u03b6_equality\u2083 (ht : t \u2208 Ioo 0 1) (hp\u2080 : p\u2080 > 0) (hq\u2080 : q\u2080 > 0) (hp\u2081 : p\u2081 > 0) (hq\u2081 : q\u2081 > 0)\n    (hp\u2080p\u2081 : p\u2080 \u2260 p\u2081) (hq\u2080q\u2081 : q\u2080 \u2260 q\u2081)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9)\n    (hq : q\u207b\u00b9 = (1 - ENNReal.ofReal t) * q\u2080\u207b\u00b9 + ENNReal.ofReal t * q\u2081\u207b\u00b9) (hp\u2080' : p\u2080 \u2260 \u22a4)\n    (hq\u2080' : q\u2080 \u2260 \u22a4) :\n    @\u03b6 p\u2080 q\u2080 p\u2081 q\u2081 t = (p\u2080.toReal * (q\u2080.toReal - q.toReal))  / (q\u2080.toReal * (p\u2080.toReal - p.toReal))\n    := by\n  rw [\u03b6_equality\u2081 ht, \u2190 preservation_interpolation, \u2190 preservation_interpolation]\n  have q_pos : 0 < q := interpolated_pos' hq\u2080 hq\u2081 hq\n  have p_pos : 0 < p := interpolated_pos' hp\u2080 hp\u2081 hp\n  have hne : p.toReal * q.toReal * p\u2080.toReal * q\u2080.toReal > 0 :=\n    mul_pos (mul_pos (mul_pos (interp_exp_toReal_pos ht hp\u2080 hp\u2081 hp\u2080p\u2081 hp)\n    (interp_exp_toReal_pos ht hq\u2080 hq\u2081 hq\u2080q\u2081 hq)) (exp_toReal_pos hp\u2080 hp\u2080'))\n    (exp_toReal_pos hq\u2080 hq\u2080')\n  rw [\u2190 mul_div_mul_right _ _ hne.ne']\n  have eq\u2081 : p\u207b\u00b9.toReal * (q\u207b\u00b9.toReal - q\u2080\u207b\u00b9.toReal) *\n      (p.toReal * q.toReal * p\u2080.toReal * q\u2080.toReal) =\n      p\u2080.toReal * (p\u207b\u00b9.toReal * p.toReal) * ((q\u207b\u00b9.toReal * q.toReal) * q\u2080.toReal -\n      (q\u2080\u207b\u00b9.toReal * q\u2080.toReal) * q.toReal) := by ring\n  have eq\u2082 : q\u207b\u00b9.toReal * (p\u207b\u00b9.toReal - p\u2080\u207b\u00b9.toReal) *\n      (p.toReal * q.toReal * p\u2080.toReal * q\u2080.toReal) =\n      q\u2080.toReal * (q\u207b\u00b9.toReal * q.toReal) * ((p\u207b\u00b9.toReal * p.toReal) * p\u2080.toReal -\n      (p\u2080\u207b\u00b9.toReal * p\u2080.toReal) * p.toReal) := by ring\n  rw [eq\u2081, eq\u2082, \u2190 @toReal_mul q\u207b\u00b9 q, \u2190 @toReal_mul p\u207b\u00b9 p, \u2190 @toReal_mul p\u2080\u207b\u00b9 p\u2080,\n      \u2190 @toReal_mul q\u2080\u207b\u00b9 q\u2080]\n  all_goals try assumption\n  -- TODO: why can below goals not be discharged?\n  repeat rw [ENNReal.inv_mul_cancel] <;> try positivity\n  all_goals simp <;> try assumption\n  \u00b7 apply interp_exp_ne_top hq\u2080q\u2081 ht hq\n  \u00b7 apply interp_exp_ne_top hp\u2080p\u2081 ht hp\n\nlemma one_sub_coe_one_sub (ht : t \u2208 Ioo 0 1) :\n    (1 - ENNReal.ofReal (1 - t)) = ENNReal.ofReal t := by\n  have := ht.2\n  rw [\u2190 ofReal_one, \u2190 ENNReal.ofReal_sub] <;> congr\n  \u00b7 linarith\n  \u00b7 linarith\n\nlemma coe_one_sub (ht : t \u2208 Ioo 0 1) :\n    ENNReal.ofReal (1 - t) = 1 - ENNReal.ofReal t := by\n  rw [\u2190 ofReal_one, \u2190 ENNReal.ofReal_sub]; exact ht.1.le\n\nlemma \u03b6_equality\u2084 (ht : t \u2208 Ioo 0 1) (hp\u2080 : p\u2080 > 0) (hq\u2080 : q\u2080 > 0) (hp\u2081 : p\u2081 > 0) (hq\u2081 : q\u2081 > 0)\n    (hp\u2080p\u2081 : p\u2080 \u2260 p\u2081) (hq\u2080q\u2081 : q\u2080 \u2260 q\u2081)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9)\n    (hq : q\u207b\u00b9 = (1 - ENNReal.ofReal t) * q\u2080\u207b\u00b9 + ENNReal.ofReal t * q\u2081\u207b\u00b9) (hp\u2081' : p\u2081 \u2260 \u22a4)\n    (hq\u2081' : q\u2081 \u2260 \u22a4) :\n    @\u03b6 p\u2080 q\u2080 p\u2081 q\u2081 t =\n    (p\u2081.toReal * (q\u2081.toReal - q.toReal)) / (q\u2081.toReal * (p\u2081.toReal - p.toReal)) := by\n  rw [\u03b6_symm]\n  have one_sub_mem : 1 - t \u2208 Ioo 0 1 := Ioo.one_sub_mem ht\n  rw [\u03b6_equality\u2083 one_sub_mem] <;> try assumption\n  \u00b7 exact hp\u2080p\u2081.symm\n  \u00b7 exact hq\u2080q\u2081.symm\n  \u00b7 rw [hp, one_sub_coe_one_sub ht, coe_one_sub ht]; ring\n  \u00b7 rw [hq, one_sub_coe_one_sub ht, coe_one_sub ht]; ring\n\nlemma \u03b6_equality\u2085 (ht : t \u2208 Ioo 0 1) (hp\u2080 : p\u2080 > 0) (hq\u2080 : q\u2080 > 0) (hp\u2081 : p\u2081 > 0) (hq\u2081 : q\u2081 > 0)\n    (hp\u2080p\u2081 : p\u2080 \u2260 p\u2081) (hq\u2080q\u2081 : q\u2080 \u2260 q\u2081)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9)\n    (hq : q\u207b\u00b9 = (1 - ENNReal.ofReal t) * q\u2080\u207b\u00b9 + ENNReal.ofReal t * q\u2081\u207b\u00b9) (hp\u2080' : p\u2080 \u2260 \u22a4)\n    (hq\u2080' : q\u2080 \u2260 \u22a4) :\n    p\u2080.toReal + (@\u03b6 p\u2080 q\u2080 p\u2081 q\u2081 t)\u207b\u00b9 * (q.toReal - q\u2080.toReal) * (p\u2080.toReal / q\u2080.toReal) = p.toReal\n    := by\n  rw [\u03b6_equality\u2083 ht] <;> try assumption\n  simp only [inv_div]\n  rw [div_eq_mul_inv, div_eq_mul_inv, mul_inv]\n  calc\n  _ = p\u2080.toReal - (q\u2080.toReal\u207b\u00b9 * q\u2080.toReal) * (p\u2080.toReal - p.toReal) * (p\u2080.toReal\u207b\u00b9 * p\u2080.toReal) *\n      ((q\u2080.toReal - q.toReal)\u207b\u00b9 * (q\u2080.toReal - q.toReal)) := by ring\n  _ = _ := by\n    rw [inv_mul_cancel\u2080, inv_mul_cancel\u2080, inv_mul_cancel\u2080]\n    \u00b7 simp only [one_mul, mul_one, _root_.sub_sub_cancel]\n    \u00b7 exact sub_ne_zero_of_ne (ne_toReal_exp_interp_exp ht hq\u2080 hq\u2081 hq\u2080q\u2081 hq)\n    \u00b7 exact (exp_toReal_pos hp\u2080 hp\u2080').ne'\n    \u00b7 exact (exp_toReal_pos hq\u2080 hq\u2080').ne'\n\nlemma \u03b6_equality\u2086 (ht : t \u2208 Ioo 0 1) (hp\u2080 : p\u2080 > 0) (hq\u2080 : q\u2080 > 0) (hp\u2081 : p\u2081 > 0) (hq\u2081 : q\u2081 > 0)\n    (hp\u2080p\u2081 : p\u2080 \u2260 p\u2081) (hq\u2080q\u2081 : q\u2080 \u2260 q\u2081)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9)\n    (hq : q\u207b\u00b9 = (1 - ENNReal.ofReal t) * q\u2080\u207b\u00b9 + ENNReal.ofReal t * q\u2081\u207b\u00b9) (hp\u2081' : p\u2081 \u2260 \u22a4)\n    (hq\u2081' : q\u2081 \u2260 \u22a4) :\n    p\u2081.toReal + (@\u03b6 p\u2080 q\u2080 p\u2081 q\u2081 t)\u207b\u00b9 * (q.toReal - q\u2081.toReal) * (p\u2081.toReal / q\u2081.toReal) = p.toReal\n    := by\n  rw [\u03b6_symm]\n  exact \u03b6_equality\u2085 (Ioo.one_sub_mem ht) hp\u2081 hq\u2081 hp\u2080 hq\u2080 hp\u2080p\u2081.symm hq\u2080q\u2081.symm\n    (switch_exponents ht hp) (switch_exponents ht hq) hp\u2081' hq\u2081'\n\nlemma \u03b6_equality\u2087 (ht : t \u2208 Ioo 0 1) (hp\u2080 : p\u2080 > 0) (hq\u2080 : q\u2080 > 0) (hp\u2081 : p\u2081 > 0) (hq\u2081 : q\u2081 > 0)\n    (hp\u2080p\u2081 : p\u2080 \u2260 p\u2081) (hq\u2080q\u2081 : q\u2080 \u2260 q\u2081)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9)\n    (hq : q\u207b\u00b9 = (1 - ENNReal.ofReal t) * q\u2080\u207b\u00b9 + ENNReal.ofReal t * q\u2081\u207b\u00b9) (hp\u2080' : p\u2080 \u2260 \u22a4)\n    (hq\u2080' : q\u2080 = \u22a4) :\n    @\u03b6 p\u2080 q\u2080 p\u2081 q\u2081 t = p\u2080.toReal / (p\u2080.toReal - p.toReal) := by\n  rw [\u03b6_equality\u2081 ht, \u2190 preservation_interpolation ht hp\u2080 hp\u2081 hp,\n    \u2190 preservation_interpolation ht hq\u2080 hq\u2081 hq, hq\u2080']\n  simp only [inv_top, zero_toReal, sub_zero, mul_zero, zero_add]\n  have obs : p\u2080.toReal * p.toReal * q.toReal > 0 :=\n    mul_pos (mul_pos (toReal_pos hp\u2080.ne' hp\u2080') (interp_exp_toReal_pos ht hp\u2080 hp\u2081 hp\u2080p\u2081 hp))\n    (interp_exp_toReal_pos ht hq\u2080 hq\u2081 hq\u2080q\u2081 hq)\n  rw [\u2190 mul_div_mul_right _ _ obs.ne']\n  congr\n  \u00b7 calc\n    _ = (p.toReal\u207b\u00b9 * p.toReal) * (q.toReal\u207b\u00b9 * q.toReal) * p\u2080.toReal := by\n      rw [toReal_inv, toReal_inv]\n      ring\n    _ = _ := by\n      rw [inv_mul_cancel\u2080, inv_mul_cancel\u2080, one_mul, one_mul]\n      \u00b7 exact (interp_exp_toReal_pos ht hq\u2080 hq\u2081 hq\u2080q\u2081 hq).ne'\n      \u00b7 exact (interp_exp_toReal_pos ht hp\u2080 hp\u2081 hp\u2080p\u2081 hp).ne'\n  \u00b7 calc\n    _ = (q.toReal\u207b\u00b9 * q.toReal) * (p.toReal\u207b\u00b9 * p.toReal * p\u2080.toReal - p\u2080.toReal\u207b\u00b9 *\n        p\u2080.toReal * p.toReal) := by\n      rw [toReal_inv, toReal_inv, toReal_inv]\n      ring\n    _ = _ := by\n      repeat rw [inv_mul_cancel\u2080, one_mul]\n      \u00b7 exact (toReal_pos hp\u2080.ne' hp\u2080').ne'\n      \u00b7 exact (interp_exp_toReal_pos ht hp\u2080 hp\u2081 hp\u2080p\u2081 hp).ne'\n      \u00b7 exact (interp_exp_toReal_pos ht hq\u2080 hq\u2081 hq\u2080q\u2081 hq).ne'\n\nlemma \u03b6_equality\u2088 (ht : t \u2208 Ioo 0 1) (hp\u2080 : p\u2080 > 0) (hq\u2080 : q\u2080 > 0) (hp\u2081 : p\u2081 > 0) (hq\u2081 : q\u2081 > 0)\n    (hp\u2080p\u2081 : p\u2080 \u2260 p\u2081) (hq\u2080q\u2081 : q\u2080 \u2260 q\u2081)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9)\n    (hq : q\u207b\u00b9 = (1 - ENNReal.ofReal t) * q\u2080\u207b\u00b9 + ENNReal.ofReal t * q\u2081\u207b\u00b9) (hp\u2081' : p\u2081 \u2260 \u22a4)\n    (hq\u2081' : q\u2081 = \u22a4) :\n    @\u03b6 p\u2080 q\u2080 p\u2081 q\u2081 t = p\u2081.toReal / (p\u2081.toReal - p.toReal) :=\n  \u03b6_symm \u25b8 \u03b6_equality\u2087 (Ioo.one_sub_mem ht) hp\u2081 hq\u2081 hp\u2080 hq\u2080 (Ne.symm hp\u2080p\u2081) (Ne.symm hq\u2080q\u2081)\n    (switch_exponents ht hp) (switch_exponents ht hq) hp\u2081' hq\u2081'\n\nlemma \u03b6_eq_top_top (ht : t \u2208 Ioo 0 1) (hp\u2080 : p\u2080 > 0) (hq\u2080 : q\u2080 > 0)\n    (hp\u2081 : p\u2081 > 0) (hq\u2081 : q\u2081 > 0) (hp\u2080p\u2081 : p\u2080 \u2260 p\u2081) (hq\u2080q\u2081 : q\u2080 \u2260 q\u2081)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9)\n    (hq : q\u207b\u00b9 = (1 - ENNReal.ofReal t) * q\u2080\u207b\u00b9 + ENNReal.ofReal t * q\u2081\u207b\u00b9) (hp\u2081' : p\u2081 = \u22a4)\n    (hq\u2081' : q\u2081 = \u22a4) :\n    @\u03b6 p\u2080 q\u2080 p\u2081 q\u2081 t = 1 := by\n  rw [\u03b6_equality\u2082 ht, \u2190 preservation_interpolation ht hp\u2080 hp\u2081 hp,\n    \u2190 preservation_interpolation ht hq\u2080 hq\u2081 hq, hp\u2081', hq\u2081']\n  simp only [inv_top, zero_toReal, sub_zero]\n  rw [mul_comm, div_eq_mul_inv, mul_inv_cancel\u2080]\n  exact (mul_pos (interp_exp_inv_pos ht hq\u2080 hq\u2081 hq\u2080q\u2081 hq)\n    (interp_exp_inv_pos ht hp\u2080 hp\u2081 hp\u2080p\u2081 hp)).ne'\n\nlemma \u03b6_pos_iff_aux (hp\u2080 : p\u2080 > 0) (hq\u2080 : q\u2080 > 0) (hp\u2080' : p\u2080 \u2260 \u22a4) (hq\u2080' : q\u2080 \u2260 \u22a4) :\n    ( 0 < p\u2080.toReal * (q\u2080.toReal - q.toReal) / (q\u2080.toReal * (p\u2080.toReal - p.toReal))) \u2194\n    ((q.toReal < q\u2080.toReal) \u2227 (p.toReal < p\u2080.toReal)) \u2228\n    ((q\u2080.toReal < q.toReal) \u2227 (p\u2080.toReal < p.toReal)) := by\n  rw [_root_.div_pos_iff, \u2190 Left.neg_pos_iff, \u2190 Left.neg_pos_iff, neg_mul_eq_mul_neg,\n      neg_mul_eq_mul_neg]\n  rw [mul_pos_iff_of_pos_left, mul_pos_iff_of_pos_left,\n      mul_pos_iff_of_pos_left, mul_pos_iff_of_pos_left, neg_sub, neg_sub]\n  \u00b7 simp only [sub_pos, sub_neg]\n  \u00b7 exact exp_toReal_pos hq\u2080 hq\u2080'\n  \u00b7 exact exp_toReal_pos hp\u2080 hp\u2080'\n  \u00b7 exact exp_toReal_pos hq\u2080 hq\u2080'\n  \u00b7 exact exp_toReal_pos hp\u2080 hp\u2080'\n\nlemma preservation_inequality (ht : t \u2208 Ioo 0 1) (hp\u2080p\u2081 : p\u2080 \u2260 p\u2081)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9) (hp\u2080' : p\u2080 \u2260 \u22a4) :\n    p.toReal < p\u2080.toReal \u2194 p < p\u2080 :=\n  toReal_lt_toReal (interp_exp_ne_top hp\u2080p\u2081 ht hp) hp\u2080'\n\nlemma preservation_inequality' (ht : t \u2208 Ioo 0 1)(hp\u2080p\u2081 : p\u2080 \u2260 p\u2081)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9) (hp\u2080' : p\u2080 \u2260 \u22a4) :\n    p\u2080.toReal < p.toReal \u2194 p\u2080 < p :=\n  toReal_lt_toReal hp\u2080' (interp_exp_ne_top hp\u2080p\u2081 ht hp)\n\nlemma preservation_inequality_of_lt\u2080 (ht : t \u2208 Ioo 0 1) (hq\u2080 : q\u2080 > 0) (hq\u2081 : q\u2081 > 0)\n    (hq : q\u207b\u00b9 = (1 - ENNReal.ofReal t) * q\u2080\u207b\u00b9 + ENNReal.ofReal t * q\u2081\u207b\u00b9) (hq\u2080q\u2081 : q\u2080 < q\u2081) :\n    q\u2080.toReal < q.toReal :=\n  (toReal_lt_toReal hq\u2080q\u2081.ne_top (interp_exp_ne_top hq\u2080q\u2081.ne ht hq)).mpr\n    ((exp_gt_iff ht hq\u2080 hq\u2081 hq\u2080q\u2081.ne hq).mpr hq\u2080q\u2081)\n\nlemma preservation_inequality_of_lt\u2081 (ht : t \u2208 Ioo 0 1) (hq\u2080 : q\u2080 > 0) (hq\u2081 : q\u2081 > 0)\n    (hq : q\u207b\u00b9 = (1 - ENNReal.ofReal t) * q\u2080\u207b\u00b9 + ENNReal.ofReal t * q\u2081\u207b\u00b9) (hq\u2080q\u2081 : q\u2080 < q\u2081)\n    (hq\u2081' : q\u2081 \u2260 \u22a4):\n    q.toReal < q\u2081.toReal :=\n  (toReal_lt_toReal (interp_exp_ne_top hq\u2080q\u2081.ne ht hq) hq\u2081').mpr\n    ((exp_lt_iff\u2081 ht hq\u2080 hq\u2081 hq\u2080q\u2081.ne hq).mpr hq\u2080q\u2081)\n\nlemma \u03b6_pos_toReal_iff\u2080 (ht : t \u2208 Ioo 0 1) (hp\u2080 : p\u2080 > 0) (hq\u2080 : q\u2080 > 0) (hp\u2081 : p\u2081 > 0)\n    (hq\u2081 : q\u2081 > 0) (hp\u2080p\u2081 : p\u2080 \u2260 p\u2081) (hq\u2080q\u2081 : q\u2080 \u2260 q\u2081)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9)\n    (hq : q\u207b\u00b9 = (1 - ENNReal.ofReal t) * q\u2080\u207b\u00b9 + ENNReal.ofReal t * q\u2081\u207b\u00b9) (hp\u2080' : p\u2080 \u2260 \u22a4)\n    (hq\u2080' : q\u2080 \u2260 \u22a4) : (0 < @\u03b6 p\u2080 q\u2080 p\u2081 q\u2081 t) \u2194\n    ((q.toReal < q\u2080.toReal) \u2227 (p.toReal < p\u2080.toReal)) \u2228\n    ((q\u2080.toReal < q.toReal) \u2227 (p\u2080.toReal < p.toReal)) := by\n  rw [\u03b6_equality\u2083 ht hp\u2080 hq\u2080 hp\u2081 hq\u2081 hp\u2080p\u2081 hq\u2080q\u2081 hp hq hp\u2080' hq\u2080']\n  exact \u03b6_pos_iff_aux hp\u2080 hq\u2080 hp\u2080' hq\u2080'\n\nlemma \u03b6_pos_toReal_iff\u2081 (ht : t \u2208 Ioo 0 1) (hp\u2080 : p\u2080 > 0) (hq\u2080 : q\u2080 > 0) (hp\u2081 : p\u2081 > 0)\n    (hq\u2081 : q\u2081 > 0) (hp\u2080p\u2081 : p\u2080 \u2260 p\u2081) (hq\u2080q\u2081 : q\u2080 \u2260 q\u2081)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9)\n    (hq : q\u207b\u00b9 = (1 - ENNReal.ofReal t) * q\u2080\u207b\u00b9 + ENNReal.ofReal t * q\u2081\u207b\u00b9) (hp\u2081' : p\u2081 \u2260 \u22a4)\n    (hq\u2081' : q\u2081 \u2260 \u22a4) :\n    (0 < @\u03b6 p\u2080 q\u2080 p\u2081 q\u2081 t) \u2194\n    ((q.toReal < q\u2081.toReal) \u2227 (p.toReal < p\u2081.toReal)) \u2228\n    ((q\u2081.toReal < q.toReal) \u2227 (p\u2081.toReal < p.toReal)) := by\n  rw [\u03b6_equality\u2084 ht hp\u2080 hq\u2080 hp\u2081 hq\u2081 hp\u2080p\u2081 hq\u2080q\u2081 hp hq hp\u2081' hq\u2081']\n  exact \u03b6_pos_iff_aux hp\u2081 hq\u2081 hp\u2081' hq\u2081'\n\nlemma \u03b6_pos_iff_aux\u2080 (ht : t \u2208 Ioo 0 1) (hp\u2080 : p\u2080 > 0) (hq\u2080 : q\u2080 > 0)\n    (hp\u2081 : p\u2081 > 0) (hq\u2081 : q\u2081 > 0) (hp\u2080p\u2081 : p\u2080 \u2260 p\u2081) (hq\u2080q\u2081 : q\u2080 \u2260 q\u2081) :\n    (0 < @\u03b6 p\u2080 q\u2080 p\u2081 q\u2081 t) \u2194\n    q\u2080\u207b\u00b9.toReal < q\u2081\u207b\u00b9.toReal \u2227 p\u2080\u207b\u00b9.toReal < p\u2081\u207b\u00b9.toReal \u2228\n    q\u2081\u207b\u00b9.toReal < q\u2080\u207b\u00b9.toReal \u2227 p\u2081\u207b\u00b9.toReal < p\u2080\u207b\u00b9.toReal := by\n  unfold \u03b6\n  rw [_root_.div_pos_iff, \u2190 Left.neg_pos_iff, \u2190 Left.neg_pos_iff, neg_mul_eq_mul_neg,\n      neg_mul_eq_mul_neg, mul_pos_iff_of_pos_left, mul_pos_iff_of_pos_left,\n      mul_pos_iff_of_pos_left, mul_pos_iff_of_pos_left, neg_sub, neg_sub]\n  \u00b7 simp only [sub_pos, sub_neg]\n  \u00b7 exact preservation_positivity_inv_toReal ht hq\u2080 hq\u2081 hq\u2080q\u2081\n  \u00b7 exact preservation_positivity_inv_toReal ht hp\u2080 hp\u2081 hp\u2080p\u2081\n  \u00b7 exact preservation_positivity_inv_toReal ht hq\u2080 hq\u2081 hq\u2080q\u2081\n  \u00b7 exact preservation_positivity_inv_toReal ht hp\u2080 hp\u2081 hp\u2080p\u2081\n\nlemma inv_toReal_iff (hp\u2080 : p\u2080 > 0) (hp\u2081 : p\u2081 > 0) :\n    p\u2080\u207b\u00b9.toReal < p\u2081\u207b\u00b9.toReal \u2194 p\u2081 < p\u2080 :=\n  Iff.trans (toReal_lt_toReal (ne_of_lt (inv_lt_top.mpr hp\u2080))\n    (ne_of_lt (inv_lt_top.mpr hp\u2081))) ENNReal.inv_lt_inv\n\nlemma \u03b6_pos_iff (ht : t \u2208 Ioo 0 1) (hp\u2080 : p\u2080 > 0) (hq\u2080 : q\u2080 > 0) (hp\u2081 : p\u2081 > 0) (hq\u2081 : q\u2081 > 0)\n    (hp\u2080p\u2081 : p\u2080 \u2260 p\u2081) (hq\u2080q\u2081 : q\u2080 \u2260 q\u2081) :\n    (0 < @\u03b6 p\u2080 q\u2080 p\u2081 q\u2081 t) \u2194\n    ((q\u2081 < q\u2080) \u2227 (p\u2081 < p\u2080)) \u2228 ((q\u2080 < q\u2081) \u2227 (p\u2080 < p\u2081)) := by\n  rw [\u03b6_pos_iff_aux\u2080 ht hp\u2080 hq\u2080 hp\u2081 hq\u2081 hp\u2080p\u2081 hq\u2080q\u2081,\n    inv_toReal_iff hq\u2080 hq\u2081, inv_toReal_iff hp\u2080 hp\u2081,\n    inv_toReal_iff hq\u2081 hq\u2080, inv_toReal_iff hp\u2081 hp\u2080]\n\nlemma \u03b6_pos_iff' (ht : t \u2208 Ioo 0 1) (hp\u2080 : p\u2080 > 0) (hq\u2080 : q\u2080 > 0)\n    (hp\u2081 : p\u2081 > 0) (hq\u2081 : q\u2081 > 0) (hp\u2080p\u2081 : p\u2080 \u2260 p\u2081) (hq\u2080q\u2081 : q\u2080 \u2260 q\u2081)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9)\n    (hq : q\u207b\u00b9 = (1 - ENNReal.ofReal t) * q\u2080\u207b\u00b9 + ENNReal.ofReal t * q\u2081\u207b\u00b9) :\n    (0 < @\u03b6 p\u2080 q\u2080 p\u2081 q\u2081 t) \u2194\n    ((q < q\u2080) \u2227 (p < p\u2080)) \u2228 ((q\u2080 < q) \u2227 (p\u2080 < p)) := by\n  rw [\u03b6_pos_iff ht hp\u2080 hq\u2080 hp\u2081 hq\u2081 hp\u2080p\u2081 hq\u2080q\u2081,\n    \u2190 exp_lt_iff ht hp\u2080 hp\u2081 hp\u2080p\u2081 hp, \u2190 exp_lt_iff ht hq\u2080 hq\u2081 hq\u2080q\u2081 hq,\n    \u2190 exp_gt_iff ht hp\u2080 hp\u2081 hp\u2080p\u2081 hp, \u2190 exp_gt_iff ht hq\u2080 hq\u2081 hq\u2080q\u2081 hq]\n\nlemma \u03b6_pos_iff_of_lt\u2080 (ht : t \u2208 Ioo 0 1) (hp\u2080 : p\u2080 > 0) (hq\u2080 : q\u2080 > 0)\n    (hp\u2081 : p\u2081 > 0) (hq\u2081 : q\u2081 > 0) (hq\u2080q\u2081 : q\u2080 \u2260 q\u2081)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9)\n    (hq : q\u207b\u00b9 = (1 - ENNReal.ofReal t) * q\u2080\u207b\u00b9 + ENNReal.ofReal t * q\u2081\u207b\u00b9) (hp\u2080p\u2081' : p\u2080 < p\u2081)  :\n    (0 < @\u03b6 p\u2080 q\u2080 p\u2081 q\u2081 t) \u2194\n    (q\u2080 < q) := by\n  rw [\u03b6_pos_iff' ht hp\u2080 hq\u2080 hp\u2081 hq\u2081 hp\u2080p\u2081'.ne hq\u2080q\u2081 hp hq]\n  rw [\u2190 exp_gt_iff (p := p) ht hp\u2080 hp\u2081 hp\u2080p\u2081'.ne hp] at hp\u2080p\u2081'\n  have : \u00ac (p < p\u2080) := not_lt_of_gt hp\u2080p\u2081'\n  tauto\n\nlemma \u03b6_pos_iff_of_lt\u2081 (ht : t \u2208 Ioo 0 1) (hp\u2080 : p\u2080 > 0) (hq\u2080 : q\u2080 > 0)\n  (hp\u2081 : p\u2081 > 0) (hq\u2081 : q\u2081 > 0) (hq\u2080q\u2081 : q\u2080 \u2260 q\u2081)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9)\n    (hq : q\u207b\u00b9 = (1 - ENNReal.ofReal t) * q\u2080\u207b\u00b9 + ENNReal.ofReal t * q\u2081\u207b\u00b9) (hp\u2080p\u2081' : p\u2080 < p\u2081) :\n    (0 < @\u03b6 p\u2080 q\u2080 p\u2081 q\u2081 t) \u2194\n    (q < q\u2081) := by\n  rw [\u2190 exp_gt_exp_lt_iff ht hq\u2080 hq\u2081 hq\u2080q\u2081 hq]\n  exact \u03b6_pos_iff_of_lt\u2080 ht hp\u2080 hq\u2080 hp\u2081 hq\u2081 hq\u2080q\u2081 hp hq hp\u2080p\u2081'\n\nlemma \u03b6_neg_iff_aux\u2080 (ht : t \u2208 Ioo 0 1) (hp\u2080 : p\u2080 > 0) (hq\u2080 : q\u2080 > 0) (hp\u2081 : p\u2081 > 0) (hq\u2081 : q\u2081 > 0)\n    (hp\u2080p\u2081 : p\u2080 \u2260 p\u2081) (hq\u2080q\u2081 : q\u2080 \u2260 q\u2081) :\n    (@\u03b6 p\u2080 q\u2080 p\u2081 q\u2081 t) < 0 \u2194\n    q\u2080\u207b\u00b9.toReal < q\u2081\u207b\u00b9.toReal \u2227 p\u2081\u207b\u00b9.toReal < p\u2080\u207b\u00b9.toReal \u2228\n    q\u2081\u207b\u00b9.toReal < q\u2080\u207b\u00b9.toReal \u2227 p\u2080\u207b\u00b9.toReal < p\u2081\u207b\u00b9.toReal := by\n  unfold \u03b6\n  rw [div_neg_iff, \u2190 Left.neg_pos_iff, \u2190 Left.neg_pos_iff, neg_mul_eq_mul_neg, neg_mul_eq_mul_neg]\n  rw [mul_pos_iff_of_pos_left, mul_pos_iff_of_pos_left,\n      mul_pos_iff_of_pos_left, mul_pos_iff_of_pos_left, neg_sub, neg_sub]\n  \u00b7 simp only [sub_pos, sub_neg]\n  \u00b7 exact preservation_positivity_inv_toReal ht hq\u2080 hq\u2081 hq\u2080q\u2081\n  \u00b7 exact preservation_positivity_inv_toReal ht hp\u2080 hp\u2081 hp\u2080p\u2081\n  \u00b7 exact preservation_positivity_inv_toReal ht hq\u2080 hq\u2081 hq\u2080q\u2081\n  \u00b7 exact preservation_positivity_inv_toReal ht hp\u2080 hp\u2081 hp\u2080p\u2081\n\nlemma \u03b6_neg_iff (ht : t \u2208 Ioo 0 1) (hp\u2080 : p\u2080 > 0) (hq\u2080 : q\u2080 > 0) (hp\u2081 : p\u2081 > 0) (hq\u2081 : q\u2081 > 0)\n    (hp\u2080p\u2081 : p\u2080 \u2260 p\u2081) (hq\u2080q\u2081 : q\u2080 \u2260 q\u2081) :\n    (@\u03b6 p\u2080 q\u2080 p\u2081 q\u2081 t) < 0 \u2194\n    q\u2081 < q\u2080 \u2227 p\u2080 < p\u2081 \u2228 q\u2080 < q\u2081 \u2227 p\u2081 < p\u2080 := by\n  rw [\u03b6_neg_iff_aux\u2080 ht hp\u2080 hq\u2080 hp\u2081 hq\u2081 hp\u2080p\u2081 hq\u2080q\u2081, inv_toReal_iff hq\u2080 hq\u2081, inv_toReal_iff hp\u2080 hp\u2081,\n    inv_toReal_iff hq\u2081 hq\u2080, inv_toReal_iff hp\u2081 hp\u2080]\n\nlemma \u03b6_neg_iff' (ht : t \u2208 Ioo 0 1) (hp\u2080 : p\u2080 > 0) (hq\u2080 : q\u2080 > 0) (hp\u2081 : p\u2081 > 0) (hq\u2081 : q\u2081 > 0)\n    (hp\u2080p\u2081 : p\u2080 \u2260 p\u2081) (hq\u2080q\u2081 : q\u2080 \u2260 q\u2081)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9)\n    (hq : q\u207b\u00b9 = (1 - ENNReal.ofReal t) * q\u2080\u207b\u00b9 + ENNReal.ofReal t * q\u2081\u207b\u00b9) :\n    (@\u03b6 p\u2080 q\u2080 p\u2081 q\u2081 t) < 0 \u2194\n    ((q < q\u2080) \u2227 (p\u2080 < p)) \u2228 ((q\u2080 < q) \u2227 (p < p\u2080)) := by\n  rw [\u03b6_neg_iff ht hp\u2080 hq\u2080 hp\u2081 hq\u2081 hp\u2080p\u2081 hq\u2080q\u2081, \u2190 exp_lt_iff ht hp\u2080 hp\u2081 hp\u2080p\u2081 hp,\n    \u2190 exp_lt_iff ht hq\u2080 hq\u2081 hq\u2080q\u2081 hq, \u2190 exp_gt_iff ht hp\u2080 hp\u2081 hp\u2080p\u2081 hp,\n    \u2190 exp_gt_iff ht hq\u2080 hq\u2081 hq\u2080q\u2081 hq]\n\nlemma \u03b6_neg_iff_of_lt\u2080 (ht : t \u2208 Ioo 0 1) (hp\u2080 : p\u2080 > 0) (hq\u2080 : q\u2080 > 0) (hp\u2081 : p\u2081 > 0)\n    (hq\u2081 : q\u2081 > 0) (hq\u2080q\u2081 : q\u2080 \u2260 q\u2081)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9)\n    (hq : q\u207b\u00b9 = (1 - ENNReal.ofReal t) * q\u2080\u207b\u00b9 + ENNReal.ofReal t * q\u2081\u207b\u00b9) (hp\u2080p\u2081' : p\u2080 < p\u2081) :\n    (@\u03b6 p\u2080 q\u2080 p\u2081 q\u2081 t) < 0 \u2194 q < q\u2080 := by\n  rw [\u03b6_neg_iff' ht hp\u2080 hq\u2080 hp\u2081 hq\u2081 hp\u2080p\u2081'.ne hq\u2080q\u2081 hp hq]\n  rw [\u2190 exp_gt_iff (p := p) ht hp\u2080 hp\u2081 hp\u2080p\u2081'.ne hp] at hp\u2080p\u2081'\n  have : \u00ac (p < p\u2080) := not_lt_of_gt hp\u2080p\u2081'\n  tauto\n\nlemma \u03b6_neg_iff_of_lt\u2081 (ht : t \u2208 Ioo 0 1) (hp\u2080 : p\u2080 > 0) (hq\u2080 : q\u2080 > 0) (hp\u2081 : p\u2081 > 0)\n    (hq\u2081 : q\u2081 > 0) (hq\u2080q\u2081 : q\u2080 \u2260 q\u2081)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9)\n    (hq : q\u207b\u00b9 = (1 - ENNReal.ofReal t) * q\u2080\u207b\u00b9 + ENNReal.ofReal t * q\u2081\u207b\u00b9) (hp\u2080p\u2081' : p\u2080 < p\u2081) :\n    (@\u03b6 p\u2080 q\u2080 p\u2081 q\u2081 t) < 0 \u2194 q\u2081 < q := by\n  rw [\u2190 exp_lt_exp_gt_iff ht hq\u2080 hq\u2081 hq\u2080q\u2081 hq]\n  exact \u03b6_neg_iff_of_lt\u2080 ht hp\u2080 hq\u2080 hp\u2081 hq\u2081 hq\u2080q\u2081 hp hq hp\u2080p\u2081'\n\nlemma \u03b6_neg_iff_aux (hp\u2080 : p\u2080 > 0) (hq\u2080 : q\u2080 > 0) (hp\u2080' : p\u2080 \u2260 \u22a4)\n    (hq\u2080' : q\u2080 \u2260 \u22a4) :\n    (p\u2080.toReal * (q\u2080.toReal - q.toReal) / (q\u2080.toReal * (p\u2080.toReal - p.toReal)) < 0) \u2194\n    ((q.toReal < q\u2080.toReal) \u2227 (p\u2080.toReal < p.toReal)) \u2228\n    ((q\u2080.toReal < q.toReal) \u2227 (p.toReal < p\u2080.toReal)) := by\n  rw [div_neg_iff, \u2190 Left.neg_pos_iff, \u2190 Left.neg_pos_iff, neg_mul_eq_mul_neg, neg_mul_eq_mul_neg,\n    mul_pos_iff_of_pos_left, mul_pos_iff_of_pos_left,\n    mul_pos_iff_of_pos_left, mul_pos_iff_of_pos_left, neg_sub, neg_sub]\n  \u00b7 simp only [sub_pos, sub_neg]\n  \u00b7 exact exp_toReal_pos hq\u2080 hq\u2080'\n  \u00b7 exact exp_toReal_pos hp\u2080 hp\u2080'\n  \u00b7 exact exp_toReal_pos hq\u2080 hq\u2080'\n  \u00b7 exact exp_toReal_pos hp\u2080 hp\u2080'\n\nlemma \u03b6_neg_toReal_iff\u2080 (ht : t \u2208 Ioo 0 1) (hp\u2080 : p\u2080 > 0) (hq\u2080 : q\u2080 > 0) (hp\u2081 : p\u2081 > 0)\n    (hq\u2081 : q\u2081 > 0) (hp\u2080p\u2081 : p\u2080 \u2260 p\u2081) (hq\u2080q\u2081 : q\u2080 \u2260 q\u2081)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9)\n    (hq : q\u207b\u00b9 = (1 - ENNReal.ofReal t) * q\u2080\u207b\u00b9 + ENNReal.ofReal t * q\u2081\u207b\u00b9) (hp\u2080' : p\u2080 \u2260 \u22a4)\n    (hq\u2080' : q\u2080 \u2260 \u22a4) :\n    (@\u03b6 p\u2080 q\u2080 p\u2081 q\u2081 t < 0) \u2194\n    ((q.toReal < q\u2080.toReal) \u2227 (p\u2080.toReal < p.toReal)) \u2228\n    ((q\u2080.toReal < q.toReal) \u2227 (p.toReal < p\u2080.toReal)) := by\n  rw [\u03b6_equality\u2083 ht hp\u2080 hq\u2080 hp\u2081 hq\u2081 hp\u2080p\u2081 hq\u2080q\u2081 hp hq hp\u2080' hq\u2080']\n  exact \u03b6_neg_iff_aux hp\u2080 hq\u2080 hp\u2080' hq\u2080'\n\nlemma \u03b6_neg_toReal_iff\u2081 (ht : t \u2208 Ioo 0 1) (hp\u2080 : p\u2080 > 0) (hq\u2080 : q\u2080 > 0) (hp\u2081 : p\u2081 > 0)\n    (hq\u2081 : q\u2081 > 0) (hp\u2080p\u2081 : p\u2080 \u2260 p\u2081) (hq\u2080q\u2081 : q\u2080 \u2260 q\u2081)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9)\n    (hq : q\u207b\u00b9 = (1 - ENNReal.ofReal t) * q\u2080\u207b\u00b9 + ENNReal.ofReal t * q\u2081\u207b\u00b9) (hp\u2081' : p\u2081 \u2260 \u22a4)\n    (hq\u2081' : q\u2081 \u2260 \u22a4) :\n    (@\u03b6 p\u2080 q\u2080 p\u2081 q\u2081 t < 0) \u2194\n    ((q.toReal < q\u2081.toReal) \u2227 (p\u2081.toReal < p.toReal)) \u2228 ((q\u2081.toReal < q.toReal) \u2227\n    (p.toReal < p\u2081.toReal)) := by\n  rw [\u03b6_equality\u2084 ht hp\u2080 hq\u2080 hp\u2081 hq\u2081 hp\u2080p\u2081 hq\u2080q\u2081 hp hq hp\u2081' hq\u2081']\n  exact \u03b6_neg_iff_aux hp\u2081 hq\u2081 hp\u2081' hq\u2081'\n\nlemma \u03b6_neg_iff\u2080 (ht : t \u2208 Ioo 0 1) (hp\u2080 : p\u2080 > 0) (hq\u2080 : q\u2080 > 0) (hp\u2081 : p\u2081 > 0) (hq\u2081 : q\u2081 > 0)\n    (hp\u2080p\u2081 : p\u2080 \u2260 p\u2081) (hq\u2080q\u2081 : q\u2080 \u2260 q\u2081)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9)\n    (hq : q\u207b\u00b9 = (1 - ENNReal.ofReal t) * q\u2080\u207b\u00b9 + ENNReal.ofReal t * q\u2081\u207b\u00b9) (hp\u2080' : p\u2080 \u2260 \u22a4)\n    (hq\u2080' : q\u2080 \u2260 \u22a4) : (@\u03b6 p\u2080 q\u2080 p\u2081 q\u2081 t < 0) \u2194\n    ((q < q\u2080) \u2227 (p\u2080 < p)) \u2228 ((q\u2080 < q) \u2227 (p < p\u2080)) := by\n  rw [\u03b6_neg_toReal_iff\u2080 ht hp\u2080 hq\u2080 hp\u2081 hq\u2081 hp\u2080p\u2081 hq\u2080q\u2081 hp hq hp\u2080' hq\u2080',\n    preservation_inequality ht hq\u2080q\u2081 hq hq\u2080', preservation_inequality ht hp\u2080p\u2081 hp hp\u2080',\n    preservation_inequality' ht hq\u2080q\u2081 hq hq\u2080', preservation_inequality' ht hp\u2080p\u2081 hp hp\u2080']\n\nlemma \u03b6_ne_zero (ht : t \u2208 Ioo 0 1) (hp\u2080 : p\u2080 > 0) (hq\u2080 : q\u2080 > 0) (hp\u2081 : p\u2081 > 0) (hq\u2081 : q\u2081 > 0)\n    (hp\u2080p\u2081 : p\u2080 \u2260 p\u2081) (hq\u2080q\u2081 : q\u2080 \u2260 q\u2081) :\n    (@\u03b6 p\u2080 q\u2080 p\u2081 q\u2081 t \u2260 0) := by\n  refine div_ne_zero ?_ ?_\n  \u00b7 apply mul_ne_zero (preservation_positivity_inv_toReal ht hp\u2080 hp\u2081 hp\u2080p\u2081).ne'\n    refine sub_ne_zero_of_ne (Ne.symm fun h \u21a6 hq\u2080q\u2081 ?_)\n    rw [\u2190 inv_inv q\u2080, \u2190 inv_inv q\u2081, \u2190 coe_inv_exponent hq\u2080, \u2190 coe_inv_exponent hq\u2081]\n    exact congrArg Inv.inv (congrArg ENNReal.ofReal h)\n  \u00b7 apply mul_ne_zero (preservation_positivity_inv_toReal ht hq\u2080 hq\u2081 hq\u2080q\u2081).ne'\n    refine sub_ne_zero_of_ne (Ne.symm fun h \u21a6 hp\u2080p\u2081 ?_)\n    rw [\u2190 inv_inv p\u2080, \u2190 inv_inv p\u2081, \u2190 coe_inv_exponent hp\u2080, \u2190 coe_inv_exponent hp\u2081]\n    exact congrArg Inv.inv (congrArg ENNReal.ofReal h)\n\nlemma \u03b6_le_zero_iff_of_lt\u2080 (ht : t \u2208 Ioo 0 1) (hp\u2080 : p\u2080 > 0) (hq\u2080 : q\u2080 > 0) (hp\u2081 : p\u2081 > 0)\n    (hq\u2081 : q\u2081 > 0) (hq\u2080q\u2081 : q\u2080 \u2260 q\u2081)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9)\n    (hq : q\u207b\u00b9 = (1 - ENNReal.ofReal t) * q\u2080\u207b\u00b9 + ENNReal.ofReal t * q\u2081\u207b\u00b9) (hp\u2080p\u2081' : p\u2080 < p\u2081) :\n    (@\u03b6 p\u2080 q\u2080 p\u2081 q\u2081 t \u2264 0) \u2194 q < q\u2080 := by\n  constructor <;> intro h\n  \u00b7 rcases (Decidable.lt_or_eq_of_le h) with \u03b6_lt_0 | \u03b6_eq_0\n    \u00b7 exact (\u03b6_neg_iff_of_lt\u2080 ht hp\u2080 hq\u2080 hp\u2081 hq\u2081 hq\u2080q\u2081 hp hq hp\u2080p\u2081').mp \u03b6_lt_0\n    \u00b7 exact False.elim <| (\u03b6_ne_zero ht hp\u2080 hq\u2080 hp\u2081 hq\u2081 hp\u2080p\u2081'.ne hq\u2080q\u2081) \u03b6_eq_0\n  \u00b7 exact ((\u03b6_neg_iff_of_lt\u2080 ht hp\u2080 hq\u2080 hp\u2081 hq\u2081 hq\u2080q\u2081 hp hq hp\u2080p\u2081').mpr h).le\n\nlemma \u03b6_le_zero_iff_of_lt\u2081 (ht : t \u2208 Ioo 0 1) (hp\u2080 : p\u2080 > 0) (hq\u2080 : q\u2080 > 0) (hp\u2081 : p\u2081 > 0)\n    (hq\u2081 : q\u2081 > 0) (hq\u2080q\u2081 : q\u2080 \u2260 q\u2081)\n    (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9)\n    (hq : q\u207b\u00b9 = (1 - ENNReal.ofReal t) * q\u2080\u207b\u00b9 + ENNReal.ofReal t * q\u2081\u207b\u00b9) (hp\u2080p\u2081' : p\u2080 < p\u2081) :\n    (@\u03b6 p\u2080 q\u2080 p\u2081 q\u2081 t) \u2264 0 \u2194 q\u2081 < q := by\n  rw [\u2190 exp_lt_exp_gt_iff ht hq\u2080 hq\u2081 hq\u2080q\u2081 hq]\n  exact \u03b6_le_zero_iff_of_lt\u2080 ht hp\u2080 hq\u2080 hp\u2081 hq\u2081 hq\u2080q\u2081 hp hq hp\u2080p\u2081'\n\nlemma eq_exponents\u2080 (ht : t \u2208 Ioo 0 1) (hq\u2080 : q\u2080 > 0) (hq\u2081 : q\u2081 > 0) (hq\u2080q\u2081 : q\u2080 \u2260 q\u2081)\n    (hq : q\u207b\u00b9 = (1 - ENNReal.ofReal t) * q\u2080\u207b\u00b9 + ENNReal.ofReal t * q\u2081\u207b\u00b9) (hq\u2080' : q\u2080 \u2260 \u22a4) :\n    (q\u2080.toReal + q\u2081\u207b\u00b9.toReal / (q\u2081\u207b\u00b9.toReal - q\u2080\u207b\u00b9.toReal) *\n    (q.toReal - q\u2080.toReal)) = (1 - t) * q.toReal := by\n  rw [mul_comm_div, \u2190 mul_div_assoc, add_div']\n  \u00b7 have : q\u2080.toReal * (q\u2081\u207b\u00b9.toReal - q\u2080\u207b\u00b9.toReal) + q\u2081\u207b\u00b9.toReal * (q.toReal - q\u2080.toReal) =\n        q.toReal * ((1 - t) * (q\u2081\u207b\u00b9.toReal - q\u2080\u207b\u00b9.toReal)) := by\n      calc\n      _ = q\u2080.toReal * q\u2081\u207b\u00b9.toReal - q\u2080.toReal * q\u2080\u207b\u00b9.toReal +\n          q\u2081\u207b\u00b9.toReal * q.toReal - q\u2081\u207b\u00b9.toReal *  q\u2080.toReal := by\n        ring\n      _ = q\u2081\u207b\u00b9.toReal * q.toReal - q\u207b\u00b9.toReal * q.toReal := by\n        rw [toReal_inv, toReal_inv, toReal_inv, mul_inv_cancel\u2080, inv_mul_cancel\u2080]\n        \u00b7 ring\n        \u00b7 exact (interp_exp_toReal_pos ht hq\u2080 hq\u2081 hq\u2080q\u2081 hq).ne'\n        \u00b7 exact (toReal_pos hq\u2080.ne' hq\u2080').ne'\n      _ = q.toReal * (q\u2081\u207b\u00b9.toReal - q\u207b\u00b9.toReal) := by ring\n      _ = _ := by\n        rw [preservation_interpolation ht hq\u2080 hq\u2081 hq]\n        congr\n        ring\n    rw [this, mul_div_assoc, mul_div_cancel_right\u2080]\n    \u00b7 ring\n    exact ne_sub_toReal_exp hq\u2080 hq\u2081 hq\u2080q\u2081\n  \u00b7 exact ne_sub_toReal_exp hq\u2080 hq\u2081 hq\u2080q\u2081\n\nlemma eq_exponents\u2082 (ht : t \u2208 Ioo 0 1) (hq\u2080 : q\u2080 > 0) (hq\u2081 : q\u2081 > 0) (hq\u2080q\u2081 : q\u2080 \u2260 q\u2081)\n    (hq : q\u207b\u00b9 = (1 - ENNReal.ofReal t) * q\u2080\u207b\u00b9 + ENNReal.ofReal t * q\u2081\u207b\u00b9) (hq\u2080' : q\u2080 \u2260 \u22a4) :\n    (q\u2080.toReal / p\u2080.toReal + p\u2080\u207b\u00b9.toReal * q\u2081\u207b\u00b9.toReal / (q\u2081\u207b\u00b9.toReal - q\u2080\u207b\u00b9.toReal) *\n    (q.toReal - q\u2080.toReal)) = (1 - t) * p\u2080\u207b\u00b9.toReal * q.toReal := by\n  rw [div_eq_inv_mul, mul_div_assoc, mul_assoc, toReal_inv, \u2190 mul_add, mul_comm_div,\n    \u2190 mul_div_assoc, add_div']\n  \u00b7 have : q\u2080.toReal * (q\u2081\u207b\u00b9.toReal - q\u2080\u207b\u00b9.toReal) + q\u2081\u207b\u00b9.toReal * (q.toReal - q\u2080.toReal) =\n        q.toReal * ((1 - t) * (q\u2081\u207b\u00b9.toReal - q\u2080\u207b\u00b9.toReal)) := by\n      calc\n      _ = q\u2080.toReal * q\u2081\u207b\u00b9.toReal - q\u2080.toReal * q\u2080\u207b\u00b9.toReal +\n          q\u2081\u207b\u00b9.toReal * q.toReal - q\u2081\u207b\u00b9.toReal *  q\u2080.toReal := by\n        ring\n      _ = q\u2081\u207b\u00b9.toReal * q.toReal - q\u207b\u00b9.toReal * q.toReal := by\n        rw [toReal_inv, toReal_inv, toReal_inv, mul_inv_cancel\u2080, inv_mul_cancel\u2080]\n        \u00b7 ring\n        \u00b7 exact (interp_exp_toReal_pos ht hq\u2080 hq\u2081 hq\u2080q\u2081 hq).ne'\n        \u00b7 exact (toReal_pos hq\u2080.ne' hq\u2080').ne'\n      _ = q.toReal * (q\u2081\u207b\u00b9.toReal - q\u207b\u00b9.toReal) := by ring\n      _ = _ := by\n        rw [preservation_interpolation ht hq\u2080 hq\u2081 hq]\n        congr\n        ring\n    rw [this, mul_div_assoc, mul_div_cancel_right\u2080]\n    \u00b7 ring\n    \u00b7 exact ne_sub_toReal_exp hq\u2080 hq\u2081 hq\u2080q\u2081\n  \u00b7 exact ne_sub_toReal_exp hq\u2080 hq\u2081 hq\u2080q\u2081\n\nlemma eq_exponents\u2081 (ht : t \u2208 Ioo 0 1) (hq\u2080 : q\u2080 > 0) (hq\u2081 : q\u2081 > 0) (hq\u2080q\u2081 : q\u2080 \u2260 q\u2081)\n    (hq : q\u207b\u00b9 = (1 - ENNReal.ofReal t) * q\u2080\u207b\u00b9 + ENNReal.ofReal t * q\u2081\u207b\u00b9) (hq\u2080' : q\u2080 \u2260 \u22a4) :\n    (q\u2080\u207b\u00b9.toReal / (q\u2081\u207b\u00b9.toReal - q\u2080\u207b\u00b9.toReal)) * (q.toReal - q\u2080.toReal) = - t * q.toReal := by\n  rw [mul_comm_div, \u2190 mul_div_assoc]\n  have : q\u2080\u207b\u00b9.toReal * (q.toReal - q\u2080.toReal) = - t * q.toReal * (q\u2081\u207b\u00b9.toReal - q\u2080\u207b\u00b9.toReal) := by\n    calc\n    _ = (q\u2080\u207b\u00b9.toReal * q.toReal - q\u2080\u207b\u00b9.toReal * q\u2080.toReal) := by ring\n    _ = (q\u2080\u207b\u00b9.toReal * q.toReal - 1) := by\n      rw [toReal_inv, inv_mul_cancel\u2080]\n      exact (exp_toReal_pos hq\u2080 hq\u2080').ne'\n    _ = (q\u2080\u207b\u00b9.toReal * q.toReal - q\u207b\u00b9.toReal * q.toReal) := by\n      rw [toReal_inv, toReal_inv, inv_mul_cancel\u2080]\n      exact (interp_exp_toReal_pos ht hq\u2080 hq\u2081 hq\u2080q\u2081 hq).ne'\n    _ = q.toReal * (q\u2080\u207b\u00b9.toReal - q\u207b\u00b9.toReal) := by ring\n    _ = _ := by\n      rw [preservation_interpolation ht hq\u2080 hq\u2081 hq]\n      ring\n  rw [this, mul_div_cancel_right\u2080]\n  exact ne_sub_toReal_exp hq\u2080 hq\u2081 hq\u2080q\u2081\n\n-- TODO: simplify these proofs with statements above\nlemma eq_exponents\u2083 (ht : t \u2208 Ioo 0 1) (hq\u2080 : q\u2080 > 0) (hq\u2081 : q\u2081 > 0) (hq\u2080q\u2081 : q\u2080 \u2260 q\u2081)\n    (hq : q\u207b\u00b9 = (1 - ENNReal.ofReal t) * q\u2080\u207b\u00b9 + ENNReal.ofReal t * q\u2081\u207b\u00b9) (hq\u2080' : q\u2080 \u2260 \u22a4) :\n    (p\u2081\u207b\u00b9.toReal * q\u2080\u207b\u00b9.toReal / (q\u2081\u207b\u00b9.toReal - q\u2080\u207b\u00b9.toReal)) * (q.toReal - q\u2080.toReal) =\n    - t * p\u2081\u207b\u00b9.toReal * q.toReal := by\n  rw [mul_comm_div, \u2190 mul_div_assoc]\n  have : (p\u2081\u207b\u00b9.toReal * q\u2080\u207b\u00b9.toReal) * (q.toReal - q\u2080.toReal) =\n      - t * p\u2081\u207b\u00b9.toReal * q.toReal * (q\u2081\u207b\u00b9.toReal - q\u2080\u207b\u00b9.toReal) := by\n    calc\n    _ = p\u2081\u207b\u00b9.toReal * (q\u2080\u207b\u00b9.toReal * q.toReal - q\u2080\u207b\u00b9.toReal * q\u2080.toReal) := by ring\n    _ = p\u2081\u207b\u00b9.toReal * (q\u2080\u207b\u00b9.toReal * q.toReal - 1) := by\n      rw [toReal_inv, toReal_inv, inv_mul_cancel\u2080]\n      apply (exp_toReal_pos hq\u2080 hq\u2080').ne'\n    _ = p\u2081\u207b\u00b9.toReal * (q\u2080\u207b\u00b9.toReal * q.toReal - q\u207b\u00b9.toReal * q.toReal) := by\n      rw [toReal_inv, toReal_inv, toReal_inv, inv_mul_cancel\u2080]\n      exact (interp_exp_toReal_pos ht hq\u2080 hq\u2081 hq\u2080q\u2081 hq).ne'\n    _ = p\u2081\u207b\u00b9.toReal * q.toReal * (q\u2080\u207b\u00b9.toReal - q\u207b\u00b9.toReal) := by ring\n    _ = _ := by\n      rw [preservation_interpolation ht hq\u2080 hq\u2081 hq]\n      ring\n  rw [this, mul_div_cancel_right\u2080]\n  exact ne_sub_toReal_exp hq\u2080 hq\u2081 hq\u2080q\u2081\n\nlemma eq_exponents\u2084  :\n    (q\u2080\u207b\u00b9.toReal / (q\u2081\u207b\u00b9.toReal - q\u2080\u207b\u00b9.toReal)) =\n    - (q\u2080\u207b\u00b9.toReal / (q\u2080\u207b\u00b9.toReal - q\u2081\u207b\u00b9.toReal)) := calc\n  _ = - (q\u2080\u207b\u00b9.toReal * (-(q\u2081\u207b\u00b9.toReal - q\u2080\u207b\u00b9.toReal)\u207b\u00b9)) := by\n    rw [div_eq_mul_inv]; ring\n  _ = _ := by congr; rw [neg_inv, neg_sub]\n\nlemma eq_exponents\u2085 (ht : t \u2208 Ioo 0 1) (hq\u2080 : q\u2080 > 0) (hq\u2081 : q\u2081 > 0) (hq\u2080q\u2081 : q\u2080 \u2260 q\u2081)\n    (hq : q\u207b\u00b9 = (1 - ENNReal.ofReal t) * q\u2080\u207b\u00b9 + ENNReal.ofReal t * q\u2081\u207b\u00b9) (hq\u2081' : q\u2081 \u2260 \u22a4):\n    (q\u2081.toReal + -(q\u2080\u207b\u00b9.toReal / (q\u2081\u207b\u00b9.toReal - q\u2080\u207b\u00b9.toReal) * (q.toReal - q\u2081.toReal)))\n    = t * q.toReal := by\n  rw [eq_exponents\u2084, neg_mul, neg_neg, eq_exponents\u2080 (Ioo.one_sub_mem ht) hq\u2081 hq\u2080 (Ne.symm hq\u2080q\u2081)\n    (switch_exponents ht hq) hq\u2081']\n  ring\n\nlemma eq_exponents\u2086 (ht : t \u2208 Ioo 0 1) (hq\u2080 : q\u2080 > 0) (hq\u2081 : q\u2081 > 0) (hq\u2080q\u2081 : q\u2080 \u2260 q\u2081)\n    (hq : q\u207b\u00b9 = (1 - ENNReal.ofReal t) * q\u2080\u207b\u00b9 + ENNReal.ofReal t * q\u2081\u207b\u00b9) (hq\u2081' : q\u2081 \u2260 \u22a4) :\n    q\u2081\u207b\u00b9.toReal / (q\u2081\u207b\u00b9.toReal - q\u2080\u207b\u00b9.toReal) * (q.toReal - q\u2081.toReal) = (1 - t) * q.toReal := by\n  rw [\u2190 neg_neg (a := q\u2081\u207b\u00b9.toReal / (q\u2081\u207b\u00b9.toReal - q\u2080\u207b\u00b9.toReal)), \u2190 eq_exponents\u2084, neg_mul,\n    eq_exponents\u2081 (Ioo.one_sub_mem ht) hq\u2081 hq\u2080 (Ne.symm hq\u2080q\u2081) (switch_exponents ht hq) hq\u2081']\n  ring\n\nlemma eq_exponents\u2087 (ht : t \u2208 Ioo 0 1) (hq\u2080 : q\u2080 > 0) (hq\u2081 : q\u2081 > 0) (hq\u2080q\u2081 : q\u2080 \u2260 q\u2081)\n    (hq : q\u207b\u00b9 = (1 - ENNReal.ofReal t) * q\u2080\u207b\u00b9 + ENNReal.ofReal t * q\u2081\u207b\u00b9) (hq\u2081' : q\u2081 \u2260 \u22a4) :\n    q\u2081.toReal / p\u2081.toReal + -(p\u2081\u207b\u00b9.toReal * q\u2080\u207b\u00b9.toReal / (q\u2081\u207b\u00b9.toReal - q\u2080\u207b\u00b9.toReal) *\n    (q.toReal - q\u2081.toReal)) =\n    t * p\u2081\u207b\u00b9.toReal * q.toReal := by\n  rw [div_eq_mul_inv, toReal_inv]\n  calc\n  _ = p\u2081.toReal\u207b\u00b9 * (q\u2081.toReal + - (q\u2080\u207b\u00b9.toReal / (q\u2081\u207b\u00b9.toReal - q\u2080\u207b\u00b9.toReal) *\n      (q.toReal - q\u2081.toReal))) := by ring\n  _ = _ := by\n    rw [eq_exponents\u2085 (ht := ht)] <;> try assumption\n    ring\n\nlemma eq_exponents\u2088 (ht : t \u2208 Ioo 0 1) (hq\u2080 : q\u2080 > 0) (hq\u2081 : q\u2081 > 0) (hq\u2080q\u2081 : q\u2080 \u2260 q\u2081)\n    (hq : q\u207b\u00b9 = (1 - ENNReal.ofReal t) * q\u2080\u207b\u00b9 + ENNReal.ofReal t * q\u2081\u207b\u00b9) (hq\u2081' : q\u2081 \u2260 \u22a4) :\n    p\u2080\u207b\u00b9.toReal * q\u2081\u207b\u00b9.toReal / (q\u2081\u207b\u00b9.toReal - q\u2080\u207b\u00b9.toReal) * (q.toReal - q\u2081.toReal) =\n    (1 - t) * p\u2080\u207b\u00b9.toReal * q.toReal := calc\n  _ = p\u2080\u207b\u00b9.toReal * (q\u2081\u207b\u00b9.toReal / (q\u2081\u207b\u00b9.toReal - q\u2080\u207b\u00b9.toReal) * (q.toReal - q\u2081.toReal)) := by ring\n  _ = _ := by\n    rw [eq_exponents\u2086] <;> try assumption\n    ring\n\nend ComputationsChoiceExponent\n\nend\n\n/-! ## Interface for using cutoff functions\n-/\nnoncomputable section\n\nopen Real Set\n\n/-- A ScaledPowerFunction is meant to represent a function of the form `t \u21a6 (t / d)^\u03c3`,\n    where `d` is strictly positive and either `\u03c3 > 0` or `\u03c3 < 0`. -/\nstructure ScaledPowerFunction where\n  \u03c3 : \u211d\n  d : \u211d\n  hd : d > 0\n  h\u03c3 : (\u03c3 > 0) \u2228 (\u03c3 < 0)\n\n/-- A ToneCouple is an couple of two monotone functions that are practically inverses of each\n    other. It is used in the proof of the real interpolation theorem.\n\n    Note: originally it seemed useful to make the possible choice of this function general\n    in the proof of the real inteprolation theorem. However, in the end really only one\n    function works for all the different cases. This infrastructure, however, could potentially\n    still be useful, if one would like to try to improve the constant. -/\nstructure ToneCouple where\n  ton : \u211d \u2192 \u211d\n  inv : \u211d \u2192 \u211d\n  mon : Bool\n  ton_is_ton : if mon then StrictMonoOn ton (Ioi 0) else StrictAntiOn ton (Ioi 0)\n  ran_ton : \u2200 t \u2208 Ioi (0 : \u211d), ton t \u2208 Ioi 0\n  ran_inv : \u2200 t \u2208 Ioi (0 : \u211d), inv t \u2208 Ioi 0\n  inv_pf : if mon\n      then \u2200 s \u2208 Ioi (0 : \u211d), \u2200 t \u2208 Ioi (0 : \u211d), (ton s < t \u2194 s < inv t) \u2227 (t < ton s \u2194 inv t < s)\n      else \u2200 s \u2208 Ioi (0 : \u211d), \u2200 t \u2208 Ioi (0 : \u211d), (ton s < t \u2194 inv t < s) \u2227 (t < ton s \u2194 s < inv t)\n\n/-- A scaled power function gives rise to a ToneCouple. -/\ndef spf_to_tc (spf : ScaledPowerFunction) : ToneCouple where\n  ton := fun s : \u211d \u21a6 (s / spf.d) ^ spf.\u03c3\n  inv := fun t : \u211d \u21a6 spf.d * t ^ spf.\u03c3\u207b\u00b9\n  mon := if spf.\u03c3 > 0 then true else false\n  ran_ton := fun t ht \u21a6 rpow_pos_of_pos (div_pos ht spf.hd) _\n  ran_inv := fun t ht \u21a6 mul_pos spf.hd (rpow_pos_of_pos ht spf.\u03c3\u207b\u00b9)\n  ton_is_ton := by\n    split <;> rename_i sgn_\u03c3\n    \u00b7 simp only [\u2193reduceIte]\n      intro s (hs : s > 0) t (ht : t > 0) hst\n      refine (rpow_lt_rpow_iff ?_ ?_ sgn_\u03c3).mpr ?_\n      \u00b7 exact (div_pos hs spf.hd).le\n      \u00b7 exact (div_pos ht spf.hd).le\n      \u00b7 exact div_lt_div_of_pos_right hst spf.hd\n    \u00b7 simp only [Bool.false_eq_true, \u2193reduceIte]\n      intro s (hs : s > 0) t (ht : t > 0) hst\n      rcases spf.h\u03c3 with \u03c3_pos | \u03c3_neg\n      \u00b7 exact (sgn_\u03c3 \u03c3_pos).elim\n      \u00b7 simp only\n        exact (Real.rpow_lt_rpow_iff_of_neg (div_pos ht spf.hd)\n          (div_pos hs spf.hd) \u03c3_neg).mpr (div_lt_div_of_pos_right hst spf.hd)\n  inv_pf := by\n    split <;> rename_i sgn_\u03c3\n    \u00b7 simp only [\u2193reduceIte, mem_Ioi]\n      refine fun s hs t ht => \u27e8?_, ?_\u27e9\n      \u00b7 rw [\u2190 Real.lt_rpow_inv_iff_of_pos (div_nonneg hs.le spf.hd.le) ht.le sgn_\u03c3,\n        \u2190 _root_.mul_lt_mul_left spf.hd, mul_div_cancel\u2080 _ spf.hd.ne']\n      \u00b7 rw [\u2190 Real.rpow_inv_lt_iff_of_pos ht.le (div_nonneg hs.le spf.hd.le)\n          sgn_\u03c3, \u2190 _root_.mul_lt_mul_left spf.hd, mul_div_cancel\u2080 _ spf.hd.ne']\n    \u00b7 simp only [\u2193reduceIte, mem_Ioi]\n      intro s hs t ht\n      rcases spf.h\u03c3 with \u03c3_pos | \u03c3_neg\n      \u00b7 contradiction\n      \u00b7 constructor\n        \u00b7 rw [\u2190 Real.rpow_inv_lt_iff_of_neg ht (div_pos hs spf.hd) \u03c3_neg,\n            \u2190 _root_.mul_lt_mul_left spf.hd, mul_div_cancel\u2080 _ spf.hd.ne']\n        \u00b7 rw [\u2190 Real.lt_rpow_inv_iff_of_neg (div_pos hs spf.hd) ht \u03c3_neg,\n            \u2190 _root_.mul_lt_mul_left spf.hd, mul_div_cancel\u2080 _ spf.hd.ne']\n\nend\n\nnoncomputable section\n\nopen NNReal ENNReal MeasureTheory Set ComputationsInterpolatedExponents\n    ComputationsChoiceExponent\n\nvariable {\u03b1 \u03b1' E E\u2081 E\u2082 E\u2083 : Type*} {m : MeasurableSpace \u03b1} {m' : MeasurableSpace \u03b1'}\n  {p p' q p\u2080 q\u2080 p\u2081 q\u2081: \u211d\u22650\u221e}\n  {C\u2080 C\u2081 : \u211d\u22650} {\u03bc : Measure \u03b1} {\u03bd : Measure \u03b1'}\n  {a : \u211d}-- truncation parameter\n  [NormedAddCommGroup E]\n  [NormedAddCommGroup E\u2081]\n  [NormedAddCommGroup E\u2082]\n  [NormedAddCommGroup E\u2083]\n  [MeasurableSpace E] [BorelSpace E]\n  [MeasurableSpace E\u2083] [BorelSpace E\u2083]\n  {f : \u03b1 \u2192 E\u2081} {t : \u211d}\n  {T : (\u03b1 \u2192 E\u2081) \u2192 (\u03b1' \u2192 E\u2082)}\n\n/-! ## Results about the particular choice of scale\n\n    The proof of the real interpolation theorem will estimate\n    `distribution (trunc f A(t)) t` and `distribution (trunc_compl f A(t)) t` for a\n    function `A`. The function `A` can be given a closed-form expression that works for\n    _all_ cases in the real interpolation theorem, because of the computation rules available\n    for elements in `\u211d\u22650\u221e` that avoid the need for a limiting procedure, e.g. `\u22a4\u207b\u00b9 = 0`.\n\n    The function `A` will be of the form `A(t) = (t / d) ^ \u03c3` for particular choices of `d` and\n    `\u03c3`. This section contatins results about the scale `d`.\n-/\nnamespace ChoiceScale\n\ndef d := ENNReal.toReal\n    (C\u2080 ^ (q\u2081\u207b\u00b9.toReal / (q\u2081\u207b\u00b9.toReal - q\u2080\u207b\u00b9.toReal)) * (eLpNorm f p \u03bc ^ p.toReal) ^\n      (p\u2080\u207b\u00b9.toReal * q\u2081\u207b\u00b9.toReal / (q\u2081\u207b\u00b9.toReal - q\u2080\u207b\u00b9.toReal)) /\n    (C\u2081 ^ (q\u2080\u207b\u00b9.toReal / (q\u2081\u207b\u00b9.toReal - q\u2080\u207b\u00b9.toReal)) * (eLpNorm f p \u03bc ^ p.toReal) ^\n      (p\u2081\u207b\u00b9.toReal * q\u2080\u207b\u00b9.toReal / (q\u2081\u207b\u00b9.toReal - q\u2080\u207b\u00b9.toReal))))\n\nlemma d_pos_aux\u2080 (hF : eLpNorm f p \u03bc \u2208 Ioo 0 \u22a4) :\n    0 < eLpNorm f p \u03bc ^ p.toReal :=\n  ENNReal.rpow_pos (pos_of_Ioo hF) (ne_top_of_Ioo hF)\n\nlemma d_ne_top_aux\u2080 {b : \u211d} {F : \u211d\u22650\u221e} (hF : F \u2208 Ioo 0 \u22a4) : F ^ b \u2260 \u22a4 :=\n  rpow_ne_top' (ne_zero_of_Ioo hF) (ne_top_of_Ioo hF)\n\nlemma d_ne_zero_aux\u2080 {b : \u211d} (hF : eLpNorm f p \u03bc \u2208 Ioo 0 \u22a4) :\n    (eLpNorm f p \u03bc ^ p.toReal) ^ b \u2260 0 :=\n  (ENNReal.rpow_pos (d_pos_aux\u2080 hF) (d_ne_top_aux\u2080 hF)).ne'\n\nlemma d_ne_zero_aux\u2081 {C : \u211d\u22650} {c : \u211d} (hC : C > 0) :\n    (ENNReal.ofNNReal C) ^ c \u2260 0 :=\n  (ENNReal.rpow_pos (ENNReal.coe_pos.mpr hC) coe_ne_top).ne'\n\nlemma d_ne_zero_aux\u2082 {C : \u211d\u22650} {b c : \u211d} (hC : C > 0)\n    (hF : eLpNorm f p \u03bc \u2208 Ioo 0 \u22a4) :\n    C ^ c * (eLpNorm f p \u03bc ^ p.toReal) ^ b \u2260 0 :=\n  (ENNReal.mul_pos (d_ne_zero_aux\u2081 hC) (d_ne_zero_aux\u2080 hF)).ne'\n\nlemma d_ne_top_aux\u2081 {C : \u211d\u22650} {c : \u211d} (hC : C > 0) :\n    (ENNReal.ofNNReal C) ^ c \u2260 \u22a4 :=\n  rpow_ne_top' (ENNReal.coe_pos.mpr hC).ne' coe_ne_top\n\nlemma d_ne_top_aux\u2082 {b : \u211d} (hF : eLpNorm f p \u03bc \u2208 Ioo 0 \u22a4) :\n    (eLpNorm f p \u03bc ^ p.toReal) ^ b \u2260 \u22a4 :=\n  rpow_ne_top' (d_pos_aux\u2080 hF).ne' (d_ne_top_aux\u2080 hF)\n\nlemma d_ne_top_aux\u2083 {C : \u211d\u22650} {b c : \u211d} (hC : C > 0)\n    (hF : eLpNorm f p \u03bc \u2208 Ioo 0 \u22a4) :\n    C ^ c * (eLpNorm f p \u03bc ^ p.toReal) ^ b \u2260 \u22a4 :=\n  mul_ne_top (d_ne_top_aux\u2081 hC) (d_ne_top_aux\u2082 hF)\n\nlemma d_ne_zero_aux\u2083 {b\u2080 c\u2080 b\u2081 c\u2081 : \u211d} (hC\u2080 : C\u2080 > 0) (hC\u2081 : C\u2081 > 0) (hF : eLpNorm f p \u03bc \u2208 Ioo 0 \u22a4) :\n    (C\u2080 ^ c\u2080 * (eLpNorm f p \u03bc ^ p.toReal) ^ b\u2080) /\n    (C\u2081 ^ c\u2081 * (eLpNorm f p \u03bc ^ p.toReal) ^ b\u2081) \u2260 0 := by\n  refine ENNReal.div_ne_zero.mpr \u27e8?_, ?_\u27e9\n  \u00b7 apply d_ne_zero_aux\u2082 <;> try assumption\n  \u00b7 apply d_ne_top_aux\u2083 <;> try assumption\n\nlemma d_ne_top_aux\u2084 {b\u2080 c\u2080 b\u2081 c\u2081 : \u211d} (hC\u2080 : C\u2080 > 0) (hC\u2081 : C\u2081 > 0) (hF : eLpNorm f p \u03bc \u2208 Ioo 0 \u22a4) :\n    (C\u2080 ^ c\u2080 * (eLpNorm f p \u03bc ^ p.toReal) ^ b\u2080) /\n    (C\u2081 ^ c\u2081 * (eLpNorm f p \u03bc ^ p.toReal) ^ b\u2081) \u2260 \u22a4 := by\n  refine (div_lt_top ?_ ?_).ne\n  \u00b7 apply d_ne_top_aux\u2083 <;> assumption\n  \u00b7 apply d_ne_zero_aux\u2082 <;> assumption\n\n-- If the `p`-norm of `f` is positive and finite, then `d` is positive\nlemma d_pos (hC\u2080 : C\u2080 > 0) (hC\u2081 : C\u2081 > 0) (hF : eLpNorm f p \u03bc \u2208 Ioo 0 \u22a4) :\n  @d \u03b1 E\u2081 m p p\u2080 q\u2080 p\u2081 q\u2081 C\u2080 C\u2081 \u03bc _ f > 0 :=\ntoReal_pos (d_ne_zero_aux\u2083 hC\u2080 hC\u2081 hF) (d_ne_top_aux\u2084 hC\u2080 hC\u2081 hF)\n\nlemma d_eq_top\u2080 (hp\u2080 : p\u2080 > 0) (hq\u2081 : q\u2081 > 0) (hp\u2080' : p\u2080 \u2260 \u22a4) (hq\u2080' : q\u2080 = \u22a4) (hq\u2080q\u2081 : q\u2080 \u2260 q\u2081):\n    @d \u03b1 E\u2081 m p p\u2080 q\u2080 p\u2081 q\u2081 C\u2080 C\u2081 \u03bc _ f =\n    (\u2191C\u2080 ^ p\u2080.toReal * eLpNorm f p \u03bc ^ p.toReal).toReal ^ p\u2080.toReal\u207b\u00b9 := by\n  unfold d\n  rw [hq\u2080']\n  simp only [inv_top, zero_toReal, sub_zero, zero_div, ENNReal.rpow_zero, mul_zero, mul_one,\n    div_one]\n  rw [mul_div_cancel_right\u2080]\n  \u00b7 rw [div_eq_mul_inv, mul_inv_cancel\u2080, ENNReal.rpow_one]\n    \u00b7 rw [toReal_rpow, ENNReal.mul_rpow_of_nonneg]\n      \u00b7 rw [ENNReal.rpow_rpow_inv, toReal_inv]\n        exact (exp_toReal_pos hp\u2080 hp\u2080').ne'\n      \u00b7 positivity\n    \u00b7 exact (inv_toReal_pos_of_ne_top hq\u2081 ((hq\u2080' \u25b8 hq\u2080q\u2081).symm)).ne'\n  \u00b7 exact (inv_toReal_pos_of_ne_top hq\u2081 ((hq\u2080' \u25b8 hq\u2080q\u2081).symm)).ne'\n\nlemma d_eq_top\u2081 (hq\u2080 : q\u2080 > 0) (hp\u2081 : p\u2081 > 0) (hp\u2081' : p\u2081 \u2260 \u22a4) (hq\u2081' : q\u2081 = \u22a4)\n    (hq\u2080q\u2081 : q\u2080 \u2260 q\u2081) (hC\u2081 : C\u2081 > 0) :\n    @d \u03b1 E\u2081 m p p\u2080 q\u2080 p\u2081 q\u2081 C\u2080 C\u2081 \u03bc _ f =\n    (\u2191C\u2081 ^ p\u2081.toReal * eLpNorm f p \u03bc ^ p.toReal).toReal ^ p\u2081.toReal\u207b\u00b9 := by\n  unfold d\n  rw [hq\u2081']\n  simp only [inv_top, zero_toReal, zero_sub, zero_div, ENNReal.rpow_zero, mul_zero, mul_one,\n    one_div]\n  rw [div_neg, div_neg]\n  rw [mul_div_cancel_right\u2080]\n  \u00b7 rw [div_eq_mul_inv, mul_inv_cancel\u2080, ENNReal.rpow_neg_one]\n    \u00b7 rw [toReal_rpow, ENNReal.mul_rpow_of_nonneg]\n      \u00b7 rw [ENNReal.rpow_rpow_inv, \u2190 toReal_inv, ENNReal.mul_inv, inv_inv]\n        \u00b7 rw [\u2190 ENNReal.rpow_neg_one, \u2190 ENNReal.rpow_mul, toReal_inv, mul_neg, mul_one, neg_neg,\n            toReal_mul, coe_toReal]\n        \u00b7 left; exact ENNReal.inv_ne_zero.mpr coe_ne_top\n        \u00b7 left; exact inv_ne_top.mpr <| (ENNReal.coe_pos.mpr hC\u2081).ne'\n        \u00b7 exact (exp_toReal_pos hp\u2081 hp\u2081').ne'\n      \u00b7 positivity\n    \u00b7 exact (inv_toReal_pos_of_ne_top hq\u2080 (hq\u2081' \u25b8 hq\u2080q\u2081)).ne'\n  \u00b7 exact (inv_toReal_pos_of_ne_top hq\u2080 (hq\u2081' \u25b8 hq\u2080q\u2081)).ne'\n\nlemma d_eq_top_of_eq (hC\u2081 : C\u2081 > 0) (hp\u2080 : p\u2080 > 0) (hq\u2080 : q\u2080 > 0) (hq\u2080' : q\u2080 \u2260 \u22a4)\n(hp\u2080': p\u2080 \u2260 \u22a4) (hp\u2081 : p\u2081 > 0) (hp\u2080p\u2081 : p\u2080 = p\u2081) (hpp\u2080: p = p\u2080) (hq\u2081' : q\u2081 = \u22a4) :\n    @d \u03b1 E\u2081 m p p\u2080 q\u2080 p\u2081 q\u2081 C\u2080 C\u2081 \u03bc _ f = (C\u2081 * eLpNorm f p \u03bc).toReal := by\n  rw [d_eq_top\u2081, \u2190 hp\u2080p\u2081, hpp\u2080] <;> try assumption\n  on_goal 1 => rw [toReal_rpow, ENNReal.mul_rpow_of_nonneg, ENNReal.rpow_rpow_inv, ENNReal.rpow_rpow_inv]\n  \u00b7 exact exp_toReal_ne_zero' hp\u2080 hp\u2080'\n  \u00b7 exact exp_toReal_ne_zero' hp\u2080 hp\u2080'\n  \u00b7 positivity\n  \u00b7 exact hp\u2080p\u2081 \u25b8 hp\u2080'\n  \u00b7 exact hq\u2081' \u25b8 hq\u2080'\n\nlemma d_eq_top_top (hq\u2080 : q\u2080 > 0) (hq\u2080q\u2081 : q\u2080 \u2260 q\u2081) (hp\u2081' : p\u2081 = \u22a4) (hq\u2081' : q\u2081 = \u22a4) :\n    @d \u03b1 E\u2081 m p p\u2080 q\u2080 p\u2081 q\u2081 C\u2080 C\u2081 \u03bc _ f = C\u2081 := by\n  unfold d\n  rw [hp\u2081', hq\u2081']\n  simp only [inv_top, zero_toReal, zero_sub, zero_div, ENNReal.rpow_zero, mul_zero, mul_one,\n    zero_mul, one_div]\n  rw [div_neg, div_eq_mul_inv, mul_inv_cancel\u2080]\n  \u00b7 rw [ENNReal.rpow_neg, ENNReal.rpow_one, inv_inv, coe_toReal]\n  \u00b7 exact (toReal_pos (ENNReal.inv_ne_zero.mpr (hq\u2081' \u25b8 hq\u2080q\u2081)) (ENNReal.inv_ne_top.mpr hq\u2080.ne')).ne'\n\n/-- The particular choice of scaled power function that works in the proof of the\n    real interpolation theorem. -/\ndef spf_ch (ht : t \u2208 Ioo 0 1) (hq\u2080q\u2081 : q\u2080 \u2260 q\u2081) (hp\u2080 : 0 < p\u2080) (hq\u2080 : 0 < q\u2080)\n    (hp\u2081 : 0 < p\u2081) (hq\u2081 : 0 < q\u2081) (hp\u2080p\u2081 : p\u2080 \u2260 p\u2081) (hC\u2080 : C\u2080 > 0) (hC\u2081 : C\u2081 > 0)\n    (hF : eLpNorm f p \u03bc \u2208 Ioo 0 \u22a4) :\n    ScaledPowerFunction where\n  \u03c3 := @\u03b6 p\u2080 q\u2080 p\u2081 q\u2081 t\n  d := @d _ E\u2081 _ p p\u2080 q\u2080 p\u2081 q\u2081 C\u2080 C\u2081 \u03bc _ f\n  h\u03c3 := lt_or_gt_of_ne <| Ne.symm <| (\u03b6_ne_zero ht hp\u2080 hq\u2080 hp\u2081 hq\u2081 hp\u2080p\u2081 hq\u2080q\u2081)\n  hd := d_pos hC\u2080 hC\u2081 hF\n\nend ChoiceScale\n\nend\n\nnoncomputable section\n\nopen NNReal ENNReal MeasureTheory Set\n\nvariable {\u03b1 \u03b1' E E\u2081 E\u2082 E\u2083 : Type*} {m : MeasurableSpace \u03b1} {m' : MeasurableSpace \u03b1'}\n  {p p' q p\u2080 q\u2080 p\u2081 q\u2081: \u211d\u22650\u221e} {c : \u211d\u22650}\n  {\u03bc : Measure \u03b1} {\u03bd : Measure \u03b1'}\n  {f : \u03b1 \u2192 E\u2081} {t : \u211d}\n  {T : (\u03b1 \u2192 E\u2081) \u2192 (\u03b1' \u2192 E\u2082)}\n\n/-! ## Some tools for measure theory computations\n    A collection of small lemmas to help with integral manipulations.\n-/\nnamespace MeasureTheory\n\n-- TODO: change lhs and rhs?\n-- TODO: rewrite the condition in filter form?\nlemma lintegral_double_restrict_set {A B: Set \u03b1} {f : \u03b1 \u2192 \u211d\u22650\u221e} (hA : MeasurableSet A)\n  (hB : MeasurableSet B) (hf : \u2200\u1d50 (x : \u03b1) \u2202\u03bc, x \u2208 A \\ B \u2192 f x \u2264 0) :\n    \u222b\u207b x in A, f x \u2202\u03bc = \u222b\u207b x in A \u2229 B, f x \u2202\u03bc := by\n  have h\u2080 := setLIntegral_mono_ae' (MeasurableSet.diff hA hB) hf; rw [lintegral_zero] at h\u2080\n  rw [\u2190 lintegral_inter_add_diff (hB := hB), nonpos_iff_eq_zero.mp h\u2080, add_zero]\n\nlemma measure_preserving_shift {a : \u211d} :\n    MeasurePreserving (fun x \u21a6 a + x) volume volume :=\n  measurePreserving_add_left volume a\n\nlemma measureable_embedding_shift {a : \u211d} : MeasurableEmbedding (fun x \u21a6 a + x) :=\n  measurableEmbedding_addLeft a\n\nlemma measure_preserving_scaling {a : \u211d} (ha : a \u2260 0) :\n    MeasurePreserving (fun x \u21a6 a * x) volume ((ENNReal.ofReal |a\u207b\u00b9|) \u2022 volume) :=\n  { measurable := measurable_const_mul a, map_eq := Real.map_volume_mul_left ha }\n\nlemma lintegral_shift (f : \u211d \u2192 ENNReal) {a : \u211d} :\n    \u222b\u207b x : \u211d, (f (x + a)) = \u222b\u207b x : \u211d, f x :=\n  lintegral_add_right_eq_self f a\n\nlemma lintegral_shift' (f : \u211d \u2192 ENNReal) {a : \u211d} {s : Set \u211d}:\n    \u222b\u207b (x : \u211d) in (fun z : \u211d \u21a6 z + a)\u207b\u00b9' s, f (x + a) = \u222b\u207b (x : \u211d) in s, f x := by\n  rw [(measurePreserving_add_right volume a).setLIntegral_comp_preimage_emb\n    (measurableEmbedding_addRight a)]\n\nlemma lintegral_add_right_Ioi (f : \u211d \u2192 ENNReal) {a b : \u211d} :\n    \u222b\u207b (x : \u211d) in Ioi (b - a), f (x + a) = \u222b\u207b (x : \u211d) in Ioi b, f x := by\n  nth_rewrite 2 [\u2190 lintegral_shift' (a := a)]\n  simp\n\nlemma lintegral_scale_constant (f: \u211d \u2192 ENNReal) {a : \u211d} (h : a \u2260 0):\n    \u222b\u207b x : \u211d, f (a*x) = ENNReal.ofReal |a\u207b\u00b9| * \u222b\u207b x, f x := by\n  rw [\u2190 @lintegral_smul_measure, MeasurePreserving.lintegral_comp_emb]\n  \u00b7 exact measure_preserving_scaling h\n  \u00b7 exact measurableEmbedding_mulLeft\u2080 h\n\nlemma lintegral_scale_constant_preimage (f: \u211d \u2192 ENNReal) {a : \u211d} (h : a \u2260 0)\n    {s : Set \u211d}:\n    \u222b\u207b x : \u211d in (fun z : \u211d \u21a6 a * z)\u207b\u00b9' s, f (a*x) = ENNReal.ofReal |a\u207b\u00b9| * \u222b\u207b x : \u211d in s, f x\n    := by\n  rw [\u2190 lintegral_smul_measure,\n    (measure_preserving_scaling h).setLIntegral_comp_preimage_emb (measurableEmbedding_mulLeft\u2080 h),\n    Measure.restrict_smul]\n\nlemma lintegral_scale_constant_halfspace (f: \u211d \u2192 ENNReal) {a : \u211d} (h : 0 < a) :\n    \u222b\u207b x : \u211d in Ioi 0, f (a*x) = ENNReal.ofReal |a\u207b\u00b9| * \u222b\u207b x : \u211d in Ioi 0, f x := by\n  rw [\u2190 lintegral_scale_constant_preimage f h.ne']\n  have h\u2080 : (fun z \u21a6 a * z) \u207b\u00b9' Ioi 0 = Ioi 0 := by\n    ext x\n    simp [mul_pos_iff_of_pos_left h]\n  rw [h\u2080]\n\nlemma lintegral_scale_constant_halfspace' {f: \u211d \u2192 ENNReal} {a : \u211d} (h : 0 < a) :\n    ENNReal.ofReal |a| * \u222b\u207b x : \u211d in Ioi 0, f (a*x) = \u222b\u207b x : \u211d in Ioi 0, f x := by\n  rw [lintegral_scale_constant_halfspace f h, \u2190 mul_assoc, \u2190 ofReal_mul (abs_nonneg a),\n    abs_inv, mul_inv_cancel\u2080 (abs_ne_zero.mpr h.ne')]\n  simp\n\nlemma lintegral_scale_constant' {f: \u211d \u2192 ENNReal} {a : \u211d} (h : a \u2260 0):\n    ENNReal.ofReal |a| * \u222b\u207b x : \u211d, f (a*x) = \u222b\u207b x, f x := by\n  rw [lintegral_scale_constant f h, \u2190 mul_assoc, \u2190 ofReal_mul (abs_nonneg a), abs_inv,\n      mul_inv_cancel\u2080 (abs_ne_zero.mpr h)]\n  simp\n\n-- local convenience function\nlemma lintegral_rw_aux {g : \u211d \u2192 \u211d\u22650\u221e} {f\u2081 f\u2082 : \u211d \u2192 \u211d\u22650\u221e} {A : Set \u211d}\n    (heq : f\u2081 =\u1da0[ae (volume.restrict A)] f\u2082) :\n    \u222b\u207b s in A, g s * f\u2081 s = \u222b\u207b s in A, g s * f\u2082 s :=\n  (lintegral_rw\u2082 (Filter.EventuallyEq.refl (ae (volume.restrict A)) g) heq HMul.hMul)\n\nlemma power_aux {p q : \u211d} :\n    (fun s \u21a6 ENNReal.ofReal s ^ (p + q)) =\u1da0[ae (volume.restrict (Ioi (0 : \u211d)))]\n    (fun s \u21a6 ENNReal.ofReal s ^ p * ENNReal.ofReal s ^ q ) := by\n  filter_upwards [self_mem_ae_restrict measurableSet_Ioi] with s (hs : s > 0)\n  rw [ofReal_rpow_of_pos hs, ofReal_rpow_of_pos hs, ofReal_rpow_of_pos hs,\n    \u2190 ofReal_mul (by positivity), \u2190 Real.rpow_add hs]\n\nlemma power_aux_2 {p q : \u211d} :\n    (fun s \u21a6 ENNReal.ofReal (s ^ (p + q))) =\u1da0[ae (volume.restrict (Ioi (0 : \u211d)))]\n    (fun s \u21a6 ENNReal.ofReal (s ^ p) * ENNReal.ofReal (s ^ q) ) := by\n  filter_upwards [self_mem_ae_restrict measurableSet_Ioi] with s (hs : s > 0)\n  rw [\u2190 ofReal_mul (by positivity), \u2190 Real.rpow_add hs]\n\nlemma ofReal_rpow_of_pos_aux {p : \u211d} :\n    (fun s \u21a6 ENNReal.ofReal s ^ p) =\u1da0[ae (volume.restrict (Ioi (0 : \u211d)))]\n    (fun s \u21a6 ENNReal.ofReal (s ^ p)) := by\n  filter_upwards [self_mem_ae_restrict measurableSet_Ioi]\n    with s (hs : s > 0) using ofReal_rpow_of_pos hs\n\nlemma extract_constant_double_integral_rpow {f : \u211d \u2192 \u211d \u2192 \u211d\u22650\u221e} {q : \u211d} (hq : q \u2265 0) {a : \u211d\u22650\u221e}\n    (ha : a \u2260 \u22a4):\n    \u222b\u207b (s : \u211d) in Ioi 0, (\u222b\u207b (t : \u211d) in Ioi 0, a * f s t) ^ q =\n    a ^ q * \u222b\u207b (s : \u211d) in Ioi 0, (\u222b\u207b (t : \u211d) in Ioi 0, f s t) ^ q := by\n  simp_rw [\u2190 lintegral_const_mul' _ _ (rpow_ne_top_of_nonneg hq ha),\n    \u2190 ENNReal.mul_rpow_of_nonneg _ _ hq, lintegral_const_mul' a _ ha]\n\nlemma ofReal_rpow_rpow_aux {p : \u211d} :\n    (fun s \u21a6 ENNReal.ofReal s ^ p) =\u1da0[ae (volume.restrict (Ioi (0 : \u211d)))]\n    (fun s \u21a6 ENNReal.ofReal (s ^ p)) := by\n  filter_upwards [self_mem_ae_restrict measurableSet_Ioi]\n    with s (hs : s > 0) using ofReal_rpow_of_pos hs\n\nlemma lintegral_rpow_of_gt {\u03b2 \u03b3 : \u211d} (h\u03b2 : \u03b2 > 0) (h\u03b3 : \u03b3 > -1) :\n    \u222b\u207b s : \u211d in Ioo 0 \u03b2, ENNReal.ofReal (s ^ \u03b3) =\n    ENNReal.ofReal (\u03b2 ^ (\u03b3 + 1) / (\u03b3 + 1)) := by\n  have h\u03b32 : \u03b3 + 1 > 0 := by linarith\n  rw [setLIntegral_congr Ioo_ae_eq_Ioc, \u2190 ofReal_integral_eq_lintegral_ofReal]\n  \u00b7 rw [\u2190 intervalIntegral.integral_of_le h\u03b2.le, integral_rpow]\n    \u00b7 rw [Real.zero_rpow h\u03b32.ne', sub_zero]\n    \u00b7 exact Or.inl h\u03b3\n  \u00b7 apply (@intervalIntegral.intervalIntegrable_rpow' 0 \u03b2 \u03b3 ?_).1\n    linarith\n  \u00b7 filter_upwards [self_mem_ae_restrict measurableSet_Ioc]\n      with s hs using Real.rpow_nonneg hs.1.le \u03b3\n\nend MeasureTheory\n\nend\n\nnoncomputable section\n\nopen NNReal ENNReal MeasureTheory Set ComputationsInterpolatedExponents\n\nvariable {\u03b1 \u03b1' E E\u2081 E\u2082 E\u2083 : Type*} {m : MeasurableSpace \u03b1} {m' : MeasurableSpace \u03b1'}\n  {p p' q p\u2080 q\u2080 p\u2081 q\u2081: \u211d\u22650\u221e} {c : \u211d\u22650} {a : \u211d}\n  {\u03bc : Measure \u03b1} {\u03bd : Measure \u03b1'}\n  {f : \u03b1 \u2192 E\u2081} {t : \u211d}\n  {T : (\u03b1 \u2192 E\u2081) \u2192 (\u03b1' \u2192 E\u2082)}\n\n/-! ## Results about truncations of a function\n-/\nnamespace MeasureTheory\n\n/-- The `t`-truncation of a function `f`. -/\ndef trunc [NormedAddCommGroup E\u2081] (f : \u03b1 \u2192 E\u2081) (t : \u211d) (x : \u03b1) : E\u2081 := if \u2016f x\u2016 \u2264 t then f x else 0\n\n/-- The complement of a `t`-truncation of a function `f`. -/\ndef trunc_compl [NormedAddCommGroup E\u2081] (f : \u03b1 \u2192 E\u2081) (t : \u211d) : \u03b1 \u2192 E\u2081 := f - trunc f t\n\nlemma trunc_compl_eq [NormedAddCommGroup E\u2081] {a : \u211d} {f : \u03b1 \u2192 E\u2081} :\n    f - trunc f a = fun x \u21a6 if a < \u2016f x\u2016 then f x else 0 := by\n  ext x\n  simp_rw [Pi.sub_apply, trunc, \u2190 not_lt, ite_not, apply_ite (f x - \u00b7), sub_zero, sub_self]\n\n/-- A function to deal with truncations and complement of truncations in one go. -/\ndef trnc [NormedAddCommGroup E\u2081] (j : Bool) (f : \u03b1 \u2192 E\u2081) (t : \u211d)  : \u03b1 \u2192 E\u2081 :=\n  match j with\n  | false => f - trunc f t\n  | true => trunc f t\n\n/-- A function is the complement if its truncation and the complement of the truncation. -/\nlemma trunc_buildup [NormedAddCommGroup E\u2081] : f = trunc f t + trunc_compl f t := by\n  ext x; simp [trunc, trunc_compl]\n\n/-- If the truncation parameter is non-positive, the truncation vanishes. -/\nlemma trunc_of_nonpos {f : \u03b1 \u2192 E\u2081} {a : \u211d} [NormedAddCommGroup E\u2081] (ha : a \u2264 0) :\n    trunc f a = 0 := by\n  unfold trunc\n  ext x\n  split_ifs\n  \u00b7 dsimp only [Pi.zero_apply]\n    apply norm_eq_zero.mp\n    \u00b7 have : \u2016f x\u2016 \u2265 0 := norm_nonneg _\n      linarith []\n  \u00b7 rfl\n\n/-- If the truncation parameter is non-positive, the complement of the truncation is the\n    function itself. -/\nlemma trunc_compl_of_nonpos {f : \u03b1 \u2192 E\u2081} {a : \u211d} [NormedAddCommGroup E\u2081] (ha : a \u2264 0) :\n    trunc_compl f a = f := by\n  unfold trunc_compl\n  rw [trunc_compl_eq]\n  ext x\n  dsimp only [Pi.zero_apply]\n  split_ifs\n  \u00b7 rfl\n  \u00b7 apply (norm_eq_zero.mp ?_).symm\n    have : \u2016f x\u2016 \u2265 0 := norm_nonneg _\n    linarith\n\n/-! ## Measurability properties of truncations -/\n\n-- @[measurability, fun_prop]\n-- lemma _root_.Measurable.trunc [MeasurableSpace E\u2081] [NormedAddCommGroup E\u2081] [BorelSpace E\u2081]\n--     (hf : Measurable f) : Measurable (trunc f t) := by\n--   refine hf.ite (measurableSet_le ?_ ?_) measurable_const <;> fun_prop\n\n-- @[measurability, fun_prop]\n-- lemma _root_.Measurable.trunc_compl [MeasurableSpace E\u2081] [NormedAddCommGroup E\u2081] [BorelSpace E\u2081]\n--     (hf : Measurable f) :\n--     Measurable (f - trunc f t) := by\n--   rw [trunc_compl_eq]\n--   apply Measurable.ite ?_ hf measurable_const\n--   exact measurableSet_lt measurable_const hf.norm\n\n@[measurability]\nprotected lemma StronglyMeasurable.trunc [NormedAddCommGroup E\u2081]\n    (hf : StronglyMeasurable f) : StronglyMeasurable (trunc f t) :=\n  StronglyMeasurable.ite (measurableSet_le hf.norm stronglyMeasurable_const) hf\n    stronglyMeasurable_const\n\n@[measurability]\nprotected lemma StronglyMeasurable.trunc_compl [NormedAddCommGroup E\u2081]\n    (hf : StronglyMeasurable f) : StronglyMeasurable (f - trunc f t) := by\n  rw [trunc_compl_eq]\n  exact hf.ite (measurableSet_lt stronglyMeasurable_const hf.norm) stronglyMeasurable_const\n\n-- @[measurability, fun_prop]\n-- lemma aemeasurable_trunc [MeasurableSpace E\u2081] [NormedAddCommGroup E\u2081] [BorelSpace E\u2081]\n--     (hf : AEMeasurable f \u03bc) :\n--     AEMeasurable (trunc f t) \u03bc := by\n--   rcases hf with \u27e8g, \u27e8wg1, wg2\u27e9\u27e9\n--   exists (trunc g t)\n--   constructor\n--   \u00b7 apply wg1.indicator (s := {x | \u2016g x\u2016 \u2264 t}) (measurableSet_le wg1.norm measurable_const)\n--   apply measure_mono_null ?_ wg2\n--   intro x\n--   contrapose\n--   simp only [mem_compl_iff, mem_setOf_eq, not_not]\n--   intro h\u2082\n--   unfold trunc\n--   rewrite [h\u2082]\n--   rfl\n\n-- @[measurability, fun_prop]\n-- lemma aeMeasurable_trunc_compl [MeasurableSpace E\u2081] [NormedAddCommGroup E\u2081] [BorelSpace E\u2081]\n--     (hf : AEMeasurable f \u03bc) :\n--     AEMeasurable (trunc_compl f t) \u03bc := by\n--   rcases hf with \u27e8g, \u27e8wg1, wg2\u27e9\u27e9\n--   exists (trunc_compl g t)\n--   constructor\n--   \u00b7 unfold trunc_compl\n--     rw [trunc_compl_eq]\n--     exact wg1.indicator (s := {x | t < \u2016g x\u2016}) (measurableSet_lt measurable_const wg1.norm)\n--   \u00b7 apply measure_mono_null ?_ wg2\n--     intro x\n--     contrapose\n--     simp only [mem_compl_iff, mem_setOf_eq, not_not]\n--     intro f_eq_g; unfold trunc_compl; unfold trunc; dsimp only [Pi.sub_apply]; rw [f_eq_g]\n\n@[measurability]\nlemma aestronglyMeasurable_trunc [NormedAddCommGroup E\u2081]\n    (hf : AEStronglyMeasurable f \u03bc) :\n    AEStronglyMeasurable (trunc f t) \u03bc := by\n  rcases hf with \u27e8g, \u27e8wg1, wg2\u27e9\u27e9\n  exists (trunc g t)\n  constructor\n  \u00b7 exact wg1.indicator (s := {x | \u2016g x\u2016 \u2264 t}) (wg1.norm.measurableSet_le stronglyMeasurable_const)\n  \u00b7 refine measure_mono_null (fun x \u21a6 ?_) wg2\n    contrapose\n    simp only [mem_compl_iff, mem_setOf_eq, not_not]\n    intro h\u2082\n    unfold trunc\n    rw [h\u2082]\n\n@[measurability]\nlemma aestronglyMeasurable_trunc_compl [NormedAddCommGroup E\u2081]\n    (hf : AEStronglyMeasurable f \u03bc) :\n    AEStronglyMeasurable (f - trunc f t) \u03bc := by\n  rcases hf with \u27e8g, \u27e8wg1, wg2\u27e9\u27e9\n  exists (g - trunc g t)\n  constructor\n  \u00b7 rw [trunc_compl_eq]\n    exact wg1.indicator (s := {x | t < \u2016g x\u2016}) (stronglyMeasurable_const.measurableSet_lt wg1.norm)\n  \u00b7 apply measure_mono_null ?_ wg2\n    intro x\n    contrapose\n    simp only [mem_compl_iff, mem_setOf_eq, not_not]\n    intro h\u2082\n    rw [trunc_compl_eq, trunc_compl_eq]\n    simp only\n    rw [h\u2082]\n\n@[measurability]\nlemma aestronglyMeasurable_trnc {j : Bool} [NormedAddCommGroup E\u2081]\n    (hf : AEStronglyMeasurable f \u03bc) :\n    AEStronglyMeasurable (trnc j f t) \u03bc := by\n  rcases j\n  \u00b7 exact aestronglyMeasurable_trunc_compl hf\n  \u00b7 exact aestronglyMeasurable_trunc hf\n\nlemma trunc_le {f : \u03b1 \u2192 E\u2081} {a : \u211d} [NormedAddCommGroup E\u2081] (x : \u03b1) :\n    \u2016trunc f a x\u2016 \u2264 max 0 a := by\n  unfold trunc\n  split_ifs with h\n  \u00b7 rcases (lt_or_le a 0) with a_lt_0 | _\n    \u00b7 exact Trans.trans (Trans.trans h a_lt_0.le) (le_max_left 0 a)\n    \u00b7 exact Trans.trans h (le_max_right 0 a)\n  \u00b7 simp\n\n/-- A small lemma that is helpful for rewriting -/\nlemma coe_coe_eq_ofReal (a : \u211d) : ofNNReal a.toNNReal = ENNReal.ofReal a := by rfl\n\nlemma trunc_eLpNormEssSup_le {f : \u03b1 \u2192 E\u2081} {a : \u211d} [NormedAddCommGroup E\u2081] :\n    eLpNormEssSup (trunc f a) \u03bc \u2264 ENNReal.ofReal (max 0 a) := by\n  refine essSup_le_of_ae_le _ (ae_of_all _ fun x \u21a6 ?_)\n  simp only [enorm_eq_nnnorm, \u2190 norm_toNNReal, coe_coe_eq_ofReal]\n  exact ofReal_le_ofReal (trunc_le x)\n\nlemma trunc_mono {f : \u03b1 \u2192 E\u2081} {a b : \u211d} [NormedAddCommGroup E\u2081]\n    (hab : a \u2264 b) {x : \u03b1} : \u2016trunc f a x\u2016 \u2264 \u2016trunc f b x\u2016 := by\n  unfold trunc\n  split_ifs\n  \u00b7 rfl\n  \u00b7 linarith\n  \u00b7 rw [norm_zero]; exact norm_nonneg _\n  \u00b7 exact le_refl _\n\n/-- The norm of the truncation is monotone in the truncation parameter -/\nlemma norm_trunc_mono {f : \u03b1 \u2192 E\u2081} [NormedAddCommGroup E\u2081] :\n    Monotone fun s \u21a6 eLpNorm (trunc f s) p \u03bc :=\n  fun _a _b hab \u21a6 eLpNorm_mono fun _x \u21a6 trunc_mono hab\n\nlemma trunc_buildup_norm {f : \u03b1 \u2192 E\u2081} {a : \u211d} {x : \u03b1} [NormedAddCommGroup E\u2081] :\n    \u2016trunc f a x\u2016 + \u2016(f - trunc f a) x\u2016 = \u2016f x\u2016 := by\n  simp only [trunc, Pi.sub_apply]; split_ifs with h <;> simp\n\nlemma trunc_le_func {f : \u03b1 \u2192 E\u2081} {a : \u211d} {x : \u03b1} [NormedAddCommGroup E\u2081] :\n    \u2016trunc f a x\u2016 \u2264 \u2016f x\u2016 := by\n  unfold trunc; split_ifs <;> simp\n\nlemma trunc_compl_le_func {f : \u03b1 \u2192 E\u2081} {a : \u211d} {x : \u03b1} [NormedAddCommGroup E\u2081] :\n    \u2016(f - trunc f a) x\u2016 \u2264 \u2016f x\u2016 := by\n  rw [trunc_compl_eq]; dsimp only; split_ifs <;> simp\n\nlemma trunc_compl_anti {f : \u03b1 \u2192 E\u2081} {a b : \u211d} {x : \u03b1} [NormedAddCommGroup E\u2081] (hab : a \u2264 b) :\n    \u2016(f - trunc f b) x\u2016 \u2264 \u2016(f - trunc f a) x\u2016 := by\n  have obs : \u2016trunc f a x\u2016 + \u2016(f - trunc f a) x\u2016 = \u2016trunc f b x\u2016 + \u2016(f - trunc f b) x\u2016 := by\n    rw [trunc_buildup_norm, trunc_buildup_norm]\n  have : \u2016trunc f a x\u2016 \u2264 \u2016trunc f b x\u2016 := trunc_mono hab\n  linarith\n\n/-- The norm of the complement of the truncation is antitone in the truncation parameter -/\nlemma norm_trunc_compl_anti {f : \u03b1 \u2192 E\u2081} [NormedAddCommGroup E\u2081] :\n    Antitone (fun s \u21a6 eLpNorm (f - trunc f s) p \u03bc) :=\n  fun _a _b hab \u21a6 eLpNorm_mono (fun _ \u21a6 trunc_compl_anti hab)\n\n/-- The norm of the truncation is meaurable in the truncation parameter -/\n@[measurability, fun_prop]\nlemma norm_trunc_measurable [NormedAddCommGroup E\u2081] :\n    Measurable (fun s \u21a6 eLpNorm (trunc f s) p \u03bc) :=\n  norm_trunc_mono.measurable\n\n/-- The norm of the complement of the truncation is measurable in the truncation parameter -/\n@[measurability, fun_prop]\nlemma norm_trunc_compl_measurable [NormedAddCommGroup E\u2081] :\n    Measurable (fun s \u21a6 eLpNorm (f - trunc f s) p \u03bc) :=\n  norm_trunc_compl_anti.measurable\n\nlemma trnc_le_func {j : Bool} {f : \u03b1 \u2192 E\u2081} {a : \u211d} {x : \u03b1} [NormedAddCommGroup E\u2081] :\n    \u2016trnc j f a x\u2016 \u2264 \u2016f x\u2016 := by\n  unfold trnc trunc\n  rcases j\n  \u00b7 dsimp only [Pi.sub_apply]\n    split_ifs <;> simp\n  \u00b7 dsimp only\n    split_ifs <;> simp\n\n-- /-- ## Distribution functions of truncations -/\n\n-- /-- The `t`-truncation of `f : \u03b1 \u2192\u2098[\u03bc] E`. -/\n-- def AEEqFun.trunc (f : \u03b1 \u2192\u2098[\u03bc] E) (t : \u211d) : \u03b1 \u2192\u2098[\u03bc] E :=\n--   AEEqFun.mk (trunc f t) (aestronglyMeasurable_trunc f.aestronglyMeasurable)\n\n-- /-- A set of measurable functions is closed under truncation. -/\n-- class IsClosedUnderTruncation (U : Set (\u03b1 \u2192\u2098[\u03bc] E)) : Prop where\n--   trunc_mem {f : \u03b1 \u2192\u2098[\u03bc] E} (hf : f \u2208 U) (t : \u211d) : f.trunc t \u2208 U\n\n/-! ## Truncations and L-p spaces -/\n\nlemma power_estimate {a b t \u03b3 : \u211d} (h\u03b3 : \u03b3 > 0) (ht\u03b3 : \u03b3 \u2264 t) (hab : a \u2264 b) :\n    (t / \u03b3) ^ a \u2264 (t / \u03b3) ^ b := by\n  gcongr\n  exact (one_le_div h\u03b3).mpr ht\u03b3\n\nlemma power_estimate' {a b t \u03b3 : \u211d} (ht : t > 0) (ht\u03b3 : t \u2264 \u03b3) (hab: a \u2264 b) :\n    (t / \u03b3) ^ b \u2264 (t / \u03b3) ^ a := by\n  have \u03b3_pos : \u03b3 > 0 := lt_of_lt_of_le ht ht\u03b3\n  exact Real.rpow_le_rpow_of_exponent_ge (div_pos ht (\u03b3_pos)) (div_le_one_of_le\u2080 ht\u03b3 \u03b3_pos.le) hab\n\nlemma rpow_le_rpow_of_exponent_le_base_le {a b t \u03b3 : \u211d} (ht : t > 0) (ht\u03b3 : t \u2264 \u03b3) (hab : a \u2264 b) :\n    ENNReal.ofReal (t ^ b) \u2264 ENNReal.ofReal (t ^ a) * ENNReal.ofReal (\u03b3 ^ (b - a)) := by\n  rw [mul_comm]\n  have \u03b3_pos : 0 < \u03b3 := lt_of_lt_of_le ht ht\u03b3\n  rw [Real.rpow_sub \u03b3_pos]\n  refine (ENNReal.mul_le_mul_left (a := ENNReal.ofReal (\u03b3 ^ (-b) )) ?_ coe_ne_top).mp ?_\n  \u00b7 exact (ofReal_pos.mpr (Real.rpow_pos_of_pos \u03b3_pos (-b))).ne'\n  \u00b7 rw [\u2190 ofReal_mul, \u2190 mul_assoc, \u2190 ofReal_mul, \u2190 mul_div_assoc, \u2190 Real.rpow_add, neg_add_cancel,\n        Real.rpow_zero, \u2190 ofReal_mul, mul_comm] <;> try positivity\n    nth_rw 2 [mul_comm]\n    rw [\u2190 neg_one_mul, Real.rpow_mul, Real.rpow_neg_one, \u2190 Real.mul_rpow] <;> try positivity\n    rw [one_div]\n    nth_rw 2 [\u2190 Real.rpow_neg_one]\n    rw [\u2190 Real.rpow_mul (by positivity)]\n    nth_rw 3 [mul_comm]\n    rw [Real.rpow_mul, Real.rpow_neg_one, \u2190 Real.mul_rpow, \u2190 div_eq_mul_inv] <;> try positivity\n    exact ofReal_le_ofReal (power_estimate' ht ht\u03b3 hab)\n\n-- TODO: there is a lot of overlap between above proof and below\nlemma rpow_le_rpow_of_exponent_le_base_ge {a b t \u03b3 : \u211d} (h\u03b3 : \u03b3 > 0) (ht\u03b3 : \u03b3 \u2264 t) (hab : a \u2264 b) :\n    ENNReal.ofReal (t ^ a) \u2264 ENNReal.ofReal (t ^ b) * ENNReal.ofReal (\u03b3 ^ (a - b)) := by\n  rw [mul_comm]\n  have t_pos : 0 < t := gt_of_ge_of_gt ht\u03b3 h\u03b3\n  rw [Real.rpow_sub h\u03b3]\n  refine (ENNReal.mul_le_mul_left (a := ENNReal.ofReal (\u03b3 ^ (-a) )) ?_ coe_ne_top).mp ?_\n  \u00b7 exact (ofReal_pos.mpr (Real.rpow_pos_of_pos h\u03b3 (-a))).ne'\n  \u00b7 rw [\u2190 ofReal_mul, \u2190 mul_assoc, \u2190 ofReal_mul, \u2190 mul_div_assoc, \u2190 Real.rpow_add, neg_add_cancel,\n        Real.rpow_zero, \u2190 ofReal_mul, mul_comm] <;> try positivity\n    nth_rw 2 [mul_comm]\n    rw [\u2190 neg_one_mul, Real.rpow_mul, Real.rpow_neg_one, \u2190 Real.mul_rpow] <;> try positivity\n    rw [one_div]\n    nth_rw 2 [\u2190 Real.rpow_neg_one]\n    rw [\u2190 Real.rpow_mul (by positivity)]\n    nth_rw 3 [mul_comm]\n    rw [Real.rpow_mul, Real.rpow_neg_one, \u2190 Real.mul_rpow, \u2190 div_eq_mul_inv] <;> try positivity\n    exact ofReal_le_ofReal (Real.rpow_le_rpow_of_exponent_le ((one_le_div h\u03b3).mpr ht\u03b3) hab)\n\nlemma trunc_preserves_Lp {p : \u211d\u22650\u221e} {a : \u211d} [NormedAddCommGroup E\u2081]\n    (hf : Mem\u2112p f p \u03bc) :\n    Mem\u2112p (trunc f a) p \u03bc := by\n  refine \u27e8aestronglyMeasurable_trunc hf.1, lt_of_le_of_lt (eLpNorm_mono_ae (ae_of_all _ ?_)) hf.2\u27e9\n  intro x\n  unfold trunc\n  split_ifs with is_fx_le_a <;> simp\n\n-- lemma snorm_trunc_compl_le {p : \u211d\u22650\u221e} {a : \u211d} [NormedAddCommGroup E\u2081] :\n--     eLpNorm (f - trunc f a) p \u03bc \u2264 eLpNorm f p \u03bc :=\n--   eLpNorm_mono (fun _ \u21a6 trunc_compl_le_func)\n\nlemma trunc_compl_preserves_Lp {p : \u211d\u22650\u221e} {a : \u211d} [NormedAddCommGroup E\u2081] (hf : Mem\u2112p f p \u03bc) :\n    Mem\u2112p (f - trunc f a) p \u03bc :=\n  Mem\u2112p.sub hf (trunc_preserves_Lp hf)\n\nlemma estimate_eLpNorm_trunc_compl {p q : \u211d\u22650\u221e} [MeasurableSpace E\u2081] [NormedAddCommGroup E\u2081]\n    [BorelSpace E\u2081] (hp : p \u2260 \u22a4) (hpq : q \u2208 Ioo 0 p) (hf : AEMeasurable f \u03bc) (ha : a > 0) :\n    eLpNorm ((f - trunc f a)) q \u03bc ^ q.toReal \u2264\n    ENNReal.ofReal (a ^ (q.toReal - p.toReal)) *\n    eLpNorm f p \u03bc ^ p.toReal := by\n  unfold eLpNorm eLpNorm'\n  have q_ne_top: q \u2260 \u22a4 := hpq.2.ne_top\n  have p_ne_zero : p \u2260 0 := (lt_trans hpq.1 hpq.2).ne'\n  have q_ne_zero : q \u2260 0 := hpq.1.ne'\n  have q_toReal_pos : q.toReal > 0 := exp_toReal_pos hpq.1 q_ne_top\n  split_ifs\n  \u00b7 contradiction\n  \u00b7 calc\n    _ = \u222b\u207b x : \u03b1 in {x | a < \u2016f x\u2016}, \u2016(f - trunc f a) x\u2016\u2091 ^ q.toReal \u2202\u03bc := by\n      rw [one_div, ENNReal.rpow_inv_rpow]\n      \u00b7 apply (setLIntegral_eq_of_support_subset _).symm\n        unfold Function.support\n        intro x\n        rw [trunc_compl_eq]\n        dsimp only [Pi.sub_apply, mem_setOf_eq]\n        split_ifs with is_a_lt_fx\n        \u00b7 exact fun _ => is_a_lt_fx\n        \u00b7 contrapose; intro _; simpa [enorm_eq_nnnorm]\n      \u00b7 exact exp_toReal_ne_zero' hpq.1 q_ne_top\n    _ \u2264 \u222b\u207b x : \u03b1 in {x | a < \u2016f x\u2016}, \u2016f x\u2016\u2091 ^ q.toReal \u2202\u03bc := by\n      apply lintegral_mono_ae\n      apply ae_of_all\n      intro x\n      gcongr\n      rw [enorm_eq_nnnorm, \u2190 norm_toNNReal, enorm_eq_nnnorm, \u2190 norm_toNNReal]\n      simp only [Pi.sub_apply, ENNReal.coe_le_coe, norm_nonneg, Real.toNNReal_le_toNNReal_iff]\n      apply trnc_le_func (j := \u22a5)\n    _ \u2264 ENNReal.ofReal (a ^ (q.toReal - p.toReal)) * \u222b\u207b x : \u03b1 in {x | a < \u2016f x\u2016},\n        \u2016f x\u2016\u2091 ^ p.toReal \u2202\u03bc := by\n      rw [\u2190 lintegral_const_mul']; swap; \u00b7 exact coe_ne_top\n      simp only [enorm_eq_nnnorm]\n      apply setLIntegral_mono_ae (AEMeasurable.restrict (by fun_prop))\n      \u00b7 apply ae_of_all\n        intro x (hx : a < \u2016f x\u2016)\n        rw [mul_comm]\n        have : ofNNReal \u2016f x\u2016\u208a = ENNReal.ofReal \u2016f x\u2016 := (ofReal_norm_eq_coe_nnnorm (f x)).symm\n        rw [this, ENNReal.ofReal_rpow_of_nonneg, ENNReal.ofReal_rpow_of_nonneg]\n          <;> try positivity\n        exact rpow_le_rpow_of_exponent_le_base_ge ha hx.le (toReal_mono hp hpq.2.le)\n    _ \u2264 ENNReal.ofReal (a ^ (q.toReal - p.toReal)) * \u222b\u207b x : \u03b1,\n        \u2191\u2016f x\u2016\u208a ^ p.toReal \u2202\u03bc := by\n      gcongr\n      exact setLIntegral_le_lintegral _ _\n    _ = _ := by\n      rw [one_div, ENNReal.rpow_inv_rpow]\n      \u00b7 simp only [enorm_eq_nnnorm]\n      \u00b7 exact exp_toReal_ne_zero' (lt_trans hpq.1 hpq.2) hp\n\nlemma estimate_eLpNorm_trunc {p q : \u211d\u22650\u221e}\n    [MeasurableSpace E\u2081] [NormedAddCommGroup E\u2081] [BorelSpace E\u2081]\n    (hq : q \u2260 \u22a4)\n    (hpq : p \u2208 Ioo 0 q) (hf : AEMeasurable f \u03bc) :\n    eLpNorm (trunc f a) q \u03bc ^ q.toReal \u2264\n    ENNReal.ofReal (a ^ (q.toReal - p.toReal)) * eLpNorm f p \u03bc ^ p.toReal := by\n  unfold eLpNorm eLpNorm'\n  have p_ne_top : p \u2260 \u22a4 := hpq.2.ne_top\n  have : p \u2260 0 := hpq.1.ne'\n  have : q \u2260 0 := (lt_trans hpq.1 hpq.2).ne'\n  split_ifs\n  \u00b7 contradiction\n  \u00b7 calc\n    _ = \u222b\u207b (x : \u03b1) in {x | 0 < \u2016f x\u2016 \u2227 \u2016f x\u2016 \u2264 a}, \u2191\u2016trunc f a x\u2016\u208a ^ q.toReal \u2202\u03bc := by\n      rw [one_div, ENNReal.rpow_inv_rpow]\n      \u00b7 apply Eq.symm\n        apply setLIntegral_eq_of_support_subset\n        unfold Function.support\n        intro x\n        dsimp only [Pi.sub_apply, mem_setOf_eq]\n        unfold trunc\n        split_ifs with is_fx_le_a\n        \u00b7 intro fx_rpow_ne_zero\n          refine \u27e8?_, is_fx_le_a\u27e9\n          contrapose! fx_rpow_ne_zero\n          rw [norm_le_zero_iff.mp fx_rpow_ne_zero]\n          simpa using toReal_pos this hq\n        \u00b7 contrapose; intro _; simpa using toReal_pos this hq\n      \u00b7 exact exp_toReal_ne_zero' (lt_trans hpq.1 hpq.2) hq\n    _ \u2264 \u222b\u207b (x : \u03b1) in {x | 0 < \u2016f x\u2016 \u2227 \u2016f x\u2016 \u2264 a}, \u2016f x\u2016\u208a ^ q.toReal \u2202 \u03bc := by\n      apply lintegral_mono_ae\n      apply ae_of_all\n      intro x\n      gcongr\n      rw [\u2190 norm_toNNReal, \u2190 norm_toNNReal]\n      exact Real.toNNReal_mono (trnc_le_func (j := \u22a4))\n    _ \u2264 ENNReal.ofReal (a ^ (q.toReal - p.toReal)) *\n        \u222b\u207b (x : \u03b1) in {x | 0 < \u2016f x\u2016 \u2227 \u2016f x\u2016 \u2264 a}, \u2016f x\u2016\u208a ^ p.toReal \u2202 \u03bc := by\n      rw [\u2190 lintegral_const_mul']\n      \u00b7 apply setLIntegral_mono_ae (AEMeasurable.restrict (by fun_prop))\n        \u00b7 apply ae_of_all\n          intro x hx\n          rw [mul_comm]\n          rw [(ofReal_norm_eq_coe_nnnorm (f x)).symm, ENNReal.ofReal_rpow_of_nonneg,\n            ENNReal.ofReal_rpow_of_nonneg] <;> try positivity\n          apply rpow_le_rpow_of_exponent_le_base_le hx.1 hx.2\n          exact toReal_mono hq hpq.2.le\n      \u00b7 exact coe_ne_top\n    _ \u2264 _ := by\n      gcongr\n      rw [one_div, ENNReal.rpow_inv_rpow]\n      \u00b7 exact setLIntegral_le_lintegral _ _\n      \u00b7 exact exp_toReal_ne_zero' hpq.1 p_ne_top\n\n/-- If `f` is in `Lp`, the truncation is element of `Lq` for `q > p`. -/\nlemma trunc_Lp_Lq_higher [MeasurableSpace E\u2081] [NormedAddCommGroup E\u2081] [BorelSpace E\u2081]\n    (hpq : p \u2208 Ioo 0 q) (hf : Mem\u2112p f p \u03bc) :\n    Mem\u2112p (trnc \u22a4 f a) q \u03bc := by\n  refine \u27e8aestronglyMeasurable_trnc hf.1, ?_\u27e9\n  rcases (eq_or_ne q \u22a4) with q_eq_top | q_ne_top\n  \u00b7 rw [q_eq_top, eLpNorm_exponent_top]\n    exact Trans.trans trunc_eLpNormEssSup_le coe_lt_top\n  \u00b7 rw [\u2190 rpow_lt_top_iff_of_pos (toReal_pos (lt_trans hpq.1 hpq.2).ne' q_ne_top)]\n    apply lt_of_le_of_lt (estimate_eLpNorm_trunc q_ne_top hpq hf.1.aemeasurable)\n    apply mul_lt_top coe_lt_top\n    refine (rpow_lt_top_iff_of_pos ?_).mpr hf.2\n    exact toReal_pos hpq.1.ne' hpq.2.ne_top\n\n/-- If `f` is in `Lp`, the complement of the truncation is in `Lq` for `q < p`. -/\nlemma trunc_compl_Lp_Lq_lower [MeasurableSpace E\u2081] [NormedAddCommGroup E\u2081] [BorelSpace E\u2081]\n    (hp : p \u2260 \u22a4)\n    (hpq : q \u2208 Ioo 0 p) (ha : a > 0) (hf : Mem\u2112p f p \u03bc) :\n    Mem\u2112p (trnc \u22a5 f a) q \u03bc := by\n  refine \u27e8aestronglyMeasurable_trnc hf.1, ?_\u27e9\n  have : q.toReal > 0 := toReal_pos hpq.left.ne' hpq.right.ne_top\n  refine (rpow_lt_top_iff_of_pos this).mp ?_\n  refine lt_of_le_of_lt\n    (estimate_eLpNorm_trunc_compl hp hpq hf.1.aemeasurable ha) ?_\n  apply mul_lt_top coe_lt_top\n  refine (rpow_lt_top_iff_of_pos ?_).mpr hf.2\n  exact toReal_pos (lt_trans hpq.left hpq.right).ne' hp\n\nend MeasureTheory\n\nend\n\nnoncomputable section\n\nopen NNReal ENNReal MeasureTheory Set\n\nvariable {\u03b1 \u03b1' E E\u2081 E\u2082 E\u2083 : Type*} {m : MeasurableSpace \u03b1} {m' : MeasurableSpace \u03b1'}\n  {p p' q p\u2080 q\u2080 p\u2081 q\u2081: \u211d\u22650\u221e}\n  {C\u2080 C\u2081 : \u211d\u22650} {\u03bc : Measure \u03b1} {\u03bd : Measure \u03b1'}\n  {a : \u211d}-- truncation parameter\n  [NormedAddCommGroup E]\n  [NormedAddCommGroup E\u2081]\n  [NormedAddCommGroup E\u2082]\n  [MeasurableSpace E] [BorelSpace E]\n  {f : \u03b1 \u2192 E\u2081} {t : \u211d}\n  {T : (\u03b1 \u2192 E\u2081) \u2192 (\u03b1' \u2192 E\u2082)}\n\n/-! ## Some results about the integrals of truncations\n\n-/\nnamespace MeasureTheory\n\ndef res (j : Bool) (\u03b2 : \u211d) : Set \u211d :=\n  if j then Ioo (0 : \u211d) \u03b2 else Ioi \u03b2\n\nlemma measurableSet_res {j : Bool} {\u03b2 : \u211d} : MeasurableSet (res j \u03b2) := by\n  unfold res\n  split\n  \u00b7 exact measurableSet_Ioo\n  \u00b7 exact measurableSet_Ioi\n\nlemma res_subset_Ioi {j : Bool} {\u03b2 : \u211d} (h\u03b2 : \u03b2 > 0) : res j \u03b2 \u2286 Ioi 0 := by\n  unfold res\n  split\n  \u00b7 exact Ioo_subset_Ioi_self\n  \u00b7 simp only [Ioi, setOf_subset_setOf]\n    intro s hs\n    linarith\n\ninstance decidableMemRes {j : Bool} {\u03b2 : \u211d} : Decidable (t \u2208 res j \u03b2) := by\n  exact Classical.propDecidable (t \u2208 res j \u03b2)\n\ndef res' (j : Bool) (\u03b2 : \u211d) : Set \u211d :=\n  if j then Ioc (0 : \u211d) \u03b2 else Ici \u03b2\n\nlemma res'comp (j : Bool) (\u03b2 : \u211d) (h\u03b2 : \u03b2 > 0) :\n    Ioi (0 : \u211d) \\ res' j \u03b2 = res (\u00acj) \u03b2 := by\n  unfold res' res\n  split_ifs with h\u2080 h\u2081 h\u2082\n  \u00b7 rw [h\u2080] at h\u2081; simp at h\u2081\n  \u00b7 ext x\n    simp only [mem_diff, mem_Ioi, mem_Ioc, not_and, not_le]\n    constructor\n    \u00b7 tauto\n    \u00b7 intro h\n      exact \u27e8lt_trans h\u03b2 h, fun _ \u21a6 h\u27e9\n  \u00b7 ext x\n    simp only [Ioi_diff_Ici, mem_Ioo]\n  \u00b7 have : j = false := eq_false_of_ne_true h\u2080\n    rw [this] at h\u2082\n    simp at h\u2082\n\nlemma measurableSet_res' {j : Bool} {\u03b2 : \u211d} : MeasurableSet (res' j \u03b2) := by\n  unfold res'\n  measurability\n\nlemma res'subset_Ioi {j : Bool} {\u03b2 : \u211d} (h\u03b2 : \u03b2 > 0) : res' j \u03b2 \u2286 Ioi 0 := by\n  unfold res'\n  split\n  \u00b7 exact Ioc_subset_Ioi_self\n  \u00b7 exact Ici_subset_Ioi.mpr h\u03b2\n\nlemma lintegral_trunc_mul\u2080 {g : \u211d \u2192 \u211d\u22650\u221e} {j : Bool} {x : \u03b1} {tc : ToneCouple} {p : \u211d} (hp : p > 0)\n    (hfx : \u2016f x\u2016\u208a > 0) :\n    \u222b\u207b s : \u211d in Ioi 0, (g s) * \u2016trnc j f (tc.ton s) x\u2016\u208a ^ p =\n    \u222b\u207b s : \u211d in res' (xor j tc.mon) (tc.inv \u2016f x\u2016), (g s) * \u2016trnc j f (tc.ton s) x\u2016\u208a ^ p := by\n  rw [lintegral_double_restrict_set (B := res' (xor j tc.mon) (tc.inv \u2016f x\u2016))\n      measurableSet_Ioi measurableSet_res']\n  \u00b7 have : Ioi 0 \u2229 res' (xor j tc.mon) (tc.inv \u2016f x\u2016) = res' (xor j tc.mon) (tc.inv \u2016f x\u2016) := by\n      refine inter_eq_self_of_subset_right (res'subset_Ioi (tc.ran_inv (\u2016f x\u2016) hfx))\n    rw [this]\n  \u00b7 apply ae_of_all\n    rw [res'comp]\n    \u00b7 intro s\n      unfold res trnc trunc\n      have mon_pf := tc.inv_pf\n      split_ifs at mon_pf with mon\n      \u00b7 rw [mon]\n        rcases j\n        \u00b7 simp only [Bool.bne_true, Bool.not_false, not_true_eq_false, decide_false,\n          Bool.false_eq_true, \u2193reduceIte, Pi.sub_apply]\n          intro (hs : s > tc.inv \u2016f x\u2016)\n          split_ifs with h\n          \u00b7 simp [hp]\n          \u00b7 have := (mon_pf s (lt_trans (tc.ran_inv \u2016f x\u2016 hfx) hs) (\u2016f x\u2016) hfx).2.mpr hs\n            contrapose! h; linarith\n        \u00b7 simp only [bne_self_eq_false, Bool.false_eq_true, not_false_eq_true, decide_true]\n          intro hs\n          split_ifs with h\n          \u00b7 have := (mon_pf s hs.1 (\u2016f x\u2016) hfx).1.mpr hs.2\n            linarith\n          \u00b7 simp [hp]\n      \u00b7 rw [Bool.not_eq_true] at mon\n        rw [mon]\n        rcases j\n        \u00b7 simp only [bne_self_eq_false, Bool.false_eq_true, not_false_eq_true, decide_true,\n          \u2193reduceIte, Pi.sub_apply]\n          intro hs\n          split_ifs with h\n          \u00b7 simp [hp]\n          \u00b7 have := (mon_pf s hs.1 (\u2016f x\u2016) hfx).2.mpr hs.2\n            linarith\n        \u00b7 simp only [Bool.bne_false, not_true_eq_false, decide_false, Bool.false_eq_true, \u2193reduceIte]\n          intro (hs : tc.inv \u2016f x\u2016 < s)\n          have := (mon_pf s (lt_trans (tc.ran_inv \u2016f x\u2016 hfx) hs) (\u2016f x\u2016) hfx).1.mpr hs\n          split_ifs with h\n          \u00b7 linarith\n          \u00b7 simp [hp]\n    \u00b7 exact tc.ran_inv \u2016f x\u2016 hfx\n\nlemma lintegral_trunc_mul\u2081 {g : \u211d \u2192 \u211d\u22650\u221e} {j : Bool} {x : \u03b1} {p : \u211d} {tc : ToneCouple} :\n    \u222b\u207b s : \u211d in res' (xor j tc.mon) (tc.inv \u2016f x\u2016), (g s) * \u2016trnc j f (tc.ton s) x\u2016\u208a ^ p =\n    \u222b\u207b s : \u211d in res (xor j tc.mon) (tc.inv \u2016f x\u2016), (g s) * \u2016trnc j f (tc.ton s) x\u2016\u208a ^ p := by\n  apply setLIntegral_congr\n  unfold res res'\n  split_ifs\n  \u00b7 exact Ioo_ae_eq_Ioc.symm\n  \u00b7 exact Ioi_ae_eq_Ici.symm\n\nlemma lintegral_trunc_mul\u2082 {g : \u211d \u2192 \u211d\u22650\u221e} {j : Bool} {x : \u03b1} {p : \u211d} {tc : ToneCouple}\n    (hfx : \u2016f x\u2016 > 0) :\n    \u222b\u207b s : \u211d in res (xor j tc.mon) (tc.inv \u2016f x\u2016), (g s) * \u2016trnc j f (tc.ton s) x\u2016\u208a ^ p =\n    \u222b\u207b s : \u211d in res (xor j tc.mon) (tc.inv \u2016f x\u2016), (g s) * \u2016f x\u2016\u208a ^ p := by\n  apply setLIntegral_congr_fun measurableSet_res\n  \u00b7 apply ae_of_all\n    unfold res trnc trunc\n    have mon_pf := tc.inv_pf\n    split_ifs at mon_pf with mon\n    \u00b7 rw [mon]\n      rcases j\n      \u00b7 simp only [Bool.bne_true, Bool.not_false, \u2193reduceIte, Pi.sub_apply]\n        intro s hs\n        split_ifs with h\n        \u00b7 have := (mon_pf s hs.1 (\u2016f x\u2016) hfx).1.mpr hs.2\n          contrapose! h; linarith\n        \u00b7 simp\n      \u00b7 simp only [bne_self_eq_false, Bool.false_eq_true, \u2193reduceIte]\n        intro s (hs : s > tc.inv \u2016f x\u2016)\n        split_ifs with h\n        \u00b7 rfl\n        \u00b7 have := (mon_pf s (lt_trans (tc.ran_inv \u2016f x\u2016 hfx) hs) (\u2016f x\u2016) hfx).2.mpr hs\n          contrapose! h; linarith\n    \u00b7 rw [Bool.not_eq_true] at mon\n      rw [mon]\n      rcases j\n      \u00b7 simp only [bne_self_eq_false, Bool.false_eq_true, \u2193reduceIte, Pi.sub_apply]\n        intro s (hs : tc.inv \u2016f x\u2016 < s)\n        have := (mon_pf s (lt_trans (tc.ran_inv \u2016f x\u2016 hfx) hs) (\u2016f x\u2016) hfx).1.mpr hs\n        split_ifs with h\n        \u00b7 linarith\n        \u00b7 simp\n      \u00b7 simp only [Bool.bne_false, \u2193reduceIte]\n        intro s hs\n        have := (mon_pf s hs.1 (\u2016f x\u2016) hfx).2.mpr hs.2\n        split_ifs with h\n        \u00b7 rfl\n        \u00b7 linarith\n\nlemma lintegral_trunc_mul {g : \u211d \u2192 \u211d\u22650\u221e} {j : Bool} {x : \u03b1} {tc : ToneCouple} {p : \u211d}\n    (hp : p > 0) (hfx : \u2016f x\u2016\u208a > 0) :\n    \u222b\u207b s : \u211d in Ioi 0, (g s) * \u2016trnc j f (tc.ton s) x\u2016\u208a ^ p =\n    (\u222b\u207b s : \u211d in res (xor j tc.mon) (tc.inv \u2016f x\u2016), (g s)) * \u2016f x\u2016\u208a ^ p := by\n  rw [lintegral_trunc_mul\u2080 hp hfx, lintegral_trunc_mul\u2081, lintegral_trunc_mul\u2082 hfx,\n    lintegral_mul_const']\n  exact ((rpow_lt_top_iff_of_pos hp).mpr coe_lt_top).ne\n\n\n/-! Extract expressions for the lower Lebesgue integral of power functions -/\n\nlemma lintegral_rpow_of_gt_abs {\u03b2 \u03b3 : \u211d} (h\u03b2 : \u03b2 > 0) (h\u03b3 : \u03b3 > -1) :\n    \u222b\u207b s : \u211d in Ioo 0 \u03b2, ENNReal.ofReal (s ^ \u03b3) =\n    ENNReal.ofReal (\u03b2 ^ (\u03b3 + 1) / |\u03b3 + 1|) := by\n  have h\u03b32 : \u03b3 + 1 > 0 := by linarith\n  rw [abs_of_nonneg h\u03b32.le]\n  exact lintegral_rpow_of_gt h\u03b2 h\u03b3\n\n-- TODO: treat symmetrically to Ioo case?\nlemma lintegral_Ioi_rpow_of_lt_abs {\u03b2 \u03c3 : \u211d} (h\u03b2 : \u03b2 > 0) (h\u03c3 : \u03c3 < -1):\n    \u222b\u207b s : \u211d in Ioi \u03b2, ENNReal.ofReal (s ^ \u03c3) =\n    ENNReal.ofReal (\u03b2 ^ (\u03c3 + 1) / |\u03c3 + 1|) := by\n  have h\u03c32 : \u03c3 + 1 < 0 := by linarith\n  rw [abs_of_neg h\u03c32, \u2190 ofReal_integral_eq_lintegral_ofReal]\n  \u00b7 rw [integral_Ioi_rpow_of_lt h\u03c3 h\u03b2, div_neg, neg_div]\n  \u00b7 apply integrableOn_Ioi_rpow_of_lt h\u03c3 h\u03b2\n  \u00b7 filter_upwards [self_mem_ae_restrict measurableSet_Ioi]\n    exact fun s hs \u21a6 Real.rpow_nonneg (lt_trans h\u03b2 hs).le \u03c3\n\nlemma lintegral_rpow_abs {j : Bool} {tc : ToneCouple} {\u03b3 : \u211d} {t : \u211d}\n    (h\u03b3 : if xor j tc.mon then \u03b3 > -1 else \u03b3 < -1 ) (ht : t > 0) :\n  \u222b\u207b s : \u211d in res (xor j tc.mon) (tc.inv t), ENNReal.ofReal s ^ \u03b3 =\n    ENNReal.ofReal ((tc.inv t) ^ (\u03b3 + 1) / |\u03b3 + 1|) := by\n  rw [\u2190 lintegral_congr_ae (Filter.mp_mem (self_mem_ae_restrict measurableSet_res)\n      (Filter.univ_mem'\n      (fun s hs \u21a6 (ofReal_rpow_of_pos (res_subset_Ioi (tc.ran_inv t ht) hs)).symm)))]\n  unfold res\n  split at h\u03b3 <;> rename_i xor_split\n  \u00b7 rw [xor_split]\n    simp only [\u2193reduceIte]\n    rw [lintegral_rpow_of_gt_abs (tc.ran_inv t ht) h\u03b3]\n  \u00b7 rw [eq_false_of_ne_true xor_split]\n    simp only [Bool.false_eq_true, \u2193reduceIte]\n    rw [lintegral_Ioi_rpow_of_lt_abs (tc.ran_inv t ht) h\u03b3]\n\nlemma value_lintegral_res\u2080 {j : Bool} {\u03b2 \u03b3 : \u211d} {tc : ToneCouple} (h\u03b2 : \u03b2 > 0)\n    (h\u03b3 : if xor j tc.mon then \u03b3 > -1 else \u03b3 < -1 ) :\n    \u222b\u207b s : \u211d in res (xor j tc.mon) \u03b2, ENNReal.ofReal (s ^ \u03b3) =\n    ENNReal.ofReal (\u03b2 ^ (\u03b3 + 1) / |\u03b3 + 1|) := by\n  unfold res\n  split_ifs at h\u03b3 with h\n  \u00b7 rw [h]\n    simp only [\u2193reduceIte]\n    rw [lintegral_rpow_of_gt_abs h\u03b2 h\u03b3]\n  \u00b7 have : xor j tc.mon = false := by\n      contrapose! h; exact eq_true_of_ne_false h\n    rw [this]\n    simp only [Bool.false_eq_true, \u2193reduceIte]\n    rw [lintegral_Ioi_rpow_of_lt_abs h\u03b2 h\u03b3]\n\nlemma value_lintegral_res\u2081 {t \u03b3 p': \u211d} {spf : ScaledPowerFunction} (ht : t > 0) :\n    ENNReal.ofReal (((spf_to_tc spf).inv t) ^ (\u03b3 + 1) / |\u03b3 + 1| ) * ENNReal.ofReal (t ^ p') =\n    ENNReal.ofReal (spf.d ^ (\u03b3 + 1) * t ^ (spf.\u03c3\u207b\u00b9 * (\u03b3 + 1) + p') / |\u03b3 + 1|) := by\n  have := spf.hd\n  unfold spf_to_tc\n  dsimp only\n  rw [\u2190 ENNReal.ofReal_mul, \u2190 mul_div_right_comm, Real.mul_rpow, mul_assoc, \u2190 Real.rpow_mul,\n      \u2190 Real.rpow_add] <;> positivity\n\nend MeasureTheory\n\nend\n\nnoncomputable section\n\nopen NNReal ENNReal MeasureTheory Set ComputationsInterpolatedExponents\n    ComputationsChoiceExponent\n\nvariable {\u03b1 \u03b1' E E\u2081 E\u2082 E\u2083 : Type*} {m : MeasurableSpace \u03b1} {m' : MeasurableSpace \u03b1'}\n  {p p' q p\u2080 q\u2080 p\u2081 q\u2081: \u211d\u22650\u221e}\n  {C\u2080 C\u2081 : \u211d\u22650} {\u03bc : Measure \u03b1} {\u03bd : Measure \u03b1'}\n  {a : \u211d}\n  {f : \u03b1 \u2192 E\u2081} {t : \u211d}\n  {T : (\u03b1 \u2192 E\u2081) \u2192 (\u03b1' \u2192 E\u2082)}\n\n/-! ## Minkowski's integral inequality -/\nnamespace MeasureTheory\n\nlemma rpow_add_of_pos (a : \u211d\u22650\u221e) (c d : \u211d) (hc : c > 0) (hd : d > 0):\n    a ^ (c + d) = a ^ c * a ^ d := by\n  have hcd : c + d  > 0 := by linarith\n  rcases (eq_or_ne a 0) with a_eq_zero | a_ne_zero\n  \u00b7 rw [a_eq_zero, zero_rpow_of_pos hcd, zero_rpow_of_pos hc, zero_rpow_of_pos hd, mul_zero]\n  \u00b7 rcases (eq_or_ne a \u22a4) with a_eq_top | a_ne_top\n    \u00b7 rw [a_eq_top, top_rpow_of_pos hcd, top_rpow_of_pos hc, top_rpow_of_pos hd, top_mul_top]\n    \u00b7 rw [ENNReal.rpow_add c d a_ne_zero a_ne_top]\n\nlemma eq_of_le_of_le (a b : \u211d\u22650\u221e) (hab : a \u2264 b) (hab': b \u2264 a) : a = b := by\n  rcases (eq_or_ne a b) with a_eq_b | a_ne_b\n  \u00b7 exact a_eq_b\n  \u00b7 rcases lt_or_gt_of_ne a_ne_b with a_lt_b | b_lt_a\n    \u00b7 contrapose! a_lt_b; exact hab'\n    \u00b7 contrapose! b_lt_a; exact hab\n\ndef trunc_cut (f : \u03b1 \u2192 \u211d\u22650\u221e) (\u03bc : Measure \u03b1) [SigmaFinite \u03bc] :=\n  fun n : \u2115 \u21a6 indicator (spanningSets \u03bc n) (fun x \u21a6 min (f x) n)\n\nlemma trunc_cut_mono {\u03bc : Measure \u03b1} [SigmaFinite \u03bc] {f : \u03b1 \u2192 \u211d\u22650\u221e} :\n    \u2200 x : \u03b1, Monotone (fun n \u21a6 trunc_cut f \u03bc n x) := by\n  intro x m n hmn; simp only [trunc_cut, indicator]\n  split_ifs with is_fx_le_m is_fx_le_n\n  \u00b7 refine min_le_min_left (f x) (Nat.cast_le.mpr hmn)\n  \u00b7 contrapose! is_fx_le_n\n    apply monotone_spanningSets _ hmn is_fx_le_m\n  \u00b7 exact zero_le _\n  \u00b7 exact zero_le _\n\nlemma trunc_cut_mono\u2080 {\u03bc : Measure \u03b1} [SigmaFinite \u03bc] {f : \u03b1 \u2192 \u211d\u22650\u221e} :\n    Monotone (trunc_cut f \u03bc) := by\n  intro m n hmn x; apply trunc_cut_mono\n  exact hmn\n\nlemma trunc_cut_sup {\u03bc : Measure \u03b1} [SigmaFinite \u03bc] {f : \u03b1 \u2192 \u211d\u22650\u221e} :\n    \u2200 x : \u03b1, \u2a06 n : \u2115, trunc_cut f \u03bc n x = f x := by\n  intro x; refine iSup_eq_of_forall_le_of_forall_lt_exists_gt ?h\u2081 ?h\u2082\n  \u00b7 intro n; unfold trunc_cut indicator\n    split_ifs\n    \u00b7 exact min_le_left (f x) \u2191n\n    \u00b7 exact zero_le _\n  \u00b7 intro w hw\n    unfold trunc_cut\n    have : \u2203 m : \u2115, x \u2208 spanningSets \u03bc m := by\n      have obs := iUnion_spanningSets \u03bc\n      refine mem_iUnion.mp ?_\n      rw [obs]\n      exact trivial\n    rcases this with \u27e8m, wm\u27e9\n    rcases ENNReal.exists_nat_gt hw.ne_top with \u27e8n, wn\u27e9\n    use (m + n)\n    simp only [indicator]\n    split_ifs with is_x_in_Ampn\n    \u00b7 refine lt_min hw ?_\n      calc\n      w < n := wn\n      _ \u2264 m + n := le_add_self\n      _ = _ := (Nat.cast_add m n).symm\n    \u00b7 contrapose! is_x_in_Ampn\n      exact monotone_spanningSets _ (Nat.le_add_right m n) wm\n\nset_option linter.flexible false in\n/-- Characterization of `\u222b\u207b x : \u03b1, f x ^ p \u2202\u03bc` by a duality argument. -/\nlemma representationLp {\u03bc : Measure \u03b1} [SigmaFinite \u03bc] {f : \u03b1 \u2192 \u211d\u22650\u221e}\n    (hf : AEMeasurable f \u03bc) {p q : \u211d} (hp : p > 1) (hq : q \u2265 1)\n    (hpq : p\u207b\u00b9 + q\u207b\u00b9 = 1) :\n    (\u222b\u207b x : \u03b1, (f x) ^ p \u2202\u03bc) ^ (1 / p) =\n    \u2a06 g \u2208 {g' : \u03b1 \u2192 \u211d\u22650\u221e | AEMeasurable g' \u03bc \u2227 \u222b\u207b x : \u03b1, (g' x) ^ q \u2202\u03bc \u2264 1},\n    \u222b\u207b x : \u03b1, (f x) * g x \u2202\u03bc := by\n  let A := spanningSets \u03bc\n  let g := trunc_cut f \u03bc\n  have hpq' : p.IsConjExponent q := Real.IsConjExponent.mk hp hpq\n  have f_mul : \u2200 n : \u2115, (g n) ^ p \u2264 f * (g n) ^ (p - 1) := by\n    intro n x\n    simp only [g, Pi.pow_apply, Pi.mul_apply, trunc_cut, indicator]\n    split_ifs\n    \u00b7 refine le_trans (b := (min (f x) \u2191n) * min (f x) \u2191n ^ (p - 1)) ?_ ?_\n      \u00b7 nth_rewrite 1 [\u2190 add_sub_cancel 1 p]\n        rw [rpow_add_of_pos, ENNReal.rpow_one] <;> try linarith\n      \u00b7 exact mul_le_mul_right' (min_le_left (f x) \u2191n) (min (f x) \u2191n ^ (p - 1))\n    \u00b7 rw [ENNReal.zero_rpow_of_pos] <;> positivity\n  have g_lim : \u2200 x : \u03b1, Filter.Tendsto (fun n \u21a6 g n x) Filter.atTop (nhds (f x)) := by\n    intro x\n    apply tendsto_atTop_isLUB (trunc_cut_mono _)\n    exact isLUB_iff_sSup_eq.mpr (trunc_cut_sup _)\n  have g_sup' : (fun x \u21a6 \u2a06 n : \u2115, (g n x) ^ p) = fun x \u21a6 (f x) ^ p := by\n    ext x\n    apply iSup_eq_of_tendsto\n    \u00b7 intro m n hmn\n      dsimp only\n      gcongr\n      exact trunc_cut_mono _ hmn\n    \u00b7 exact (g_lim x).ennrpow_const p\n  have g_meas (n : \u2115): AEMeasurable (g n) \u03bc := by\n    exact AEMeasurable.indicator (by fun_prop) (measurableSet_spanningSets \u03bc n)\n  have g_fin (n : \u2115): \u222b\u207b (z : \u03b1), g n z ^ p \u2202\u03bc < \u22a4 := by\n    calc\n    _ = \u222b\u207b (z : \u03b1) in A n, g n z ^ p \u2202\u03bc := by\n      unfold g trunc_cut\n      rw [\u2190 lintegral_indicator]; swap; exact measurableSet_spanningSets \u03bc n\n      congr 1\n      ext x\n      dsimp only [indicator]\n      split_ifs\n      \u00b7 rfl\n      \u00b7 simp only [ENNReal.rpow_eq_zero_iff, true_and, zero_ne_top, false_and, or_false]; positivity\n    _ \u2264 \u222b\u207b (_x : \u03b1) in A n, n ^ p \u2202\u03bc := by\n      apply setLIntegral_mono measurable_const\n      \u00b7 intro x hx\n        gcongr\n        unfold g trunc_cut indicator\n        split_ifs\n        \u00b7 exact min_le_right (f x) \u2191n\n        \u00b7 contradiction\n    _ = n ^ p * \u03bc (A n) := setLIntegral_const (A n) (\u2191n ^ p)\n    _ < \u22a4 := mul_lt_top (rpow_lt_top_of_nonneg (by linarith) coe_ne_top)\n              (measure_spanningSets_lt_top \u03bc n)\n  have obs : \u2200 n : \u2115, \u222b\u207b x : \u03b1, (f x) * ((g n x) ^ (p - 1) /\n      (\u222b\u207b y : \u03b1, ((g n y) ^ (p - 1)) ^ q \u2202\u03bc) ^ q\u207b\u00b9) \u2202\u03bc \u2265\n      (\u222b\u207b x : \u03b1, (g n x) ^ p \u2202\u03bc) ^ p\u207b\u00b9 := by\n    intro n\n    rcases eq_or_ne (\u222b\u207b x : \u03b1, (g n x) ^ p \u2202\u03bc) 0  with int_eq_zero | int_ne_zero\n    \u00b7 rw [int_eq_zero, ENNReal.zero_rpow_of_pos]\n      \u00b7 exact zero_le _\n      \u00b7 refine inv_pos_of_pos (by positivity)\n    \u00b7 calc\n      _ = (\u222b\u207b x : \u03b1, (f x) * (g n x) ^ (p - 1) \u2202\u03bc) * (\n          (\u222b\u207b y : \u03b1, ((g n y) ^ (p - 1)) ^ q \u2202\u03bc) ^ q\u207b\u00b9)\u207b\u00b9 := by\n        simp_rw [div_eq_mul_inv, \u2190 mul_assoc]\n        rw [lintegral_mul_const'' _ (by fun_prop)]\n      _ \u2265 (\u222b\u207b x : \u03b1, (g n x) ^ (p) \u2202\u03bc) * ((\u222b\u207b y : \u03b1, ((g n y) ^ (p - 1)) ^ q \u2202\u03bc) ^ q\u207b\u00b9)\u207b\u00b9 := by\n        gcongr\n        apply f_mul\n      _ = (\u222b\u207b x : \u03b1, (g n x) ^ (p) \u2202\u03bc) * ((\u222b\u207b y : \u03b1, (g n y) ^ p \u2202\u03bc) ^ q\u207b\u00b9)\u207b\u00b9 := by\n        congr\n        ext x\n        rw [\u2190 ENNReal.rpow_mul]\n        congr\n        refine Real.IsConjExponent.sub_one_mul_conj ?_\n        exact Real.IsConjExponent.mk hp hpq\n      _ = (\u222b\u207b x : \u03b1, (g n x) ^ p \u2202\u03bc) ^ p\u207b\u00b9 := by\n        rw [\u2190 ENNReal.rpow_neg]\n        nth_rw 1 [\u2190 ENNReal.rpow_one (x := (\u222b\u207b x : \u03b1, (g n x) ^ (p) \u2202\u03bc))]\n        rw [\u2190 ENNReal.rpow_add _ _ int_ne_zero (g_fin n).ne]\n        congr\n        exact add_neg_eq_of_eq_add hpq.symm\n  have int_fg : \u222b\u207b (x : \u03b1), f x ^ p \u2202\u03bc = \u2a06 n : \u2115, \u222b\u207b x : \u03b1, g n x ^ p \u2202\u03bc := by\n    rw [\u2190 g_sup']\n    apply lintegral_iSup' (fun n \u21a6 by fun_prop) (ae_of_all _ fun x m n hmn \u21a6 ?_)\n    dsimp only\n    gcongr\n    exact trunc_cut_mono _ hmn\n  have sup_rpow : (\u2a06 n : \u2115, \u222b\u207b x : \u03b1, g n x ^ p \u2202\u03bc) ^ (1 / p) =\n      \u2a06 n : \u2115, (\u222b\u207b x : \u03b1, g n x ^ p \u2202\u03bc) ^ (1 / p) := by\n    apply Monotone.map_iSup_of_continuousAt (f := fun (x : \u211d\u22650\u221e) \u21a6 x ^ (1 / p))\n    \u00b7 fun_prop\n    \u00b7 apply ENNReal.monotone_rpow_of_nonneg (by positivity)\n    \u00b7 simp; positivity\n  let h := fun n : \u2115 \u21a6 (fun x \u21a6 g n x ^ (p - 1) / (\u222b\u207b y : \u03b1, ((g n y) ^ (p - 1)) ^ q \u2202\u03bc) ^ q\u207b\u00b9)\n  have comp_sup : (\u2a06 n : \u2115, \u222b\u207b (x : \u03b1), f x * h n x \u2202\u03bc) \u2264\n      \u2a06 g \u2208 {g' : \u03b1 \u2192 \u211d\u22650\u221e | AEMeasurable g' \u03bc \u2227 \u222b\u207b (z : \u03b1), (g' z) ^ q \u2202\u03bc \u2264 1},\n      \u222b\u207b (x : \u03b1), f x * g x \u2202\u03bc := by\n    nth_rw 1 [\u2190 iSup_range (f := fun n : \u2115 \u21a6 h n) (g := fun r \u21a6 \u222b\u207b x : \u03b1, f x * r x \u2202\u03bc)]\n    apply iSup_le_iSup_of_subset fun r exists_n \u21a6 ?_\n    rcases exists_n with \u27e8n, wn\u27e9\n    simp_rw [\u2190 wn]\n    unfold h\n    refine \u27e8by fun_prop, ?_\u27e9\n    simp_rw [div_eq_mul_inv]\n    calc\n    _ = \u222b\u207b (z : \u03b1), ((g n z ^ (p - 1)) ^ q) *\n        ((\u222b\u207b (y : \u03b1), (g n y ^ (p - 1)) ^ q \u2202\u03bc) ^ q\u207b\u00b9)\u207b\u00b9 ^ q \u2202\u03bc := by\n      congr 1\n      ext z\n      rw [ENNReal.mul_rpow_of_nonneg]\n      linarith\n    _ = (\u222b\u207b (z : \u03b1), ((g n z ^ (p - 1)) ^ q) \u2202\u03bc) *\n        ((\u222b\u207b (y : \u03b1), (g n y ^ (p - 1)) ^ q \u2202\u03bc) ^ q\u207b\u00b9)\u207b\u00b9 ^ q := by\n      rw [lintegral_mul_const'' _ (by fun_prop)]\n    _ \u2264 _ := by\n      rcases eq_or_ne (\u222b\u207b x : \u03b1, ((g n x) ^ (p - 1)) ^ q \u2202\u03bc) 0 with int_eq_zero | int_ne_zero\n      \u00b7 rw [int_eq_zero]\n        simp\n      \u00b7 rw [ENNReal.inv_rpow, ENNReal.rpow_inv_rpow]\n        apply le_of_eq\n        refine ENNReal.mul_inv_cancel int_ne_zero ?inr.a.ht\n        \u00b7 apply ne_of_lt\n          calc\n          _ = \u222b\u207b (z : \u03b1), g n z ^ p \u2202\u03bc := by\n            congr 1\n            ext z\n            rw [\u2190 ENNReal.rpow_mul]\n            congr\n            exact Real.IsConjExponent.sub_one_mul_conj hpq'\n          _ < \u22a4 := g_fin n\n        \u00b7 linarith\n  apply eq_of_le_of_le\n  \u00b7 rw [int_fg, sup_rpow]\n    calc\n    _ \u2264 \u2a06 n : \u2115, \u222b\u207b x : \u03b1, (f x) * ((g n x) ^ (p - 1) /\n        (\u222b\u207b y : \u03b1, ((g n y) ^ (p - 1)) ^ q \u2202\u03bc) ^ q\u207b\u00b9) \u2202\u03bc := by\n      gcongr\n      rw [one_div]\n      apply obs\n    _ \u2264 _ := comp_sup\n  \u00b7 refine iSup_le fun r \u21a6 iSup_le fun hr \u21a6 ?_\n    calc\n    _ \u2264 (\u222b\u207b x : \u03b1, f x ^ p \u2202\u03bc) ^ (1 / p) * (\u222b\u207b x : \u03b1, r x ^ q \u2202\u03bc) ^ (1 / q) :=\n      ENNReal.lintegral_mul_le_Lp_mul_Lq _ hpq' hf hr.1\n    _ \u2264 (\u222b\u207b x : \u03b1, f x ^ p \u2202\u03bc) ^ (1 / p) * (1) ^ (1 / q) := by\n      gcongr\n      exact hr.2\n    _ = _ := by simp\n\nlemma aemeasurability_prod\u2081 {\u03b1 : Type u_1} {\u03b2 : Type u_3}\n    [MeasurableSpace \u03b1] [MeasurableSpace \u03b2]\n    {\u03bc : Measure \u03b1} {\u03bd : Measure \u03b2} [SFinite \u03bd]\n    \u2983f : \u03b1 \u00d7 \u03b2 \u2192 ENNReal\u2984\n    (hf : AEMeasurable f (\u03bc.prod \u03bd)) :\n    \u2200\u1d50 x : \u03b1 \u2202\u03bc, AEMeasurable (f \u2218 (Prod.mk x)) \u03bd := by\n  rcases hf with \u27e8g, hg\u27e9\n  filter_upwards [Measure.ae_ae_of_ae_prod hg.2] with x h\n  exact \u27e8g \u2218 Prod.mk x, hg.1.comp (measurable_prod_mk_left), h\u27e9\n\nlemma aemeasurability_prod\u2082 {\u03b1 : Type u_1} {\u03b2 : Type u_3}\n    [MeasurableSpace \u03b1] [MeasurableSpace \u03b2]\n    {\u03bc : Measure \u03b1} {\u03bd : Measure \u03b2} [SFinite \u03bd]\n    [SFinite \u03bc] \u2983f : \u03b1 \u00d7 \u03b2 \u2192 ENNReal\u2984\n    (hf : AEMeasurable f (\u03bc.prod \u03bd)) :\n    \u2200\u1d50 y : \u03b2 \u2202\u03bd, AEMeasurable (f \u2218 (fun x \u21a6 Prod.mk x y)) \u03bc := by\n  have : AEMeasurable (f \u2218 Prod.swap) (\u03bd.prod \u03bc) := by\n    refine AEMeasurable.comp_measurable ?_ measurable_swap\n    rw [Measure.prod_swap]\n    assumption\n  exact aemeasurability_prod\u2081 this\n\nlemma aemeasurability_integral_component {\u03b1 : Type u_1} {\u03b2 : Type u_3}\n    [MeasurableSpace \u03b1] [MeasurableSpace \u03b2]\n    {\u03bc : Measure \u03b1} {\u03bd : Measure \u03b2} [SFinite \u03bd]\n    \u2983f : \u03b1 \u00d7 \u03b2 \u2192 ENNReal\u2984\n    (hf : AEMeasurable f (\u03bc.prod \u03bd)) :\n    AEMeasurable (fun x \u21a6 \u222b\u207b (y : \u03b2), f (x, y) \u2202\u03bd) \u03bc := by\n  rcases hf with \u27e8g, hg\u27e9\n  refine \u27e8fun x \u21a6 \u222b\u207b y : \u03b2, g (x, y) \u2202\u03bd, Measurable.lintegral_prod_right hg.1, ?_\u27e9\n  filter_upwards [Measure.ae_ae_of_ae_prod hg.2] with x h using lintegral_congr_ae h\n\n/-- Minkowsi's integral inequality -/\n-- TODO: the condition on `\u03bc` can probably be weakened to `SFinite \u03bc`, by using a limit\n-- argument\nlemma lintegral_lintegral_pow_swap {\u03b1 : Type u_1} {\u03b2 : Type u_3} {p : \u211d} (hp : 1 \u2264 p)\n    [MeasurableSpace \u03b1] [MeasurableSpace \u03b2]\n    {\u03bc : Measure \u03b1} {\u03bd : Measure \u03b2} [SFinite \u03bd]\n    [SigmaFinite \u03bc] \u2983f : \u03b1 \u2192 \u03b2 \u2192 ENNReal\u2984\n    (hf : AEMeasurable (Function.uncurry f) (\u03bc.prod \u03bd)) :\n    (\u222b\u207b (x : \u03b1), (\u222b\u207b (y : \u03b2), f x y \u2202\u03bd) ^ p \u2202\u03bc) ^ p\u207b\u00b9 \u2264\n    \u222b\u207b (y : \u03b2), (\u222b\u207b (x : \u03b1), (f x y) ^ p \u2202\u03bc) ^ p\u207b\u00b9 \u2202\u03bd := by\n  rcases Decidable.lt_or_eq_of_le hp with one_lt_p | one_eq_p\n  \u00b7 let q := Real.conjExponent p\n    have hpq' : p.IsConjExponent q := Real.IsConjExponent.conjExponent one_lt_p\n    have one_lt_q : 1 < q := (Real.IsConjExponent.symm hpq').one_lt\n    have ineq : \u2200 g \u2208 {g' : \u03b1 \u2192 \u211d\u22650\u221e | AEMeasurable g' \u03bc \u2227 \u222b\u207b (z : \u03b1), (g' z) ^ q \u2202\u03bc \u2264 1},\n        \u222b\u207b x : \u03b1, (\u222b\u207b y : \u03b2, f x y \u2202\u03bd) * g x \u2202\u03bc \u2264\n        \u222b\u207b (y : \u03b2), (\u222b\u207b (x : \u03b1), f x y ^ p \u2202\u03bc) ^ p\u207b\u00b9 \u2202\u03bd := by\n      intro g \u27e8hg1, hg2\u27e9\n      have ae_meas\u2081 : \u2200\u1d50 x : \u03b1 \u2202\u03bc, AEMeasurable (f x) \u03bd :=\n        aemeasurability_prod\u2081 (f := Function.uncurry f) hf\n      calc\n      _ = \u222b\u207b x : \u03b1, (\u222b\u207b y : \u03b2, f x y * g x \u2202\u03bd) \u2202\u03bc := by\n        apply lintegral_congr_ae\n        filter_upwards [ae_meas\u2081] with a ha using (lintegral_mul_const'' _ ha).symm\n      _ = \u222b\u207b y : \u03b2, (\u222b\u207b x : \u03b1, f x y * g x \u2202\u03bc) \u2202\u03bd := lintegral_lintegral_swap (hf.mul hg1.fst)\n      _ \u2264 \u222b\u207b (y : \u03b2), (\u222b\u207b (x : \u03b1), f x y ^ p \u2202\u03bc) ^ p\u207b\u00b9 \u2202\u03bd := by\n        apply lintegral_mono_ae\n        filter_upwards [aemeasurability_prod\u2082 hf] with y hy\n        calc\n        _ \u2264 (\u222b\u207b (x : \u03b1), f x y ^ p \u2202\u03bc) ^ (1 / p) * (\u222b\u207b (x : \u03b1), g x ^ q \u2202\u03bc) ^ (1 / q) :=\n          ENNReal.lintegral_mul_le_Lp_mul_Lq \u03bc hpq' hy hg1\n        _ \u2264 (\u222b\u207b (x : \u03b1), f x y ^ p \u2202\u03bc) ^ (1 / p) * 1 ^ (1 / q) := by\n          gcongr\n        _ = (\u222b\u207b (x : \u03b1), f x y ^ p \u2202\u03bc) ^ p\u207b\u00b9 := by\n          simp [one_div]\n    nth_rw 1 [\u2190 one_div]\n    rw [representationLp (hp := one_lt_p) (hq := one_lt_q.le) (hpq := hpq'.inv_add_inv_conj)]\n    \u00b7 exact (iSup_le fun g \u21a6 iSup_le fun hg \u21a6 ineq g hg)\n    \u00b7 exact (aemeasurability_integral_component hf)\n  \u00b7 rw [\u2190 one_eq_p]\n    simp only [ENNReal.rpow_one, inv_one]\n    exact (lintegral_lintegral_swap hf).le\n\nlemma lintegral_lintegral_pow_swap_rpow {\u03b1 : Type u_1} {\u03b2 : Type u_3} {p : \u211d} (hp : p \u2265 1)\n    [MeasurableSpace \u03b1] [MeasurableSpace \u03b2]\n    {\u03bc : Measure \u03b1} {\u03bd : Measure \u03b2} [SFinite \u03bd]\n    [SigmaFinite \u03bc] \u2983f : \u03b1 \u2192 \u03b2 \u2192 ENNReal\u2984\n    (hf : AEMeasurable (Function.uncurry f) (\u03bc.prod \u03bd)) :\n    (\u222b\u207b (x : \u03b1), (\u222b\u207b (y : \u03b2), f x y \u2202\u03bd) ^ p \u2202\u03bc) \u2264\n    (\u222b\u207b (y : \u03b2), (\u222b\u207b (x : \u03b1), (f x y) ^ p \u2202\u03bc) ^ p\u207b\u00b9 \u2202\u03bd) ^ p := by\n  have p_pos : p > 0 := lt_of_lt_of_le zero_lt_one hp\n  refine le_of_rpow_le (inv_pos_of_pos p_pos) ?_\n  rw [ENNReal.rpow_rpow_inv p_pos.ne']\n  exact lintegral_lintegral_pow_swap hp hf\n\n/-! ## Apply Minkowski's integral inequality to truncations\n-/\n\n@[measurability, fun_prop]\ntheorem ton_aeMeasurable (tc : ToneCouple) : AEMeasurable tc.ton (volume.restrict (Ioi 0)) := by\n  -- ton is either increasing or decreasing\n  have mono_or_anti := tc.ton_is_ton\n  split_ifs at mono_or_anti\n  \u00b7 exact aemeasurable_restrict_of_monotoneOn measurableSet_Ioi mono_or_anti.monotoneOn\n  \u00b7 exact aemeasurable_restrict_of_antitoneOn measurableSet_Ioi mono_or_anti.antitoneOn\n\n@[measurability]\nlemma indicator_ton_measurable {g : \u03b1 \u2192 E\u2081} [MeasurableSpace E\u2081] [NormedAddCommGroup E\u2081]\n    [BorelSpace E\u2081] [SigmaFinite \u03bc] (hg : AEMeasurable g \u03bc) (tc : ToneCouple) :\n    NullMeasurableSet {(s, x) : \u211d \u00d7 \u03b1 | \u2016g x\u2016\u208a \u2264 tc.ton s }\n        ((volume.restrict (Ioi 0)).prod \u03bc) :=\n  nullMeasurableSet_le hg.snd.norm (ton_aeMeasurable tc).fst\n\n@[measurability]\nlemma indicator_ton_measurable_lt {g : \u03b1 \u2192 E\u2081} [MeasurableSpace E\u2081] [NormedAddCommGroup E\u2081]\n    [BorelSpace E\u2081] [SigmaFinite \u03bc] (hg : AEMeasurable g \u03bc) (tc : ToneCouple) :\n    NullMeasurableSet {(s, x) : \u211d \u00d7 \u03b1 | tc.ton s < \u2016g x\u2016\u208a }\n        ((volume.restrict (Ioi 0)).prod \u03bc) :=\n  nullMeasurableSet_lt (ton_aeMeasurable tc).fst hg.snd.norm\n\n@[measurability]\nlemma truncation_ton_measurable {f : \u03b1 \u2192 E\u2081}\n    [MeasurableSpace E\u2081] [NormedAddCommGroup E\u2081] [BorelSpace E\u2081]\n    [SigmaFinite (\u03bc.restrict (Function.support f))] -- TODO: TypeClass or implicit variable?\n    (hf : AEMeasurable f \u03bc) (tc : ToneCouple) :\n    AEMeasurable (fun a : \u211d \u00d7 \u03b1 \u21a6 (trunc f (tc.ton a.1)) a.2)\n    ((volume.restrict (Ioi 0)).prod (\u03bc.restrict (Function.support f) )) := by\n  let A := {(s, x) : \u211d \u00d7 \u03b1 | \u2016f x\u2016\u208a \u2264 tc.ton s}\n  have : (fun z : \u211d \u00d7 \u03b1 \u21a6 (trunc f (tc.ton z.1)) z.2) =\n      Set.indicator A (fun z : \u211d \u00d7 \u03b1 \u21a6 f z.2) := by\n    ext z; simp [trunc, indicator, A]\n  rw [this]\n  exact (aemeasurable_indicator_iff\u2080 (indicator_ton_measurable hf.restrict _)).mpr\n    hf.restrict.snd.restrict\n\n@[measurability]\nlemma truncation_compl_ton_measurable {f : \u03b1 \u2192 E\u2081}\n    [MeasurableSpace E\u2081] [NormedAddCommGroup E\u2081] [BorelSpace E\u2081]\n    [SigmaFinite (\u03bc.restrict (Function.support f))] -- TODO: TypeClass or implicit variable?\n    (hf : AEMeasurable f \u03bc) (tc : ToneCouple) :\n    AEMeasurable (fun a : \u211d \u00d7 \u03b1 \u21a6 ((f - trunc f (tc.ton a.1))) a.2)\n    ((volume.restrict (Ioi 0)).prod (\u03bc.restrict (Function.support f) )) := by\n  let A := {(s, x) : \u211d \u00d7 \u03b1 | tc.ton s < \u2016f x\u2016\u208a}\n  have : (fun z : \u211d \u00d7 \u03b1 \u21a6 (f - trunc f (tc.ton z.1)) z.2) = Set.indicator A (fun z : \u211d \u00d7 \u03b1 \u21a6 f z.2) := by\n    ext z; rw [trunc_compl_eq]; simp [A, indicator]\n  rw [this]\n  refine (aemeasurable_indicator_iff\u2080 (indicator_ton_measurable_lt hf.restrict _)).mpr\n    hf.restrict.snd.restrict\n\nlemma restrict_to_support {a : \u211d} {p : \u211d} (hp : p > 0) [NormedAddCommGroup E\u2081] (f : \u03b1 \u2192 E\u2081) :\n    \u222b\u207b x : \u03b1 in Function.support f, \u2016trunc f a x\u2016\u208a ^ p \u2202 \u03bc = \u222b\u207b x : \u03b1, \u2016trunc f a x\u2016\u208a ^ p \u2202\u03bc := by\n  apply setLIntegral_eq_of_support_subset\n  unfold Function.support trunc\n  rw [setOf_subset_setOf]\n  intro x\n  contrapose!\n  intro f_zero\n  simp_rw [f_zero]; simp [hp]\n\nlemma restrict_to_support_trunc_compl {a : \u211d} {p : \u211d} [NormedAddCommGroup E\u2081] (hp : p > 0)\n    (f : \u03b1 \u2192 E\u2081) :\n    \u222b\u207b x : \u03b1 in Function.support f, \u2016(f - trunc f a) x\u2016\u208a ^ p \u2202\u03bc =\n    \u222b\u207b x : \u03b1, \u2016(f - trunc f a) x\u2016\u208a ^ p \u2202\u03bc := by\n  apply setLIntegral_eq_of_support_subset\n  unfold Function.support trunc\n  rw [setOf_subset_setOf]\n  intro x\n  contrapose!\n  intro f_zero\n  rw [Pi.sub_apply, f_zero]\n  simp [hp]\n\nlemma restrict_to_support_trnc {a : \u211d} {p : \u211d} {j : Bool} [NormedAddCommGroup E\u2081] (hp : p > 0)\n    (f : \u03b1 \u2192 E\u2081) :\n    \u222b\u207b x : \u03b1 in Function.support f, \u2016trnc j f a x\u2016\u208a ^ p \u2202\u03bc =\n    \u222b\u207b x : \u03b1, \u2016trnc j f a x\u2016\u208a ^ p \u2202\u03bc := by\n  apply setLIntegral_eq_of_support_subset\n  unfold Function.support trnc trunc\n  rw [setOf_subset_setOf]\n  intro x\n  contrapose!\n  intro f_zero\n  rcases j\n  \u00b7 dsimp only [Pi.sub_apply]; simp_rw [f_zero]; simp [hp]\n  \u00b7 simp_rw [f_zero]; simp [hp]\n\n@[fun_prop]\ntheorem aeMeasurable_trunc_restrict\n    [MeasurableSpace E\u2081] [NormedAddCommGroup E\u2081] [BorelSpace E\u2081] {j : Bool}\n    {h\u03bc : SigmaFinite (\u03bc.restrict (Function.support f))} (hf : AEMeasurable f \u03bc) (tc : ToneCouple) :\n    AEMeasurable (fun a \u21a6 trnc j f (tc.ton a.1) a.2)\n      ((volume.restrict (Ioi 0)).prod (\u03bc.restrict (Function.support f))) := by\n  rcases j\n  \u00b7 exact truncation_compl_ton_measurable hf _\n  \u00b7 exact truncation_ton_measurable hf _\n\nlemma lintegral_lintegral_pow_swap_trunc_compl {q q\u2080 p\u2080 : \u211d} [MeasurableSpace E\u2081]\n    [NormedAddCommGroup E\u2081]\n    [BorelSpace E\u2081] {j : Bool} {h\u03bc : SigmaFinite (\u03bc.restrict (Function.support f))}\n    (hp\u2080 : p\u2080 > 0) (hp\u2080q\u2080 : p\u2080 \u2264 q\u2080)\n    (hf : AEMeasurable f \u03bc) (tc : ToneCouple) :\n    \u222b\u207b (s : \u211d) in Ioi 0,\n        (\u222b\u207b (a : \u03b1) in Function.support f, ENNReal.ofReal (s ^ (q - q\u2080 - 1)) ^ (p\u2080\u207b\u00b9 * q\u2080)\u207b\u00b9 *\n        \u2191\u2016trnc j f (tc.ton s) a\u2016\u208a ^ p\u2080 \u2202\u03bc) ^ (p\u2080\u207b\u00b9 * q\u2080) \u2264\n    (\u222b\u207b a : \u03b1 in Function.support f,\n      (\u222b\u207b (s : \u211d) in Ioi 0,\n        (ENNReal.ofReal (s ^ (q - q\u2080 - 1)) ^ (p\u2080\u207b\u00b9 * q\u2080)\u207b\u00b9 *\n        \u2191\u2016trnc j f (tc.ton s) a\u2016\u208a  ^ p\u2080) ^ (p\u2080\u207b\u00b9 * q\u2080)) ^ (p\u2080\u207b\u00b9 * q\u2080)\u207b\u00b9 \u2202\u03bc) ^ (p\u2080\u207b\u00b9 * q\u2080) := by\n  apply lintegral_lintegral_pow_swap_rpow\n  \u00b7 apply le_of_mul_le_mul_left _ hp\u2080\n    field_simp [hp\u2080q\u2080]\n  \u00b7 unfold Function.uncurry\n    simp only [Pi.sub_apply]\n    fun_prop\n\nlemma lintegral_congr_support {f : \u03b1 \u2192 E\u2081} {g h: \u03b1 \u2192 ENNReal}\n    [MeasurableSpace E\u2081] [NormedAddCommGroup E\u2081] [BorelSpace E\u2081]\n    (hf : AEMeasurable f \u03bc) (hgh : \u2200 x \u2208 Function.support f, g x = h x) :\n    \u222b\u207b x : \u03b1 in Function.support f, g x \u2202\u03bc = \u222b\u207b x : \u03b1 in Function.support f, h x \u2202\u03bc := by\n  refine lintegral_congr_ae (ae_iff.mpr ?_)\n  rw [Measure.restrict_apply\u2080']\n  \u00b7 refine measure_mono_null (fun x h\u2080 \u21a6 ?_) measure_empty\n    have : g x = h x := hgh _ (mem_of_mem_inter_right h\u2080)\n    have : x \u2208 {a | \u00acg a = h a} := mem_of_mem_diff h\u2080\n    change \u00ac (g x = h x) at this\n    contradiction\n  \u00b7 have : (Function.support f) = (Function.support (fun x \u21a6 \u2016f x\u2016)) := by\n      unfold Function.support\n      ext x\n      simp only [ne_eq, mem_setOf_eq, norm_eq_zero]\n    rw [this]\n    exact (aestronglyMeasurable_iff_aemeasurable.mpr hf.norm).nullMeasurableSet_support\n\n/-- One of the key estimates for the real interpolation theorem, not yet using\n    the particular choice of exponent and scale in the `ScaledPowerFunction`. -/\nlemma estimate_trnc {p\u2080 q\u2080 q : \u211d} {spf : ScaledPowerFunction} {j : Bool}\n    [MeasurableSpace E\u2081] [NormedAddCommGroup E\u2081] [BorelSpace E\u2081]\n    (hp\u2080 : p\u2080 > 0) (hq\u2080 : q\u2080 > 0) (hp\u2080q\u2080 : p\u2080 \u2264 q\u2080)\n    (hf : AEMeasurable f \u03bc) (hf\u2082 : SigmaFinite (\u03bc.restrict (Function.support f)))\n    (hpowers : if xor j (spf_to_tc spf).mon = true then q\u2080 < q else q < q\u2080) :\n    \u222b\u207b s : \u211d in Ioi 0,\n    eLpNorm (trnc j f ((spf_to_tc spf).ton s)) (ENNReal.ofReal p\u2080) \u03bc ^ q\u2080 *\n    ENNReal.ofReal (s ^ (q - q\u2080 - 1)) \u2264\n    ENNReal.ofReal (spf.d ^ (q - q\u2080)) * ENNReal.ofReal |q - q\u2080|\u207b\u00b9 *\n    (\u222b\u207b (a : \u03b1) in Function.support f,\n    ENNReal.ofReal (\u2016f a\u2016 ^ (p\u2080 + spf.\u03c3\u207b\u00b9 * (q - q\u2080) * (p\u2080 / q\u2080))) \u2202\u03bc) ^\n    (p\u2080\u207b\u00b9 * q\u2080) := by\n  have := spf.hd\n  unfold eLpNorm eLpNorm'\n  let tc := spf_to_tc spf\n  split_ifs with is_p\u2080pos is_p\u2080top\n  \u00b7 have : p\u2080 \u2264 0 := ofReal_eq_zero.mp is_p\u2080pos\n    contrapose! this; exact hp\u2080\n  \u00b7 contrapose! is_p\u2080top; exact coe_ne_top\n  \u00b7 rw [toReal_ofReal hp\u2080.le]\n    calc\n    _ = \u222b\u207b s : \u211d in Ioi 0, ENNReal.ofReal (s ^ (q - q\u2080 - 1)) *\n    ((\u222b\u207b (a : \u03b1), \u2191\u2016trnc j f ((spf_to_tc spf).ton s) a\u2016\u208a ^ p\u2080 \u2202\u03bc) ^ (1 / p\u2080)) ^ q\u2080  := by\n      simp only [enorm_eq_nnnorm]\n      congr 1\n      ext x\n      rw [mul_comm]\n    _ = \u222b\u207b (s : \u211d) in Ioi 0,\n        (ENNReal.ofReal (s ^ (q - q\u2080 - 1)) ^ (p\u2080\u207b\u00b9 * q\u2080)\u207b\u00b9) ^ (p\u2080\u207b\u00b9 * q\u2080) *\n        (\u222b\u207b (a : \u03b1) in Function.support f, \u2191\u2016trnc j f (tc.ton s) a\u2016\u208a ^ p\u2080 \u2202\u03bc) ^ (p\u2080\u207b\u00b9 * q\u2080)\n        := by\n      apply setLIntegral_congr_fun measurableSet_Ioi\n      filter_upwards with s _\n      rw [ENNReal.rpow_inv_rpow]\n      \u00b7 rw [one_div, \u2190 ENNReal.rpow_mul, restrict_to_support_trnc hp\u2080]\n      \u00b7 positivity\n    _ = \u222b\u207b (s : \u211d) in Ioi 0,\n        (\u222b\u207b (a : \u03b1) in Function.support f,\n        ENNReal.ofReal (s ^ (q - q\u2080 - 1)) ^ (p\u2080\u207b\u00b9 * q\u2080)\u207b\u00b9 *\n        \u2191\u2016trnc j f (tc.ton s) a\u2016\u208a ^ p\u2080 \u2202\u03bc) ^ (p\u2080\u207b\u00b9 * q\u2080)\n        := by\n      apply setLIntegral_congr_fun measurableSet_Ioi\n      filter_upwards with s _\n      rw [lintegral_const_mul', ENNReal.mul_rpow_of_nonneg]\n      \u00b7 positivity\n      \u00b7 exact (ENNReal.rpow_lt_top_of_nonneg (by positivity) coe_ne_top).ne\n    _ \u2264 (\u222b\u207b a : \u03b1 in Function.support f,\n        (\u222b\u207b (s : \u211d) in Ioi 0,\n        (ENNReal.ofReal (s ^ (q - q\u2080 - 1)) ^ (p\u2080\u207b\u00b9 * q\u2080)\u207b\u00b9 *\n        \u2191\u2016trnc j f (tc.ton s) a\u2016\u208a  ^ p\u2080) ^ (p\u2080\u207b\u00b9 * q\u2080)) ^ (p\u2080\u207b\u00b9 * q\u2080)\u207b\u00b9 \u2202\u03bc) ^ (p\u2080\u207b\u00b9 * q\u2080) := by\n      -- This is a consequence of Minkowski's integral inequality\n      apply lintegral_lintegral_pow_swap_trunc_compl hp\u2080 hp\u2080q\u2080 hf tc; assumption\n    _ = (\u222b\u207b a : \u03b1 in Function.support f,\n        (\u222b\u207b (s : \u211d) in Ioi 0,\n        (ENNReal.ofReal (s ^ (q - q\u2080 - 1)) *\n        \u2191\u2016trnc j f (tc.ton s) a\u2016\u208a ^ q\u2080)) ^ (p\u2080\u207b\u00b9 * q\u2080)\u207b\u00b9 \u2202\u03bc) ^ (p\u2080\u207b\u00b9 * q\u2080) := by\n      congr 1\n      apply lintegral_congr_support hf\n      intro x _\n      congr 1\n      apply setLIntegral_congr_fun measurableSet_Ioi\n      filter_upwards with s _\n      rw [ENNReal.mul_rpow_of_nonneg, ENNReal.rpow_inv_rpow, \u2190 ENNReal.rpow_mul] <;> try positivity\n      congr\n      field_simp\n    _ = (\u222b\u207b a : \u03b1 in Function.support f,\n        ((\u222b\u207b (s : \u211d) in res (xor j tc.mon) (tc.inv \u2016f a\u2016),\n        (ENNReal.ofReal (s ^ (q - q\u2080 - 1))))*\n        \u2191\u2016f a\u2016\u208a ^ q\u2080) ^ (p\u2080\u207b\u00b9 * q\u2080)\u207b\u00b9 \u2202\u03bc) ^ (p\u2080\u207b\u00b9 * q\u2080) := by\n      congr 1\n      apply lintegral_congr_support hf\n      intro x hfx\n      congr 1\n      apply lintegral_trunc_mul hq\u2080 (nnnorm_pos.mpr hfx)\n    _ = (\u222b\u207b a : \u03b1 in Function.support f,\n        ((ENNReal.ofReal (tc.inv \u2016f a\u2016 ^ (q - q\u2080 - 1 + 1) / |q - q\u2080 - 1 + 1|)) *\n        ENNReal.ofReal (\u2016f a\u2016 ^ q\u2080)) ^ (p\u2080\u207b\u00b9 * q\u2080)\u207b\u00b9 \u2202\u03bc) ^ (p\u2080\u207b\u00b9 * q\u2080) := by\n      congr 1\n      apply lintegral_congr_support hf\n      intro x hfx\n      congr 2\n      \u00b7 apply value_lintegral_res\u2080\n        \u00b7 apply tc.ran_inv\n          exact norm_pos_iff.mpr hfx\n        \u00b7 split_ifs with h\n          \u00b7 simp only [h, \u2193reduceIte] at hpowers; linarith\n          \u00b7 simp only [h, Bool.false_eq_true, \u2193reduceIte] at hpowers; linarith\n      \u00b7 rw [\u2190 ofReal_rpow_of_nonneg] <;> try positivity\n        congr\n        exact norm_toNNReal.symm\n    _ = (\u222b\u207b a : \u03b1 in Function.support f,\n        ((ENNReal.ofReal\n        (spf.d ^ (q - q\u2080 - 1 + 1) * \u2016f a\u2016 ^ (spf.\u03c3\u207b\u00b9 * (q - q\u2080 - 1 + 1) + q\u2080) /\n      |q - q\u2080 - 1 + 1|))) ^ (p\u2080\u207b\u00b9 * q\u2080)\u207b\u00b9 \u2202\u03bc) ^ (p\u2080\u207b\u00b9 * q\u2080) := by\n      congr 1\n      apply lintegral_congr_support hf\n      intro x hfx\n      congr 1\n      apply value_lintegral_res\u2081\n      exact norm_pos_iff.mpr hfx\n    _ = (\u222b\u207b a : \u03b1 in Function.support f,\n        ((ENNReal.ofReal (spf.d ^ (q - q\u2080)) ^ (p\u2080\u207b\u00b9 * q\u2080)\u207b\u00b9 *\n        ENNReal.ofReal (\u2016f a\u2016 ^ ((spf.\u03c3\u207b\u00b9 * (q - q\u2080) + q\u2080) * (p\u2080\u207b\u00b9 * q\u2080)\u207b\u00b9)) *\n    ENNReal.ofReal |q - q\u2080|\u207b\u00b9 ^ (p\u2080\u207b\u00b9 * q\u2080)\u207b\u00b9))  \u2202\u03bc) ^ (p\u2080\u207b\u00b9 * q\u2080) := by\n      congr 1\n      apply lintegral_congr_support hf\n      intro x _\n      rw [div_eq_mul_inv, ENNReal.ofReal_mul, sub_add_cancel, ENNReal.ofReal_mul,\n          ENNReal.mul_rpow_of_nonneg, ENNReal.mul_rpow_of_nonneg] <;> try positivity\n      nth_rw 2 [ENNReal.ofReal_rpow_of_nonneg] <;> try positivity\n      rw [\u2190 Real.rpow_mul] ; try positivity\n    _ = ENNReal.ofReal (spf.d ^ (q - q\u2080)) *\n        (\u222b\u207b (a : \u03b1) in Function.support f,\n        ENNReal.ofReal (\u2016f a\u2016 ^ ((spf.\u03c3\u207b\u00b9 * (q - q\u2080) + q\u2080) * (p\u2080\u207b\u00b9 * q\u2080)\u207b\u00b9)) \u2202\u03bc) ^\n        (p\u2080\u207b\u00b9 * q\u2080) *\n        ENNReal.ofReal |q - q\u2080|\u207b\u00b9 := by\n      rw [lintegral_mul_const', lintegral_const_mul', ENNReal.mul_rpow_of_nonneg,\n          ENNReal.mul_rpow_of_nonneg, ENNReal.rpow_inv_rpow, ENNReal.rpow_inv_rpow] <;>\n          try positivity\n      \u00b7 exact rpow_ne_top_of_nonneg (by positivity) coe_ne_top\n      \u00b7 exact rpow_ne_top_of_nonneg (by positivity) coe_ne_top\n    _ = ENNReal.ofReal (spf.d ^ (q - q\u2080)) *\n        (\u222b\u207b (a : \u03b1) in Function.support f,\n        ENNReal.ofReal (\u2016f a\u2016 ^ (p\u2080 + spf.\u03c3\u207b\u00b9 * (q - q\u2080) * (p\u2080 / q\u2080))) \u2202\u03bc) ^\n        (p\u2080\u207b\u00b9 * q\u2080) *\n        ENNReal.ofReal |q - q\u2080|\u207b\u00b9 := by\n      congr\n      ext x\n      congr\n      ring_nf\n      rw [inv_inv]\n      field_simp\n    _ = _ := by ring\n\ndef sel (j : Bool) (p\u2080 p\u2081 : \u211d\u22650\u221e) := match j with | true => p\u2081 | false => p\u2080\n\n/-- One of the key estimates for the real interpolation theorem, now using\n    the particular choice of exponent, but not yet using the\n    particular choice of scale in the `ScaledPowerFunction`. -/\nlemma estimate_trnc\u2081 {spf : ScaledPowerFunction} {j : Bool}\n    [MeasurableSpace E\u2081] [NormedAddCommGroup E\u2081] [BorelSpace E\u2081] (ht : t \u2208 Ioo 0 1)\n    (hp\u2080 : p\u2080 > 0) (hq\u2080 : q\u2080 > 0) (hp\u2081 : p\u2081 > 0) (hq\u2081 : q\u2081 > 0) (hpq : sel j p\u2080 p\u2081 \u2264 sel j q\u2080 q\u2081)\n    (hp' : sel j p\u2080 p\u2081 \u2260 \u22a4) (hq' : sel j q\u2080 q\u2081 \u2260 \u22a4)  (hp\u2080p\u2081 : p\u2080 < p\u2081)\n    (hq\u2080q\u2081 : q\u2080 \u2260 q\u2081) (hp : p\u207b\u00b9 = (1 - ENNReal.ofReal t) * p\u2080\u207b\u00b9 + ENNReal.ofReal t * p\u2081\u207b\u00b9)\n    (hq : q\u207b\u00b9 = (1 - ENNReal.ofReal t) * q\u2080\u207b\u00b9 + ENNReal.ofReal t * q\u2081\u207b\u00b9)\n    (hf : AEMeasurable f \u03bc) (hf\u2082 : SigmaFinite (\u03bc.restrict (Function.support f)))\n    (hspf : spf.\u03c3 = @\u03b6 p\u2080 q\u2080 p\u2081 q\u2081 t) :\n    \u222b\u207b s : \u211d in Ioi 0,\n    eLpNorm (trnc j f ((spf_to_tc spf).ton s)) (sel j p\u2080 p\u2081) \u03bc ^ (sel j q\u2080 q\u2081).toReal *\n    ENNReal.ofReal (s ^ (q.toReal - (sel j q\u2080 q\u2081).toReal - 1)) \u2264\n    ENNReal.ofReal (spf.d ^ (q.toReal - (sel j q\u2080 q\u2081).toReal)) *\n    ENNReal.ofReal |q.toReal - (sel j q\u2080 q\u2081).toReal|\u207b\u00b9 *\n    ((eLpNorm f p \u03bc) ^ p.toReal) ^ ((sel j p\u2080 p\u2081).toReal \u207b\u00b9 * (sel j q\u2080 q\u2081).toReal) := by\n  have p_toReal_pos : p.toReal > 0 :=\n    interp_exp_toReal_pos' ht hp\u2080 hp\u2081 hp (Or.inl hp\u2080p\u2081.ne_top)\n  calc\n  _ \u2264 ENNReal.ofReal (spf.d ^ (q.toReal - (sel j q\u2080 q\u2081).toReal)) *\n      ENNReal.ofReal |q.toReal - (sel j q\u2080 q\u2081).toReal|\u207b\u00b9 *\n      (\u222b\u207b (a : \u03b1) in Function.support f,\n      ENNReal.ofReal (\u2016f a\u2016 ^ ((sel j p\u2080 p\u2081).toReal + spf.\u03c3\u207b\u00b9 * (q.toReal - (sel j q\u2080 q\u2081).toReal) *\n      ((sel j p\u2080 p\u2081).toReal / (sel j q\u2080 q\u2081).toReal))) \u2202\u03bc) ^\n      ((sel j p\u2080 p\u2081).toReal \u207b\u00b9 * (sel j q\u2080 q\u2081).toReal) := by\n    have coe_p' : ENNReal.ofReal (sel j p\u2080 p\u2081).toReal = (sel j p\u2080 p\u2081) := ofReal_toReal_eq_iff.mpr hp'\n    nth_rw 1 [\u2190 coe_p']\n    apply estimate_trnc\n    \u00b7 apply toReal_pos\n      \u00b7 cases j\n        \u00b7 exact hp\u2080.ne'\n        \u00b7 exact hp\u2081.ne'\n      \u00b7 exact hp'\n    \u00b7 apply toReal_pos\n      \u00b7 cases j\n        \u00b7 exact hq\u2080.ne'\n        \u00b7 exact hq\u2081.ne'\n      \u00b7 exact hq'\n    \u00b7 exact toReal_mono hq' hpq\n    \u00b7 exact hf\n    \u00b7 exact hf\u2082\n    \u00b7 unfold spf_to_tc\n      cases j\n      \u00b7 unfold sel\n        dsimp only\n        rw [hspf]\n        simp only [Bool.if_false_right, Bool.and_true, Bool.false_bne, decide_eq_true_eq]\n        split_ifs with is_\u03b6_pos\n        \u00b7 apply toReal_strict_mono\n          \u00b7 exact interp_exp_ne_top hq\u2080q\u2081 ht hq\n          \u00b7 exact (\u03b6_pos_iff_of_lt\u2080 ht hp\u2080 hq\u2080 hp\u2081 hq\u2081 hq\u2080q\u2081 hp hq hp\u2080p\u2081).mp is_\u03b6_pos\n        \u00b7 apply toReal_strict_mono hq'\n          exact (\u03b6_le_zero_iff_of_lt\u2080 ht hp\u2080 hq\u2080 hp\u2081 hq\u2081 hq\u2080q\u2081 hp hq hp\u2080p\u2081).mp\n            (le_of_not_lt is_\u03b6_pos)\n      \u00b7 unfold sel\n        dsimp only\n        rw [hspf]\n        simp only [Bool.if_false_right, Bool.and_true, Bool.true_bne, Bool.not_eq_true',\n            decide_eq_false_iff_not]\n        split_ifs with is_\u03b6_pos\n        \u00b7 apply toReal_strict_mono hq'\n          exact (\u03b6_pos_iff_of_lt\u2081 ht hp\u2080 hq\u2080 hp\u2081 hq\u2081 hq\u2080q\u2081 hp hq hp\u2080p\u2081).mp is_\u03b6_pos\n        \u00b7 apply toReal_strict_mono\n          \u00b7 exact interp_exp_ne_top hq\u2080q\u2081 ht hq\n          \u00b7 exact (\u03b6_le_zero_iff_of_lt\u2081 ht hp\u2080 hq\u2080 hp\u2081 hq\u2081 hq\u2080q\u2081 hp hq hp\u2080p\u2081).mp\n                (le_of_not_lt is_\u03b6_pos)\n  _ = ENNReal.ofReal (spf.d ^ (q.toReal - (sel j q\u2080 q\u2081).toReal)) *\n        ENNReal.ofReal |q.toReal - (sel j q\u2080 q\u2081).toReal|\u207b\u00b9 *\n        (\u222b\u207b (a : \u03b1) in Function.support f,\n        ENNReal.ofReal (\u2016f a\u2016 ^ p.toReal) \u2202\u03bc) ^\n        ((sel j p\u2080 p\u2081).toReal \u207b\u00b9 * (sel j q\u2080 q\u2081).toReal) := by\n    congr\n    ext x\n    congr\n    rcases j\n    \u00b7 dsimp only [sel]\n      rw [hspf]\n      apply \u03b6_equality\u2085 (hp\u2080p\u2081 := hp\u2080p\u2081.ne) <;> assumption\n    \u00b7 dsimp only [sel]\n      rw [hspf]\n      apply \u03b6_equality\u2086 (hp\u2080p\u2081 := hp\u2080p\u2081.ne) <;> assumption\n  _ \u2264 ENNReal.ofReal (spf.d ^ (q.toReal - (sel j q\u2080 q\u2081).toReal)) *\n      ENNReal.ofReal |q.toReal - (sel j q\u2080 q\u2081).toReal|\u207b\u00b9 *\n      (\u222b\u207b (a : \u03b1),\n      ENNReal.ofReal (\u2016f a\u2016 ^ p.toReal) \u2202\u03bc) ^\n      ((sel j p\u2080 p\u2081).toReal \u207b\u00b9 * (sel j q\u2080 q\u2081).toReal) := by\n    gcongr\n    exact setLIntegral_le_lintegral _ _\n  _ = ENNReal.ofReal (spf.d ^ (q.toReal - (sel j q\u2080 q\u2081).toReal)) *\n      ENNReal.ofReal |q.toReal - (sel j q\u2080 q\u2081).toReal|\u207b\u00b9 *\n      (((\u222b\u207b (a : \u03b1), \u2016f a\u2016\u208a ^ p.toReal \u2202\u03bc) ^ p.toReal\u207b\u00b9 ) ^ p.toReal) ^\n      ((sel j p\u2080 p\u2081).toReal \u207b\u00b9 * (sel j q\u2080 q\u2081).toReal) := by\n    congr\n    rw [ENNReal.rpow_inv_rpow] <;> try positivity\n    congr\n    ext x\n    rw [\u2190 ofReal_rpow_of_nonneg] <;> try positivity\n    congr\n    exact ofReal_norm_eq_coe_nnnorm (f x)\n  _ = ENNReal.ofReal (spf.d ^ (q.toReal - (sel j q\u2080 q\u2081).toReal)) *\n      ENNReal.ofReal |q.toReal - (sel j q\u2080 q\u2081).toReal|\u207b\u00b9 *\n      ((eLpNorm f p \u03bc) ^ p.toReal) ^\n      ((sel j p\u2080 p\u2081).toReal \u207b\u00b9 * (sel j q\u2080 q\u2081).toReal) := by\n    congr\n    rw [\u2190 one_div]\n    refine (eLpNorm_eq_lintegral_rpow_nnnorm ?_ ?_).symm\n    \u00b7 exact (interpolated_pos' hp\u2080 hp\u2081 hp).ne'\n    \u00b7 exact interp_exp_ne_top hp\u2080p\u2081.ne ht hp\n\n-- TODO: move this to Weaktype.lean?\nlemma wnorm_eq_zero_iff {f : \u03b1 \u2192 E\u2081} {p : \u211d\u22650\u221e} [NormedAddCommGroup E\u2081] (hp : p \u2260 0) :\n    wnorm f p \u03bc = 0 \u2194 f =\u1d50[\u03bc] 0 := by\n  unfold wnorm\n  split_ifs with h\u2080\n  \u00b7 exact eLpNormEssSup_eq_zero_iff\n  \u00b7 refine Iff.trans \u27e8?_, ?_\u27e9 eLpNormEssSup_eq_zero_iff <;> intro h\n    \u00b7 have iSup_wnorm := iSup_eq_zero.mp h\n      by_contra h\u2081\n      have : eLpNormEssSup f \u03bc > 0 := pos_iff_ne_zero.mpr h\u2081\n      unfold eLpNormEssSup at this\n      rw [essSup_eq_sInf] at this\n      let b := (min (sInf {a : \u211d\u22650\u221e | \u03bc {x | a < \u2191\u2016f x\u2016\u208a} = 0}) 1) / 2\n      have b_lt_inf : b < min (sInf {a : \u211d\u22650\u221e | \u03bc {x | a < \u2191\u2016f x\u2016\u208a} = 0}) 1 :=\n        ENNReal.half_lt_self (lt_min this zero_lt_one).ne'\n          (lt_of_le_of_lt (min_le_right _ 1) one_lt_top).ne\n      have meas_ne_zero : \u03bc {x | b < \u2191\u2016f x\u2016\u208a} \u2260 0 := by\n        intro h\n        have obs : sInf {a | \u03bc {x | a < \u2191\u2016f x\u2016\u208a} = 0} \u2264 b := csInf_le' h\n        contrapose! obs\n        calc\n        _ < _ := b_lt_inf\n        _ \u2264 _ := min_le_left ..\n      have b_ne_0 : b \u2260 0 := (ENNReal.half_pos (lt_min this zero_lt_one).ne').ne'\n      have p_toReal_inv_pos : p.toReal\u207b\u00b9 > 0 := inv_pos_of_pos (toReal_pos hp h\u2080)\n      have coe_b : ENNReal.ofNNReal b.toNNReal = b := coe_toNNReal b_lt_inf.ne_top\n      have : distribution f b \u03bc = 0 := by\n        refine (rpow_eq_zero_iff_of_pos p_toReal_inv_pos).mp ?_\n        refine eq_zero_of_ne_zero_of_mul_left_eq_zero b_ne_0 ?_\n        rw [\u2190 coe_b]\n        exact iSup_wnorm b.toNNReal\n      exact meas_ne_zero this\n    \u00b7 refine iSup_eq_zero.mpr fun t \u21a6 mul_eq_zero.mpr\n        (Or.inr ((rpow_eq_zero_iff_of_pos (inv_pos_of_pos (toReal_pos hp h\u2080))).mpr (nonpos_iff_eq_zero.mp ?_)))\n      calc\n        _ \u2264 distribution f 0 \u03bc := by gcongr; exact zero_le _\n        _ = distribution f (eLpNormEssSup f \u03bc) \u03bc := by congr; exact h.symm\n        _ = 0 := distribution_snormEssSup\n\n\n/-! ## Weaktype estimates applied to truncations -/\n\nlemma eLpNorm_trnc_est {f : \u03b1 \u2192 E\u2081} {j : Bool} {a : \u211d} [NormedAddCommGroup E\u2081] :\n    eLpNorm (trnc j f a) p \u03bc \u2264 eLpNorm f p \u03bc := eLpNorm_mono fun _x \u21a6 trnc_le_func\n\n-- TODO: remove the subindex 0 here\nlemma weaktype_estimate {C\u2080 : \u211d\u22650} {p : \u211d\u22650\u221e} {q : \u211d\u22650\u221e} {f : \u03b1 \u2192 E\u2081}\n     [NormedAddCommGroup E\u2081] [NormedAddCommGroup E\u2082] (hq : 0 < q) (hq' : q < \u22a4) (hf : Mem\u2112p f p \u03bc)\n    (h\u2080T : HasWeakType T p q \u03bc \u03bd C\u2080) {t : \u211d} (ht : t > 0) :\n    distribution (T f) (ENNReal.ofReal t) \u03bd \u2264 C\u2080 ^ q.toReal *\n        eLpNorm f p \u03bc ^ q.toReal * ENNReal.ofReal (t ^ (-q.toReal)) := by\n  have wt_est := (h\u2080T f hf).2 -- the weaktype estimate\n  have q_pos : q.toReal > 0 := toReal_pos hq.ne' hq'.ne_top\n  have tq_pos : ENNReal.ofReal t ^ q.toReal > 0 := coe_pow_pos ht\n  have tq_ne_top : (ENNReal.ofReal t) ^ q.toReal \u2260 \u22a4 := coe_rpow_ne_top' q_pos\n  -- have hq\u2081 : q.toReal = q := by exact toReal_ofReal q_nonneg\n  simp only [wnorm, wnorm', hq'.ne_top, \u2193reduceIte, iSup_le_iff] at wt_est\n  have wt_est_t := wt_est t.toNNReal -- this is the weaktype estimate applied to t\n  rw [\u2190 ENNReal.mul_le_mul_right (c := (ENNReal.ofReal t) ^ q.toReal) _ tq_ne_top,\n      ofReal_rpow_of_pos, mul_assoc _ _ (ENNReal.ofReal (t ^ q.toReal)), \u2190 ofReal_mul',\n      \u2190 Real.rpow_add, neg_add_cancel, Real.rpow_zero, ofReal_one, mul_one, mul_comm,\n      \u2190 ENNReal.mul_rpow_of_nonneg] <;> try positivity\n  refine (ENNReal.rpow_inv_le_iff q_pos).mp ?_\n  rw [ENNReal.mul_rpow_of_nonneg, ENNReal.ofReal_rpow_of_pos,\n      Real.rpow_rpow_inv] <;> try positivity\n  rwa [\u2190 coe_coe_eq_ofReal]\n\nlemma weaktype_estimate_top {C : \u211d\u22650} {p : \u211d\u22650\u221e} {q : \u211d\u22650\u221e}\n    [NormedAddCommGroup E\u2081] [NormedAddCommGroup E\u2082]\n    (hq' : q = \u22a4) {f : \u03b1 \u2192 E\u2081} (hf : Mem\u2112p f p \u03bc)\n    (hT : HasWeakType T p q \u03bc \u03bd C) {t : \u211d} (ht : C * eLpNorm f p \u03bc \u2264 ENNReal.ofReal t) :\n    distribution (T f) (ENNReal.ofReal t) \u03bd = 0 := by\n  have wt_est := (hT f hf).2\n  unfold wnorm at wt_est\n  split_ifs at wt_est\n  apply nonpos_iff_eq_zero.mp\n  calc\n  _ \u2264 distribution (T f) (eLpNormEssSup (T f) \u03bd) \u03bd := distribution_mono_right (le_trans wt_est ht)\n  _ = _ := meas_eLpNormEssSup_lt\n\n/-- If `T` has weaktype `p\u2080`-`p\u2081`, `f` is `AEStronglyMeasurable` and the `p`-norm of `f`\n    vanishes, then the `q`-norm of `T f` vanishes.\n    -/\nlemma weaktype_aux\u2080 {p\u2080 q\u2080 p q : \u211d\u22650\u221e} [NormedAddCommGroup E\u2081] [NormedAddCommGroup E\u2082]\n    (hp\u2080 : p\u2080 > 0) (hq\u2080 : q\u2080 > 0) (hp : p > 0) (hq : q > 0)\n    {C\u2080 : \u211d\u22650}\n    (h\u2080T : HasWeakType T p\u2080 q\u2080 \u03bc \u03bd C\u2080) (hf : AEStronglyMeasurable f \u03bc)\n    (hF : eLpNorm f p \u03bc = 0) :\n    eLpNorm (T f) q \u03bd = 0 := by\n  have f_ae_0 : f =\u1d50[\u03bc] 0 := (eLpNorm_eq_zero_iff hf hp.ne').mp hF\n  have hf\u2082 : eLpNorm f p\u2080 \u03bc = 0 := (eLpNorm_eq_zero_iff hf hp\u2080.ne').mpr f_ae_0\n  have hf\u2081 : Mem\u2112p f p\u2080 \u03bc := \u27e8hf, by rw [hf\u2082]; exact zero_lt_top\u27e9\n  have := (h\u2080T f hf\u2081).2\n  rw [hf\u2082, mul_zero] at this\n  have wnorm_0 : wnorm (T f) q\u2080 \u03bd = 0 := nonpos_iff_eq_zero.mp this\n  have : (T f) =\u1d50[\u03bd] 0 := (wnorm_eq_zero_iff hq\u2080.ne').mp wnorm_0\n  exact (eLpNorm_eq_zero_iff (h\u2080T _ hf\u2081).1 hq.ne').mpr this\n\nlemma weaktype_estimate_trunc_compl {C\u2080 : \u211d\u22650} {p p\u2080: \u211d\u22650\u221e} {f : \u03b1 \u2192 E\u2081}\n    [MeasurableSpace E\u2081] [NormedAddCommGroup E\u2081] [BorelSpace E\u2081] [NormedAddCommGroup E\u2082]\n    (hp\u2080 : 0 < p\u2080) {q\u2080 : \u211d\u22650\u221e} (hp : p \u2260 \u22a4) (hq\u2080 : 0 < q\u2080) (hq\u2080' : q\u2080 < \u22a4)\n    (hp\u2080p : p\u2080 < p) (hf : Mem\u2112p f p \u03bc)\n    (h\u2080T : HasWeakType T p\u2080 q\u2080 \u03bc \u03bd C\u2080) {t : \u211d} (ht : t > 0) {a : \u211d} (ha : a > 0) :\n    distribution (T (f - trunc f a)) (ENNReal.ofReal t) \u03bd \u2264 C\u2080 ^ q\u2080.toReal *\n        eLpNorm (f - trunc f a) p\u2080 \u03bc ^ q\u2080.toReal * (ENNReal.ofReal (t ^ (-q\u2080.toReal))) := by\n  apply weaktype_estimate hq\u2080 hq\u2080' ?_ h\u2080T ht\n  exact trunc_compl_Lp_Lq_lower hp \u27e8hp\u2080, hp\u2080p\u27e9 ha hf\n\nlemma weaktype_estimate_trunc {C\u2081 : \u211d\u22650} {p p\u2081 q\u2081: \u211d\u22650\u221e} {f : \u03b1 \u2192 E\u2081}\n    [MeasurableSpace E\u2081] [NormedAddCommGroup E\u2081] [BorelSpace E\u2081] [NormedAddCommGroup E\u2082]\n    (hp : 0 < p)\n    (hq\u2081 : 0 < q\u2081) (hq\u2081' : q\u2081 < \u22a4) (hp\u2081p : p < p\u2081)\n    (hf : Mem\u2112p f p \u03bc)\n    (h\u2081T : HasWeakType T p\u2081 q\u2081 \u03bc \u03bd C\u2081) {t : \u211d} (ht : t > 0) {a : \u211d} :\n    distribution (T (trunc f a)) (ENNReal.ofReal t) \u03bd \u2264 C\u2081 ^ q\u2081.toReal *\n      eLpNorm (trunc f a) p\u2081 \u03bc ^ q\u2081.toReal * ENNReal.ofReal (t ^ (-q\u2081.toReal)) :=\n  weaktype_estimate hq\u2081 hq\u2081' (trunc_Lp_Lq_higher (p := p) \u27e8hp, hp\u2081p\u27e9 hf) h\u2081T ht\n\nlemma weaktype_estimate_trunc_top_top {a : \u211d} {C\u2081 : \u211d\u22650}\n    [MeasurableSpace E\u2081] [NormedAddCommGroup E\u2081] [BorelSpace E\u2081] [NormedAddCommGroup E\u2082]\n    (hC\u2081 : C\u2081 > 0) {p p\u2081 q\u2081 : \u211d\u22650\u221e} (hp : 0 < p)\n    (hp\u2081 : p\u2081 = \u22a4) (hq\u2081 : q\u2081 = \u22a4) (hp\u2081p : p < p\u2081) {f : \u03b1 \u2192 E\u2081} (hf : Mem\u2112p f p \u03bc)\n    (h\u2081T : HasWeakType T p\u2081 q\u2081 \u03bc \u03bd C\u2081) {t : \u211d} (ht : t > 0) (ha : a = t / C\u2081) :\n    distribution (T (trunc f a)) (ENNReal.ofReal t) \u03bd = 0 := by\n  rw [ha]\n  have obs : Mem\u2112p (trunc f (t / C\u2081)) p\u2081 \u03bc := trunc_Lp_Lq_higher \u27e8hp, hp\u2081p\u27e9 hf\n  have wt_est := (h\u2081T (trunc f (t / C\u2081)) obs).2\n  simp only [wnorm, eLpNorm, hq\u2081, \u2193reduceIte, hp\u2081, top_ne_zero] at wt_est\n  apply nonpos_iff_eq_zero.mp\n  have ineq : eLpNormEssSup (T (trunc f (t / C\u2081))) \u03bd \u2264 ENNReal.ofReal t := calc\n    _ \u2264 C\u2081 * eLpNormEssSup (trunc f (t / C\u2081)) \u03bc := wt_est\n    _ \u2264 C\u2081 * ENNReal.ofReal (max 0 (t / C\u2081)) := by\n      gcongr\n      exact trunc_eLpNormEssSup_le\n    _ \u2264 _ := by\n      let C := C\u2081.toReal\n      have coe_C : C.toNNReal = C\u2081 := Real.toNNReal_coe\n      rw [\u2190 coe_C, coe_coe_eq_ofReal, \u2190 ENNReal.ofReal_mul, max_eq_right, congrArg toReal coe_C,\n        mul_div_cancel\u2080]\n      \u00b7 exact Ne.symm (ne_of_lt hC\u2081)\n      \u00b7 positivity\n      \u00b7 positivity\n  calc\n  _ \u2264 distribution (T (trunc f (t / C\u2081))) (eLpNormEssSup (T (trunc f (t / C\u2081))) \u03bd) \u03bd :=\n      distribution_mono_right ineq\n  _ = 0 := distribution_snormEssSup\n\nlemma weaktype_estimate_trunc_compl_top {C\u2080 : \u211d\u22650} (hC\u2080 : C\u2080 > 0) {p p\u2080 q\u2080 : \u211d\u22650\u221e}\n    [MeasurableSpace E\u2081] [NormedAddCommGroup E\u2081] [BorelSpace E\u2081] [NormedAddCommGroup E\u2082]\n    (hp\u2080 : 0 < p\u2080) (hq\u2080 : q\u2080 = \u22a4) (hp\u2080p : p\u2080 < p) (hp : p \u2260 \u22a4) {f : \u03b1 \u2192 E\u2081} (hf : Mem\u2112p f p \u03bc)\n    (h\u2080T : HasWeakType T p\u2080 q\u2080 \u03bc \u03bd C\u2080) {t : \u211d} (ht : t > 0) {a : \u211d} {d : \u211d} -- (hd : d > 0)\n    (ha : a = (t / d) ^ (p\u2080.toReal / (p\u2080.toReal - p.toReal)))\n    (hdeq : d = ((ENNReal.ofNNReal C\u2080) ^ p\u2080.toReal *\n        eLpNorm f p \u03bc ^ p.toReal).toReal ^ p\u2080.toReal\u207b\u00b9) :\n    distribution (T (f - trunc f a)) (ENNReal.ofReal t) \u03bd = 0 := by\n  rcases (eq_zero_or_pos (eLpNormEssSup f \u03bc)) with snorm_zero | snorm_pos\n  \u00b7 have : eLpNorm (trnc \u22a5 f a) \u22a4 \u03bc = 0 := by\n      apply nonpos_iff_eq_zero.mp\n      rw [\u2190 snorm_zero]\n      exact eLpNorm_trnc_est (p := \u22a4)\n    have obs : eLpNorm (T (trnc \u22a5 f a)) \u22a4 \u03bd = 0 :=\n      weaktype_aux\u2080 hp\u2080 (hq\u2080 \u25b8 zero_lt_top) zero_lt_top zero_lt_top h\u2080T\n        (aestronglyMeasurable_trunc_compl hf.1) this\n    exact nonpos_iff_eq_zero.mp (Trans.trans (distribution_mono_right (Trans.trans obs\n      (zero_le (ENNReal.ofReal t)))) meas_eLpNormEssSup_lt)\n  \u00b7 have p_pos : p > 0 := lt_trans hp\u2080 hp\u2080p\n    have snorm_p_pos : eLpNorm f p \u03bc \u2260 0 := fun snorm_0 \u21a6 snorm_pos.ne' <|\n      eLpNormEssSup_eq_zero_iff.mpr <| (eLpNorm_eq_zero_iff hf.1 p_pos.ne').mp snorm_0\n    have term_pos : (ENNReal.ofNNReal C\u2080) ^ p\u2080.toReal * eLpNorm f p \u03bc ^ p.toReal > 0 := by\n      apply ENNReal.mul_pos <;> exact (rpow_pos_of_nonneg (by positivity) (by positivity)).ne'\n    have term_ne_top : (ENNReal.ofNNReal C\u2080) ^ p\u2080.toReal * eLpNorm f p \u03bc ^ p.toReal \u2260 \u22a4\n        := mul_ne_top (rpow_ne_top' (ENNReal.coe_ne_zero.mpr hC\u2080.ne') coe_ne_top)\n          (rpow_ne_top' snorm_p_pos (Mem\u2112p.eLpNorm_ne_top hf))\n    have d_pos : d > 0 := hdeq \u25b8 Real.rpow_pos_of_pos (zero_toReal \u25b8\n      toReal_strict_mono term_ne_top term_pos) _\n    have a_pos : a > 0 := by rw [ha]; positivity\n    have obs : Mem\u2112p (f - trunc f a) p\u2080 \u03bc := trunc_compl_Lp_Lq_lower hp \u27e8hp\u2080, hp\u2080p\u27e9 a_pos hf\n    have wt_est := (h\u2080T (f - trunc f a) obs).2\n    unfold wnorm at wt_est\n    split_ifs at wt_est\n    have snorm_est : eLpNormEssSup (T (f - trunc f a)) \u03bd \u2264 ENNReal.ofReal t := by\n      apply le_of_rpow_le (exp_toReal_pos hp\u2080 hp\u2080p.ne_top)\n      calc\n      _ \u2264 (\u2191C\u2080 * eLpNorm (f - trunc f a) p\u2080 \u03bc) ^ p\u2080.toReal := by gcongr\n      _ \u2264 (\u2191C\u2080) ^ p\u2080.toReal * (ENNReal.ofReal (a ^ (p\u2080.toReal - p.toReal)) *\n          eLpNorm f p \u03bc ^ p.toReal) := by\n        rw [ENNReal.mul_rpow_of_nonneg _ _ toReal_nonneg]\n        gcongr\n        exact estimate_eLpNorm_trunc_compl hp \u27e8hp\u2080, hp\u2080p\u27e9 hf.1.aemeasurable a_pos\n      _ = (\u2191C\u2080) ^ p\u2080.toReal * eLpNorm f p \u03bc ^ p.toReal *\n          (ENNReal.ofReal (d ^ p\u2080.toReal))\u207b\u00b9 * ENNReal.ofReal (t ^ p\u2080.toReal) := by\n        rw [ha, \u2190 Real.rpow_mul, div_mul_cancel\u2080]\n        \u00b7 rw [Real.div_rpow] <;> try positivity\n          rw [ENNReal.ofReal_div_of_pos] <;> try positivity\n          rw [div_eq_mul_inv]\n          ring\n        \u00b7 exact (sub_neg.mpr (toReal_strict_mono hp hp\u2080p)).ne\n        \u00b7 positivity\n      _ = _ := by\n        rw [ofReal_rpow_of_pos ht]\n        nth_rw 3 [\u2190 one_mul (ENNReal.ofReal _)]\n        rw [hdeq]\n        rw [Real.rpow_inv_rpow] <;> try positivity\n        rw [ofReal_toReal term_ne_top, ENNReal.mul_inv_cancel (by positivity) term_ne_top]\n        exact toReal_ne_zero.mpr \u27e8hp\u2080.ne', hp\u2080p.ne_top\u27e9\n    apply nonpos_iff_eq_zero.mp\n    calc\n    _ \u2264 distribution (T (f - trunc f a)) (eLpNormEssSup (T (f - trunc f a)) \u03bd) \u03bd :=\n      distribution_mono_right snorm_est\n    _ = _ := meas_eLpNormEssSup_lt\n\nlemma weaktype_estimate_trunc_top {C\u2081 : \u211d\u22650} (hC\u2081 : C\u2081 > 0) {p p\u2081 q\u2081 : \u211d\u22650\u221e} [MeasurableSpace E\u2081]\n    [NormedAddCommGroup E\u2081]\n    [BorelSpace E\u2081] [NormedAddCommGroup E\u2082] (hp : 0 < p)\n    (hp\u2081 : p\u2081 < \u22a4) (hq\u2081 : q\u2081 = \u22a4) (hp\u2081p : p < p\u2081) {f : \u03b1 \u2192 E\u2081} (hf : Mem\u2112p f p \u03bc)\n    (h\u2081T : HasWeakType T p\u2081 q\u2081 \u03bc \u03bd C\u2081) {t : \u211d} (ht : t > 0) {a : \u211d} {d : \u211d} -- (hd : d > 0)\n    (ha : a = (t / d) ^ (p\u2081.toReal / (p\u2081.toReal - p.toReal)))\n    (hdeq : d = ((ENNReal.ofNNReal C\u2081) ^ p\u2081.toReal *\n        eLpNorm f p \u03bc ^ p.toReal).toReal ^ p\u2081.toReal\u207b\u00b9) :\n    distribution (T (trunc f a)) (ENNReal.ofReal t) \u03bd = 0 := by\n  have obs : Mem\u2112p (trunc f a) p\u2081 \u03bc := trunc_Lp_Lq_higher \u27e8hp, hp\u2081p\u27e9 hf\n  have wt_est := (h\u2081T (trunc f a) obs).2\n  unfold wnorm at wt_est\n  split_ifs at wt_est\n  have : p\u2081.toReal \u2260 0 := exp_toReal_ne_zero' (lt_trans hp hp\u2081p) hp\u2081.ne_top\n  have : eLpNormEssSup (T (trunc f a)) \u03bd ^ p\u2081.toReal \u2264 (\u2191C\u2081 * eLpNorm (trunc f a) p\u2081 \u03bc) ^ p\u2081.toReal\n      := by gcongr\n  have snorm_est : eLpNormEssSup (T (trunc f a)) \u03bd \u2264 ENNReal.ofReal t := by\n    apply le_of_rpow_le (exp_toReal_pos (lt_trans hp hp\u2081p) hp\u2081.ne_top)\n    refine le_trans this ?_\n    rcases (eq_zero_or_pos (eLpNormEssSup f \u03bc)) with snorm_zero | snorm_pos\n    \u00b7 gcongr\n      calc\n      _ \u2264 (ENNReal.ofNNReal C\u2081) * eLpNorm f p\u2081 \u03bc := by\n        gcongr\n        apply eLpNorm_mono (fun x \u21a6 trunc_le_func)\n      _ \u2264 _ := by\n        have : eLpNorm f p\u2081 \u03bc = 0 := Trans.trans (eLpNorm_congr_ae\n            (eLpNormEssSup_eq_zero_iff.mp snorm_zero)) eLpNorm_zero\n        simp only [this, mul_zero, zero_le]\n    \u00b7 have snorm_p_pos : eLpNorm f p \u03bc \u2260 0 := by\n        intro snorm_0\n        apply Ne.symm (ne_of_lt snorm_pos)\n        apply eLpNormEssSup_eq_zero_iff.mpr\n        exact (eLpNorm_eq_zero_iff hf.1 hp.ne').mp snorm_0\n      have term_pos : (ENNReal.ofNNReal C\u2081) ^ p\u2081.toReal * eLpNorm f p \u03bc ^ p.toReal > 0 := by\n        apply ENNReal.mul_pos <;> exact (rpow_pos_of_nonneg (by positivity) (by positivity)).ne'\n      have term_ne_top : (ENNReal.ofNNReal C\u2081) ^ p\u2081.toReal * eLpNorm f p \u03bc ^ p.toReal \u2260 \u22a4 :=\n        mul_ne_top (rpow_ne_top' (ENNReal.coe_ne_zero.mpr hC\u2081.ne') coe_ne_top)\n          (rpow_ne_top' snorm_p_pos (Mem\u2112p.eLpNorm_ne_top hf))\n      have d_pos : d > 0 := hdeq \u25b8 Real.rpow_pos_of_pos (zero_toReal \u25b8\n        toReal_strict_mono term_ne_top term_pos) _\n      calc\n      _ \u2264 \u2191C\u2081 ^ p\u2081.toReal * ((ENNReal.ofReal (a ^ (p\u2081.toReal - p.toReal))) * eLpNorm f p \u03bc ^ p.toReal) := by\n        rw [ENNReal.mul_rpow_of_nonneg]\n        gcongr\n        \u00b7 exact estimate_eLpNorm_trunc hp\u2081.ne_top \u27e8hp, hp\u2081p\u27e9 hf.1.aemeasurable\n        \u00b7 exact toReal_nonneg\n      _ = \u2191C\u2081 ^ p\u2081.toReal * eLpNorm f p \u03bc ^ p.toReal * (ENNReal.ofReal (d ^ p\u2081.toReal))\u207b\u00b9 *\n          ENNReal.ofReal (t ^ p\u2081.toReal) := by\n        rw [ha, \u2190 Real.rpow_mul, div_mul_cancel\u2080]\n        \u00b7 rw [Real.div_rpow] <;> try positivity\n          rw [ENNReal.ofReal_div_of_pos] <;> try positivity\n          rw [div_eq_mul_inv]\n          ring\n        \u00b7 exact (sub_pos.mpr (toReal_strict_mono hp\u2081.ne_top hp\u2081p)).ne'\n        \u00b7 positivity\n      _ = _ := by\n        rw [ofReal_rpow_of_pos ht]\n        nth_rw 3 [\u2190 one_mul (ENNReal.ofReal _)]\n        rw [hdeq]\n        rw [Real.rpow_inv_rpow] <;> try positivity\n        rw [ofReal_toReal term_ne_top, ENNReal.mul_inv_cancel (by positivity) term_ne_top]\n  apply nonpos_iff_eq_zero.mp\n  calc\n  _ \u2264 distribution (T (trunc f a)) (eLpNormEssSup (T (trunc f a)) \u03bd) \u03bd := by gcongr\n  _ = _ := meas_eLpNormEssSup_lt\n\nend MeasureTheory\n\nend\n\nnoncomputable section\n\nopen NNReal ENNReal MeasureTheory Set\n\nvariable {\u03b1 \u03b1' E E\u2081 E\u2082 E\u2083 : Type*} {m : MeasurableSpace \u03b1} {m' : MeasurableSpace \u03b1'}\n  {p p' q p\u2080 q\u2080 p\u2081 q\u2081: \u211d\u22650\u221e}\n  {C\u2080 C\u2081 : \u211d\u22650} {\u03bc : Measure \u03b1} {\u03bd : Measure \u03b1'}\n  {a : \u211d}-- truncation parameter\n  [NormedAddCommGroup E] [NormedAddCommGroup E\u2081] [NormedAddCommGroup E\u2082] [NormedAddCommGroup E\u2083]\n  [MeasurableSpace E] [BorelSpace E]\n  [MeasurableSpace E\u2083] [BorelSpace E\u2083]\n  {f : \u03b1 \u2192 E\u2081} {t : \u211d}\n  {T : (\u03b1 \u2192 E\u2081) \u2192 (\u03b1' \u2192 E\u2082)}\nnamespace MeasureTheory\n\n-- /-- # The real interpolation theorem\n\n-- ## Definitions-/\n\ndef Subadditive (T : (\u03b1 \u2192 E\u2081) \u2192 \u03b1' \u2192 E\u2082) : Prop :=\n  \u2203 A > 0, \u2200 (f g : \u03b1 \u2192 E\u2081) (x : \u03b1'), \u2016T (f + g) x\u2016 \u2264 A * (\u2016T f x\u2016 + \u2016T g x\u2016)\n\n-- TODO: put `A` in \u211d\u22650\u221e?\ndef Subadditive_trunc (T : (\u03b1 \u2192 E\u2081) \u2192 \u03b1' \u2192 E\u2082) (A : \u211d) (f : \u03b1 \u2192 E\u2081) (\u03bd : Measure \u03b1') : Prop :=\n  \u2200 a : \u211d, a > 0 \u2192 \u2200\u1d50 y \u2202\u03bd,\n  \u2016T (trunc f a + trunc_compl f a) y\u2016 \u2264 A * (\u2016T (trunc f a) y\u2016 + \u2016T (trunc_compl f a) y\u2016)\n\n/-- The operator is subadditive on functions satisfying `P` with constant `A`. -/\ndef AESubAdditiveOn (T : (\u03b1 \u2192 E\u2081) \u2192 \u03b1' \u2192 E\u2082) (P : (\u03b1 \u2192 E\u2081) \u2192 Prop) (A : \u211d) (\u03bd : Measure \u03b1') : Prop :=\n  \u2200 (f g : \u03b1 \u2192 E\u2081), P f \u2192 P g \u2192 \u2200\u1d50 x \u2202\u03bd, \u2016T (f + g) x\u2016 \u2264 A * (\u2016T f x\u2016 + \u2016T g x\u2016)\n\nnamespace AESubAdditiveOn\n\nvariable {\u03bd : Measure \u03b1'}\n\nlemma antitone {T : (\u03b1 \u2192 E\u2081) \u2192 \u03b1' \u2192 E\u2082} {P P' : (\u03b1 \u2192 E\u2081) \u2192 Prop}\n    (h : \u2200 {u : \u03b1 \u2192 E\u2081}, P u \u2192 P' u) {A : \u211d} (sa : AESubAdditiveOn T P' A \u03bd) : AESubAdditiveOn T P A \u03bd :=\n  fun f g hf hg \u21a6 sa f g (h hf) (h hg)\n\nlemma neg (P : (\u03b1 \u2192 E\u2081) \u2192 Prop) {A : \u211d} (hA : A < 0) (h : AESubAdditiveOn T P A \u03bd)\n    (f : \u03b1 \u2192 E\u2081) (hf : P f) : T f =\u1d50[\u03bd] 0 := by\n  filter_upwards [h f f hf hf] with x hx using norm_le_zero_iff.mp\n    (by nlinarith [norm_nonneg (T (f + f) x), hx])\n\nlemma zero {P : (\u03b1 \u2192 E\u2081) \u2192 Prop} (hP : \u2200 {f g : \u03b1 \u2192 E\u2081}, P f \u2192 P g \u2192 P (f + g))\n    (A : \u211d) (h : \u2200 u, P u \u2192 T u =\u1d50[\u03bd] 0) : AESubAdditiveOn T P A \u03bd := by\n  intro f g hf hg\n  filter_upwards [h f hf, h g hg, h (f + g) (hP hf hg)] with x hx1 hx2 hx3\n  simp [hx1, hx2, hx3]\n\nlemma biSup {\u03b9 : Type*} (\ud835\udcd1 : Set \u03b9) (h\ud835\udcd1 : \ud835\udcd1.Countable) {T : \u03b9 \u2192 (\u03b1 \u2192 E\u2081) \u2192 \u03b1' \u2192 \u211d\u22650\u221e}\n    {P : (\u03b1 \u2192 E\u2081) \u2192 Prop} (hT : \u2200 (u : \u03b1 \u2192 E\u2081), P u \u2192 \u2200\u1d50 x \u2202\u03bd, \u2a06 i \u2208 \ud835\udcd1, T i u x \u2260 \u221e)\n    (hP : \u2200 {f g : \u03b1 \u2192 E\u2081}, P f \u2192 P g \u2192 P (f + g))\n    (A : \u211d) (h : \u2200 i \u2208 \ud835\udcd1, AESubAdditiveOn (fun u x \u21a6 (T i u x).toReal) P A \u03bd) :\n    AESubAdditiveOn (fun u x \u21a6 (\u2a06 i \u2208 \ud835\udcd1, T i u x).toReal) P A \u03bd := by\n  have hT' : \u2200 i \u2208 \ud835\udcd1, \u2200 (u : \u03b1 \u2192 E\u2081), P u \u2192 \u2200\u1d50 x \u2202\u03bd, T i u x \u2260 \u221e := by\n    intro i hi f hf\n    filter_upwards [hT f hf] with x hx\n    rw [ne_eq, eq_top_iff] at hx \u22a2\n    exact fun h \u21a6 hx <| h.trans (le_biSup (fun i \u21a6 T i f x) hi)\n  rcases lt_or_le A 0 with A0 | A0\n  \u00b7 refine AESubAdditiveOn.zero hP A (fun f hf \u21a6 ?_)\n    have h (i : \u03b9) (hi : i \u2208 \ud835\udcd1) := (h i hi).neg _ A0\n    simp_rw [Set.forall_in_swap, imp.swap, \u2190 imp_forall_iff] at h hT'\n    filter_upwards [(ae_ball_iff h\ud835\udcd1).mpr (h f hf), (ae_ball_iff h\ud835\udcd1).mpr (hT' f hf)] with x hx hx'\n    simp only [Pi.zero_apply, toReal_eq_zero_iff, ENNReal.iSup_eq_zero]\n    refine Or.inl fun i hi \u21a6 ?_\n    have := (ENNReal.toReal_eq_zero_iff _).mp (hx i hi)\n    tauto\n  intro f g hf hg\n  simp_rw [AESubAdditiveOn, Set.forall_in_swap, imp.swap, \u2190 imp_forall_iff] at h hT'\n  specialize h f hf g hg\n  simp only [Real.norm_eq_abs, abs_toReal] at h \u22a2\n  filter_upwards [hT f hf, hT g hg, (ae_ball_iff h\ud835\udcd1).mpr h, (ae_ball_iff h\ud835\udcd1).mpr (hT' f hf),\n    (ae_ball_iff h\ud835\udcd1).mpr (hT' g hg), (ae_ball_iff h\ud835\udcd1).mpr (hT' (f + g) (hP hf hg))] with x hTfx hTgx hx hT'fx hT'gx hT'fgx\n  rw [\u2190 toReal_add hTfx hTgx, \u2190 toReal_ofReal A0, \u2190 toReal_mul]\n  apply toReal_mono <| mul_ne_top ofReal_ne_top (add_ne_top.mpr \u27e8hTfx, hTgx\u27e9)\n  simp only [iSup_le_iff]\n  intro i hi\n  specialize hx i hi\n  rw [\u2190 toReal_add (hT'fx i hi) (hT'gx i hi), \u2190 toReal_ofReal A0, \u2190 toReal_mul,\n    toReal_le_toReal (hT'fgx i hi) <| mul_ne_top ofReal_ne_top <|\n    add_ne_top.mpr \u27e8hT'fx i hi, hT'gx i hi\u27e9] at hx\n  apply hx.trans\n  gcongr <;> apply le_biSup _ hi\n\nlemma indicator {T : (\u03b1 \u2192 E\u2081) \u2192 \u03b1' \u2192 E\u2082} {P : (\u03b1 \u2192 E\u2081) \u2192 Prop} {A : \u211d}\n    (sa : AESubAdditiveOn T P A \u03bd) (S : Set \u03b1') :\n    AESubAdditiveOn (fun u x \u21a6 (S.indicator (fun y \u21a6 T u y) x)) P A \u03bd := by\n  intro f g hf hg\n  filter_upwards [sa f g hf hg] with x hx\n  by_cases h : x \u2208 S <;> simp [hx, h]\n\n-- If `T` is constant in the second argument (but not necessarily the first) and satisfies\n-- a subadditivity criterion, then `AESubAdditiveOn T P 1`\nlemma const (T : (\u03b1 \u2192 E\u2081) \u2192 E\u2082) (P : (\u03b1 \u2192 E\u2081) \u2192 Prop)\n    (h_add : \u2200 {f g}, P f \u2192 P g \u2192 \u2016T (f + g)\u2016 \u2264 \u2016T f\u2016 + \u2016T g\u2016) :\n    AESubAdditiveOn (fun u (_ : \u03b1') \u21a6 T u) P 1 \u03bd :=\n  fun f g hf hg \u21a6 ae_of_all _ fun _ \u21a6 (by simpa using h_add hf hg)\n\nend AESubAdditiveOn\n\nvariable [NormedSpace \u211d E\u2081] [NormedSpace \u211d E\u2082]\n\n/-- The operator is sublinear on functions satisfying `P` with constant `A`. -/\ndef AESublinearOn (T : (\u03b1 \u2192 E\u2081) \u2192 \u03b1' \u2192 E\u2082) (P : (\u03b1 \u2192 E\u2081) \u2192 Prop) (A : \u211d) (\u03bd : Measure \u03b1') : Prop :=\n  AESubAdditiveOn T P A \u03bd \u2227 \u2200 (f : \u03b1 \u2192 E\u2081) (c : \u211d), P f \u2192 c \u2265 0 \u2192 T (c \u2022 f) =\u1d50[\u03bd] c \u2022 T f\n\nnamespace AESublinearOn\n\nvariable {\u03bd : Measure \u03b1'}\n\nlemma antitone {T : (\u03b1 \u2192 E\u2081) \u2192 \u03b1' \u2192 E\u2082} {P P' : (\u03b1 \u2192 E\u2081) \u2192 Prop}\n    (h : \u2200 {u : \u03b1 \u2192 E\u2081}, P u \u2192 P' u) {A : \u211d} (sl : AESublinearOn T P' A \u03bd) : AESublinearOn T P A \u03bd :=\n  \u27e8sl.1.antitone (fun hu \u21a6 h hu), fun u c hu hc \u21a6 sl.2 u c (h hu) hc\u27e9\n\nlemma biSup {\u03b9 : Type*} (\ud835\udcd1 : Set \u03b9) (h\ud835\udcd1 : \ud835\udcd1.Countable) (T : \u03b9 \u2192 (\u03b1 \u2192 E\u2081) \u2192 \u03b1' \u2192 \u211d\u22650\u221e)\n    {P : (\u03b1 \u2192 E\u2081) \u2192 Prop} (hT : \u2200 (u : \u03b1 \u2192 E\u2081), P u \u2192 \u2200\u1d50 x \u2202\u03bd, \u2a06 i \u2208 \ud835\udcd1, T i u x \u2260 \u221e)\n    (h_add : \u2200 {f g : \u03b1 \u2192 E\u2081}, P f \u2192 P g \u2192 P (f + g))\n    (h_smul : \u2200 {f : \u03b1 \u2192 E\u2081} {c : \u211d}, P f \u2192 c \u2265 0 \u2192 P (c \u2022 f))\n    {A : \u211d} (h : \u2200 i \u2208 \ud835\udcd1, AESublinearOn (fun u x \u21a6 (T i u x).toReal) P A \u03bd) :\n    AESublinearOn (fun u x \u21a6 (\u2a06 i \u2208 \ud835\udcd1, T i u x).toReal) P A \u03bd := by\n  have hT' : \u2200 i \u2208 \ud835\udcd1, \u2200 (u : \u03b1 \u2192 E\u2081), P u \u2192 \u2200\u1d50 x \u2202\u03bd, T i u x \u2260 \u221e := by\n    intro i hi f hf\n    filter_upwards [hT f hf] with x hx\n    rw [ne_eq, eq_top_iff] at hx \u22a2\n    exact fun h \u21a6 hx <| h.trans (le_biSup (fun i \u21a6 T i f x) hi)\n  refine \u27e8AESubAdditiveOn.biSup \ud835\udcd1 h\ud835\udcd1 hT h_add A (fun i hi \u21a6 (h i hi).1), fun f c hf hc \u21a6 ?_\u27e9\n  simp_rw [Set.forall_in_swap, imp.swap, \u2190 imp_forall_iff] at hT'\n  filter_upwards [(ae_ball_iff h\ud835\udcd1).mpr (fun i hi \u21a6 (h i hi).2 f c hf hc),\n    (ae_ball_iff h\ud835\udcd1).mpr (hT' f hf), (ae_ball_iff h\ud835\udcd1).mpr (hT' (c \u2022 f) (h_smul hf hc))] with x hx hT'fx hT'cfx\n  rw [Pi.smul_apply, \u2190 ENNReal.toReal_ofReal hc, smul_eq_mul]\n  simp only [\u2190 toReal_mul, ENNReal.mul_iSup]\n  congr 1\n  refine biSup_congr (fun i hi \u21a6 ?_)\n  specialize hx i hi\n  simp only [Pi.smul_apply, smul_eq_mul, \u2190 toReal_ofReal_mul c (T i f x) hc] at hx\n  simp_rw [ENNReal.toReal_eq_toReal (hT'cfx i hi) (mul_ne_top ofReal_ne_top (hT'fx i hi))] at hx\n  rwa [toReal_ofReal hc]\n\nlemma indicator {T : (\u03b1 \u2192 E\u2081) \u2192 \u03b1' \u2192 E\u2082} {P : (\u03b1 \u2192 E\u2081) \u2192 Prop} {A : \u211d} (S : Set \u03b1')\n    (sl : AESublinearOn T P A \u03bd) :\n    AESublinearOn (fun u x \u21a6 (S.indicator (fun y \u21a6 T u y) x)) P A \u03bd := by\n  refine \u27e8AESubAdditiveOn.indicator sl.1 S, fun f c hf hc \u21a6 ?_\u27e9\n  filter_upwards [sl.2 f c hf hc] with x hx\n  by_cases h : x \u2208 S <;> simp [h, hx]\n\n-- If `T` is constant in the second argument (but not necessarily the first) and satisfies\n-- certain requirements, then `AESublinearOn T P 1`\nlemma const (T : (\u03b1 \u2192 E\u2081) \u2192 E\u2082) (P : (\u03b1 \u2192 E\u2081) \u2192 Prop)\n    (h_add : \u2200 {f g}, P f \u2192 P g \u2192 \u2016T (f + g)\u2016 \u2264 \u2016T f\u2016 + \u2016T g\u2016)\n    (h_smul : \u2200 f {c : \u211d}, P f \u2192 c \u2265 0 \u2192 T (c \u2022 f) = c \u2022 T f) :\n    AESublinearOn (fun u (_ : \u03b1') \u21a6 T u) P 1 \u03bd := by\n  refine \u27e8AESubAdditiveOn.const T P h_add, fun f c hf hc \u21a6 ae_of_all _ fun _ \u21a6 ?_\u27e9\n  simpa using h_smul f hf hc\n\nend AESublinearOn\n\nend MeasureTheory\n\nend\n\n\nnoncomputable section\n\nopen NNReal ENNReal MeasureTheory Set ComputationsChoiceExponent\n    ComputationsInterpolatedExponents ChoiceScale\n\nvariable {\u03b1 \u03b1' E E\u2081 E\u2082 E\u2083 : Type*} {m : MeasurableSpace \u03b1} {m' : MeasurableSpace \u03b1'}\n  {p p' q p\u2080 q\u2080 p\u2081 q\u2081: \u211d\u22650\u221e}\n  {C\u2080 C\u2081 : \u211d\u22650} {\u03bc : Measure \u03b1} {\u03bd : Measure \u03b1'}\n  {a : \u211d}-- truncation parameter\n  {f : \u03b1 \u2192 E\u2081} {t : \u211d}\n  {T : (\u03b1 \u2192 E\u2081) \u2192 (\u03b1' \u2192 E\u2082)}\n\n/-! ## Proof of the real interpolation theorem\n\n    In this section the estimates are combined to finally give a proof of the\n    real interpolation theorem.\n-/\nnamespace MeasureTheory\n\n/-- Proposition that expresses that the map `T` map between function spaces preserves\n    AE strong measurability on L^p. -/\ndef PreservesAEStrongMeasurability\n    [NormedAddCommGroup E\u2081] [NormedAddCommGroup E\u2082]\n    (T : (\u03b1 \u2192 E\u2081) \u2192 \u03b1' \u2192 E\u2082) (p : \u211d\u22650\u221e) : Prop :=\n    \u2200 \u2983f : \u03b1 \u2192 E\u2081\u2984, Mem\u2112p f p \u03bc \u2192 AEStronglyMeasurable (T f) \u03bd\n\nlemma estimate_distribution_Subadditive_trunc {f : \u03b1 \u2192 E\u2081} {t : \u211d}\n    [NormedAddCommGroup E\u2081] [NormedAddCommGroup E\u2082]\n    (ht : t > 0) {a : \u211d} (ha : a > 0) {A : \u211d} (hA : A \u2265 0) (h : Subadditive_trunc T A f \u03bd) :\n    distribution (T f) (ENNReal.ofReal (2 * A * t)) \u03bd \u2264\n    distribution (T (trunc f a)) (ENNReal.ofReal t) \u03bd +\n    distribution (T (f - trunc f a)) (ENNReal.ofReal t) \u03bd := by\n  nth_rw 2 [mul_comm]\n  rw [mul_assoc, two_mul, ENNReal.ofReal_mul, ofReal_add] <;> try positivity\n  apply distribution_add_le' hA\n  nth_rw 1 [trunc_buildup (f := f) (t := a)]\n  exact h a ha\n\nlemma rewrite_norm_func {q : \u211d} {g : \u03b1' \u2192 E}\n    [MeasurableSpace E] [NormedAddCommGroup E] [BorelSpace E] (hq : 0 < q) {A : \u211d} (hA : A > 0)\n    (hg : AEMeasurable g \u03bd) :\n    \u222b\u207b x, \u2016g x\u2016\u208a ^q \u2202\u03bd =\n    ENNReal.ofReal ((2 * A)^q * q) * \u222b\u207b s in Ioi (0 : \u211d),\n    distribution g ((ENNReal.ofReal (2 * A * s)))  \u03bd * (ENNReal.ofReal (s^(q - 1))) := by\n  simp only [\u2190 enorm_eq_nnnorm]\n  rw [lintegral_norm_pow_eq_distribution hg (by linarith)]\n  nth_rewrite 1 [\u2190 lintegral_scale_constant_halfspace' (a := (2*A)) (by linarith)]\n  rw [\u2190 lintegral_const_mul']; swap; \u00b7 exact coe_ne_top\n  rw [\u2190 lintegral_const_mul']; swap; \u00b7 exact coe_ne_top\n  apply lintegral_congr_ae\n  filter_upwards [self_mem_ae_restrict measurableSet_Ioi] with t (zero_lt_t : 0 < t)\n  nth_rw 12 [mul_comm]\n  rw [Real.mul_rpow, \u2190 mul_assoc, \u2190 ofReal_mul', \u2190 mul_assoc, \u2190 mul_assoc, \u2190 mul_assoc,\n      \u2190 ofReal_mul']\n      <;> try positivity\n  congr 3\n  rw [mul_assoc, mul_comm q, \u2190 mul_assoc]\n  congr 1\n  rw [abs_of_nonneg] <;> try positivity\n  nth_rw 1 [\u2190 Real.rpow_one (2 * A), \u2190 Real.rpow_add (by linarith), add_sub_cancel]\n\nlemma estimate_norm_rpow_range_operator {q : \u211d} {f : \u03b1 \u2192 E\u2081}\n    [NormedAddCommGroup E\u2081]\n    [MeasurableSpace E\u2082] [NormedAddCommGroup E\u2082] [BorelSpace E\u2082]\n    (hq : 0 < q) (tc : ToneCouple) {A : \u211d} (hA : A > 0)\n    (ht : Subadditive_trunc T A f \u03bd) (hTf : AEMeasurable (T f) \u03bd) :\n  \u222b\u207b x : \u03b1', \u2016T f x\u2016\u208a ^ q \u2202\u03bd \u2264\n  ENNReal.ofReal ((2 * A)^q * q) * \u222b\u207b s in Ioi (0 : \u211d), distribution (T (trunc f (tc.ton s)))\n      (ENNReal.ofReal s) \u03bd * ENNReal.ofReal (s^(q - 1)) +\n  distribution (T (f - trunc f (tc.ton s))) (ENNReal.ofReal s) \u03bd * ENNReal.ofReal (s^(q - 1)) := by\n  rw [rewrite_norm_func hq hA hTf]\n  apply mul_le_mul' (le_refl _)\n  apply setLIntegral_mono' measurableSet_Ioi\n  intro s s_pos\n  rw [\u2190 add_mul]\n  apply mul_le_mul' ?_ (le_refl _)\n  exact estimate_distribution_Subadditive_trunc s_pos (tc.ran_ton s s_pos) hA.le ht\n\n-- XXX: can this be golfed or unified with `ton_aeMeasurable`?\n\n@[measurability, fun_prop]\ntheorem ton_aeMeasurable_eLpNorm_trunc [NormedAddCommGroup E\u2081] (tc : ToneCouple) :\n    AEMeasurable (fun x \u21a6 eLpNorm (trunc f (tc.ton x)) p\u2081 \u03bc) (volume.restrict (Ioi 0))  := by\n  have := tc.ton_is_ton\n  split_ifs\n  apply aemeasurable_restrict_of_monotoneOn measurableSet_Ioi\n  exact norm_trunc_mono.comp_monotoneOn this.monotoneOn\n  apply aemeasurable_restrict_of_antitoneOn measurableSet_Ioi\n  exact norm_trunc_mono.comp_antitoneOn this.antitoneOn\n", "allTactics": true, "theorems": true, "env": 0}