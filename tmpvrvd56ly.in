{"cmd": "/- Copyright 2023 Daniel J. Velleman -/\n\nimport HTPILib.Chap7\nset_option linter.style.longFile 0\nnamespace HTPI\n\n/- Definitions -/\ndef fnz (n : Nat) : Int := if 2 \u2223 n then \u2191(n / 2) else -\u2191((n + 1) / 2)\n\ndef fzn (a : Int) : Nat := if a \u2265 0 then 2 * Int.toNat a else 2 * Int.toNat (-a) - 1\n\ndef tri (k : Nat) : Nat := k * (k + 1) / 2\n\ndef fnnn (p : Nat \u00d7 Nat) : Nat := tri (p.1 + p.2) + p.1\n\ndef num_elts_below (A : Set Nat) (m s : Nat) : Prop :=\n  match m with\n    | 0 => s = 0\n    | n + 1 => (n \u2208 A \u2227 1 \u2264 s \u2227 num_elts_below A n (s - 1)) \u2228\n                (n \u2209 A \u2227 num_elts_below A n s)\n\ndef enum (A : Set Nat) (s n : Nat) : Prop := n \u2208 A \u2227 num_elts_below A n s\n\ndef unique_val_on_N {U : Type} (R : Rel Nat U) : Prop :=\n  \u2200 \u2983n : Nat\u2984 \u2983x1 x2 : U\u2984, R n x1 \u2192 R n x2 \u2192 x1 = x2\n\ndef nat_rel_onto {U : Type} (R : Rel Nat U) (A : Set U) : Prop :=\n  \u2200 \u2983x : U\u2984, x \u2208 A \u2192 \u2203 (n : Nat), R n x\n\ndef fcnl_onto_from_nat {U : Type} (R : Rel Nat U) (A : Set U) : Prop :=\n  unique_val_on_N R \u2227 nat_rel_onto R A\n\ndef fcnl_one_one_to_nat {U : Type} (R : Rel U Nat) (A : Set U) : Prop :=\n  fcnl_on R A \u2227 \u2200 \u2983x1 x2 : U\u2984 \u2983n : Nat\u2984,\n    (x1 \u2208 A \u2227 R x1 n) \u2192 (x2 \u2208 A \u2227 R x2 n) \u2192 x1 = x2\n\ndef least_rel_to {U : Type} (S : Rel Nat U) (x : U) (n : Nat) : Prop :=\n  S n x \u2227 \u2200 (m : Nat), S m x \u2192 n \u2264 m\n\ndef restrict_to {U V : Type} (S : Rel U V) (A : Set U)\n  (x : U) (y : V) : Prop := x \u2208 A \u2227 S x y\n\ndef fqn (q : Rat) : Nat := fnnn (fzn q.num, q.den)\n\ndef Set_rp_below (m : Nat) : Set Nat := {n : Nat | rel_prime m n \u2227 n < m}\n\ndef Set_prod {U V : Type} (A : Set U) (B : Set V) : Set (U \u00d7 V) :=\n  {(a, b) : U \u00d7 V | a \u2208 A \u2227 b \u2208 B}\n\nnotation:75 A:75 \" \u00d7\u209b \" B:75 => Set_prod A B\n\ndef Rel_prod {U V W X : Type} (R : Rel U V) (S : Rel W X)\n  (p : U \u00d7 W) (q : V \u00d7 X) : Prop := R p.1 q.1 \u2227 S p.2 q.2\n\nnotation:75 R:75 \" \u00d7\u1d63 \" S:75 => Rel_prod R S\n\ndef qr (n a : Nat) : Nat \u00d7 Nat := (a / n, a % n)\n\ndef mod_mod (m n a : Nat) : Nat \u00d7 Nat := (a % m, a % n)\n\ndef enum_union_fam {U : Type}\n  (F : Set (Set U)) (f : Set U \u2192 Rel Nat U) (R : Rel Nat (Set U))\n  (n : Nat) (a : U) : Prop := \u2203 (p : Nat \u00d7 Nat), fnnn p = n \u2227\n    \u2203 A \u2208 F, R p.1 A \u2227 (f A) p.2 a\n\ndef seq {U : Type} (A : Set U) : Set (List U) :=\n  {l : List U | \u2200 x \u2208 l, x \u2208 A}\n\ndef seq_by_length {U : Type} (A : Set U) (n : Nat) : Set (List U) :=\n  {l : List U | l \u2208 seq A \u2227 l.length = n}\n\ndef seq_cons (U : Type) (p : U \u00d7 (List U)) : List U := p.1 :: p.2\n\ndef sbl_set {U : Type} (A : Set U) : Set (Set (List U)) :=\n  {S : Set (List U) | \u2203 (n : Nat), seq_by_length A n = S}\n\ndef rep_common_image\n  {U V : Type} (R S : Rel U V) (X0 : Set U) (n : Nat) : Set U :=\n  match n with\n    | 0 => X0\n    | m + 1 => {a : U | \u2203 x \u2208 rep_common_image R S X0 m,\n                          \u2203 (y : V), R x y \u2227 S a y}\n\ndef cum_rep_image {U V : Type} (R S : Rel U V) (X0 : Set U) : Set U :=\n  {a : U | \u2203 (n : Nat), a \u2208 rep_common_image R S X0 n}\n\ndef csb_match {U V : Type} (R S : Rel U V) (X0 : Set U)\n  (x : U) (y : V) : Prop := x \u2208 cum_rep_image R S X0 \u2227 R x y \u2228\n    x \u2209 cum_rep_image R S X0 \u2227 S x y\n\n/- Section 8.1 -/\n#eval [fnz 0, fnz 1, fnz 2, fnz 3, fnz 4, fnz 5, fnz 6]\n  --Answer: [0, -1, 1, -2, 2, -3, 3]\n\n#eval [fzn 0, fzn (-1), fzn 1, fzn (-2), fzn 2, fzn (-3), fzn 3]\n  --Answer: [0, 1, 2, 3, 4, 5, 6]\n"}

{"cmd": "lemma fnz_even (k : Nat) : fnz (2 * k) = \u2191k := by\n  have h1 : 2 \u2223 2 * k := by\n    apply Exists.intro k\n    rfl\n    done\n  have h2 : fnz (2 * k) = if 2 \u2223 2 * k then \u2191(2 * k / 2)\n    else -\u2191((2 * k + 1) / 2) := by rfl\n  rewrite [if_pos h1] at h2  --h2 : fnz (2 * k) = \u2191(2 * k / 2)\n  have h3 : 0 < 2 := by linarith\n  rewrite [Nat.mul_div_cancel_left k h3] at h2\n  show fnz (2 * k) = \u2191k from h2\n  done\n\nlemma fnz_odd (k : Nat) : fnz (2 * k + 1) = -\u2191(k + 1) := sorry\n\nlemma fzn_nat (k : Nat) : fzn \u2191k = 2 * k := by rfl\n\nlemma fzn_neg_succ_nat (k : Nat) : fzn (-\u2191(k + 1)) = 2 * k + 1 := by rfl\n\n--From exercises of Section 6.1\ntheorem Exercise_6_1_16a1 : \u2200 (n : Nat), nat_even n \u2228 nat_odd n := sorry\n\nlemma fzn_fnz : fzn \u2218 fnz = id := by\n  apply funext        --Goal : \u2200 (x : Nat), (fzn \u2218 fnz) x = id x\n  fix n : Nat\n  rewrite [comp_def]  --Goal : fzn (fnz n) = id n\n  have h1 : nat_even n \u2228 nat_odd n := Exercise_6_1_16a1 n\n  by_cases on h1\n  \u00b7 -- Case 1. h1 : nat_even n\n    obtain (k : Nat) (h2 : n = 2 * k) from h1\n    rewrite [h2, fnz_even, fzn_nat]\n    rfl\n    done\n  \u00b7 -- Case 2. h1 : nat_odd n\n    obtain (k : Nat) (h2 : n = 2 * k + 1) from h1\n    rewrite [h2, fnz_odd, fzn_neg_succ_nat]\n    rfl\n    done\n  done\n\nlemma fnz_fzn : fnz \u2218 fzn = id  := sorry\n\nlemma fzn_one_one : one_to_one fzn := Theorem_5_3_3_1 fzn fnz fnz_fzn\n\nlemma fzn_onto : onto fzn := Theorem_5_3_3_2 fzn fnz fzn_fnz\n\nlemma fnz_one_one : one_to_one fnz := Theorem_5_3_3_1 fnz fzn fzn_fnz\n\nlemma fnz_onto : onto fnz := Theorem_5_3_3_2 fnz fzn fnz_fzn\n\nlemma fnnn_def (a b : Nat) : fnnn (a, b) = tri (a + b) + a := by rfl\n\n#eval [fnnn (0, 0), fnnn (0, 1), fnnn (1, 0), fnnn (0, 2), fnnn (1, 1)]\n  --Answer: [0, 1, 2, 3, 4]\n\nlemma tri_step (k : Nat) : tri (k + 1) = tri k + k + 1 := sorry\n\nlemma tri_incr {j k : Nat} (h1 : j \u2264 k) : tri j \u2264 tri k := sorry\n\nlemma le_of_fnnn_eq {a1 b1 a2 b2 : Nat}\n    (h1 : fnnn (a1, b1) = fnnn (a2, b2)) : a1 + b1 \u2264 a2 + b2 := by\n  by_contra h2\n  have h3 : a2 + b2 + 1 \u2264 a1 + b1 := by linarith\n  have h4 : fnnn (a2, b2) < fnnn (a1, b1) :=\n    calc fnnn (a2, b2)\n      _ = tri (a2 + b2) + a2 := by rfl\n      _ < tri (a2 + b2) + (a2 + b2) + 1 := by linarith\n      _ = tri (a2 + b2 + 1) := (tri_step _).symm\n      _ \u2264 tri (a1 + b1) := tri_incr h3\n      _ \u2264 tri (a1 + b1) + a1 := by linarith\n      _ = fnnn (a1, b1) := by rfl\n  linarith\n  done\n\nlemma fnnn_one_one : one_to_one fnnn := by\n  fix (a1, b1) : Nat \u00d7 Nat\n  fix (a2, b2) : Nat \u00d7 Nat\n  assume h1 : fnnn (a1, b1) = fnnn (a2, b2)  --Goal : (a1, b1) = (a2, b2)\n  have h2 : a1 + b1 \u2264 a2 + b2 := le_of_fnnn_eq h1\n  have h3 : a2 + b2 \u2264 a1 + b1 := le_of_fnnn_eq h1.symm\n  have h4 : a1 + b1 = a2 + b2 := by linarith\n  rewrite [fnnn_def, fnnn_def, h4] at h1\n    --h1 : tri (a2 + b2) + a1 = tri (a2 + b2) + a2\n  have h6 : a1 = a2 := Nat.add_left_cancel h1\n  rewrite [h6] at h4   --h4 : a2 + b1 = a2 + b2\n  have h7 : b1 = b2 := Nat.add_left_cancel h4\n  rewrite [h6, h7]\n  rfl\n  done\n\nlemma fnnn_onto : onto fnnn := by\n  define  --Goal : \u2200 (y : Nat), \u2203 (x : Nat \u00d7 Nat), fnnn x = y\n  by_induc\n  \u00b7 -- Base Case\n    apply Exists.intro (0, 0)\n    rfl\n    done\n  \u00b7 -- Induction Step\n    fix n : Nat\n    assume ih : \u2203 (x : Nat \u00d7 Nat), fnnn x = n\n    obtain ((a, b) : Nat \u00d7 Nat) (h1 : fnnn (a, b) = n) from ih\n    by_cases h2 : b = 0\n    \u00b7 -- Case 1. h2 : b = 0\n      apply Exists.intro (0, a + 1)\n      show fnnn (0, a + 1) = n + 1 from\n        calc fnnn (0, a + 1)\n          _ = tri (0 + (a + 1)) + 0 := by rfl\n          _ = tri (a + 1) := by ring\n          _ = tri a + a + 1 := tri_step a\n          _ = tri (a + 0) + a + 1 := by ring\n          _ = fnnn (a, b) + 1 := by rw [h2, fnnn_def]\n          _ = n + 1 := by rw [h1]\n      done\n    \u00b7 -- Case 2. h2 : b \u2260 0\n      obtain (k : Nat) (h3 : b = k + 1) from\n        exists_eq_add_one_of_ne_zero h2\n      apply Exists.intro (a + 1, k)\n      show fnnn (a + 1, k) = n + 1 from\n        calc fnnn (a + 1, k)\n          _ = tri (a + 1 + k) + (a + 1) := by rfl\n          _ = tri (a + (k + 1)) + a + 1 := by ring\n          _ = tri (a + b) + a + 1 := by rw [h3]\n          _ = fnnn (a, b) + 1 := by rfl\n          _ = n + 1 := by rw [h1]\n      done\n    done\n  done\n\nlemma one_one_on_of_one_one {U V : Type} {f : U \u2192 V}\n    (h : one_to_one f) (A : Set U) : one_one_on f A := by\n  define\n  fix x1 : U; fix x2 : U\n  assume h1 : x1 \u2208 A\n  assume h2 : x2 \u2208 A\n  show f x1 = f x2 \u2192 x1 = x2 from h x1 x2\n  done\n\nlemma elt_Univ {U : Type} (u : U) :\n    u \u2208 Univ U := by trivial\n\ntheorem equinum_Univ {U V : Type} {f : U \u2192 V}\n    (h1 : one_to_one f) (h2 : onto f) : Univ U \u223c Univ V := by\n  have h3 : image f (Univ U) = Univ V := by\n    apply Set.ext\n    fix v : V\n    apply Iff.intro\n    \u00b7 -- (\u2192)\n      assume h3 : v \u2208 image f (Univ U)\n      show v \u2208 Univ V from elt_Univ v\n      done\n    \u00b7 -- (\u2190)\n      assume h3 : v \u2208 Univ V\n      obtain (u : U) (h4 : f u = v) from h2 v\n      apply Exists.intro u\n      apply And.intro _ h4\n      show u \u2208 Univ U from elt_Univ u\n      done\n    done\n  show Univ U \u223c Univ V from\n    equinum_image (one_one_on_of_one_one h1 (Univ U)) h3\n  done\n\ntheorem Z_equinum_N : Univ Int \u223c Univ Nat :=\n  equinum_Univ fzn_one_one fzn_onto\n\ntheorem NxN_equinum_N : Univ (Nat \u00d7 Nat) \u223c Univ Nat :=\n  equinum_Univ fnnn_one_one fnnn_onto\n\nlemma neb_step (A : Set Nat) (n s : Nat) : num_elts_below A (n + 1) s \u2194\n    (n \u2208 A \u2227 1 \u2264 s \u2227 num_elts_below A n (s - 1)) \u2228\n      (n \u2209 A \u2227 num_elts_below A n s) := by rfl\n\nlemma neb_step_elt {A : Set Nat} {n : Nat} (h1 : n \u2208 A) (s : Nat) :\n    num_elts_below A (n + 1) s \u2194 1 \u2264 s \u2227 num_elts_below A n (s - 1) := by\n  rewrite [neb_step]\n  apply Iff.intro\n  \u00b7 -- (\u2192)\n    assume h2 : n \u2208 A \u2227 1 \u2264 s \u2227 num_elts_below A n (s - 1) \u2228\n      \u00acn \u2208 A \u2227 num_elts_below A n s\n    by_cases on h2\n    \u00b7 -- Case 1. h2 : n \u2208 A \u2227 1 \u2264 s \u2227 num_elts_below A n (s - 1)\n      show 1 \u2264 s \u2227 num_elts_below A n (s - 1) from h2.right\n      done\n    \u00b7 -- Case 2. h2 : \u00acn \u2208 A \u2227 num_elts_below A n s\n      show 1 \u2264 s \u2227 num_elts_below A n (s - 1) from absurd h1 h2.left\n      done\n    done\n  \u00b7 -- (\u2190)\n    assume h2 : 1 \u2264 s \u2227 num_elts_below A n (s - 1)\n    apply Or.inl\n    show n \u2208 A \u2227 1 \u2264 s \u2227 num_elts_below A n (s - 1) from And.intro h1 h2\n    done\n  done\n\nlemma neb_step_not_elt {A : Set Nat} {n : Nat} (h1 : n \u2209 A) (s : Nat) :\n    num_elts_below A (n + 1) s \u2194 num_elts_below A n s := by\n  rewrite [neb_step]\n  apply Iff.intro\n  \u00b7 -- (\u2192)\n    assume h2 : n \u2208 A \u2227 1 \u2264 s \u2227 num_elts_below A n (s - 1) \u2228\n      \u00acn \u2208 A \u2227 num_elts_below A n s\n    by_cases on h2\n    \u00b7 -- Case 1. h2 : n \u2208 A \u2227 1 \u2264 s \u2227 num_elts_below A n (s - 1)\n      show num_elts_below A n s from absurd h2.left h1\n      done\n    \u00b7 -- Case 2. h2 : \u00acn \u2208 A \u2227 num_elts_below A n s\n      show num_elts_below A n s from h2.right\n      done\n    done\n  \u00b7 -- (\u2190)\n    assume h2 : num_elts_below A n s\n    apply Or.inr\n    show \u00acn \u2208 A \u2227 num_elts_below A n s from And.intro h1 h2\n    done\n  done\n\nlemma neb_exists (A : Set Nat) :\n    \u2200 (n : Nat), \u2203 (s : Nat), num_elts_below A n s := by\n  by_induc\n  \u00b7 -- Base Case\n    apply Exists.intro 0\n    define\n    rfl\n    done\n  \u00b7 -- Induction Step\n    fix n : Nat\n    assume ih : \u2203 (s : Nat), num_elts_below A n s\n    obtain (t : Nat) (h1 : num_elts_below A n t) from ih\n    by_cases h2 : n \u2208 A\n    \u00b7 -- Case 1. h2 : n \u2208 A\n      apply Exists.intro (t + 1)\n      rewrite [neb_step_elt h2, Nat.add_sub_cancel]\n      apply And.intro _ h1\n      linarith\n      done\n    \u00b7 -- Case 2. h2 : n \u2209 A\n      apply Exists.intro t\n      rewrite [neb_step_not_elt h2]\n      show num_elts_below A n t from h1\n      done\n    done\n  done\n\nlemma neb_unique (A : Set Nat) : \u2200 \u2983n : Nat\u2984, \u2200 \u2983s1 s2 : Nat\u2984,\n    num_elts_below A n s1 \u2192 num_elts_below A n s2 \u2192 s1 = s2 := by\n  by_induc\n  \u00b7 -- Base Case\n    fix s1 : Nat; fix s2 : Nat\n    assume h1 : num_elts_below A 0 s1\n    assume h2 : num_elts_below A 0 s2\n    define at h1; define at h2  --h1 : s1 = 0; h2 : s2 = 0\n    rewrite [h1, h2]\n    rfl\n    done\n  \u00b7 -- Induction Step\n    fix n : Nat\n    assume ih : \u2200 \u2983s1 s2 : Nat\u2984,\n      num_elts_below A n s1 \u2192 num_elts_below A n s2 \u2192 s1 = s2\n    fix s1 : Nat; fix s2 : Nat\n    assume h1 : num_elts_below A (n + 1) s1\n    assume h2 : num_elts_below A (n + 1) s2\n    by_cases h3 : n \u2208 A\n    \u00b7 -- Case 1. h3 : n \u2208 A\n      rewrite [neb_step_elt h3] at h1\n      rewrite [neb_step_elt h3] at h2\n        --h1 : 1 \u2264 s1 \u2227 num_elts_below A n (s1 - 1)\n        --h2 : 1 \u2264 s2 \u2227 num_elts_below A n (s2 - 1)\n      have h4 : s1 - 1 = s2 - 1 := ih h1.right h2.right\n      show s1 = s2 from\n        calc s1\n          _ = s1 - 1 + 1 := (Nat.sub_add_cancel h1.left).symm\n          _ = s2 - 1 + 1 := by rw [h4]\n          _ = s2 := Nat.sub_add_cancel h2.left\n      done\n    \u00b7 -- Case 2. h3 : n \u2209 A\n      rewrite [neb_step_not_elt h3] at h1 --h1 : num_elts_below A n s1\n      rewrite [neb_step_not_elt h3] at h2 --h2 : num_elts_below A n s2\n      show s1 = s2 from ih h1 h2\n      done\n    done\n  done\n\nlemma neb_increase {A : Set Nat} {n s : Nat} (h1 : enum A s n) :\n    \u2200 \u2983m : Nat\u2984, m \u2265 n + 1 \u2192 \u2200 \u2983t : Nat\u2984, num_elts_below A m t \u2192 s < t := by\n  by_induc\n  \u00b7 -- Base Case\n    define at h1\n    fix t : Nat\n    assume h2 : num_elts_below A (n + 1) t\n    rewrite [neb_step_elt h1.left] at h2\n    have h3 : s = t - 1 := neb_unique A h1.right h2.right\n    show s < t from\n      calc s\n        _ = t - 1 := h3\n        _ < t - 1 + 1 := by linarith\n        _ = t := Nat.sub_add_cancel h2.left\n    done\n  \u00b7 -- Induction Step\n    fix m : Nat\n    assume h2 : m \u2265 n + 1\n    assume ih : \u2200 \u2983t : Nat\u2984, num_elts_below A m t \u2192 s < t\n    fix t : Nat\n    assume h3 : num_elts_below A (m + 1) t\n    by_cases h4 : m \u2208 A\n    \u00b7 -- Case 1. h4 : m \u2208 A\n      rewrite [neb_step_elt h4] at h3\n      have h5 : s < t - 1 := ih h3.right\n      show s < t from\n        calc s\n          _ < t - 1 := h5\n          _ \u2264 t := Nat.sub_le _ _\n      done\n    \u00b7 -- Case 2. h4 : m \u2209 A\n      rewrite [neb_step_not_elt h4] at h3\n      show s < t from ih h3\n      done\n    done\n  done\n\nlemma enum_not_skip {A : Set Nat} : \u2200 \u2983m s : Nat\u2984, num_elts_below A m s \u2192\n    \u2200 t < s, \u2203 (n : Nat), enum A t n := by\n  by_induc\n  \u00b7 -- Base Case\n    fix s : Nat\n    assume h1 : num_elts_below A 0 s\n    define at h1\n    fix t : Nat\n    contrapos\n    assume h2 : \u00ac\u2203 (n : Nat), enum A t n\n    linarith\n    done\n  \u00b7 -- Induction Step\n    fix m : Nat\n    assume ih : \u2200 \u2983s : Nat\u2984, num_elts_below A m s \u2192 \u2200 t < s, \u2203 (n : Nat), enum A t n\n    fix s : Nat\n    assume h1 : num_elts_below A (m + 1) s\n    by_cases h2 : m \u2208 A\n    \u00b7 -- Case 1. h2 : m \u2208 A\n      rewrite [neb_step_elt h2] at h1\n      have h3 : \u2200 t < s - 1, \u2203 (n : Nat), enum A t n := ih h1.right\n      fix t : Nat\n      assume h4 : t < s\n      by_cases h5 : t = s - 1\n      \u00b7 -- Case 1.1. h5 : t = s - 1\n        apply Exists.intro m\n        define\n        apply And.intro h2\n        rewrite [h5]\n        show num_elts_below A m (s - 1) from h1.right\n        done\n      \u00b7 -- Case 1.2. h5 : t \u2260 s - 1\n        have h6 : t \u2264 s - 1 := Nat.le_pred_of_lt h4\n        have h7 : t < s - 1 := Nat.lt_of_le_of_ne h6 h5\n        show \u2203 (n : Nat), enum A t n from ih h1.right t h7\n        done\n      done\n    \u00b7 -- Case 2. h2 : m \u2209 A\n      rewrite [neb_step_not_elt h2] at h1\n      show \u2200 t < s, \u2203 (n : Nat), enum A t n from ih h1\n      done\n    done\n  done\n\nlemma enum_le {A : Set Nat} {t n1 n2 : Nat}\n    (h1 : enum A t n1) (h2 : enum A t n2) : n1 \u2264 n2 := by\n  by_contra h3\n  have h4 : n2 + 1 \u2264 n1 := by linarith\n  define at h1\n  have h5 : t < t := neb_increase h2 h4 h1.right\n  linarith\n  done\n\nlemma enum_unique (A : Set Nat) (t : Nat) :\n    \u2200 \u2983n1 n2 : Nat\u2984, enum A t n1 \u2192 enum A t n2 \u2192 n1 = n2 := by\n  fix n1 : Nat; fix n2 : Nat\n  assume h1 : enum A t n1\n  assume h2 : enum A t n2\n  have h3 : n1 \u2264 n2 := enum_le h1 h2\n  have h4 : n2 \u2264 n1 := enum_le h2 h1\n  linarith\n  done\n\nlemma inv_enum_fcnl (A : Set Nat) : fcnl_on (invRel (enum A)) A := by\n  define\n  fix n : Nat\n  assume h1 : n \u2208 A\n  exists_unique\n  \u00b7 -- Existence\n    obtain (s : Nat) (h2 : num_elts_below A n s) from neb_exists A n\n    apply Exists.intro s\n    define\n    show n \u2208 A \u2227 num_elts_below A n s from And.intro h1 h2\n    done\n  \u00b7 -- Uniqueness\n    fix s1 : Nat; fix s2 : Nat\n    assume h2 : invRel (enum A) n s1\n    assume h3 : invRel (enum A) n s2\n    define at h2; define at h3\n    show s1 = s2 from neb_unique A h2.right h3.right\n    done\n  done\n\nlemma bdd_subset_nat_match {A : Set Nat} {m s : Nat}\n    (h1 : \u2200 n \u2208 A, n < m) (h2 : num_elts_below A m s) :\n    matching (enum A) (I s) A := by\n  define\n  apply And.intro\n  \u00b7 -- Proof of rel_within\n    define\n    fix t : Nat; fix n : Nat\n    assume h3 : enum A t n\n    have h4 : \u2200 \u2983m : Nat\u2984, m \u2265 n + 1 \u2192 \u2200 \u2983t_1 : Nat\u2984, num_elts_below A m t_1 \u2192 t < t_1 :=\n      neb_increase h3\n    define at h3\n    apply And.intro _ h3.left\n    define\n    have h5 : n < m := h1 n h3.left\n    have h6 : m \u2265 n + 1 := h5\n    show t < s from h4 h6 h2\n    done\n  \u00b7 -- Proof of fcnl_ons\n    apply And.intro\n    \u00b7 -- proof of fcnl_on (enum A) (I s)\n      define\n      fix t : Nat\n      assume h3 : t \u2208 I s\n      define at h3\n      exists_unique\n      \u00b7 -- Existence\n        show \u2203 (y : Nat), enum A t y from enum_not_skip h2 t h3\n        done\n      \u00b7 -- Uniqueness\n        show \u2200 (y_1 y_2 : Nat), enum A t y_1 \u2192 enum A t y_2 \u2192 y_1 = y_2 from\n          enum_unique A t\n        done\n      done\n    \u00b7 -- Proof of fcnl_on (invRel (enum A)) A\n      show fcnl_on (invRel (enum A)) A from inv_enum_fcnl A\n      done\n    done\n  done\n\nlemma bdd_subset_nat {A : Set Nat} {m s : Nat}\n    (h1 : \u2200 n \u2208 A, n < m) (h2 : num_elts_below A m s) :\n    I s \u223c A := Exists.intro (enum A) (bdd_subset_nat_match h1 h2)\n\nlemma enum_fcnl_of_unbdd {A : Set Nat} (h1 : \u2200 (m : Nat), \u2203 n \u2208 A, n \u2265 m) :\n    fcnl_on (enum A) (Univ Nat) := by\n  define\n  by_induc\n  \u00b7 -- Base Case\n    assume h2 : 0 \u2208 Univ Nat\n    exists_unique\n    \u00b7 -- Existence\n      obtain (n : Nat) (h3 : n \u2208 A \u2227 n \u2265 0) from h1 0\n      obtain (s : Nat) (h4 : num_elts_below A (n + 1) s) from neb_exists A (n + 1)\n      have h5 : \u2200 (t : Nat), t < s \u2192 \u2203 (n : Nat), enum A t n := enum_not_skip h4\n      rewrite [neb_step_elt h3.left] at h4\n      show \u2203 (y : Nat), enum A 0 y from h5 0 h4.left\n      done\n    \u00b7 -- Uniqueness\n      show \u2200 (y_1 y_2 : Nat), enum A 0 y_1 \u2192 enum A 0 y_2 \u2192 y_1 = y_2 from enum_unique A 0\n      done\n    done\n  \u00b7 -- Induction Step\n    fix s : Nat\n    assume ih : s \u2208 Univ Nat \u2192 \u2203! (y : Nat), enum A s y\n    assume h2 : s + 1 \u2208 Univ Nat\n    exists_unique\n    \u00b7 -- Existence\n      have h3 : s \u2208 Univ Nat := elt_Univ s\n      obtain (m : Nat) (h4 : enum A s m)\n        (h5 : \u2200 (y_1 y_2 : Nat), enum A s y_1 \u2192 enum A s y_2 \u2192 y_1 = y_2) from ih h3\n      obtain (n : Nat) (h6 : n \u2208 A \u2227 n \u2265 m + 1) from h1 (m + 1)\n      obtain (t : Nat) (h7 : num_elts_below A n t) from neb_exists A n\n      have h8 : s < t := neb_increase h4 h6.right h7\n      have h9 : s + 1 < t \u2228 s + 1 = t := Nat.lt_or_eq_of_le h8\n      by_cases on h9\n      \u00b7 -- Case 1. h9 : s + 1 < t\n        show \u2203 (y : Nat), enum A (s + 1) y from enum_not_skip h7 (s + 1) h9\n        done\n      \u00b7 -- Case 2. h9 : s + 1 = t\n        rewrite [h9]\n        apply Exists.intro n\n        define\n        show n \u2208 A \u2227 num_elts_below A n t from And.intro h6.left h7\n        done\n      done\n    \u00b7 -- Uniqueness\n      show \u2200 (y_1 y_2 : Nat), enum A (s + 1) y_1 \u2192 enum A (s + 1) y_2 \u2192 y_1 = y_2\n        from enum_unique A (s + 1)\n      done\n    done\n  done\n\nlemma unbdd_subset_nat_match {A : Set Nat}\n    (h1 : \u2200 (m : Nat), \u2203 n \u2208 A, n \u2265 m) :\n    matching (enum A) (Univ Nat) A := by\n  define\n  apply And.intro\n  \u00b7 -- Proof of rel_within\n    define\n    fix s : Nat; fix n : Nat\n    assume h2 : enum A s n\n    define at h2\n    apply And.intro (elt_Univ s) h2.left\n    done\n  \u00b7 -- Proof of fcnl_ons\n    apply And.intro\n    \u00b7 -- Proof of fcnl_on (enum A)\n      show fcnl_on (enum A) (Univ Nat) from enum_fcnl_of_unbdd h1\n      done\n    \u00b7 -- Proof of fcnl_on (invRel (enum A))\n      show fcnl_on (invRel (enum A)) A from inv_enum_fcnl A\n      done\n    done\n  done\n\nlemma unbdd_subset_nat {A : Set Nat}\n    (h1 : \u2200 (m : Nat), \u2203 n \u2208 A, n \u2265 m) :\n    denum A := Exists.intro (enum A) (unbdd_subset_nat_match h1)\n\nlemma subset_nat_ctble (A : Set Nat) : ctble A := by\n  define          --Goal : finite A \u2228 denum A\n  by_cases h1 : \u2203 (m : Nat), \u2200 n \u2208 A, n < m\n  \u00b7 -- Case 1. h1 : \u2203 (m : Nat), \u2200 n \u2208 A, n < m\n    apply Or.inl  --Goal : finite A\n    obtain (m : Nat) (h2 : \u2200 n \u2208 A, n < m) from h1\n    obtain (s : Nat) (h3 : num_elts_below A m s) from neb_exists A m\n    apply Exists.intro s\n    show I s \u223c A from bdd_subset_nat h2 h3\n    done\n  \u00b7 -- Case 2. h1 : \u00ac\u2203 (m : Nat), \u2200 n \u2208 A, n < m\n    apply Or.inr  --Goal : denum A\n    push_neg at h1\n      --This tactic converts h1 to \u2200 (m : Nat), \u2203 n \u2208 A, m \u2264 n\n    show denum A from unbdd_subset_nat h1\n    done\n  done\n\nlemma ctble_of_equinum_ctble {U V : Type} {A : Set U} {B : Set V}\n    (h1 : A \u223c B) (h2 : ctble A) : ctble B := sorry\n\nlemma ctble_iff_equinum_set_nat {U : Type} (A : Set U) :\n    ctble A \u2194 \u2203 (I : Set Nat), I \u223c A := by\n  apply Iff.intro\n  \u00b7 -- (\u2192)\n    assume h1 : ctble A\n    define at h1  --h1 : finite A \u2228 denum A\n    by_cases on h1\n    \u00b7 -- Case 1. h1 : finite A\n      define at h1  --h1 : \u2203 (n : Nat), I n \u223c A\n      obtain (n : Nat) (h2 : I n \u223c A) from h1\n      show \u2203 (I : Set Nat), I \u223c A from Exists.intro (I n) h2\n      done\n    \u00b7 -- Case 2. h1 : denum A\n      rewrite [denum_def] at h1  --h1 : Univ Nat \u223c A\n      show \u2203 (I : Set Nat), I \u223c A from Exists.intro (Univ Nat) h1\n      done\n    done\n  \u00b7 -- (\u2190)\n    assume h1 : \u2203 (I : Set Nat), I \u223c A\n    obtain (I : Set Nat) (h2 : I \u223c A) from h1\n    have h3 : ctble I := subset_nat_ctble I\n    show ctble A from ctble_of_equinum_ctble h2 h3\n    done\n  done\n\ntheorem Theorem_8_1_5_1_to_2 {U : Type} {A : Set U} (h1 : ctble A) :\n    \u2203 (R : Rel Nat U), fcnl_onto_from_nat R A := by\n  rewrite [ctble_iff_equinum_set_nat] at h1\n  obtain (I : Set Nat) (h2 : I \u223c A) from h1\n  obtain (R : Rel Nat U) (h3 : matching R I A) from h2\n  define at h3\n    --h3 : rel_within R I A \u2227 fcnl_on R I \u2227 fcnl_on (invRel R) A\n  apply Exists.intro R\n  define  --Goal : unique_val_on_N R \u2227 nat_rel_onto R A\n  apply And.intro\n  \u00b7 -- Proof of unique_val_on_N R\n    define\n    fix n : Nat; fix x1 : U; fix x2 : U\n    assume h4 : R n x1\n    assume h5 : R n x2      --Goal : x1 = x2\n    have h6 : n \u2208 I \u2227 x1 \u2208 A := h3.left h4\n    show x1 = x2 from fcnl_unique h3.right.left h6.left h4 h5\n    done\n  \u00b7 -- Proof of nat_rel_onto R A\n    define\n    fix x : U\n    assume h4 : x \u2208 A  --Goal : \u2203 (n : Nat), R n x\n    show \u2203 (n : Nat), R n x from fcnl_exists h3.right.right h4\n    done\n  done\n\nlemma exists_least_rel_to {U : Type} {S : Rel Nat U} {x : U}\n    (h1 : \u2203 (n : Nat), S n x) : \u2203 (n : Nat), least_rel_to S x n := by\n  set W : Set Nat := {n : Nat | S n x}\n  have h2 : \u2203 (n : Nat), n \u2208 W := h1\n  show \u2203 (n : Nat), least_rel_to S x n from well_ord_princ W h2\n  done\n\ntheorem Theorem_8_1_5_2_to_3 {U : Type} {A : Set U}\n    (h1 : \u2203 (R : Rel Nat U), fcnl_onto_from_nat R A) :\n    \u2203 (R : Rel U Nat), fcnl_one_one_to_nat R A := by\n  obtain (S : Rel Nat U) (h2 : fcnl_onto_from_nat S A) from h1\n  define at h2  --h2 : unique_val_on_N S \u2227 nat_rel_onto S A\n  set R : Rel U Nat := least_rel_to S\n  apply Exists.intro R\n  define\n  apply And.intro\n  \u00b7 -- Proof of fcnl_on R A\n    define\n    fix x : U\n    assume h4 : x \u2208 A  --Goal : \u2203! (y : Nat), R x y\n    exists_unique\n    \u00b7 -- Existence\n      have h5 : \u2203 (n : Nat), S n x := h2.right h4\n      show \u2203 (n : Nat), R x n from exists_least_rel_to h5\n      done\n    \u00b7 -- Uniqueness\n      fix n1 : Nat; fix n2 : Nat\n      assume h5 : R x n1\n      assume h6 : R x n2      --Goal : n1 = n2\n      define at h5    --h5 : S n1 x \u2227 \u2200 (m : Nat), S m x \u2192 n1 \u2264 m\n      define at h6    --h6 : S n2 x \u2227 \u2200 (m : Nat), S m x \u2192 n2 \u2264 m\n      have h7 : n1 \u2264 n2 := h5.right n2 h6.left\n      have h8 : n2 \u2264 n1 := h6.right n1 h5.left\n      linarith\n      done\n    done\n  \u00b7 -- Proof of one-to-one\n    fix x1 : U; fix x2 : U; fix n : Nat\n    assume h4 : x1 \u2208 A \u2227 R x1 n\n    assume h5 : x2 \u2208 A \u2227 R x2 n\n    have h6 : R x1 n := h4.right\n    have h7 : R x2 n := h5.right\n    define at h6   --h6 : S n x1 \u2227 \u2200 (m : Nat), S m x1 \u2192 n \u2264 m\n    define at h7   --h7 : S n x2 \u2227 \u2200 (m : Nat), S m x2 \u2192 n \u2264 m\n    show x1 = x2 from h2.left h6.left h7.left\n    done\n  done\n\ntheorem Theorem_8_1_5_3_to_1 {U : Type} {A : Set U}\n    (h1 : \u2203 (R : Rel U Nat), fcnl_one_one_to_nat R A) :\n    ctble A := by\n  obtain (S : Rel U Nat) (h2 : fcnl_one_one_to_nat S A) from h1\n  define at h2  --h2 : fcnl_on S A \u2227 \u2200 \u2983x1 x2 : U\u2984 \u2983n : Nat\u2984,\n                --x1 \u2208 A \u2227 S x1 n \u2192 x2 \u2208 A \u2227 S x2 n \u2192 x1 = x2\n  rewrite [ctble_iff_equinum_set_nat]  --Goal : \u2203 (I : Set Nat), I \u223c A\n  set R : Rel Nat U := invRel (restrict_to S A)\n  set I : Set Nat := {n : Nat | \u2203 (x : U), R n x}\n  apply Exists.intro I\n  define        --Goal : \u2203 (R : Rel Nat U), matching R I A\n  apply Exists.intro R\n  define\n  apply And.intro\n  \u00b7 -- Proof of rel_within R I A\n    define\n    fix n : Nat; fix x : U\n    assume h3 : R n x   --Goal : n \u2208 I \u2227 x \u2208 A\n    apply And.intro\n    \u00b7 -- Proof that n \u2208 I\n      define            --Goal : \u2203 (x : U), R n x\n      show \u2203 (x : U), R n x from Exists.intro x h3\n      done\n    \u00b7 -- Proof that x \u2208 A\n      define at h3      --h3 : x \u2208 A \u2227 S x n\n      show x \u2208 A from h3.left\n      done\n    done\n  \u00b7 -- Proofs of fcnl_ons\n    apply And.intro\n    \u00b7 -- Proof of fcnl_on R I\n      define\n      fix n : Nat\n      assume h3 : n \u2208 I   --Goal : \u2203! (y : U), R n y\n      exists_unique\n      \u00b7 -- Existence\n        define at h3      --h3 : \u2203 (x : U), R n x\n        show \u2203 (y : U), R n y from h3\n        done\n      \u00b7 -- Uniqueness\n        fix x1 : U; fix x2 : U\n        assume h4 : R n x1\n        assume h5 : R n x2\n        define at h4      --h4 : x1 \u2208 A \u2227 S x1 n;\n        define at h5      --h5 : x2 \u2208 A \u2227 S x2 n\n        show x1 = x2 from h2.right h4 h5\n        done\n      done\n    \u00b7 -- Proof of fcnl_on (invRel R) A\n      define\n      fix x : U\n      assume h3 : x \u2208 A  --Goal : \u2203! (y : Nat), invRel R x y\n      exists_unique\n      \u00b7 -- Existence\n        obtain (y : Nat) (h4 : S x y) from fcnl_exists h2.left h3\n        apply Exists.intro y\n        define\n        show x \u2208 A \u2227 S x y from And.intro h3 h4\n        done\n      \u00b7 -- Uniqueness\n        fix n1 : Nat; fix n2 : Nat\n        assume h4 : invRel R x n1\n        assume h5 : invRel R x n2  --Goal : n1 = n2\n        define at h4     --h4 : x \u2208 A \u2227 S x n1\n        define at h5     --h5 : x \u2208 A \u2227 S x n2\n        show n1 = n2 from fcnl_unique h2.left h3 h4.right h5.right\n        done\n      done\n    done\n  done\n\ntheorem Theorem_8_1_5_2 {U : Type} (A : Set U) :\n    ctble A \u2194 \u2203 (R : Rel Nat U), fcnl_onto_from_nat R A := by\n  apply Iff.intro\n  \u00b7 -- (\u2192)\n    assume h1 : ctble A\n    show \u2203 (R : Rel Nat U), fcnl_onto_from_nat R A from\n      Theorem_8_1_5_1_to_2 h1\n    done\n  \u00b7 -- (\u2190)\n    assume h1 : \u2203 (R : Rel Nat U), fcnl_onto_from_nat R A\n    have h2 : \u2203 (R : Rel U Nat), fcnl_one_one_to_nat R A :=\n      Theorem_8_1_5_2_to_3 h1\n    show ctble A from Theorem_8_1_5_3_to_1 h2\n    done\n  done\n\ntheorem Theorem_8_1_5_3 {U : Type} (A : Set U) :\n    ctble A \u2194 \u2203 (R : Rel U Nat), fcnl_one_one_to_nat R A := by\n  apply Iff.intro\n  \u00b7 -- (\u2192)\n    assume h1 : ctble A\n    have h2 : \u2203 (R : Rel Nat U), fcnl_onto_from_nat R A :=\n      Theorem_8_1_5_1_to_2 h1\n    show \u2203 (R : Rel U Nat), fcnl_one_one_to_nat R A from\n      Theorem_8_1_5_2_to_3 h2\n    done\n  \u00b7 -- (\u2190)\n    assume h1 : \u2203 (R : Rel U Nat), fcnl_one_one_to_nat R A\n    show ctble A from Theorem_8_1_5_3_to_1 h1\n    done\n  done\n\nlemma fqn_def (q : Rat) : fqn q = fnnn (fzn q.num, q.den) := by rfl\n\nlemma fqn_one_one : one_to_one fqn := by\n  define\n  fix q1 : Rat; fix q2 : Rat\n  assume h1 : fqn q1 = fqn q2\n  rewrite [fqn_def, fqn_def] at h1\n    --h1 : fnnn (fzn q1.num, q1.den) = fnnn (fzn q2.num, q2.den)\n  have h2 : (fzn q1.num, q1.den) = (fzn q2.num, q2.den) :=\n    fnnn_one_one _ _ h1\n  have h3 : fzn q1.num = fzn q2.num \u2227 q1.den = q2.den :=\n    Prod.mk.inj h2\n  have h4 : q1.num = q2.num := fzn_one_one _ _ h3.left\n  show q1 = q2 from Rat.ext h4 h3.right\n  done\n\nlemma image_fqn_unbdd :\n    \u2200 (m : Nat), \u2203 n \u2208 image fqn (Univ Rat), n \u2265 m := by\n  fix m : Nat\n  set n : Nat := fqn \u2191m\n  apply Exists.intro n\n  apply And.intro\n  \u00b7 -- Proof that n \u2208 image fqn (Univ Rat)\n    define\n    apply Exists.intro \u2191m\n    apply And.intro (elt_Univ (\u2191m : Rat))\n    rfl\n    done\n  \u00b7 -- Proof that n \u2265 m\n    show n \u2265 m from\n      calc n\n        _ = tri (2 * m + 1) + 2 * m := by rfl\n        _ \u2265 m := by linarith\n    done\n  done\n\ntheorem Theorem_8_1_6 : denum (Univ Rat) := by\n  set I : Set Nat := image fqn (Univ Rat)\n  have h1 : Univ Nat \u223c I := unbdd_subset_nat image_fqn_unbdd\n  have h2 : image fqn (Univ Rat) = I := by rfl\n  have h3 : Univ Rat \u223c I :=\n    equinum_image (one_one_on_of_one_one fqn_one_one (Univ Rat)) h2\n  have h4 : I \u223c Univ Rat := Theorem_8_1_3_2 h3\n  show denum (Univ Rat) from Theorem_8_1_3_3 h1 h4\n  done\n\n/- Section 8.1\u00bd -/\nlemma eq_zero_of_I_zero_equinum {n : Nat} (h1 : I 0 \u223c I n) : n = 0 := by\n  rewrite [\u2190numElts_def, zero_elts_iff_empty] at h1\n    --h1 : empty (I n)\n  contradict h1 with h2       --Goal : \u2203 (x : Nat), x \u2208 I n\n  apply Exists.intro 0\n  define\n  show 0 < n from Nat.pos_of_ne_zero h2\n  done\n\ntheorem eq_of_I_equinum : \u2200 \u2983m n : Nat\u2984, I m \u223c I n \u2192 m = n := by\n  by_induc\n  \u00b7 -- Base Case\n    fix n : Nat\n    assume h1 : I 0 \u223c I n\n    show 0 = n from (eq_zero_of_I_zero_equinum h1).symm\n    done\n  \u00b7 -- Induction Step\n    fix m : Nat\n    assume ih : \u2200 \u2983n : Nat\u2984, I m \u223c I n \u2192 m = n\n    fix n : Nat\n    assume h1 : I (m + 1) \u223c I n      --Goal : m + 1 = n\n    have h2 : n \u2260 0 := by\n      by_contra h2\n      have h3 : I n \u223c I (m + 1) := Theorem_8_1_3_2 h1\n      rewrite [h2] at h3\n      have h4 : m + 1 = 0 := eq_zero_of_I_zero_equinum h3\n      linarith\n      done\n    obtain (k : Nat) (h3 : n = k + 1) from exists_eq_add_one_of_ne_zero h2\n    rewrite [h3] at h1               --h1 : I (m + 1) \u223c I (k + 1)\n    rewrite [h3]                     --Goal : m + 1 = k + 1\n    have h4 : m \u2208 I (m + 1) := I_max m\n    have h5 : k \u2208 I (k + 1) := I_max k\n    have h6 : I (m + 1) \\ {m} \u223c I (k + 1) \\ {k} :=\n      remove_one_equinum h1 h4 h5\n    rewrite [I_diff, I_diff] at h6   --h6 : I m \u223c I k\n    have h7 : m = k := ih h6\n    rewrite [h7]\n    rfl\n    done\n  done\n\ntheorem numElts_unique {U : Type} {A : Set U} {m n : Nat}\n    (h1 : numElts A m) (h2 : numElts A n) : m = n := by\n  rewrite [numElts_def] at h1      --h1 : I m \u223c A\n  rewrite [numElts_def] at h2      --h2 : I n \u223c A\n  have h3 : A \u223c I n := Theorem_8_1_3_2 h2\n  have h4 : I m \u223c I n := Theorem_8_1_3_3 h1 h3\n  show m = n from eq_of_I_equinum h4\n  done\n\nlemma Set_rp_below_def (a m : Nat) :\n    a \u2208 Set_rp_below m \u2194 rel_prime m a \u2227 a < m := by rfl\n\nlemma neb_nrpb (m : Nat) : \u2200 \u2983k : Nat\u2984, k \u2264 m \u2192\n    num_elts_below (Set_rp_below m) k (num_rp_below m k) := sorry\n\nlemma neb_phi (m : Nat) :\n    num_elts_below (Set_rp_below m) m (phi m) := by\n  rewrite [phi_def]\n  have h1 : m \u2264 m := by linarith\n  show num_elts_below (Set_rp_below m) m (num_rp_below m m) from\n    neb_nrpb m h1\n  done\n\nlemma phi_is_numElts (m : Nat) :\n    numElts (Set_rp_below m) (phi m) := by\n  rewrite [numElts_def]    --Goal : I (phi m) \u223c Set_rp_below m\n  have h1 : \u2200 n \u2208 Set_rp_below m, n < m := by\n    fix n : Nat\n    assume h2 : n \u2208 Set_rp_below m\n    define at h2\n    show n < m from h2.right\n    done\n  have h2 : num_elts_below (Set_rp_below m) m (phi m) := neb_phi m\n  show I (phi m) \u223c Set_rp_below m from bdd_subset_nat h1 h2\n  done\n\nlemma Lemma_7_4_7_aux {m n : Nat} {s t : Int}\n    (h : s * m + t * n = 1) (a b : Nat) :\n    t * n * a + s * m * b \u2261 a (MOD m) := by\n  define\n  apply Exists.intro (s * (b - a))\n  show t * n * a + s * m * b - a = m * (s * (b - a)) from\n    calc t * n * a + s * m * b - a\n      _ = (t * n - 1) * a + s * m * b := by ring\n      _ = (t * n - (s * m + t * n)) * a + s * m * b := by rw [h]\n      _ = m * (s * (b - a)) := by ring\n  done\n\nlemma Lemma_7_4_7 {m n : Nat} [NeZero m] [NeZero n]\n    (h1 : rel_prime m n) (a b : Nat) :\n    \u2203 (r : Nat), r < m * n \u2227 r \u2261 a (MOD m) \u2227 r \u2261 b (MOD n) := by\n  set s : Int := gcd_c1 m n\n  set t : Int := gcd_c2 m n\n  have h4 : s * m + t * n = gcd m n := gcd_lin_comb n m\n  define at h1                      --h1 : gcd m n = 1\n  rewrite [h1, Nat.cast_one] at h4  --h4 : s * m + t * n = 1\n  set x : Int := t * n * a + s * m * b\n  have h5 : x \u2261 a (MOD m) := Lemma_7_4_7_aux h4 a b\n  rewrite [add_comm] at h4          --h4 : t * n + s * m = 1\n  have h6 : s * m * b + t * n * a \u2261 b (MOD n) :=\n    Lemma_7_4_7_aux h4 b a\n  have h7 : s * m * b + t * n * a = x := by ring\n  rewrite [h7] at h6                --h6 : x \u2261 b (MOD n)\n  have h8 : m * n \u2260 0 := mul_ne_zero (NeZero.ne m) (NeZero.ne n)\n  rewrite [\u2190neZero_iff] at h8       --h8 : NeZero (m * n)\n  have h9 : 0 \u2264 x % \u2191(m * n) \u2227 x % \u2191(m * n) < \u2191(m * n) \u2227\n    x \u2261 x % \u2191(m * n) (MOD m * n) := mod_cmpl_res (m * n) x\n  have h10 : x % \u2191(m * n) < \u2191(m * n) \u2227\n    x \u2261 x % \u2191(m * n) (MOD m * n) := h9.right\n  set r : Nat := Int.toNat (x % \u2191(m * n))\n  have h11 : x % \u2191(m * n) = \u2191r := (Int.toNat_of_nonneg h9.left).symm\n  rewrite [h11, Nat.cast_lt] at h10 --h10 : r < m * n \u2227 x \u2261 r (MOD m * n)\n  apply Exists.intro r\n  apply And.intro h10.left\n  have h12 : r \u2261 x (MOD (m * n)) := congr_symm h10.right\n  rewrite [Lemma_7_4_5 _ _ h1] at h12 --h12 : r \u2261 x (MOD m) \u2227 r \u2261 x (MOD n)\n  apply And.intro\n  \u00b7 -- Proof that r \u2261 a (MOD m)\n    show r \u2261 a (MOD m) from congr_trans h12.left h5\n    done\n  \u00b7 -- Proof that r \u2261 b (MOD n)\n    show r \u2261 b (MOD n) from congr_trans h12.right h6\n    done\n  done\n\nlemma Set_prod_def {U V : Type} (A : Set U) (B : Set V) (a : U) (b : V) :\n    (a, b) \u2208 A \u00d7\u209b B \u2194 a \u2208 A \u2227 b \u2208 B := by rfl\n\nlemma Rel_prod_def {U V W X : Type} (R : Rel U V) (S : Rel W X)\n    (u : U) (v : V) (w : W) (x : X) :\n    (R \u00d7\u1d63 S) (u, w) (v, x) \u2194 R u v \u2227 S w x := by rfl\n\nlemma prod_match {U V W X : Type}\n    {A : Set U} {B : Set V} {C : Set W} {D : Set X}\n    {R : Rel U V} {S : Rel W X}\n    (h1 : matching R A B) (h2 : matching S C D) :\n    matching (R \u00d7\u1d63 S) (A \u00d7\u209b C) (B \u00d7\u209b D) := sorry\n\ntheorem Theorem_8_1_2_1\n    {U V W X : Type} {A : Set U} {B : Set V} {C : Set W} {D : Set X}\n    (h1 : A \u223c B) (h2 : C \u223c D) : A \u00d7\u209b C \u223c B \u00d7\u209b D := by\n  obtain (R : Rel U V) (h3 : matching R A B) from h1\n  obtain (S : Rel W X) (h4 : matching S C D) from h2\n  apply Exists.intro (R \u00d7\u1d63 S)\n  show matching (R \u00d7\u1d63 S) (A \u00d7\u209b C) (B \u00d7\u209b D) from prod_match h3 h4\n  done\n\nlemma qr_def (n a : Nat) : qr n a = (a / n, a % n) := by rfl\n\nlemma qr_one_one (n : Nat) : one_to_one (qr n) := by\n  define\n  fix a1 : Nat; fix a2 : Nat\n  assume h1 : qr n a1 = qr n a2       --Goal : a1 = a2\n  rewrite [qr_def, qr_def] at h1\n  have h2 : a1 / n = a2 / n \u2227 a1 % n = a2 % n := Prod.mk.inj h1\n  show a1 = a2 from\n    calc a1\n      _ = n * (a1 / n) + a1 % n := (Nat.div_add_mod a1 n).symm\n      _ = n * (a2 / n) + a2 % n := by rw [h2.left, h2.right]\n      _ = a2 := Nat.div_add_mod a2 n\n  done\n\nlemma qr_image (m n : Nat) :\n    image (qr n) (I (m * n)) = I m \u00d7\u209b I n := sorry\n\nlemma I_prod (m n : Nat) : I (m * n) \u223c I m \u00d7\u209b I n := equinum_image\n  (one_one_on_of_one_one (qr_one_one n) (I (m * n))) (qr_image m n)\n\ntheorem numElts_prod {U V : Type} {A : Set U} {B : Set V} {m n : Nat}\n    (h1 : numElts A m) (h2 : numElts B n) : numElts (A \u00d7\u209b B) (m * n) := by\n  rewrite [numElts_def] at h1     --h1 : I m \u223c A\n  rewrite [numElts_def] at h2     --h2 : I n \u223c B\n  rewrite [numElts_def]           --Goal : I (m * n) \u223c A \u00d7\u209b B\n  have h3 : I m \u00d7\u209b I n \u223c A \u00d7\u209b B := Theorem_8_1_2_1 h1 h2\n  have h4 : I (m * n) \u223c I m \u00d7\u209b I n := I_prod m n\n  show I (m * n) \u223c A \u00d7\u209b B from Theorem_8_1_3_3 h4 h3\n  done\n\nlemma mod_mod_def (m n a : Nat) : mod_mod m n a = (a % m, a % n) := by rfl\n\n--From exercises of Section 7.3\ntheorem congr_rel_prime {m a b : Nat} (h1 : a \u2261 b (MOD m)) :\n    rel_prime m a \u2194 rel_prime m b := sorry\n\ntheorem rel_prime_mod (m a : Nat) :\n    rel_prime m (a % m) \u2194 rel_prime m a := sorry\n\n/- Stated in Chap7.lean\ntheorem congr_iff_mod_eq_Nat (m a b : Nat) [NeZero m] :\n    \u2191a \u2261 \u2191b (MOD m) \u2194 a % m = b % m := sorry\n-/\n\n--From exercises of Section 7.4\nlemma Lemma_7_4_6 {a b c : Nat} :\n    rel_prime (a * b) c \u2194 rel_prime a c \u2227 rel_prime b c := sorry\n\nlemma left_NeZero_of_mul {m n : Nat} (h : m * n \u2260 0) : NeZero m :=\n  neZero_iff.rtl (left_ne_zero_of_mul h)\n\nlemma right_NeZero_of_mul {m n : Nat} (h : m * n \u2260 0) : NeZero n :=\n  neZero_iff.rtl (right_ne_zero_of_mul h)\n\nlemma mod_mod_one_one_on {m n : Nat} (h1 : rel_prime m n) :\n    one_one_on (mod_mod m n) (Set_rp_below (m * n)) := by\n  define\n  fix a1 : Nat; fix a2 : Nat\n  assume h2 : a1 \u2208 Set_rp_below (m * n)\n  assume h3 : a2 \u2208 Set_rp_below (m * n)\n  assume h4 : mod_mod m n a1 = mod_mod m n a2   --Goal : a1 = a2\n  define at h2; define at h3\n  rewrite [mod_mod_def, mod_mod_def] at h4\n  have h5 : a1 % m = a2 % m \u2227 a1 % n = a2 % n := Prod.mk.inj h4\n  have h6 : m * n \u2260 0 := by linarith\n  have h7 : NeZero m := left_NeZero_of_mul h6\n  have h8 : NeZero n := right_NeZero_of_mul h6\n  rewrite [\u2190congr_iff_mod_eq_Nat, \u2190congr_iff_mod_eq_Nat] at h5\n      --h5 : \u2191a1 \u2261 \u2191a2 (MOD m) \u2227 \u2191a1 \u2261 \u2191a2 (MOD n)\n  rewrite [\u2190Lemma_7_4_5 _ _ h1] at h5  --h5 : \u2191a1 \u2261 \u2191a2 (MOD m * n)\n  rewrite [congr_iff_mod_eq_Nat] at h5 --h5 : a1 % (m * n) = a2 % (m * n)\n  rewrite [Nat.mod_eq_of_lt h2.right, Nat.mod_eq_of_lt h3.right] at h5\n  show a1 = a2 from h5\n  done\n\nlemma mod_elt_Set_rp_below {a m : Nat} [NeZero m] (h1 : rel_prime m a) :\n    a % m \u2208 Set_rp_below m := by\n  define                  --Goal : rel_prime m (a % m) \u2227 a % m < m\n  rewrite [rel_prime_mod] --Goal : rel_prime m a \u2227 a % m < m\n  show rel_prime m a \u2227 a % m < m from\n    And.intro h1 (mod_nonzero_lt a (NeZero.ne m))\n  done\n\nlemma mod_mod_image {m n : Nat} (h1 : rel_prime m n) :\n    image (mod_mod m n) (Set_rp_below (m * n)) =\n      (Set_rp_below m) \u00d7\u209b (Set_rp_below n) := by\n  apply Set.ext\n  fix (b, c) : Nat \u00d7 Nat\n  apply Iff.intro\n  \u00b7 -- (\u2192)\n    assume h2 : (b, c) \u2208 image (mod_mod m n) (Set_rp_below (m * n))\n    define at h2\n    obtain (a : Nat)\n      (h3 : a \u2208 Set_rp_below (m * n) \u2227 mod_mod m n a = (b, c)) from h2\n    rewrite [Set_rp_below_def, mod_mod_def] at h3\n    have h4 : rel_prime (m * n) a := h3.left.left\n    rewrite [Lemma_7_4_6] at h4   --h4 : rel_prime m a \u2227 rel_prime n a\n    have h5 : a % m = b \u2227 a % n = c := Prod.mk.inj h3.right\n    define\n    rewrite [\u2190h5.left, \u2190h5.right]\n      --Goal : a % m \u2208 Set_rp_below m \u2227 a % n \u2208 Set_rp_below n\n    have h6 : m * n \u2260 0 := by linarith\n    have h7 : NeZero m := left_NeZero_of_mul h6\n    have h8 : NeZero n := right_NeZero_of_mul h6\n    apply And.intro\n    \u00b7 -- Proof that a % m \u2208 Set_rp_below m\n      show a % m \u2208 Set_rp_below m from mod_elt_Set_rp_below h4.left\n      done\n    \u00b7 -- Proof that a % n \u2208 Set_rp_below n\n      show a % n \u2208 Set_rp_below n from mod_elt_Set_rp_below h4.right\n      done\n    done\n  \u00b7 -- (\u2190)\n    assume h2 : (b, c) \u2208 Set_rp_below m \u00d7\u209b Set_rp_below n\n    rewrite [Set_prod_def, Set_rp_below_def, Set_rp_below_def] at h2\n      --h2 : (rel_prime m b \u2227 b < m) \u2227 (rel_prime n c \u2227 c < n)\n    define\n    have h3 : m \u2260 0 := by linarith\n    have h4 : n \u2260 0 := by linarith\n    rewrite [\u2190neZero_iff] at h3\n    rewrite [\u2190neZero_iff] at h4\n    obtain (a : Nat) (h5 : a < m * n \u2227 a \u2261 b (MOD m) \u2227 a \u2261 c (MOD n))\n      from Lemma_7_4_7 h1 b c\n    apply Exists.intro a\n    apply And.intro\n    \u00b7 -- Proof of a \u2208 Set_rp_below (m * n)\n      define                  --Goal : rel_prime (m * n) a \u2227 a < m * n\n      apply And.intro _ h5.left\n      rewrite [Lemma_7_4_6]   --Goal : rel_prime m a \u2227 rel_prime n a\n      rewrite [congr_rel_prime h5.right.left,\n        congr_rel_prime h5.right.right]\n      show rel_prime m b \u2227 rel_prime n c from\n        And.intro h2.left.left h2.right.left\n      done\n    \u00b7 -- Proof of mod_mod m n a = (b, c)\n      rewrite [congr_iff_mod_eq_Nat, congr_iff_mod_eq_Nat] at h5\n      rewrite [mod_mod_def, h5.right.left, h5.right.right]\n        --Goal : (b % m, c % n) = (b, c)\n      rewrite [Nat.mod_eq_of_lt h2.left.right,\n        Nat.mod_eq_of_lt h2.right.right]\n      rfl\n      done\n    done\n  done\n\nlemma Set_rp_below_prod {m n : Nat} (h1 : rel_prime m n) :\n    Set_rp_below (m * n) \u223c (Set_rp_below m) \u00d7\u209b (Set_rp_below n) :=\n  equinum_image (mod_mod_one_one_on h1) (mod_mod_image h1)\n\nlemma eq_numElts_of_equinum {U V : Type} {A : Set U} {B : Set V} {n : Nat}\n    (h1 : A \u223c B) (h2 : numElts A n) : numElts B n := by\n  rewrite [numElts_def] at h2   --h2 : I n \u223c A\n  rewrite [numElts_def]         --Goal : I n \u223c B\n  show I n \u223c B from Theorem_8_1_3_3 h2 h1\n  done\n\ntheorem Theorem_7_4_4 {m n : Nat} (h1 : rel_prime m n) :\n    phi (m * n) = (phi m) * (phi n) := by\n  have h2 : numElts (Set_rp_below m) (phi m) := phi_is_numElts m\n  have h3 : numElts (Set_rp_below n) (phi n) := phi_is_numElts n\n  have h4 : numElts (Set_rp_below (m * n)) (phi (m * n)) :=\n    phi_is_numElts (m * n)\n  have h5 : numElts (Set_rp_below m \u00d7\u209b Set_rp_below n) (phi (m * n)) :=\n    eq_numElts_of_equinum (Set_rp_below_prod h1) h4\n  have h6 : numElts (Set_rp_below m \u00d7\u209b Set_rp_below n) (phi m * phi n) :=\n    numElts_prod h2 h3\n  show phi (m * n) = phi m * phi n from numElts_unique h5 h6\n  done\n\n/- Section 8.2 -/\n--From exercises of Section 8.1\ntheorem Exercise_8_1_17 {U : Type} {A B : Set U}\n    (h1 : B \u2286 A) (h2 : ctble A) : ctble B := sorry\n\ntheorem Theorem_8_2_1_1 {U V : Type} {A : Set U} {B : Set V}\n    (h1 : ctble A) (h2 : ctble B) : ctble (A \u00d7\u209b B) := by\n  rewrite [ctble_iff_equinum_set_nat] at h1\n  rewrite [ctble_iff_equinum_set_nat] at h2\n  obtain (I : Set Nat) (h3 : I \u223c A) from h1\n  obtain (J : Set Nat) (h4 : J \u223c B) from h2\n  have h5 : I \u00d7\u209b J \u223c A \u00d7\u209b B := Theorem_8_1_2_1 h3 h4\n  have h6 : I \u00d7\u209b J \u2286 Univ (Nat \u00d7 Nat) := by\n    fix p : Nat \u00d7 Nat\n    assume h6 : p \u2208 I \u00d7\u209b J\n    show p \u2208 Univ (Nat \u00d7 Nat) from elt_Univ p\n    done\n  have h7 : ctble (Univ (Nat \u00d7 Nat)) := by\n    define   --Goal : finite (Univ (Nat \u00d7 Nat)) \u2228 denum (Univ (Nat \u00d7 Nat))\n    apply Or.inr\n    rewrite [denum_def]\n    show Univ Nat \u223c Univ (Nat \u00d7 Nat) from Theorem_8_1_3_2 NxN_equinum_N\n    done\n  have h8 : ctble (I \u00d7\u209b J) := Exercise_8_1_17 h6 h7\n  show ctble (A \u00d7\u209b B) from ctble_of_equinum_ctble h5 h8\n  done\n\nlemma Lemma_8_2_2_1 {U : Type} {F : Set (Set U)} {f : Set U \u2192 Rel Nat U}\n    (h1 : ctble F) (h2 : \u2200 A \u2208 F, fcnl_onto_from_nat (f A) A) :\n    ctble (\u22c3\u2080 F) := by\n  rewrite [Theorem_8_1_5_2] at h1\n  rewrite [Theorem_8_1_5_2]\n  obtain (R : Rel Nat (Set U)) (h3 : fcnl_onto_from_nat R F) from h1\n  define at h3\n  have Runiqueval : unique_val_on_N R := h3.left\n  have Ronto : nat_rel_onto R F := h3.right\n  set S : Rel Nat U := enum_union_fam F f R\n  apply Exists.intro S\n  define\n  apply And.intro\n  \u00b7 -- Proof of unique_val_on_N S\n    define\n    fix n : Nat; fix a1 : U; fix a2 : U\n    assume Sna1 : S n a1\n    assume Sna2 : S n a2         --Goal : a1 = a2\n    define at Sna1; define at Sna2\n    obtain ((i1, j1) : Nat \u00d7 Nat) (h4 : fnnn (i1, j1) = n \u2227\n      \u2203 A \u2208 F, R i1 A \u2227 f A j1 a1) from Sna1\n    obtain (A1 : Set U) (Aija1 : A1 \u2208 F \u2227 R i1 A1 \u2227 f A1 j1 a1)\n      from h4.right\n    obtain ((i2, j2) : Nat \u00d7 Nat) (h5 : fnnn (i2, j2) = n \u2227\n      \u2203 A \u2208 F, R i2 A \u2227 f A j2 a2) from Sna2\n    obtain (A2 : Set U) (Aija2 : A2 \u2208 F \u2227 R i2 A2 \u2227 f A2 j2 a2)\n      from h5.right\n    rewrite [\u2190h5.left] at h4\n    have h6 : (i1, j1) = (i2, j2) :=\n      fnnn_one_one (i1, j1) (i2, j2) h4.left\n    have h7 : i1 = i2 \u2227 j1 = j2 := Prod.mk.inj h6\n    rewrite [h7.left, h7.right] at Aija1\n      --Aija1 : A1 \u2208 F \u2227 R i2 A1 \u2227 f A1 j2 a1\n    define at Runiqueval\n    have h8 : A1 = A2 := Runiqueval Aija1.right.left Aija2.right.left\n    rewrite [h8] at Aija1       --Aija1 : A2 \u2208 F \u2227 R i2 A2 \u2227 f A2 j2 a1\n    have fA2fcnlonto : fcnl_onto_from_nat (f A2) A2 := h2 A2 Aija2.left\n    define at fA2fcnlonto\n    have fA2uniqueval : unique_val_on_N (f A2) := fA2fcnlonto.left\n    define at fA2uniqueval\n    show a1 = a2 from fA2uniqueval Aija1.right.right Aija2.right.right\n    done\n  \u00b7 -- Proof of nat_rel_onto S (\u22c3\u2080 F)\n    define\n    fix x : U\n    assume h4 : x \u2208 \u22c3\u2080 F    --Goal : \u2203 (n : Nat), S n x\n    define at h4\n    obtain (A : Set U) (h5 : A \u2208 F \u2227 x \u2208 A) from h4\n    define at Ronto\n    obtain (i : Nat) (h6 : R i A) from Ronto h5.left\n    have fAfcnlonto : fcnl_onto_from_nat (f A) A := h2 A h5.left\n    define at fAfcnlonto\n    have fAonto : nat_rel_onto (f A) A := fAfcnlonto.right\n    define at fAonto\n    obtain (j : Nat) (h7 : f A j x) from fAonto h5.right\n    apply Exists.intro (fnnn (i, j))\n    define    --Goal : \u2203 (p : Nat \u00d7 Nat), fnnn p = fnnn (i, j) \u2227\n              --       \u2203 A \u2208 F, R p.1 A \u2227 f A p.2 x\n    apply Exists.intro (i, j)\n    apply And.intro\n    \u00b7 -- Proof that fnnn (i, j) = fnnn (i, j)\n      rfl\n      done\n    \u00b7 -- Proof that \u2203 A \u2208 F, R (i, j).1 A \u2227 f A (i, j).2 x\n      apply Exists.intro A\n      show A \u2208 F \u2227 R (i, j).1 A \u2227 f A (i, j).2 x from\n        And.intro h5.left (And.intro h6 h7)\n      done\n    done\n  done\n\nlemma Lemma_8_2_2_2 {U : Type} {F : Set (Set U)} (h : \u2200 A \u2208 F, ctble A) :\n    \u2203 (f : Set U \u2192 Rel Nat U), \u2200 A \u2208 F, fcnl_onto_from_nat (f A) A := by\n  have h1 : \u2200 (A : Set U), \u2203 (SA : Rel Nat U),\n      A \u2208 F \u2192 fcnl_onto_from_nat SA A := by\n    fix A : Set U\n    by_cases h2 : A \u2208 F\n    \u00b7 -- Case 1. h2 : A \u2208 F\n      have h3 : ctble A := h A h2\n      rewrite [Theorem_8_1_5_2] at h3\n      obtain (SA : Rel Nat U) (h4 : fcnl_onto_from_nat SA A) from h3\n      apply Exists.intro SA\n      assume h5 : A \u2208 F\n      show fcnl_onto_from_nat SA A from h4\n      done\n    \u00b7 -- Case 2. h2 : A \u2209 F\n      apply Exists.intro (emptyRel Nat U)\n      assume h3 : A \u2208 F\n      show fcnl_onto_from_nat (emptyRel Nat U) A from absurd h3 h2\n      done\n    done\n  set f : Set U \u2192 Rel Nat U := fun (A : Set U) => Classical.choose (h1 A)\n  apply Exists.intro f\n  fix A : Set U\n  show A \u2208 F \u2192 fcnl_onto_from_nat (f A) A from Classical.choose_spec (h1 A)\n  done\n\ntheorem Theorem_8_2_2 {U : Type} {F : Set (Set U)}\n    (h1 : ctble F) (h2 : \u2200 A \u2208 F, ctble A) : ctble (\u22c3\u2080 F) := by\n  obtain (f : Set U \u2192 Rel Nat U) (h3 : \u2200 A \u2208 F, fcnl_onto_from_nat (f A) A)\n    from Lemma_8_2_2_2 h2\n  show ctble (\u22c3\u2080 F) from Lemma_8_2_2_1 h1 h3\n  done\n\nlemma seq_def {U : Type} (A : Set U) (l : List U) :\n    l \u2208 seq A \u2194 \u2200 x \u2208 l, x \u2208 A := by rfl\n\nlemma sbl_base {U : Type} (A : Set U) : seq_by_length A 0 = {[]} := by\n  apply Set.ext\n  fix l : List U\n  apply Iff.intro\n  \u00b7 -- (\u2192)\n    assume h1 : l \u2208 seq_by_length A 0\n    define at h1   --h1 : l \u2208 seq A \u2227 l.length = 0\n    rewrite [List.length_eq_zero] at h1\n    define\n    show l = [] from h1.right\n    done\n  \u00b7 -- (\u2190)\n    assume h1 : l \u2208 {[]}\n    define at h1     --h1 : l = []\n    define           --Goal : l \u2208 seq A \u2227 l.length = 0\n    apply And.intro _ (List.length_eq_zero.rtl h1)\n    define           --Goal : \u2200 x \u2208 l, x \u2208 A\n    fix x : U\n    assume h2 : x \u2208 l\n    contradict h2 with h3\n    rewrite [h1]\n    show x \u2209 [] from List.not_mem_nil x\n    done\n  done\n\nlemma seq_cons_def {U : Type} (x : U) (l : List U) :\n    seq_cons U (x, l) = x :: l := by rfl\n\nlemma seq_cons_one_one (U : Type) : one_to_one (seq_cons U) := by\n  fix (a1, l1) : U \u00d7 List U; fix (a2, l2) : U \u00d7 List U\n  assume h1 : seq_cons U (a1, l1) = seq_cons U (a2, l2)\n  rewrite [seq_cons_def, seq_cons_def] at h1  --h1 : a1 :: l1 = a2 :: l2\n  rewrite [List.cons_eq_cons] at h1           --h1 : a1 = a2 \u2227 l1 = l2\n  rewrite [h1.left, h1.right]\n  rfl\n  done\n\nlemma seq_cons_image {U : Type} (A : Set U) (n : Nat) :\n    image (seq_cons U) (A \u00d7\u209b (seq_by_length A n)) =\n      seq_by_length A (n + 1) := sorry\n\nlemma Lemma_8_2_4_1 {U : Type} (A : Set U) (n : Nat) :\n    A \u00d7\u209b (seq_by_length A n) \u223c seq_by_length A (n + 1) :=\n  equinum_image (one_one_on_of_one_one (seq_cons_one_one U)\n    (A \u00d7\u209b (seq_by_length A n))) (seq_cons_image A n)\n\nlemma Lemma_8_2_4_2 {U : Type} {A : Set U} (h1 : ctble A) :\n    \u2200 (n : Nat), ctble (seq_by_length A n) := by\n  by_induc\n  \u00b7 -- Base Case\n    rewrite [sbl_base]   --Goal : ctble {[]}\n    define\n    apply Or.inl         --Goal : finite {[]}\n    rewrite [finite_def]\n    apply Exists.intro 1 --Goal : numElts {[]} 1\n    show numElts {[]} 1 from singleton_one_elt []\n    done\n  \u00b7 -- Induction Step\n    fix n : Nat\n    assume ih : ctble (seq_by_length A n)\n    have h2 : A \u00d7\u209b (seq_by_length A n) \u223c seq_by_length A (n + 1) :=\n      Lemma_8_2_4_1 A n\n    have h3 : ctble (A \u00d7\u209b (seq_by_length A n)) := Theorem_8_2_1_1 h1 ih\n    show ctble (seq_by_length A (n + 1)) from ctble_of_equinum_ctble h2 h3\n    done\n  done\n\nlemma Lemma_8_2_4_3 {U : Type} (A : Set U) : \u22c3\u2080 (sbl_set A) = seq A := by\n  apply Set.ext\n  fix l : List U\n  apply Iff.intro\n  \u00b7 -- (\u2192)\n    assume h1 : l \u2208 \u22c3\u2080 (sbl_set A)\n    define at h1\n    obtain (S : Set (List U)) (h2 :  S \u2208 sbl_set A \u2227 l \u2208 S) from h1\n    have h3 : S \u2208 sbl_set A := h2.left\n    define at h3\n    obtain (n : Nat) (h4 : seq_by_length A n = S) from h3\n    have h5 : l \u2208 S := h2.right\n    rewrite [\u2190h4] at h5\n    define at h5\n    show l \u2208 seq A from h5.left\n    done\n  \u00b7 -- (\u2190)\n    assume h1 : l \u2208 seq A\n    define\n    set n : Nat := l.length\n    apply Exists.intro (seq_by_length A n)\n    apply And.intro\n    \u00b7 -- Proof of seq_by_length A n \u2208 sbl_set A\n      define\n      apply Exists.intro n\n      rfl\n      done\n    \u00b7 -- Proof of l \u2208 seq_by_length A n\n      define\n      apply And.intro h1\n      rfl\n      done\n    done\n  done\n\ntheorem ctble_of_onto_func_from_N {U : Type} {A : Set U} {f : Nat \u2192 U}\n    (h1 : \u2200 x \u2208 A, \u2203 (n : Nat), f n = x) : ctble A := sorry\n\nlemma Lemma_8_2_4_4 {U : Type} (A : Set U) : ctble (sbl_set A) := by\n  have h1 : \u2200 S \u2208 sbl_set A, \u2203 (n : Nat), seq_by_length A n = S := by\n    fix S : Set (List U)\n    assume h1 : S \u2208 sbl_set A\n    define at h1\n    show \u2203 (n : Nat), seq_by_length A n = S from h1\n    done\n  show ctble (sbl_set A) from ctble_of_onto_func_from_N h1\n  done\n\ntheorem Theorem_8_2_4 {U : Type} {A : Set U}\n    (h1 : ctble A) : ctble (seq A) := by\n  set F : Set (Set (List U)) := sbl_set A\n  have h2 : ctble F := Lemma_8_2_4_4 A\n  have h3 : \u2200 S \u2208 F, ctble S := by\n    fix S : Set (List U)\n    assume h3 : S \u2208 F\n    define at h3\n    obtain (n : Nat) (h4 : seq_by_length A n = S) from h3\n    rewrite [\u2190h4]\n    show ctble (seq_by_length A n) from Lemma_8_2_4_2 h1 n\n    done\n  rewrite [\u2190Lemma_8_2_4_3 A]\n  show ctble (\u22c3\u2080 sbl_set A) from Theorem_8_2_2 h2 h3\n  done\n\nlemma set_elt_powerset_univ {U : Type} (A : Set U) :\n    A \u2208 \ud835\udcab (Univ U) := by\n  fix x : U\n  assume h : x \u2208 A\n  show x \u2208 Univ U from elt_Univ x\n  done\n\n\ntheorem Cantor's_theorem : \u00acctble (\ud835\udcab (Univ Nat))  := by\n  by_contra h1\n  rewrite [Theorem_8_1_5_2] at h1\n  obtain R h2 from h1\n  have h3 := h2.left\n  have h4 := h2.right\n  set D : Set Nat := {n | \u2203 X, R n X \u2227 n \u2209 X}\n  have h5 : D \u2208 \ud835\udcab (Univ Nat) := set_elt_powerset_univ D\n  obtain n h6 from h4 h5\n  by_cases h7 : n \u2208 D\n  \u00b7 obtain X h8 from h7\n    have h9 : D = X := h3 h6 h8.left\n    rw [h9] at h8\n    exact h8.right h7\n  \u00b7 exact h7 \u27e8D, \u27e8h6, h7\u27e9\u27e9\n", "allTactics": true, "theorems": true, "env": 0}