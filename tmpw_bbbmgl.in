{"cmd": "/-\nCopyright (c) 2022 Jo\u00ebl Riou. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Jo\u00ebl Riou\n-/\nimport Mathlib.AlgebraicTopology.SimplicialObject\nimport Mathlib.CategoryTheory.Limits.Shapes.Products\n\n#align_import algebraic_topology.split_simplicial_object from \"leanprover-community/mathlib\"@\"dd1f8496baa505636a82748e6b652165ea888733\"\n\n/-!\n\n# Split simplicial objects\n\nIn this file, we introduce the notion of split simplicial object.\nIf `C` is a category that has finite coproducts, a splitting\n`s : Splitting X` of a simplicial object `X` in `C` consists\nof the datum of a sequence of objects `s.N : \u2115 \u2192 C` (which\nwe shall refer to as \"nondegenerate simplices\") and a\nsequence of morphisms `s.\u03b9 n : s.N n \u2192 X _[n]` that have\nthe property that a certain canonical map identifies `X _[n]`\nwith the coproduct of objects `s.N i` indexed by all possible\nepimorphisms `[n] \u27f6 [i]` in `SimplexCategory`. (We do not\nassume that the morphisms `s.\u03b9 n` are monomorphisms: in the\nmost common categories, this would be a consequence of the\naxioms.)\n\nSimplicial objects equipped with a splitting form a category\n`SimplicialObject.Split C`.\n\n## References\n* [Stacks: Splitting simplicial objects] https://stacks.math.columbia.edu/tag/017O\n\n-/\n\n\nnoncomputable section\n\nopen CategoryTheory CategoryTheory.Category CategoryTheory.Limits Opposite SimplexCategory\n\nopen Simplicial\n\nuniverse u\n\nvariable {C : Type*} [Category C]\n\nnamespace SimplicialObject\n\nnamespace Splitting\n\n/-- The index set which appears in the definition of split simplicial objects. -/\ndef IndexSet (\u0394 : SimplexCategory\u1d52\u1d56) :=\n  \u03a3\u0394' : SimplexCategory\u1d52\u1d56, { \u03b1 : \u0394.unop \u27f6 \u0394'.unop // Epi \u03b1 }\n#align simplicial_object.splitting.index_set SimplicialObject.Splitting.IndexSet\n\nnamespace IndexSet\n\n/-- The element in `Splitting.IndexSet \u0394` attached to an epimorphism `f : \u0394 \u27f6 \u0394'`. -/\n@[simps]\ndef mk {\u0394 \u0394' : SimplexCategory} (f : \u0394 \u27f6 \u0394') [Epi f] : IndexSet (op \u0394) :=\n  \u27e8op \u0394', f, inferInstance\u27e9\n#align simplicial_object.splitting.index_set.mk SimplicialObject.Splitting.IndexSet.mk\n\nvariable {\u0394 : SimplexCategory\u1d52\u1d56} (A : IndexSet \u0394)\n\n/-- The epimorphism in `SimplexCategory` associated to `A : Splitting.IndexSet \u0394` -/\ndef e :=\n  A.2.1\n#align simplicial_object.splitting.index_set.e SimplicialObject.Splitting.IndexSet.e\n\ninstance : Epi A.e :=\n  A.2.2\n\ntheorem ext' : A = \u27e8A.1, \u27e8A.e, A.2.2\u27e9\u27e9 := rfl\n#align simplicial_object.splitting.index_set.ext' SimplicialObject.Splitting.IndexSet.ext'\n"}

{"cmd": "theorem ext (A\u2081 A\u2082 : IndexSet \u0394) (h\u2081 : A\u2081.1 = A\u2082.1) (h\u2082 : A\u2081.e \u226b eqToHom (by rw [h\u2081]) = A\u2082.e) :\n    A\u2081 = A\u2082 := by\n  rcases A\u2081 with \u27e8\u0394\u2081, \u27e8\u03b1\u2081, h\u03b1\u2081\u27e9\u27e9\n  rcases A\u2082 with \u27e8\u0394\u2082, \u27e8\u03b1\u2082, h\u03b1\u2082\u27e9\u27e9\n  simp only at h\u2081\n  subst h\u2081\n  simp only [eqToHom_refl, comp_id, IndexSet.e] at h\u2082\n  simp only [h\u2082]\n#align simplicial_object.splitting.index_set.ext SimplicialObject.Splitting.IndexSet.ext\n\ninstance : Fintype (IndexSet \u0394) :=\n  Fintype.ofInjective\n    (fun A =>\n      \u27e8\u27e8A.1.unop.len, Nat.lt_succ_iff.mpr (len_le_of_epi (inferInstance : Epi A.e))\u27e9,\n        A.e.toOrderHom\u27e9 :\n      IndexSet \u0394 \u2192 Sigma fun k : Fin (\u0394.unop.len + 1) => Fin (\u0394.unop.len + 1) \u2192 Fin (k + 1))\n    (by\n      rintro \u27e8\u0394\u2081, \u03b1\u2081\u27e9 \u27e8\u0394\u2082, \u03b1\u2082\u27e9 h\u2081\n      induction' \u0394\u2081 using Opposite.rec with \u0394\u2081\n      induction' \u0394\u2082 using Opposite.rec with \u0394\u2082\n      simp only [unop_op, Sigma.mk.inj_iff, Fin.mk.injEq] at h\u2081\n      have h\u2082 : \u0394\u2081 = \u0394\u2082 := by\n        ext1\n        simpa only [Fin.mk_eq_mk] using h\u2081.1\n      subst h\u2082\n      refine ext _ _ rfl ?_\n      ext : 2\n      exact eq_of_heq h\u2081.2)\n\nvariable (\u0394)\n\n/-- The distinguished element in `Splitting.IndexSet \u0394` which corresponds to the\nidentity of `\u0394`. -/\n@[simps]\ndef id : IndexSet \u0394 :=\n  \u27e8\u0394, \u27e8\ud835\udfd9 _, by infer_instance\u27e9\u27e9\n#align simplicial_object.splitting.index_set.id SimplicialObject.Splitting.IndexSet.id\n\ninstance : Inhabited (IndexSet \u0394) :=\n  \u27e8id \u0394\u27e9\n\nvariable {\u0394}\n\n/-- The condition that an element `Splitting.IndexSet \u0394` is the distinguished\nelement `Splitting.IndexSet.Id \u0394`. -/\n@[simp]\ndef EqId : Prop :=\n  A = id _\n#align simplicial_object.splitting.index_set.eq_id SimplicialObject.Splitting.IndexSet.EqId\n\ntheorem eqId_iff_eq : A.EqId \u2194 A.1 = \u0394 := by\n  constructor\n  \u00b7 intro h\n    dsimp at h\n    rw [h]\n    rfl\n  \u00b7 intro h\n    rcases A with \u27e8_, \u27e8f, hf\u27e9\u27e9\n    simp only at h\n    subst h\n    refine ext _ _ rfl ?_\n    haveI := hf\n    simp only [eqToHom_refl, comp_id]\n    exact eq_id_of_epi f\n#align simplicial_object.splitting.index_set.eq_id_iff_eq SimplicialObject.Splitting.IndexSet.eqId_iff_eq\n\ntheorem eqId_iff_len_eq : A.EqId \u2194 A.1.unop.len = \u0394.unop.len := by\n  rw [eqId_iff_eq]\n  constructor\n  \u00b7 intro h\n    rw [h]\n  \u00b7 intro h\n    rw [\u2190 unop_inj_iff]\n    ext\n    exact h\n#align simplicial_object.splitting.index_set.eq_id_iff_len_eq SimplicialObject.Splitting.IndexSet.eqId_iff_len_eq\n\ntheorem eqId_iff_len_le : A.EqId \u2194 \u0394.unop.len \u2264 A.1.unop.len := by\n  rw [eqId_iff_len_eq]\n  constructor\n  \u00b7 intro h\n    rw [h]\n  \u00b7 exact le_antisymm (len_le_of_epi (inferInstance : Epi A.e))\n#align simplicial_object.splitting.index_set.eq_id_iff_len_le SimplicialObject.Splitting.IndexSet.eqId_iff_len_le\n\ntheorem eqId_iff_mono : A.EqId \u2194 Mono A.e := by\n  constructor\n  \u00b7 intro h\n    dsimp at h\n    subst h\n    dsimp only [id, e]\n    infer_instance\n  \u00b7 intro h\n    rw [eqId_iff_len_le]\n    exact len_le_of_mono h\n#align simplicial_object.splitting.index_set.eq_id_iff_mono SimplicialObject.Splitting.IndexSet.eqId_iff_mono\n\n/-- Given `A : IndexSet \u0394\u2081`, if `p.unop : unop \u0394\u2082 \u27f6 unop \u0394\u2081` is an epi, this\nis the obvious element in `A : IndexSet \u0394\u2082` associated to the composition\nof epimorphisms `p.unop \u226b A.e`. -/\n@[simps]\ndef epiComp {\u0394\u2081 \u0394\u2082 : SimplexCategory\u1d52\u1d56} (A : IndexSet \u0394\u2081) (p : \u0394\u2081 \u27f6 \u0394\u2082) [Epi p.unop] :\n    IndexSet \u0394\u2082 :=\n  \u27e8A.1, \u27e8p.unop \u226b A.e, epi_comp _ _\u27e9\u27e9\n#align simplicial_object.splitting.index_set.epi_comp SimplicialObject.Splitting.IndexSet.epiComp\n\n\nvariable {\u0394' : SimplexCategory\u1d52\u1d56} (\u03b8 : \u0394 \u27f6 \u0394')\n\n/-- When `A : IndexSet \u0394` and `\u03b8 : \u0394 \u2192 \u0394'` is a morphism in `SimplexCategory\u1d52\u1d56`,\nan element in `IndexSet \u0394'` can be defined by using the epi-mono factorisation\nof `\u03b8.unop \u226b A.e`. -/\ndef pull : IndexSet \u0394' :=\n  mk (factorThruImage (\u03b8.unop \u226b A.e))\n#align simplicial_object.splitting.index_set.pull SimplicialObject.Splitting.IndexSet.pull\n\n@[reassoc]\ntheorem fac_pull : (A.pull \u03b8).e \u226b image.\u03b9 (\u03b8.unop \u226b A.e) = \u03b8.unop \u226b A.e :=\n  image.fac _\n#align simplicial_object.splitting.index_set.fac_pull SimplicialObject.Splitting.IndexSet.fac_pull\n\nend IndexSet\n\nvariable (N : \u2115 \u2192 C) (\u0394 : SimplexCategory\u1d52\u1d56) (X : SimplicialObject C) (\u03c6 : \u2200 n, N n \u27f6 X _[n])\n\n/-- Given a sequences of objects `N : \u2115 \u2192 C` in a category `C`, this is\na family of objects indexed by the elements `A : Splitting.IndexSet \u0394`.\nThe `\u0394`-simplices of a split simplicial objects shall identify to the\ncoproduct of objects in such a family. -/\n@[simp, nolint unusedArguments]\ndef summand (A : IndexSet \u0394) : C :=\n  N A.1.unop.len\n#align simplicial_object.splitting.summand SimplicialObject.Splitting.summand\n\n/-- The cofan for `summand N \u0394` induced by morphisms `N n \u27f6 X_ [n]` for all `n : \u2115`. -/\ndef cofan' (\u0394 : SimplexCategory\u1d52\u1d56) : Cofan (summand N \u0394) :=\n  Cofan.mk (X.obj \u0394) (fun A => \u03c6 A.1.unop.len \u226b X.map A.e.op)\n\nend Splitting\n\n--porting note (#5171): removed @[nolint has_nonempty_instance]\n/-- A splitting of a simplicial object `X` consists of the datum of a sequence\nof objects `N`, a sequence of morphisms `\u03b9 : N n \u27f6 X _[n]` such that\nfor all `\u0394 : SimplexCategory\u1d52\u1d56`, the canonical map `Splitting.map X \u03b9 \u0394`\nis an isomorphism. -/\nstructure Splitting (X : SimplicialObject C) where\n  /-- The \"nondegenerate simplices\" `N n` for all `n : \u2115`. -/\n  N : \u2115 \u2192 C\n  /-- The \"inclusion\" `N n \u27f6 X _[n]` for all `n : \u2115`. -/\n  \u03b9 : \u2200 n, N n \u27f6 X _[n]\n  /-- For each `\u0394`, `X.obj \u0394` identifies to the coproduct of the objects `N A.1.unop.len`\n  for all `A : IndexSet \u0394`.  -/\n  isColimit' : \u2200 \u0394 : SimplexCategory\u1d52\u1d56, IsColimit (Splitting.cofan' N X \u03b9 \u0394)\n#align simplicial_object.splitting SimplicialObject.Splitting\n\nnamespace Splitting\n\nvariable {X Y : SimplicialObject C} (s : Splitting X)\n\n/-- The cofan for `summand s.N \u0394` induced by a splitting of a simplicial object.  -/\ndef cofan (\u0394 : SimplexCategory\u1d52\u1d56) : Cofan (summand s.N \u0394) :=\n  Cofan.mk (X.obj \u0394) (fun A => s.\u03b9 A.1.unop.len \u226b X.map A.e.op)\n\n/-- The cofan `s.cofan \u0394` is colimit. -/\ndef isColimit (\u0394 : SimplexCategory\u1d52\u1d56) : IsColimit (s.cofan \u0394) := s.isColimit' \u0394\n\n@[reassoc]\ntheorem cofan_inj_eq {\u0394 : SimplexCategory\u1d52\u1d56} (A : IndexSet \u0394) :\n    (s.cofan \u0394).inj  A = s.\u03b9 A.1.unop.len \u226b X.map A.e.op := rfl\n#align simplicial_object.splitting.\u03b9_summand_eq SimplicialObject.Splitting.cofan_inj_eq\n\ntheorem cofan_inj_id (n : \u2115) : (s.cofan _).inj (IndexSet.id (op [n])) = s.\u03b9 n := by\n  erw [cofan_inj_eq, X.map_id, comp_id]\n  rfl\n#align simplicial_object.splitting.\u03b9_summand_id SimplicialObject.Splitting.cofan_inj_id\n\n/-- As it is stated in `Splitting.hom_ext`, a morphism `f : X \u27f6 Y` from a split\nsimplicial object to any simplicial object is determined by its restrictions\n`s.\u03c6 f n : s.N n \u27f6 Y _[n]` to the distinguished summands in each degree `n`. -/\n@[simp]\ndef \u03c6 (f : X \u27f6 Y) (n : \u2115) : s.N n \u27f6 Y _[n] :=\n  s.\u03b9 n \u226b f.app (op [n])\n#align simplicial_object.splitting.\u03c6 SimplicialObject.Splitting.\u03c6\n\n@[reassoc (attr := simp)]\ntheorem cofan_inj_comp_app (f : X \u27f6 Y) {\u0394 : SimplexCategory\u1d52\u1d56} (A : IndexSet \u0394) :\n    (s.cofan \u0394).inj A \u226b f.app \u0394 = s.\u03c6 f A.1.unop.len \u226b Y.map A.e.op := by\n  simp only [cofan_inj_eq_assoc, \u03c6, assoc]\n  erw [NatTrans.naturality]\n#align simplicial_object.splitting.\u03b9_summand_comp_app SimplicialObject.Splitting.cofan_inj_comp_app\n\ntheorem hom_ext' {Z : C} {\u0394 : SimplexCategory\u1d52\u1d56} (f g : X.obj \u0394 \u27f6 Z)\n    (h : \u2200 A : IndexSet \u0394, (s.cofan \u0394).inj A \u226b f = (s.cofan \u0394).inj A \u226b g) : f = g :=\n  Cofan.IsColimit.hom_ext (s.isColimit \u0394) _ _ h\n#align simplicial_object.splitting.hom_ext' SimplicialObject.Splitting.hom_ext'\n\ntheorem hom_ext (f g : X \u27f6 Y) (h : \u2200 n : \u2115, s.\u03c6 f n = s.\u03c6 g n) : f = g := by\n  ext \u0394\n  apply s.hom_ext'\n  intro A\n  induction' \u0394 using Opposite.rec with \u0394\n  induction' \u0394 using SimplexCategory.rec with n\n  dsimp\n  simp only [s.cofan_inj_comp_app, h]\n#align simplicial_object.splitting.hom_ext SimplicialObject.Splitting.hom_ext\n\n/-- The map `X.obj \u0394 \u27f6 Z` obtained by providing a family of morphisms on all the\nterms of decomposition given by a splitting `s : Splitting X`  -/\ndef desc {Z : C} (\u0394 : SimplexCategory\u1d52\u1d56) (F : \u2200 A : IndexSet \u0394, s.N A.1.unop.len \u27f6 Z) :\n    X.obj \u0394 \u27f6 Z :=\n  Cofan.IsColimit.desc (s.isColimit \u0394) F\n#align simplicial_object.splitting.desc SimplicialObject.Splitting.desc\n\n@[reassoc (attr := simp)]\ntheorem \u03b9_desc {Z : C} (\u0394 : SimplexCategory\u1d52\u1d56) (F : \u2200 A : IndexSet \u0394, s.N A.1.unop.len \u27f6 Z)\n    (A : IndexSet \u0394) : (s.cofan \u0394).inj A \u226b s.desc \u0394 F = F A := by\n  apply Cofan.IsColimit.fac\n#align simplicial_object.splitting.\u03b9_desc SimplicialObject.Splitting.\u03b9_desc\n\n/-- A simplicial object that is isomorphic to a split simplicial object is split. -/\n@[simps]\ndef ofIso (e : X \u2245 Y) : Splitting Y where\n  N := s.N\n  \u03b9 n := s.\u03b9 n \u226b e.hom.app (op [n])\n  isColimit' \u0394 := IsColimit.ofIsoColimit (s.isColimit \u0394 ) (Cofan.ext (e.app \u0394)\n    (fun A => by simp [cofan, cofan']))\n#align simplicial_object.splitting.of_iso SimplicialObject.Splitting.ofIso\n\n@[reassoc]\ntheorem cofan_inj_epi_naturality {\u0394\u2081 \u0394\u2082 : SimplexCategory\u1d52\u1d56} (A : IndexSet \u0394\u2081) (p : \u0394\u2081 \u27f6 \u0394\u2082)\n    [Epi p.unop] : (s.cofan \u0394\u2081).inj A \u226b X.map p = (s.cofan \u0394\u2082).inj (A.epiComp p) := by\n  dsimp [cofan]\n  rw [assoc, \u2190 X.map_comp]\n  rfl\n#align simplicial_object.splitting.\u03b9_summand_epi_naturality SimplicialObject.Splitting.cofan_inj_epi_naturality\n\nend Splitting\n\nvariable (C)\n\n-- porting note (#5171): removed @[nolint has_nonempty_instance]\n/-- The category `SimplicialObject.Split C` is the category of simplicial objects\nin `C` equipped with a splitting, and morphisms are morphisms of simplicial objects\nwhich are compatible with the splittings. -/\n@[ext]\nstructure Split where\n  /-- the underlying simplicial object -/\n  X : SimplicialObject C\n  /-- a splitting of the simplicial object -/\n  s : Splitting X\n#align simplicial_object.split SimplicialObject.Split\n\nnamespace Split\n\nvariable {C}\n\n/-- The object in `SimplicialObject.Split C` attached to a splitting `s : Splitting X`\nof a simplicial object `X`. -/\n@[simps]\ndef mk' {X : SimplicialObject C} (s : Splitting X) : Split C :=\n  \u27e8X, s\u27e9\n#align simplicial_object.split.mk' SimplicialObject.Split.mk'\n\n-- porting note (#5171): removed @[nolint has_nonempty_instance]\n/-- Morphisms in `SimplicialObject.Split C` are morphisms of simplicial objects that\nare compatible with the splittings. -/\nstructure Hom (S\u2081 S\u2082 : Split C) where\n  /-- the morphism between the underlying simplicial objects -/\n  F : S\u2081.X \u27f6 S\u2082.X\n  /-- the morphism between the \"nondegenerate\" `n`-simplices for all `n : \u2115` -/\n  f : \u2200 n : \u2115, S\u2081.s.N n \u27f6 S\u2082.s.N n\n  comm : \u2200 n : \u2115, S\u2081.s.\u03b9 n \u226b F.app (op [n]) = f n \u226b S\u2082.s.\u03b9 n := by aesop_cat\n#align simplicial_object.split.hom SimplicialObject.Split.Hom\n\n\n@[reassoc]\ntheorem cofan_inj_epi_naturality {\u0394\u2081 \u0394\u2082 : SimplexCategory\u1d52\u1d56} (A : IndexSet \u0394\u2081) (p : \u0394\u2081 \u27f6 \u0394\u2082)\n    [Epi p.unop] : (s.cofan \u0394\u2081).inj A \u226b X.map p = (s.cofan \u0394\u2082).inj (A.epiComp p)  := by\n  ext\n  simp [A.epiComp]\n", "allTactics": true, "theorems": true, "env": 0}

{"cmd": "theorem ext (A\u2081 A\u2082 : IndexSet \u0394) (h\u2081 : A\u2081.1 = A\u2082.1) (h\u2082 : A\u2081.e \u226b eqToHom (by rw [h\u2081]) = A\u2082.e) :\n    A\u2081 = A\u2082 := by\n  rcases A\u2081 with \u27e8\u0394\u2081, \u27e8\u03b1\u2081, h\u03b1\u2081\u27e9\u27e9\n  rcases A\u2082 with \u27e8\u0394\u2082, \u27e8\u03b1\u2082, h\u03b1\u2082\u27e9\u27e9\n  simp only at h\u2081\n  subst h\u2081\n  simp only [eqToHom_refl, comp_id, IndexSet.e] at h\u2082\n  simp only [h\u2082]\n#align simplicial_object.splitting.index_set.ext SimplicialObject.Splitting.IndexSet.ext\n\ninstance : Fintype (IndexSet \u0394) :=\n  Fintype.ofInjective\n    (fun A =>\n      \u27e8\u27e8A.1.unop.len, Nat.lt_succ_iff.mpr (len_le_of_epi (inferInstance : Epi A.e))\u27e9,\n        A.e.toOrderHom\u27e9 :\n      IndexSet \u0394 \u2192 Sigma fun k : Fin (\u0394.unop.len + 1) => Fin (\u0394.unop.len + 1) \u2192 Fin (k + 1))\n    (by\n      rintro \u27e8\u0394\u2081, \u03b1\u2081\u27e9 \u27e8\u0394\u2082, \u03b1\u2082\u27e9 h\u2081\n      induction' \u0394\u2081 using Opposite.rec with \u0394\u2081\n      induction' \u0394\u2082 using Opposite.rec with \u0394\u2082\n      simp only [unop_op, Sigma.mk.inj_iff, Fin.mk.injEq] at h\u2081\n      have h\u2082 : \u0394\u2081 = \u0394\u2082 := by\n        ext1\n        simpa only [Fin.mk_eq_mk] using h\u2081.1\n      subst h\u2082\n      refine ext _ _ rfl ?_\n      ext : 2\n      exact eq_of_heq h\u2081.2)\n\nvariable (\u0394)\n\n/-- The distinguished element in `Splitting.IndexSet \u0394` which corresponds to the\nidentity of `\u0394`. -/\n@[simps]\ndef id : IndexSet \u0394 :=\n  \u27e8\u0394, \u27e8\ud835\udfd9 _, by infer_instance\u27e9\u27e9\n#align simplicial_object.splitting.index_set.id SimplicialObject.Splitting.IndexSet.id\n\ninstance : Inhabited (IndexSet \u0394) :=\n  \u27e8id \u0394\u27e9\n\nvariable {\u0394}\n\n/-- The condition that an element `Splitting.IndexSet \u0394` is the distinguished\nelement `Splitting.IndexSet.Id \u0394`. -/\n@[simp]\ndef EqId : Prop :=\n  A = id _\n#align simplicial_object.splitting.index_set.eq_id SimplicialObject.Splitting.IndexSet.EqId\n\ntheorem eqId_iff_eq : A.EqId \u2194 A.1 = \u0394 := by\n  constructor\n  \u00b7 intro h\n    dsimp at h\n    rw [h]\n    rfl\n  \u00b7 intro h\n    rcases A with \u27e8_, \u27e8f, hf\u27e9\u27e9\n    simp only at h\n    subst h\n    refine ext _ _ rfl ?_\n    haveI := hf\n    simp only [eqToHom_refl, comp_id]\n    exact eq_id_of_epi f\n#align simplicial_object.splitting.index_set.eq_id_iff_eq SimplicialObject.Splitting.IndexSet.eqId_iff_eq\n\ntheorem eqId_iff_len_eq : A.EqId \u2194 A.1.unop.len = \u0394.unop.len := by\n  rw [eqId_iff_eq]\n  constructor\n  \u00b7 intro h\n    rw [h]\n  \u00b7 intro h\n    rw [\u2190 unop_inj_iff]\n    ext\n    exact h\n#align simplicial_object.splitting.index_set.eq_id_iff_len_eq SimplicialObject.Splitting.IndexSet.eqId_iff_len_eq\n\ntheorem eqId_iff_len_le : A.EqId \u2194 \u0394.unop.len \u2264 A.1.unop.len := by\n  rw [eqId_iff_len_eq]\n  constructor\n  \u00b7 intro h\n    rw [h]\n  \u00b7 exact le_antisymm (len_le_of_epi (inferInstance : Epi A.e))\n#align simplicial_object.splitting.index_set.eq_id_iff_len_le SimplicialObject.Splitting.IndexSet.eqId_iff_len_le\n\ntheorem eqId_iff_mono : A.EqId \u2194 Mono A.e := by\n  constructor\n  \u00b7 intro h\n    dsimp at h\n    subst h\n    dsimp only [id, e]\n    infer_instance\n  \u00b7 intro h\n    rw [eqId_iff_len_le]\n    exact len_le_of_mono h\n#align simplicial_object.splitting.index_set.eq_id_iff_mono SimplicialObject.Splitting.IndexSet.eqId_iff_mono\n\n/-- Given `A : IndexSet \u0394\u2081`, if `p.unop : unop \u0394\u2082 \u27f6 unop \u0394\u2081` is an epi, this\nis the obvious element in `A : IndexSet \u0394\u2082` associated to the composition\nof epimorphisms `p.unop \u226b A.e`. -/\n@[simps]\ndef epiComp {\u0394\u2081 \u0394\u2082 : SimplexCategory\u1d52\u1d56} (A : IndexSet \u0394\u2081) (p : \u0394\u2081 \u27f6 \u0394\u2082) [Epi p.unop] :\n    IndexSet \u0394\u2082 :=\n  \u27e8A.1, \u27e8p.unop \u226b A.e, epi_comp _ _\u27e9\u27e9\n#align simplicial_object.splitting.index_set.epi_comp SimplicialObject.Splitting.IndexSet.epiComp\n\n\nvariable {\u0394' : SimplexCategory\u1d52\u1d56} (\u03b8 : \u0394 \u27f6 \u0394')\n\n/-- When `A : IndexSet \u0394` and `\u03b8 : \u0394 \u2192 \u0394'` is a morphism in `SimplexCategory\u1d52\u1d56`,\nan element in `IndexSet \u0394'` can be defined by using the epi-mono factorisation\nof `\u03b8.unop \u226b A.e`. -/\ndef pull : IndexSet \u0394' :=\n  mk (factorThruImage (\u03b8.unop \u226b A.e))\n#align simplicial_object.splitting.index_set.pull SimplicialObject.Splitting.IndexSet.pull\n\n@[reassoc]\ntheorem fac_pull : (A.pull \u03b8).e \u226b image.\u03b9 (\u03b8.unop \u226b A.e) = \u03b8.unop \u226b A.e :=\n  image.fac _\n#align simplicial_object.splitting.index_set.fac_pull SimplicialObject.Splitting.IndexSet.fac_pull\n\nend IndexSet\n\nvariable (N : \u2115 \u2192 C) (\u0394 : SimplexCategory\u1d52\u1d56) (X : SimplicialObject C) (\u03c6 : \u2200 n, N n \u27f6 X _[n])\n\n/-- Given a sequences of objects `N : \u2115 \u2192 C` in a category `C`, this is\na family of objects indexed by the elements `A : Splitting.IndexSet \u0394`.\nThe `\u0394`-simplices of a split simplicial objects shall identify to the\ncoproduct of objects in such a family. -/\n@[simp, nolint unusedArguments]\ndef summand (A : IndexSet \u0394) : C :=\n  N A.1.unop.len\n#align simplicial_object.splitting.summand SimplicialObject.Splitting.summand\n\n/-- The cofan for `summand N \u0394` induced by morphisms `N n \u27f6 X_ [n]` for all `n : \u2115`. -/\ndef cofan' (\u0394 : SimplexCategory\u1d52\u1d56) : Cofan (summand N \u0394) :=\n  Cofan.mk (X.obj \u0394) (fun A => \u03c6 A.1.unop.len \u226b X.map A.e.op)\n\nend Splitting\n\n--porting note (#5171): removed @[nolint has_nonempty_instance]\n/-- A splitting of a simplicial object `X` consists of the datum of a sequence\nof objects `N`, a sequence of morphisms `\u03b9 : N n \u27f6 X _[n]` such that\nfor all `\u0394 : SimplexCategory\u1d52\u1d56`, the canonical map `Splitting.map X \u03b9 \u0394`\nis an isomorphism. -/\nstructure Splitting (X : SimplicialObject C) where\n  /-- The \"nondegenerate simplices\" `N n` for all `n : \u2115`. -/\n  N : \u2115 \u2192 C\n  /-- The \"inclusion\" `N n \u27f6 X _[n]` for all `n : \u2115`. -/\n  \u03b9 : \u2200 n, N n \u27f6 X _[n]\n  /-- For each `\u0394`, `X.obj \u0394` identifies to the coproduct of the objects `N A.1.unop.len`\n  for all `A : IndexSet \u0394`.  -/\n  isColimit' : \u2200 \u0394 : SimplexCategory\u1d52\u1d56, IsColimit (Splitting.cofan' N X \u03b9 \u0394)\n#align simplicial_object.splitting SimplicialObject.Splitting\n\nnamespace Splitting\n\nvariable {X Y : SimplicialObject C} (s : Splitting X)\n\n/-- The cofan for `summand s.N \u0394` induced by a splitting of a simplicial object.  -/\ndef cofan (\u0394 : SimplexCategory\u1d52\u1d56) : Cofan (summand s.N \u0394) :=\n  Cofan.mk (X.obj \u0394) (fun A => s.\u03b9 A.1.unop.len \u226b X.map A.e.op)\n\n/-- The cofan `s.cofan \u0394` is colimit. -/\ndef isColimit (\u0394 : SimplexCategory\u1d52\u1d56) : IsColimit (s.cofan \u0394) := s.isColimit' \u0394\n\n@[reassoc]\ntheorem cofan_inj_eq {\u0394 : SimplexCategory\u1d52\u1d56} (A : IndexSet \u0394) :\n    (s.cofan \u0394).inj  A = s.\u03b9 A.1.unop.len \u226b X.map A.e.op := rfl\n#align simplicial_object.splitting.\u03b9_summand_eq SimplicialObject.Splitting.cofan_inj_eq\n\ntheorem cofan_inj_id (n : \u2115) : (s.cofan _).inj (IndexSet.id (op [n])) = s.\u03b9 n := by\n  erw [cofan_inj_eq, X.map_id, comp_id]\n  rfl\n#align simplicial_object.splitting.\u03b9_summand_id SimplicialObject.Splitting.cofan_inj_id\n\n/-- As it is stated in `Splitting.hom_ext`, a morphism `f : X \u27f6 Y` from a split\nsimplicial object to any simplicial object is determined by its restrictions\n`s.\u03c6 f n : s.N n \u27f6 Y _[n]` to the distinguished summands in each degree `n`. -/\n@[simp]\ndef \u03c6 (f : X \u27f6 Y) (n : \u2115) : s.N n \u27f6 Y _[n] :=\n  s.\u03b9 n \u226b f.app (op [n])\n#align simplicial_object.splitting.\u03c6 SimplicialObject.Splitting.\u03c6\n\n@[reassoc (attr := simp)]\ntheorem cofan_inj_comp_app (f : X \u27f6 Y) {\u0394 : SimplexCategory\u1d52\u1d56} (A : IndexSet \u0394) :\n    (s.cofan \u0394).inj A \u226b f.app \u0394 = s.\u03c6 f A.1.unop.len \u226b Y.map A.e.op := by\n  simp only [cofan_inj_eq_assoc, \u03c6, assoc]\n  erw [NatTrans.naturality]\n#align simplicial_object.splitting.\u03b9_summand_comp_app SimplicialObject.Splitting.cofan_inj_comp_app\n\ntheorem hom_ext' {Z : C} {\u0394 : SimplexCategory\u1d52\u1d56} (f g : X.obj \u0394 \u27f6 Z)\n    (h : \u2200 A : IndexSet \u0394, (s.cofan \u0394).inj A \u226b f = (s.cofan \u0394).inj A \u226b g) : f = g :=\n  Cofan.IsColimit.hom_ext (s.isColimit \u0394) _ _ h\n#align simplicial_object.splitting.hom_ext' SimplicialObject.Splitting.hom_ext'\n\ntheorem hom_ext (f g : X \u27f6 Y) (h : \u2200 n : \u2115, s.\u03c6 f n = s.\u03c6 g n) : f = g := by\n  ext \u0394\n  apply s.hom_ext'\n  intro A\n  induction' \u0394 using Opposite.rec with \u0394\n  induction' \u0394 using SimplexCategory.rec with n\n  dsimp\n  simp only [s.cofan_inj_comp_app, h]\n#align simplicial_object.splitting.hom_ext SimplicialObject.Splitting.hom_ext\n\n/-- The map `X.obj \u0394 \u27f6 Z` obtained by providing a family of morphisms on all the\nterms of decomposition given by a splitting `s : Splitting X`  -/\ndef desc {Z : C} (\u0394 : SimplexCategory\u1d52\u1d56) (F : \u2200 A : IndexSet \u0394, s.N A.1.unop.len \u27f6 Z) :\n    X.obj \u0394 \u27f6 Z :=\n  Cofan.IsColimit.desc (s.isColimit \u0394) F\n#align simplicial_object.splitting.desc SimplicialObject.Splitting.desc\n\n@[reassoc (attr := simp)]\ntheorem \u03b9_desc {Z : C} (\u0394 : SimplexCategory\u1d52\u1d56) (F : \u2200 A : IndexSet \u0394, s.N A.1.unop.len \u27f6 Z)\n    (A : IndexSet \u0394) : (s.cofan \u0394).inj A \u226b s.desc \u0394 F = F A := by\n  apply Cofan.IsColimit.fac\n#align simplicial_object.splitting.\u03b9_desc SimplicialObject.Splitting.\u03b9_desc\n\n/-- A simplicial object that is isomorphic to a split simplicial object is split. -/\n@[simps]\ndef ofIso (e : X \u2245 Y) : Splitting Y where\n  N := s.N\n  \u03b9 n := s.\u03b9 n \u226b e.hom.app (op [n])\n  isColimit' \u0394 := IsColimit.ofIsoColimit (s.isColimit \u0394 ) (Cofan.ext (e.app \u0394)\n    (fun A => by simp [cofan, cofan']))\n#align simplicial_object.splitting.of_iso SimplicialObject.Splitting.ofIso\n\n@[reassoc]\ntheorem cofan_inj_epi_naturality {\u0394\u2081 \u0394\u2082 : SimplexCategory\u1d52\u1d56} (A : IndexSet \u0394\u2081) (p : \u0394\u2081 \u27f6 \u0394\u2082)\n    [Epi p.unop] : (s.cofan \u0394\u2081).inj A \u226b X.map p = (s.cofan \u0394\u2082).inj (A.epiComp p) := by\n  dsimp [cofan]\n  rw [assoc, \u2190 X.map_comp]\n  rfl\n#align simplicial_object.splitting.\u03b9_summand_epi_naturality SimplicialObject.Splitting.cofan_inj_epi_naturality\n\nend Splitting\n\nvariable (C)\n\n-- porting note (#5171): removed @[nolint has_nonempty_instance]\n/-- The category `SimplicialObject.Split C` is the category of simplicial objects\nin `C` equipped with a splitting, and morphisms are morphisms of simplicial objects\nwhich are compatible with the splittings. -/\n@[ext]\nstructure Split where\n  /-- the underlying simplicial object -/\n  X : SimplicialObject C\n  /-- a splitting of the simplicial object -/\n  s : Splitting X\n#align simplicial_object.split SimplicialObject.Split\n\nnamespace Split\n\nvariable {C}\n\n/-- The object in `SimplicialObject.Split C` attached to a splitting `s : Splitting X`\nof a simplicial object `X`. -/\n@[simps]\ndef mk' {X : SimplicialObject C} (s : Splitting X) : Split C :=\n  \u27e8X, s\u27e9\n#align simplicial_object.split.mk' SimplicialObject.Split.mk'\n\n-- porting note (#5171): removed @[nolint has_nonempty_instance]\n/-- Morphisms in `SimplicialObject.Split C` are morphisms of simplicial objects that\nare compatible with the splittings. -/\nstructure Hom (S\u2081 S\u2082 : Split C) where\n  /-- the morphism between the underlying simplicial objects -/\n  F : S\u2081.X \u27f6 S\u2082.X\n  /-- the morphism between the \"nondegenerate\" `n`-simplices for all `n : \u2115` -/\n  f : \u2200 n : \u2115, S\u2081.s.N n \u27f6 S\u2082.s.N n\n  comm : \u2200 n : \u2115, S\u2081.s.\u03b9 n \u226b F.app (op [n]) = f n \u226b S\u2082.s.\u03b9 n := by aesop_cat\n#align simplicial_object.split.hom SimplicialObject.Split.Hom\n\n\n@[reassoc]\ntheorem cofan_inj_epi_naturality {\u0394\u2081 \u0394\u2082 : SimplexCategory\u1d52\u1d56} (A : IndexSet \u0394\u2081) (p : \u0394\u2081 \u27f6 \u0394\u2082)\n    [Epi p.unop] : (s.cofan \u0394\u2081).inj A \u226b X.map p = (s.cofan \u0394\u2082).inj (A.epiComp p)  := by\n  dsimp [cofan]\n  simp only [assoc, X.map_comp]\n", "allTactics": true, "theorems": true, "env": 0}

{"cmd": "theorem ext (A\u2081 A\u2082 : IndexSet \u0394) (h\u2081 : A\u2081.1 = A\u2082.1) (h\u2082 : A\u2081.e \u226b eqToHom (by rw [h\u2081]) = A\u2082.e) :\n    A\u2081 = A\u2082 := by\n  rcases A\u2081 with \u27e8\u0394\u2081, \u27e8\u03b1\u2081, h\u03b1\u2081\u27e9\u27e9\n  rcases A\u2082 with \u27e8\u0394\u2082, \u27e8\u03b1\u2082, h\u03b1\u2082\u27e9\u27e9\n  simp only at h\u2081\n  subst h\u2081\n  simp only [eqToHom_refl, comp_id, IndexSet.e] at h\u2082\n  simp only [h\u2082]\n#align simplicial_object.splitting.index_set.ext SimplicialObject.Splitting.IndexSet.ext\n\ninstance : Fintype (IndexSet \u0394) :=\n  Fintype.ofInjective\n    (fun A =>\n      \u27e8\u27e8A.1.unop.len, Nat.lt_succ_iff.mpr (len_le_of_epi (inferInstance : Epi A.e))\u27e9,\n        A.e.toOrderHom\u27e9 :\n      IndexSet \u0394 \u2192 Sigma fun k : Fin (\u0394.unop.len + 1) => Fin (\u0394.unop.len + 1) \u2192 Fin (k + 1))\n    (by\n      rintro \u27e8\u0394\u2081, \u03b1\u2081\u27e9 \u27e8\u0394\u2082, \u03b1\u2082\u27e9 h\u2081\n      induction' \u0394\u2081 using Opposite.rec with \u0394\u2081\n      induction' \u0394\u2082 using Opposite.rec with \u0394\u2082\n      simp only [unop_op, Sigma.mk.inj_iff, Fin.mk.injEq] at h\u2081\n      have h\u2082 : \u0394\u2081 = \u0394\u2082 := by\n        ext1\n        simpa only [Fin.mk_eq_mk] using h\u2081.1\n      subst h\u2082\n      refine ext _ _ rfl ?_\n      ext : 2\n      exact eq_of_heq h\u2081.2)\n\nvariable (\u0394)\n\n/-- The distinguished element in `Splitting.IndexSet \u0394` which corresponds to the\nidentity of `\u0394`. -/\n@[simps]\ndef id : IndexSet \u0394 :=\n  \u27e8\u0394, \u27e8\ud835\udfd9 _, by infer_instance\u27e9\u27e9\n#align simplicial_object.splitting.index_set.id SimplicialObject.Splitting.IndexSet.id\n\ninstance : Inhabited (IndexSet \u0394) :=\n  \u27e8id \u0394\u27e9\n\nvariable {\u0394}\n\n/-- The condition that an element `Splitting.IndexSet \u0394` is the distinguished\nelement `Splitting.IndexSet.Id \u0394`. -/\n@[simp]\ndef EqId : Prop :=\n  A = id _\n#align simplicial_object.splitting.index_set.eq_id SimplicialObject.Splitting.IndexSet.EqId\n\ntheorem eqId_iff_eq : A.EqId \u2194 A.1 = \u0394 := by\n  constructor\n  \u00b7 intro h\n    dsimp at h\n    rw [h]\n    rfl\n  \u00b7 intro h\n    rcases A with \u27e8_, \u27e8f, hf\u27e9\u27e9\n    simp only at h\n    subst h\n    refine ext _ _ rfl ?_\n    haveI := hf\n    simp only [eqToHom_refl, comp_id]\n    exact eq_id_of_epi f\n#align simplicial_object.splitting.index_set.eq_id_iff_eq SimplicialObject.Splitting.IndexSet.eqId_iff_eq\n\ntheorem eqId_iff_len_eq : A.EqId \u2194 A.1.unop.len = \u0394.unop.len := by\n  rw [eqId_iff_eq]\n  constructor\n  \u00b7 intro h\n    rw [h]\n  \u00b7 intro h\n    rw [\u2190 unop_inj_iff]\n    ext\n    exact h\n#align simplicial_object.splitting.index_set.eq_id_iff_len_eq SimplicialObject.Splitting.IndexSet.eqId_iff_len_eq\n\ntheorem eqId_iff_len_le : A.EqId \u2194 \u0394.unop.len \u2264 A.1.unop.len := by\n  rw [eqId_iff_len_eq]\n  constructor\n  \u00b7 intro h\n    rw [h]\n  \u00b7 exact le_antisymm (len_le_of_epi (inferInstance : Epi A.e))\n#align simplicial_object.splitting.index_set.eq_id_iff_len_le SimplicialObject.Splitting.IndexSet.eqId_iff_len_le\n\ntheorem eqId_iff_mono : A.EqId \u2194 Mono A.e := by\n  constructor\n  \u00b7 intro h\n    dsimp at h\n    subst h\n    dsimp only [id, e]\n    infer_instance\n  \u00b7 intro h\n    rw [eqId_iff_len_le]\n    exact len_le_of_mono h\n#align simplicial_object.splitting.index_set.eq_id_iff_mono SimplicialObject.Splitting.IndexSet.eqId_iff_mono\n\n/-- Given `A : IndexSet \u0394\u2081`, if `p.unop : unop \u0394\u2082 \u27f6 unop \u0394\u2081` is an epi, this\nis the obvious element in `A : IndexSet \u0394\u2082` associated to the composition\nof epimorphisms `p.unop \u226b A.e`. -/\n@[simps]\ndef epiComp {\u0394\u2081 \u0394\u2082 : SimplexCategory\u1d52\u1d56} (A : IndexSet \u0394\u2081) (p : \u0394\u2081 \u27f6 \u0394\u2082) [Epi p.unop] :\n    IndexSet \u0394\u2082 :=\n  \u27e8A.1, \u27e8p.unop \u226b A.e, epi_comp _ _\u27e9\u27e9\n#align simplicial_object.splitting.index_set.epi_comp SimplicialObject.Splitting.IndexSet.epiComp\n\n\nvariable {\u0394' : SimplexCategory\u1d52\u1d56} (\u03b8 : \u0394 \u27f6 \u0394')\n\n/-- When `A : IndexSet \u0394` and `\u03b8 : \u0394 \u2192 \u0394'` is a morphism in `SimplexCategory\u1d52\u1d56`,\nan element in `IndexSet \u0394'` can be defined by using the epi-mono factorisation\nof `\u03b8.unop \u226b A.e`. -/\ndef pull : IndexSet \u0394' :=\n  mk (factorThruImage (\u03b8.unop \u226b A.e))\n#align simplicial_object.splitting.index_set.pull SimplicialObject.Splitting.IndexSet.pull\n\n@[reassoc]\ntheorem fac_pull : (A.pull \u03b8).e \u226b image.\u03b9 (\u03b8.unop \u226b A.e) = \u03b8.unop \u226b A.e :=\n  image.fac _\n#align simplicial_object.splitting.index_set.fac_pull SimplicialObject.Splitting.IndexSet.fac_pull\n\nend IndexSet\n\nvariable (N : \u2115 \u2192 C) (\u0394 : SimplexCategory\u1d52\u1d56) (X : SimplicialObject C) (\u03c6 : \u2200 n, N n \u27f6 X _[n])\n\n/-- Given a sequences of objects `N : \u2115 \u2192 C` in a category `C`, this is\na family of objects indexed by the elements `A : Splitting.IndexSet \u0394`.\nThe `\u0394`-simplices of a split simplicial objects shall identify to the\ncoproduct of objects in such a family. -/\n@[simp, nolint unusedArguments]\ndef summand (A : IndexSet \u0394) : C :=\n  N A.1.unop.len\n#align simplicial_object.splitting.summand SimplicialObject.Splitting.summand\n\n/-- The cofan for `summand N \u0394` induced by morphisms `N n \u27f6 X_ [n]` for all `n : \u2115`. -/\ndef cofan' (\u0394 : SimplexCategory\u1d52\u1d56) : Cofan (summand N \u0394) :=\n  Cofan.mk (X.obj \u0394) (fun A => \u03c6 A.1.unop.len \u226b X.map A.e.op)\n\nend Splitting\n\n--porting note (#5171): removed @[nolint has_nonempty_instance]\n/-- A splitting of a simplicial object `X` consists of the datum of a sequence\nof objects `N`, a sequence of morphisms `\u03b9 : N n \u27f6 X _[n]` such that\nfor all `\u0394 : SimplexCategory\u1d52\u1d56`, the canonical map `Splitting.map X \u03b9 \u0394`\nis an isomorphism. -/\nstructure Splitting (X : SimplicialObject C) where\n  /-- The \"nondegenerate simplices\" `N n` for all `n : \u2115`. -/\n  N : \u2115 \u2192 C\n  /-- The \"inclusion\" `N n \u27f6 X _[n]` for all `n : \u2115`. -/\n  \u03b9 : \u2200 n, N n \u27f6 X _[n]\n  /-- For each `\u0394`, `X.obj \u0394` identifies to the coproduct of the objects `N A.1.unop.len`\n  for all `A : IndexSet \u0394`.  -/\n  isColimit' : \u2200 \u0394 : SimplexCategory\u1d52\u1d56, IsColimit (Splitting.cofan' N X \u03b9 \u0394)\n#align simplicial_object.splitting SimplicialObject.Splitting\n\nnamespace Splitting\n\nvariable {X Y : SimplicialObject C} (s : Splitting X)\n\n/-- The cofan for `summand s.N \u0394` induced by a splitting of a simplicial object.  -/\ndef cofan (\u0394 : SimplexCategory\u1d52\u1d56) : Cofan (summand s.N \u0394) :=\n  Cofan.mk (X.obj \u0394) (fun A => s.\u03b9 A.1.unop.len \u226b X.map A.e.op)\n\n/-- The cofan `s.cofan \u0394` is colimit. -/\ndef isColimit (\u0394 : SimplexCategory\u1d52\u1d56) : IsColimit (s.cofan \u0394) := s.isColimit' \u0394\n\n@[reassoc]\ntheorem cofan_inj_eq {\u0394 : SimplexCategory\u1d52\u1d56} (A : IndexSet \u0394) :\n    (s.cofan \u0394).inj  A = s.\u03b9 A.1.unop.len \u226b X.map A.e.op := rfl\n#align simplicial_object.splitting.\u03b9_summand_eq SimplicialObject.Splitting.cofan_inj_eq\n\ntheorem cofan_inj_id (n : \u2115) : (s.cofan _).inj (IndexSet.id (op [n])) = s.\u03b9 n := by\n  erw [cofan_inj_eq, X.map_id, comp_id]\n  rfl\n#align simplicial_object.splitting.\u03b9_summand_id SimplicialObject.Splitting.cofan_inj_id\n\n/-- As it is stated in `Splitting.hom_ext`, a morphism `f : X \u27f6 Y` from a split\nsimplicial object to any simplicial object is determined by its restrictions\n`s.\u03c6 f n : s.N n \u27f6 Y _[n]` to the distinguished summands in each degree `n`. -/\n@[simp]\ndef \u03c6 (f : X \u27f6 Y) (n : \u2115) : s.N n \u27f6 Y _[n] :=\n  s.\u03b9 n \u226b f.app (op [n])\n#align simplicial_object.splitting.\u03c6 SimplicialObject.Splitting.\u03c6\n\n@[reassoc (attr := simp)]\ntheorem cofan_inj_comp_app (f : X \u27f6 Y) {\u0394 : SimplexCategory\u1d52\u1d56} (A : IndexSet \u0394) :\n    (s.cofan \u0394).inj A \u226b f.app \u0394 = s.\u03c6 f A.1.unop.len \u226b Y.map A.e.op := by\n  simp only [cofan_inj_eq_assoc, \u03c6, assoc]\n  erw [NatTrans.naturality]\n#align simplicial_object.splitting.\u03b9_summand_comp_app SimplicialObject.Splitting.cofan_inj_comp_app\n\ntheorem hom_ext' {Z : C} {\u0394 : SimplexCategory\u1d52\u1d56} (f g : X.obj \u0394 \u27f6 Z)\n    (h : \u2200 A : IndexSet \u0394, (s.cofan \u0394).inj A \u226b f = (s.cofan \u0394).inj A \u226b g) : f = g :=\n  Cofan.IsColimit.hom_ext (s.isColimit \u0394) _ _ h\n#align simplicial_object.splitting.hom_ext' SimplicialObject.Splitting.hom_ext'\n\ntheorem hom_ext (f g : X \u27f6 Y) (h : \u2200 n : \u2115, s.\u03c6 f n = s.\u03c6 g n) : f = g := by\n  ext \u0394\n  apply s.hom_ext'\n  intro A\n  induction' \u0394 using Opposite.rec with \u0394\n  induction' \u0394 using SimplexCategory.rec with n\n  dsimp\n  simp only [s.cofan_inj_comp_app, h]\n#align simplicial_object.splitting.hom_ext SimplicialObject.Splitting.hom_ext\n\n/-- The map `X.obj \u0394 \u27f6 Z` obtained by providing a family of morphisms on all the\nterms of decomposition given by a splitting `s : Splitting X`  -/\ndef desc {Z : C} (\u0394 : SimplexCategory\u1d52\u1d56) (F : \u2200 A : IndexSet \u0394, s.N A.1.unop.len \u27f6 Z) :\n    X.obj \u0394 \u27f6 Z :=\n  Cofan.IsColimit.desc (s.isColimit \u0394) F\n#align simplicial_object.splitting.desc SimplicialObject.Splitting.desc\n\n@[reassoc (attr := simp)]\ntheorem \u03b9_desc {Z : C} (\u0394 : SimplexCategory\u1d52\u1d56) (F : \u2200 A : IndexSet \u0394, s.N A.1.unop.len \u27f6 Z)\n    (A : IndexSet \u0394) : (s.cofan \u0394).inj A \u226b s.desc \u0394 F = F A := by\n  apply Cofan.IsColimit.fac\n#align simplicial_object.splitting.\u03b9_desc SimplicialObject.Splitting.\u03b9_desc\n\n/-- A simplicial object that is isomorphic to a split simplicial object is split. -/\n@[simps]\ndef ofIso (e : X \u2245 Y) : Splitting Y where\n  N := s.N\n  \u03b9 n := s.\u03b9 n \u226b e.hom.app (op [n])\n  isColimit' \u0394 := IsColimit.ofIsoColimit (s.isColimit \u0394 ) (Cofan.ext (e.app \u0394)\n    (fun A => by simp [cofan, cofan']))\n#align simplicial_object.splitting.of_iso SimplicialObject.Splitting.ofIso\n\n@[reassoc]\ntheorem cofan_inj_epi_naturality {\u0394\u2081 \u0394\u2082 : SimplexCategory\u1d52\u1d56} (A : IndexSet \u0394\u2081) (p : \u0394\u2081 \u27f6 \u0394\u2082)\n    [Epi p.unop] : (s.cofan \u0394\u2081).inj A \u226b X.map p = (s.cofan \u0394\u2082).inj (A.epiComp p) := by\n  dsimp [cofan]\n  rw [assoc, \u2190 X.map_comp]\n  rfl\n#align simplicial_object.splitting.\u03b9_summand_epi_naturality SimplicialObject.Splitting.cofan_inj_epi_naturality\n\nend Splitting\n\nvariable (C)\n\n-- porting note (#5171): removed @[nolint has_nonempty_instance]\n/-- The category `SimplicialObject.Split C` is the category of simplicial objects\nin `C` equipped with a splitting, and morphisms are morphisms of simplicial objects\nwhich are compatible with the splittings. -/\n@[ext]\nstructure Split where\n  /-- the underlying simplicial object -/\n  X : SimplicialObject C\n  /-- a splitting of the simplicial object -/\n  s : Splitting X\n#align simplicial_object.split SimplicialObject.Split\n\nnamespace Split\n\nvariable {C}\n\n/-- The object in `SimplicialObject.Split C` attached to a splitting `s : Splitting X`\nof a simplicial object `X`. -/\n@[simps]\ndef mk' {X : SimplicialObject C} (s : Splitting X) : Split C :=\n  \u27e8X, s\u27e9\n#align simplicial_object.split.mk' SimplicialObject.Split.mk'\n\n-- porting note (#5171): removed @[nolint has_nonempty_instance]\n/-- Morphisms in `SimplicialObject.Split C` are morphisms of simplicial objects that\nare compatible with the splittings. -/\nstructure Hom (S\u2081 S\u2082 : Split C) where\n  /-- the morphism between the underlying simplicial objects -/\n  F : S\u2081.X \u27f6 S\u2082.X\n  /-- the morphism between the \"nondegenerate\" `n`-simplices for all `n : \u2115` -/\n  f : \u2200 n : \u2115, S\u2081.s.N n \u27f6 S\u2082.s.N n\n  comm : \u2200 n : \u2115, S\u2081.s.\u03b9 n \u226b F.app (op [n]) = f n \u226b S\u2082.s.\u03b9 n := by aesop_cat\n#align simplicial_object.split.hom SimplicialObject.Split.Hom\n\n\n@[reassoc]\ntheorem cofan_inj_epi_naturality {\u0394\u2081 \u0394\u2082 : SimplexCategory\u1d52\u1d56} (A : IndexSet \u0394\u2081) (p : \u0394\u2081 \u27f6 \u0394\u2082)\n    [Epi p.unop] : (s.cofan \u0394\u2081).inj A \u226b X.map p = (s.cofan \u0394\u2082).inj (A.epiComp p)  := by\n  dsimp [cofan, IndexSet.epiComp]\n  rw [assoc, \u2190 X.map_comp]\n", "allTactics": true, "theorems": true, "env": 0}