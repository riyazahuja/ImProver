{"cmd": "/-\nCopyright (c) 2022 Jo\u00ebl Riou. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Jo\u00ebl Riou\n-/\nimport Mathlib.AlgebraicTopology.DoldKan.Decomposition\nimport Mathlib.Tactic.FinCases\n\n#align_import algebraic_topology.dold_kan.degeneracies from \"leanprover-community/mathlib\"@\"32a7e535287f9c73f2e4d2aef306a39190f0b504\"\n\n/-!\n\n# Behaviour of P_infty with respect to degeneracies\n\nFor any `X : SimplicialObject C` where `C` is an abelian category,\nthe projector `PInfty : K[X] \u27f6 K[X]` is supposed to be the projection\non the normalized subcomplex, parallel to the degenerate subcomplex, i.e.\nthe subcomplex generated by the images of all `X.\u03c3 i`.\n\nIn this file, we obtain `degeneracy_comp_P_infty` which states that\nif `X : SimplicialObject C` with `C` a preadditive category,\n`\u03b8 : [n] \u27f6 \u0394'` is a non injective map in `SimplexCategory`, then\n`X.map \u03b8.op \u226b P_infty.f n = 0`. It follows from the more precise\nstatement vanishing statement `\u03c3_comp_P_eq_zero` for the `P q`.\n\n(See `Equivalence.lean` for the general strategy of proof of the Dold-Kan equivalence.)\n\n-/\n\n\nopen CategoryTheory CategoryTheory.Category CategoryTheory.Limits\n  CategoryTheory.Preadditive Simplicial\n\nnamespace AlgebraicTopology\n\nnamespace DoldKan\n\nvariable {C : Type*} [Category C] [Preadditive C]\n"}

{"cmd": "theorem HigherFacesVanish.comp_\u03c3 {Y : C} {X : SimplicialObject C} {n b q : \u2115} {\u03c6 : Y \u27f6 X _[n + 1]}\n    (v : HigherFacesVanish q \u03c6) (hnbq : n + 1 = b + q) :\n    HigherFacesVanish q\n      (\u03c6 \u226b\n        X.\u03c3 \u27e8b, by\n          simp only [hnbq, Nat.lt_add_one_iff, le_add_iff_nonneg_right, zero_le]\u27e9) :=\n  fun j hj => by\n  rw [assoc, SimplicialObject.\u03b4_comp_\u03c3_of_gt', Fin.pred_succ, v.comp_\u03b4_eq_zero_assoc _ _ hj,\n    zero_comp]\n  \u00b7 dsimp\n    rw [Fin.lt_iff_val_lt_val, Fin.val_succ]\n    linarith\n  \u00b7 intro hj'\n    simp only [hnbq, add_comm b, add_assoc, hj', Fin.val_zero, zero_add, add_le_iff_nonpos_right,\n      nonpos_iff_eq_zero, add_eq_zero, false_and] at hj\n#align algebraic_topology.dold_kan.higher_faces_vanish.comp_\u03c3 AlgebraicTopology.DoldKan.HigherFacesVanish.comp_\u03c3\n\ntheorem \u03c3_comp_P_eq_zero (X : SimplicialObject C) {n q : \u2115} (i : Fin (n + 1)) (hi : n + 1 \u2264 i + q) :\n    X.\u03c3 i \u226b (P q).f (n + 1) = 0 := by\n  revert i hi\n  induction' q with q hq\n  \u00b7 intro i (hi : n + 1 \u2264 i)\n    exfalso\n    linarith [Fin.is_lt i]\n  \u00b7 intro i (hi : n + 1 \u2264 i + q + 1)\n    by_cases h : n + 1 \u2264 (i : \u2115) + q\n    \u00b7 rw [P_succ, HomologicalComplex.comp_f, \u2190 assoc, hq i h, zero_comp]\n    \u00b7 replace hi : n = i + q := by\n        obtain \u27e8j, hj\u27e9 := le_iff_exists_add.mp hi\n        rw [\u2190 Nat.lt_succ_iff, Nat.succ_eq_add_one, hj, not_lt, add_le_iff_nonpos_right,\n          nonpos_iff_eq_zero] at h\n        rw [\u2190 add_left_inj 1, hj, self_eq_add_right, h]\n      rcases n with _|n\n      \u00b7 fin_cases i\n        dsimp at h hi\n        rw [show q = 0 by omega]\n        change X.\u03c3 0 \u226b (P 1).f 1 = 0\n        simp only [P_succ, HomologicalComplex.add_f_apply, comp_add,\n          HomologicalComplex.id_f, AlternatingFaceMapComplex.obj_d_eq, H\u03c3,\n          HomologicalComplex.comp_f, Homotopy.nullHomotopicMap'_f (c_mk 2 1 rfl) (c_mk 1 0 rfl),\n          comp_id]\n        erw [h\u03c3'_eq' (zero_add 0).symm, h\u03c3'_eq' (add_zero 1).symm, comp_id, Fin.sum_univ_two,\n          Fin.sum_univ_succ, Fin.sum_univ_two]\n        simp only [Fin.val_zero, pow_zero, pow_one, pow_add, one_smul, neg_smul, Fin.mk_one,\n          Fin.val_succ, Fin.val_one, Fin.succ_one_eq_two, P_zero, HomologicalComplex.id_f,\n          Fin.val_two, pow_two, mul_neg, one_mul, neg_mul, neg_neg, id_comp, add_comp,\n          comp_add, Fin.mk_zero, neg_comp, comp_neg, Fin.succ_zero_eq_one]\n        erw [SimplicialObject.\u03b4_comp_\u03c3_self, SimplicialObject.\u03b4_comp_\u03c3_self_assoc,\n          SimplicialObject.\u03b4_comp_\u03c3_succ, comp_id,\n          SimplicialObject.\u03b4_comp_\u03c3_of_le X\n            (show (0 : Fin 2) \u2264 Fin.castSucc 0 by rw [Fin.castSucc_zero]),\n          SimplicialObject.\u03b4_comp_\u03c3_self_assoc, SimplicialObject.\u03b4_comp_\u03c3_succ_assoc]\n        simp only [add_right_neg, add_zero, zero_add]\n      \u00b7 rw [\u2190 id_comp (X.\u03c3 i), \u2190 (P_add_Q_f q n.succ : _ = \ud835\udfd9 (X.obj _)), add_comp, add_comp,\n          P_succ]\n        have v : HigherFacesVanish q ((P q).f n.succ \u226b X.\u03c3 i) :=\n          (HigherFacesVanish.of_P q n).comp_\u03c3 hi\n        erw [\u2190 assoc, v.comp_P_eq_self, HomologicalComplex.add_f_apply, Preadditive.comp_add,\n          comp_id, v.comp_H\u03c3_eq hi, assoc, SimplicialObject.\u03b4_comp_\u03c3_succ_assoc, Fin.eta,\n          decomposition_Q n q, sum_comp, sum_comp, Finset.sum_eq_zero, add_zero, add_neg_eq_zero]\n        intro j hj\n        simp only [true_and_iff, Finset.mem_univ, Finset.mem_filter] at hj\n        simp only [Nat.succ_eq_add_one] at hi\n        obtain \u27e8k, hk\u27e9 := Nat.le.dest (Nat.lt_succ_iff.mp (Fin.is_lt j))\n        rw [add_comm] at hk\n        have hi' : i = Fin.castSucc \u27e8i, by omega\u27e9 := by\n          ext\n          simp only [Fin.castSucc_mk, Fin.eta]\n        have eq := hq j.rev.succ (by\n          simp only [\u2190 hk, Fin.rev_eq j hk.symm, Nat.succ_eq_add_one, Fin.succ_mk, Fin.val_mk]\n          omega)\n        rw [HomologicalComplex.comp_f, assoc, assoc, assoc, hi',\n          SimplicialObject.\u03c3_comp_\u03c3_assoc, reassoc_of% eq, zero_comp, comp_zero, comp_zero,\n          comp_zero]\n        simp only [Fin.rev_eq j hk.symm, Fin.le_iff_val_le_val, Fin.val_mk]\n        omega\nset_option linter.uppercaseLean3 false in\n#align algebraic_topology.dold_kan.\u03c3_comp_P_eq_zero AlgebraicTopology.DoldKan.\u03c3_comp_P_eq_zero\n\n@[reassoc (attr := simp)]\ntheorem \u03c3_comp_PInfty (X : SimplicialObject C) {n : \u2115} (i : Fin (n + 1)) :\n    X.\u03c3 i \u226b PInfty.f (n + 1) = 0 := by\n  rw [PInfty_f, \u03c3_comp_P_eq_zero X i]\n  simp only [le_add_iff_nonneg_left, zero_le]\nset_option linter.uppercaseLean3 false in\n#align algebraic_topology.dold_kan.\u03c3_comp_P_infty AlgebraicTopology.DoldKan.\u03c3_comp_PInfty\n\n\n@[reassoc]\ntheorem degeneracy_comp_PInfty (X : SimplicialObject C) (n : \u2115) {\u0394' : SimplexCategory}\n    (\u03b8 : ([n] : SimplexCategory) \u27f6 \u0394') (h\u03b8 : \u00acMono \u03b8) : X.map \u03b8.op \u226b PInfty.f n = 0  := by\n  rw [SimplexCategory.mono_iff_injective] at h\u03b8\n  cases n\n  \u00b7 exfalso; apply h\u03b8; intro x y h; fin_cases x; fin_cases y; rfl\n  \u00b7 obtain \u27e8i, \u03b1, h\u27e9 := SimplexCategory.eq_\u03c3_comp_of_not_injective \u03b8 h\u03b8\n    rw [h, op_comp, X.map_comp, assoc, \u2190X.\u03c3 i, \u03c3_comp_PInfty, comp_zero]\n", "allTactics": true, "theorems": true, "env": 0}

{"cmd": "theorem HigherFacesVanish.comp_\u03c3 {Y : C} {X : SimplicialObject C} {n b q : \u2115} {\u03c6 : Y \u27f6 X _[n + 1]}\n    (v : HigherFacesVanish q \u03c6) (hnbq : n + 1 = b + q) :\n    HigherFacesVanish q\n      (\u03c6 \u226b\n        X.\u03c3 \u27e8b, by\n          simp only [hnbq, Nat.lt_add_one_iff, le_add_iff_nonneg_right, zero_le]\u27e9) :=\n  fun j hj => by\n  rw [assoc, SimplicialObject.\u03b4_comp_\u03c3_of_gt', Fin.pred_succ, v.comp_\u03b4_eq_zero_assoc _ _ hj,\n    zero_comp]\n  \u00b7 dsimp\n    rw [Fin.lt_iff_val_lt_val, Fin.val_succ]\n    linarith\n  \u00b7 intro hj'\n    simp only [hnbq, add_comm b, add_assoc, hj', Fin.val_zero, zero_add, add_le_iff_nonpos_right,\n      nonpos_iff_eq_zero, add_eq_zero, false_and] at hj\n#align algebraic_topology.dold_kan.higher_faces_vanish.comp_\u03c3 AlgebraicTopology.DoldKan.HigherFacesVanish.comp_\u03c3\n\ntheorem \u03c3_comp_P_eq_zero (X : SimplicialObject C) {n q : \u2115} (i : Fin (n + 1)) (hi : n + 1 \u2264 i + q) :\n    X.\u03c3 i \u226b (P q).f (n + 1) = 0 := by\n  revert i hi\n  induction' q with q hq\n  \u00b7 intro i (hi : n + 1 \u2264 i)\n    exfalso\n    linarith [Fin.is_lt i]\n  \u00b7 intro i (hi : n + 1 \u2264 i + q + 1)\n    by_cases h : n + 1 \u2264 (i : \u2115) + q\n    \u00b7 rw [P_succ, HomologicalComplex.comp_f, \u2190 assoc, hq i h, zero_comp]\n    \u00b7 replace hi : n = i + q := by\n        obtain \u27e8j, hj\u27e9 := le_iff_exists_add.mp hi\n        rw [\u2190 Nat.lt_succ_iff, Nat.succ_eq_add_one, hj, not_lt, add_le_iff_nonpos_right,\n          nonpos_iff_eq_zero] at h\n        rw [\u2190 add_left_inj 1, hj, self_eq_add_right, h]\n      rcases n with _|n\n      \u00b7 fin_cases i\n        dsimp at h hi\n        rw [show q = 0 by omega]\n        change X.\u03c3 0 \u226b (P 1).f 1 = 0\n        simp only [P_succ, HomologicalComplex.add_f_apply, comp_add,\n          HomologicalComplex.id_f, AlternatingFaceMapComplex.obj_d_eq, H\u03c3,\n          HomologicalComplex.comp_f, Homotopy.nullHomotopicMap'_f (c_mk 2 1 rfl) (c_mk 1 0 rfl),\n          comp_id]\n        erw [h\u03c3'_eq' (zero_add 0).symm, h\u03c3'_eq' (add_zero 1).symm, comp_id, Fin.sum_univ_two,\n          Fin.sum_univ_succ, Fin.sum_univ_two]\n        simp only [Fin.val_zero, pow_zero, pow_one, pow_add, one_smul, neg_smul, Fin.mk_one,\n          Fin.val_succ, Fin.val_one, Fin.succ_one_eq_two, P_zero, HomologicalComplex.id_f,\n          Fin.val_two, pow_two, mul_neg, one_mul, neg_mul, neg_neg, id_comp, add_comp,\n          comp_add, Fin.mk_zero, neg_comp, comp_neg, Fin.succ_zero_eq_one]\n        erw [SimplicialObject.\u03b4_comp_\u03c3_self, SimplicialObject.\u03b4_comp_\u03c3_self_assoc,\n          SimplicialObject.\u03b4_comp_\u03c3_succ, comp_id,\n          SimplicialObject.\u03b4_comp_\u03c3_of_le X\n            (show (0 : Fin 2) \u2264 Fin.castSucc 0 by rw [Fin.castSucc_zero]),\n          SimplicialObject.\u03b4_comp_\u03c3_self_assoc, SimplicialObject.\u03b4_comp_\u03c3_succ_assoc]\n        simp only [add_right_neg, add_zero, zero_add]\n      \u00b7 rw [\u2190 id_comp (X.\u03c3 i), \u2190 (P_add_Q_f q n.succ : _ = \ud835\udfd9 (X.obj _)), add_comp, add_comp,\n          P_succ]\n        have v : HigherFacesVanish q ((P q).f n.succ \u226b X.\u03c3 i) :=\n          (HigherFacesVanish.of_P q n).comp_\u03c3 hi\n        erw [\u2190 assoc, v.comp_P_eq_self, HomologicalComplex.add_f_apply, Preadditive.comp_add,\n          comp_id, v.comp_H\u03c3_eq hi, assoc, SimplicialObject.\u03b4_comp_\u03c3_succ_assoc, Fin.eta,\n          decomposition_Q n q, sum_comp, sum_comp, Finset.sum_eq_zero, add_zero, add_neg_eq_zero]\n        intro j hj\n        simp only [true_and_iff, Finset.mem_univ, Finset.mem_filter] at hj\n        simp only [Nat.succ_eq_add_one] at hi\n        obtain \u27e8k, hk\u27e9 := Nat.le.dest (Nat.lt_succ_iff.mp (Fin.is_lt j))\n        rw [add_comm] at hk\n        have hi' : i = Fin.castSucc \u27e8i, by omega\u27e9 := by\n          ext\n          simp only [Fin.castSucc_mk, Fin.eta]\n        have eq := hq j.rev.succ (by\n          simp only [\u2190 hk, Fin.rev_eq j hk.symm, Nat.succ_eq_add_one, Fin.succ_mk, Fin.val_mk]\n          omega)\n        rw [HomologicalComplex.comp_f, assoc, assoc, assoc, hi',\n          SimplicialObject.\u03c3_comp_\u03c3_assoc, reassoc_of% eq, zero_comp, comp_zero, comp_zero,\n          comp_zero]\n        simp only [Fin.rev_eq j hk.symm, Fin.le_iff_val_le_val, Fin.val_mk]\n        omega\nset_option linter.uppercaseLean3 false in\n#align algebraic_topology.dold_kan.\u03c3_comp_P_eq_zero AlgebraicTopology.DoldKan.\u03c3_comp_P_eq_zero\n\n@[reassoc (attr := simp)]\ntheorem \u03c3_comp_PInfty (X : SimplicialObject C) {n : \u2115} (i : Fin (n + 1)) :\n    X.\u03c3 i \u226b PInfty.f (n + 1) = 0 := by\n  rw [PInfty_f, \u03c3_comp_P_eq_zero X i]\n  simp only [le_add_iff_nonneg_left, zero_le]\nset_option linter.uppercaseLean3 false in\n#align algebraic_topology.dold_kan.\u03c3_comp_P_infty AlgebraicTopology.DoldKan.\u03c3_comp_PInfty\n\n\n@[reassoc]\ntheorem degeneracy_comp_PInfty (X : SimplicialObject C) (n : \u2115) {\u0394' : SimplexCategory}\n    (\u03b8 : ([n] : SimplexCategory) \u27f6 \u0394') (h\u03b8 : \u00acMono \u03b8) : X.map \u03b8.op \u226b PInfty.f n = 0  := by\n  rw [SimplexCategory.mono_iff_injective] at h\u03b8\n  cases n\n  \u00b7 exfalso; apply h\u03b8; fin_cases (x : Fin 1); fin_cases (y : Fin 1); rfl\n  \u00b7 obtain \u27e8i, \u03b1, h\u27e9 := SimplexCategory.eq_\u03c3_comp_of_not_injective \u03b8 h\u03b8\n    simp_rw [h, op_comp, X.map_comp, assoc, \u03c3_comp_PInfty, comp_zero]\n", "allTactics": true, "theorems": true, "env": 0}

{"cmd": "theorem HigherFacesVanish.comp_\u03c3 {Y : C} {X : SimplicialObject C} {n b q : \u2115} {\u03c6 : Y \u27f6 X _[n + 1]}\n    (v : HigherFacesVanish q \u03c6) (hnbq : n + 1 = b + q) :\n    HigherFacesVanish q\n      (\u03c6 \u226b\n        X.\u03c3 \u27e8b, by\n          simp only [hnbq, Nat.lt_add_one_iff, le_add_iff_nonneg_right, zero_le]\u27e9) :=\n  fun j hj => by\n  rw [assoc, SimplicialObject.\u03b4_comp_\u03c3_of_gt', Fin.pred_succ, v.comp_\u03b4_eq_zero_assoc _ _ hj,\n    zero_comp]\n  \u00b7 dsimp\n    rw [Fin.lt_iff_val_lt_val, Fin.val_succ]\n    linarith\n  \u00b7 intro hj'\n    simp only [hnbq, add_comm b, add_assoc, hj', Fin.val_zero, zero_add, add_le_iff_nonpos_right,\n      nonpos_iff_eq_zero, add_eq_zero, false_and] at hj\n#align algebraic_topology.dold_kan.higher_faces_vanish.comp_\u03c3 AlgebraicTopology.DoldKan.HigherFacesVanish.comp_\u03c3\n\ntheorem \u03c3_comp_P_eq_zero (X : SimplicialObject C) {n q : \u2115} (i : Fin (n + 1)) (hi : n + 1 \u2264 i + q) :\n    X.\u03c3 i \u226b (P q).f (n + 1) = 0 := by\n  revert i hi\n  induction' q with q hq\n  \u00b7 intro i (hi : n + 1 \u2264 i)\n    exfalso\n    linarith [Fin.is_lt i]\n  \u00b7 intro i (hi : n + 1 \u2264 i + q + 1)\n    by_cases h : n + 1 \u2264 (i : \u2115) + q\n    \u00b7 rw [P_succ, HomologicalComplex.comp_f, \u2190 assoc, hq i h, zero_comp]\n    \u00b7 replace hi : n = i + q := by\n        obtain \u27e8j, hj\u27e9 := le_iff_exists_add.mp hi\n        rw [\u2190 Nat.lt_succ_iff, Nat.succ_eq_add_one, hj, not_lt, add_le_iff_nonpos_right,\n          nonpos_iff_eq_zero] at h\n        rw [\u2190 add_left_inj 1, hj, self_eq_add_right, h]\n      rcases n with _|n\n      \u00b7 fin_cases i\n        dsimp at h hi\n        rw [show q = 0 by omega]\n        change X.\u03c3 0 \u226b (P 1).f 1 = 0\n        simp only [P_succ, HomologicalComplex.add_f_apply, comp_add,\n          HomologicalComplex.id_f, AlternatingFaceMapComplex.obj_d_eq, H\u03c3,\n          HomologicalComplex.comp_f, Homotopy.nullHomotopicMap'_f (c_mk 2 1 rfl) (c_mk 1 0 rfl),\n          comp_id]\n        erw [h\u03c3'_eq' (zero_add 0).symm, h\u03c3'_eq' (add_zero 1).symm, comp_id, Fin.sum_univ_two,\n          Fin.sum_univ_succ, Fin.sum_univ_two]\n        simp only [Fin.val_zero, pow_zero, pow_one, pow_add, one_smul, neg_smul, Fin.mk_one,\n          Fin.val_succ, Fin.val_one, Fin.succ_one_eq_two, P_zero, HomologicalComplex.id_f,\n          Fin.val_two, pow_two, mul_neg, one_mul, neg_mul, neg_neg, id_comp, add_comp,\n          comp_add, Fin.mk_zero, neg_comp, comp_neg, Fin.succ_zero_eq_one]\n        erw [SimplicialObject.\u03b4_comp_\u03c3_self, SimplicialObject.\u03b4_comp_\u03c3_self_assoc,\n          SimplicialObject.\u03b4_comp_\u03c3_succ, comp_id,\n          SimplicialObject.\u03b4_comp_\u03c3_of_le X\n            (show (0 : Fin 2) \u2264 Fin.castSucc 0 by rw [Fin.castSucc_zero]),\n          SimplicialObject.\u03b4_comp_\u03c3_self_assoc, SimplicialObject.\u03b4_comp_\u03c3_succ_assoc]\n        simp only [add_right_neg, add_zero, zero_add]\n      \u00b7 rw [\u2190 id_comp (X.\u03c3 i), \u2190 (P_add_Q_f q n.succ : _ = \ud835\udfd9 (X.obj _)), add_comp, add_comp,\n          P_succ]\n        have v : HigherFacesVanish q ((P q).f n.succ \u226b X.\u03c3 i) :=\n          (HigherFacesVanish.of_P q n).comp_\u03c3 hi\n        erw [\u2190 assoc, v.comp_P_eq_self, HomologicalComplex.add_f_apply, Preadditive.comp_add,\n          comp_id, v.comp_H\u03c3_eq hi, assoc, SimplicialObject.\u03b4_comp_\u03c3_succ_assoc, Fin.eta,\n          decomposition_Q n q, sum_comp, sum_comp, Finset.sum_eq_zero, add_zero, add_neg_eq_zero]\n        intro j hj\n        simp only [true_and_iff, Finset.mem_univ, Finset.mem_filter] at hj\n        simp only [Nat.succ_eq_add_one] at hi\n        obtain \u27e8k, hk\u27e9 := Nat.le.dest (Nat.lt_succ_iff.mp (Fin.is_lt j))\n        rw [add_comm] at hk\n        have hi' : i = Fin.castSucc \u27e8i, by omega\u27e9 := by\n          ext\n          simp only [Fin.castSucc_mk, Fin.eta]\n        have eq := hq j.rev.succ (by\n          simp only [\u2190 hk, Fin.rev_eq j hk.symm, Nat.succ_eq_add_one, Fin.succ_mk, Fin.val_mk]\n          omega)\n        rw [HomologicalComplex.comp_f, assoc, assoc, assoc, hi',\n          SimplicialObject.\u03c3_comp_\u03c3_assoc, reassoc_of% eq, zero_comp, comp_zero, comp_zero,\n          comp_zero]\n        simp only [Fin.rev_eq j hk.symm, Fin.le_iff_val_le_val, Fin.val_mk]\n        omega\nset_option linter.uppercaseLean3 false in\n#align algebraic_topology.dold_kan.\u03c3_comp_P_eq_zero AlgebraicTopology.DoldKan.\u03c3_comp_P_eq_zero\n\n@[reassoc (attr := simp)]\ntheorem \u03c3_comp_PInfty (X : SimplicialObject C) {n : \u2115} (i : Fin (n + 1)) :\n    X.\u03c3 i \u226b PInfty.f (n + 1) = 0 := by\n  rw [PInfty_f, \u03c3_comp_P_eq_zero X i]\n  simp only [le_add_iff_nonneg_left, zero_le]\nset_option linter.uppercaseLean3 false in\n#align algebraic_topology.dold_kan.\u03c3_comp_P_infty AlgebraicTopology.DoldKan.\u03c3_comp_PInfty\n\n\n@[reassoc]\ntheorem degeneracy_comp_PInfty (X : SimplicialObject C) (n : \u2115) {\u0394' : SimplexCategory}\n    (\u03b8 : ([n] : SimplexCategory) \u27f6 \u0394') (h\u03b8 : \u00acMono \u03b8) : X.map \u03b8.op \u226b PInfty.f n = 0  := by\n  rw [SimplexCategory.mono_iff_injective] at h\u03b8\n  cases n\n  \u00b7 exfalso\n    apply h\u03b8\n    intro x y h\n    fin_cases x\n    fin_cases y\n    rfl\n  \u00b7 obtain \u27e8i, \u03b1, h\u27e9 := SimplexCategory.eq_\u03c3_comp_of_not_injective \u03b8 h\u03b8\n    rw [h, op_comp, X.map_comp, assoc, show X.map (SimplexCategory.\u03c3 i).op = X.\u03c3 i by rfl,\n    \u03c3_comp_PInfty, comp_zero]\n", "allTactics": true, "theorems": true, "env": 0}