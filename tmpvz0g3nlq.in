{"cmd": "/-\nCopyright (c) 2023 Jo\u00ebl Riou. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Jo\u00ebl Riou\n-/\nimport Mathlib.CategoryTheory.Localization.Opposite\n\n/-!\n# Calculus of fractions\n\nFollowing the definitions by [Gabriel and Zisman][gabriel-zisman-1967],\ngiven a morphism property `W : MorphismProperty C` on a category `C`,\nwe introduce the class `W.HasLeftCalculusOfFractions`. The main\nresult `Localization.exists_leftFraction` is that if `L : C \u2964 D`\nis a localization functor for `W`, then for any morphism `L.obj X \u27f6 L.obj Y` in `D`,\nthere exists an auxiliary object `Y' : C` and morphisms `g : X \u27f6 Y'` and `s : Y \u27f6 Y'`,\nwith `W s`, such that the given morphism is a sort of fraction `g / s`,\nor more precisely of the form `L.map g \u226b (Localization.isoOfHom L W s hs).inv`.\nWe also show that the functor `L.mapArrow : Arrow C \u2964 Arrow D` is essentially surjective.\n\nSimilar results are obtained when `W` has a right calculus of fractions.\n\n## References\n\n* [P. Gabriel, M. Zisman, *Calculus of fractions and homotopy theory*][gabriel-zisman-1967]\n\n-/\n\nnamespace CategoryTheory\n\nvariable {C D : Type*} [Category C] [Category D]\n\nopen Category\n\nnamespace MorphismProperty\n\n/-- A left fraction from `X : C` to `Y : C` for `W : MorphismProperty C` consists of the\ndatum of an object `Y' : C` and maps `f : X \u27f6 Y'` and `s : Y \u27f6 Y'` such that `W s`. -/\nstructure LeftFraction (W : MorphismProperty C) (X Y : C) where\n  /-- the auxiliary object of a left fraction -/\n  {Y' : C}\n  /-- the numerator of a left fraction -/\n  f : X \u27f6 Y'\n  /-- the denominator of a left fraction -/\n  s : Y \u27f6 Y'\n  /-- the condition that the denominator belongs to the given morphism property -/\n  hs : W s\n\nnamespace LeftFraction\n\nvariable (W : MorphismProperty C) {X Y : C}\n\n/-- The left fraction from `X` to `Y` given by a morphism `f : X \u27f6 Y`. -/\n@[simps]\ndef ofHom (f : X \u27f6 Y) [W.ContainsIdentities] :\n    W.LeftFraction X Y := mk f (\ud835\udfd9 Y) (W.id_mem Y)\n\nvariable {W}\n\n/-- The left fraction from `X` to `Y` given by a morphism `s : Y \u27f6 X` such that `W s`. -/\n@[simps]\ndef ofInv (s : Y \u27f6 X) (hs : W s) :\n    W.LeftFraction X Y := mk (\ud835\udfd9 X) s hs\n\n/-- If `\u03c6 : W.LeftFraction X Y` and `L` is a functor which inverts `W`, this is the\ninduced morphism `L.obj X \u27f6 L.obj Y`  -/\nnoncomputable def map (\u03c6 : W.LeftFraction X Y) (L : C \u2964 D) (hL : W.IsInvertedBy L) :\n    L.obj X \u27f6 L.obj Y :=\n  have := hL _ \u03c6.hs\n  L.map \u03c6.f \u226b inv (L.map \u03c6.s)\n"}

{"cmd": "@[reassoc (attr := simp)]\nlemma map_comp_map_s (\u03c6 : W.LeftFraction X Y) (L : C \u2964 D) (hL : W.IsInvertedBy L) :\n    \u03c6.map L hL \u226b L.map \u03c6.s = L.map \u03c6.f := by\n  letI := hL _ \u03c6.hs\n  simp [map]\n\nvariable (W)\n\nlemma map_ofHom (f : X \u27f6 Y) (L : C \u2964 D) (hL : W.IsInvertedBy L) [W.ContainsIdentities] :\n    (ofHom W f).map L hL = L.map f := by\n  simp [map]\n\n@[reassoc (attr := simp)]\nlemma map_ofInv_hom_id (s : Y \u27f6 X) (hs : W s) (L : C \u2964 D) (hL : W.IsInvertedBy L) :\n    (ofInv s hs).map L hL \u226b L.map s = \ud835\udfd9 _ := by\n  letI := hL _ hs\n  simp [map]\n\n@[reassoc (attr := simp)]\nlemma map_hom_ofInv_id (s : Y \u27f6 X) (hs : W s) (L : C \u2964 D) (hL : W.IsInvertedBy L) :\n    L.map s \u226b (ofInv s hs).map L hL = \ud835\udfd9 _ := by\n  letI := hL _ hs\n  simp [map]\n\nvariable {W}\n\nlemma cases (\u03b1 : W.LeftFraction X Y) :\n    \u2203 (Y' : C) (f : X \u27f6 Y') (s : Y \u27f6 Y') (hs : W s), \u03b1 = LeftFraction.mk f s hs :=\n  \u27e8_, _, _, _, rfl\u27e9\n\nend LeftFraction\n\n/-- A right fraction from `X : C` to `Y : C` for `W : MorphismProperty C` consists of the\ndatum of an object `X' : C` and maps `s : X' \u27f6 X` and `f : X' \u27f6 Y` such that `W s`. -/\nstructure RightFraction (W : MorphismProperty C) (X Y : C) where\n  /-- the auxiliary object of a right fraction -/\n  {X' : C}\n  /-- the denominator of a right fraction -/\n  s : X' \u27f6 X\n  /-- the condition that the denominator belongs to the given morphism property -/\n  hs : W s\n  /-- the numerator of a right fraction -/\n  f : X' \u27f6 Y\n\nnamespace RightFraction\n\nvariable (W : MorphismProperty C)\nvariable {X Y : C}\n\n/-- The right fraction from `X` to `Y` given by a morphism `f : X \u27f6 Y`. -/\n@[simps]\ndef ofHom (f : X \u27f6 Y) [W.ContainsIdentities] :\n    W.RightFraction X Y := mk (\ud835\udfd9 X) (W.id_mem X) f\n\nvariable {W}\n\n/-- The right fraction from `X` to `Y` given by a morphism `s : Y \u27f6 X` such that `W s`. -/\n@[simps]\ndef ofInv (s : Y \u27f6 X) (hs : W s) :\n    W.RightFraction X Y := mk s hs (\ud835\udfd9 Y)\n\n/-- If `\u03c6 : W.RightFraction X Y` and `L` is a functor which inverts `W`, this is the\ninduced morphism `L.obj X \u27f6 L.obj Y`  -/\nnoncomputable def map (\u03c6 : W.RightFraction X Y) (L : C \u2964 D) (hL : W.IsInvertedBy L) :\n    L.obj X \u27f6 L.obj Y :=\n  have := hL _ \u03c6.hs\n  inv (L.map \u03c6.s) \u226b L.map \u03c6.f\n\n@[reassoc (attr := simp)]\nlemma map_s_comp_map (\u03c6 : W.RightFraction X Y) (L : C \u2964 D) (hL : W.IsInvertedBy L) :\n    L.map \u03c6.s \u226b \u03c6.map L hL = L.map \u03c6.f := by\n  letI := hL _ \u03c6.hs\n  simp [map]\n\nvariable (W)\n\n@[simp]\nlemma map_ofHom (f : X \u27f6 Y) (L : C \u2964 D) (hL : W.IsInvertedBy L) [W.ContainsIdentities] :\n    (ofHom W f).map L hL = L.map f := by\n  simp [map]\n\n@[reassoc (attr := simp)]\nlemma map_ofInv_hom_id (s : Y \u27f6 X) (hs : W s) (L : C \u2964 D) (hL : W.IsInvertedBy L) :\n    (ofInv s hs).map L hL \u226b L.map s = \ud835\udfd9 _ := by\n  letI := hL _ hs\n  simp [map]\n\n@[reassoc (attr := simp)]\nlemma map_hom_ofInv_id (s : Y \u27f6 X) (hs : W s) (L : C \u2964 D) (hL : W.IsInvertedBy L) :\n    L.map s \u226b (ofInv s hs).map L hL = \ud835\udfd9 _ := by\n  letI := hL _ hs\n  simp [map]\n\nvariable {W}\n\nlemma cases (\u03b1 : W.RightFraction X Y) :\n    \u2203 (X' : C) (s : X' \u27f6 X) (hs : W s) (f : X' \u27f6 Y) , \u03b1 = RightFraction.mk s hs f :=\n  \u27e8_, _, _, _, rfl\u27e9\n\nend RightFraction\n\nvariable (W : MorphismProperty C)\n\n/-- A multiplicative morphism property `W` has left calculus of fractions if\nany right fraction can be turned into a left fraction and that two morphisms\nthat can be equalized by precomposition with a morphism in `W` can also\nbe equalized by postcomposition with a morphism in `W`. -/\nclass HasLeftCalculusOfFractions extends W.IsMultiplicative : Prop where\n  exists_leftFraction \u2983X Y : C\u2984 (\u03c6 : W.RightFraction X Y) :\n    \u2203 (\u03c8 : W.LeftFraction X Y), \u03c6.f \u226b \u03c8.s = \u03c6.s \u226b \u03c8.f\n  ext : \u2200 \u2983X' X Y : C\u2984 (f\u2081 f\u2082 : X \u27f6 Y) (s : X' \u27f6 X) (_ : W s)\n    (_ : s \u226b f\u2081 = s \u226b f\u2082), \u2203 (Y' : C) (t : Y \u27f6 Y') (_ : W t), f\u2081 \u226b t = f\u2082 \u226b t\n\n/-- A multiplicative morphism property `W` has right calculus of fractions if\nany left fraction can be turned into a right fraction and that two morphisms\nthat can be equalized by postcomposition with a morphism in `W` can also\nbe equalized by precomposition with a morphism in `W`. -/\nclass HasRightCalculusOfFractions extends W.IsMultiplicative : Prop where\n  exists_rightFraction \u2983X Y : C\u2984 (\u03c6 : W.LeftFraction X Y) :\n    \u2203 (\u03c8 : W.RightFraction X Y), \u03c8.s \u226b \u03c6.f = \u03c8.f \u226b \u03c6.s\n  ext : \u2200 \u2983X Y Y' : C\u2984 (f\u2081 f\u2082 : X \u27f6 Y) (s : Y \u27f6 Y') (_ : W s)\n    (_ : f\u2081 \u226b s = f\u2082 \u226b s), \u2203 (X' : C) (t : X' \u27f6 X) (_ : W t), t \u226b f\u2081 = t \u226b f\u2082\n\nvariable {W}\n\nlemma RightFraction.exists_leftFraction [W.HasLeftCalculusOfFractions] {X Y : C}\n    (\u03c6 : W.RightFraction X Y) : \u2203 (\u03c8 : W.LeftFraction X Y), \u03c6.f \u226b \u03c8.s = \u03c6.s \u226b \u03c8.f :=\n  HasLeftCalculusOfFractions.exists_leftFraction \u03c6\n\n/-- A choice of a left fraction deduced from a right fraction for a morphism property `W`\nwhen `W` has left calculus of fractions. -/\nnoncomputable def RightFraction.leftFraction [W.HasLeftCalculusOfFractions] {X Y : C}\n    (\u03c6 : W.RightFraction X Y) : W.LeftFraction X Y :=\n  \u03c6.exists_leftFraction.choose\n\n@[reassoc]\nlemma RightFraction.leftFraction_fac [W.HasLeftCalculusOfFractions] {X Y : C}\n    (\u03c6 : W.RightFraction X Y) : \u03c6.f \u226b \u03c6.leftFraction.s = \u03c6.s \u226b \u03c6.leftFraction.f :=\n  \u03c6.exists_leftFraction.choose_spec\n\nlemma LeftFraction.exists_rightFraction [W.HasRightCalculusOfFractions] {X Y : C}\n    (\u03c6 : W.LeftFraction X Y) : \u2203 (\u03c8 : W.RightFraction X Y), \u03c8.s \u226b \u03c6.f = \u03c8.f \u226b \u03c6.s :=\n  HasRightCalculusOfFractions.exists_rightFraction \u03c6\n\n/-- A choice of a right fraction deduced from a left fraction for a morphism property `W`\nwhen `W` has right calculus of fractions. -/\nnoncomputable def LeftFraction.rightFraction [W.HasRightCalculusOfFractions] {X Y : C}\n    (\u03c6 : W.LeftFraction X Y) : W.RightFraction X Y :=\n  \u03c6.exists_rightFraction.choose\n\n@[reassoc]\nlemma LeftFraction.rightFraction_fac [W.HasRightCalculusOfFractions] {X Y : C}\n    (\u03c6 : W.LeftFraction X Y) : \u03c6.rightFraction.s \u226b \u03c6.f = \u03c6.rightFraction.f \u226b \u03c6.s :=\n  \u03c6.exists_rightFraction.choose_spec\n\n/-- The equivalence relation on left fractions for a morphism property `W`. -/\ndef LeftFractionRel {X Y : C} (z\u2081 z\u2082 : W.LeftFraction X Y) : Prop :=\n  \u2203 (Z : C)  (t\u2081 : z\u2081.Y' \u27f6 Z) (t\u2082 : z\u2082.Y' \u27f6 Z) (_ : z\u2081.s \u226b t\u2081 = z\u2082.s \u226b t\u2082)\n    (_ : z\u2081.f \u226b t\u2081 = z\u2082.f \u226b t\u2082), W (z\u2081.s \u226b t\u2081)\n\nnamespace LeftFractionRel\n\nlemma refl {X Y : C} (z : W.LeftFraction X Y) : LeftFractionRel z z :=\n  \u27e8z.Y', \ud835\udfd9 _, \ud835\udfd9 _, rfl, rfl, by simpa only [Category.comp_id] using z.hs\u27e9\n\nlemma symm {X Y : C} {z\u2081 z\u2082 : W.LeftFraction X Y} (h : LeftFractionRel z\u2081 z\u2082) :\n    LeftFractionRel z\u2082 z\u2081 := by\n  obtain \u27e8Z, t\u2081, t\u2082, hst, hft, ht\u27e9 := h\n  exact \u27e8Z, t\u2082, t\u2081, hst.symm, hft.symm, by simpa only [\u2190 hst] using ht\u27e9\n\nlemma trans {X Y : C} {z\u2081 z\u2082 z\u2083 : W.LeftFraction X Y}\n    [HasLeftCalculusOfFractions W]\n    (h\u2081\u2082 : LeftFractionRel z\u2081 z\u2082) (h\u2082\u2083 : LeftFractionRel z\u2082 z\u2083) :\n    LeftFractionRel z\u2081 z\u2083 := by\n  obtain \u27e8Z\u2084, t\u2081, t\u2082, hst, hft, ht\u27e9 := h\u2081\u2082\n  obtain \u27e8Z\u2085, u\u2082, u\u2083, hsu, hfu, hu\u27e9 := h\u2082\u2083\n  obtain \u27e8\u27e8v\u2084, v\u2085, hv\u2085\u27e9, fac\u27e9 := HasLeftCalculusOfFractions.exists_leftFraction\n    (RightFraction.mk (z\u2081.s \u226b t\u2081) ht (z\u2083.s \u226b u\u2083))\n  simp only [Category.assoc] at fac\n  have eq : z\u2082.s \u226b u\u2082 \u226b v\u2085  = z\u2082.s \u226b t\u2082 \u226b v\u2084 := by\n    simpa only [\u2190 reassoc_of% hsu, reassoc_of% hst] using fac\n  obtain \u27e8Z\u2087, w, hw, fac'\u27e9 := HasLeftCalculusOfFractions.ext _ _ _ z\u2082.hs eq\n  simp only [Category.assoc] at fac'\n  refine \u27e8Z\u2087, t\u2081 \u226b v\u2084 \u226b w, u\u2083 \u226b v\u2085 \u226b w, ?_, ?_, ?_\u27e9\n  \u00b7 rw [reassoc_of% fac]\n  \u00b7 rw [reassoc_of% hft, \u2190 fac', reassoc_of% hfu]\n  \u00b7 rw [\u2190 reassoc_of% fac, \u2190 reassoc_of% hsu, \u2190 Category.assoc]\n    exact W.comp_mem _ _ hu (W.comp_mem _ _ hv\u2085 hw)\n\nend LeftFractionRel\n\nsection\n\nvariable [W.HasLeftCalculusOfFractions] (W)\n\nlemma equivalenceLeftFractionRel (X Y : C) :\n    @_root_.Equivalence (W.LeftFraction X Y) LeftFractionRel where\n  refl := LeftFractionRel.refl\n  symm := LeftFractionRel.symm\n  trans := LeftFractionRel.trans\n\nvariable {W}\n\nnamespace LeftFraction\n\nopen HasLeftCalculusOfFractions\n\n/-- Auxiliary definition for the composition of left fractions. -/\n@[simp]\ndef comp\u2080 {X Y Z : C} (z\u2081 : W.LeftFraction X Y) (z\u2082 : W.LeftFraction Y Z)\n    (z\u2083 : W.LeftFraction z\u2081.Y' z\u2082.Y') :\n    W.LeftFraction X Z :=\n  mk (z\u2081.f \u226b z\u2083.f) (z\u2082.s \u226b z\u2083.s) (W.comp_mem _ _ z\u2082.hs z\u2083.hs)\n\n/-- The equivalence class of `z\u2081.comp\u2080 z\u2082 z\u2083` does not depend on the choice of `z\u2083` provided\nthey satisfy the compatibility `z\u2082.f \u226b z\u2083.s = z\u2081.s \u226b z\u2083.f`. -/\nlemma comp\u2080_rel {X Y Z : C} (z\u2081 : W.LeftFraction X Y) (z\u2082 : W.LeftFraction Y Z)\n    (z\u2083 z\u2083' : W.LeftFraction z\u2081.Y' z\u2082.Y') (h\u2083 : z\u2082.f \u226b z\u2083.s = z\u2081.s \u226b z\u2083.f)\n    (h\u2083' : z\u2082.f \u226b z\u2083'.s = z\u2081.s \u226b z\u2083'.f) :\n    LeftFractionRel (z\u2081.comp\u2080 z\u2082 z\u2083) (z\u2081.comp\u2080 z\u2082 z\u2083') := by\n  obtain \u27e8z\u2084, fac\u27e9 := exists_leftFraction (RightFraction.mk z\u2083.s z\u2083.hs z\u2083'.s)\n  dsimp at fac\n  have eq : z\u2081.s \u226b z\u2083.f \u226b z\u2084.f = z\u2081.s \u226b z\u2083'.f \u226b z\u2084.s := by\n    rw [\u2190 reassoc_of% h\u2083, \u2190 reassoc_of% h\u2083', fac]\n  obtain \u27e8Y, t, ht, fac'\u27e9 := HasLeftCalculusOfFractions.ext _ _ _ z\u2081.hs eq\n  simp only [assoc] at fac'\n  refine \u27e8Y, z\u2084.f \u226b t, z\u2084.s \u226b t, ?_, ?_, ?_\u27e9\n  \u00b7 simp only [comp\u2080, assoc, reassoc_of% fac]\n  \u00b7 simp only [comp\u2080, assoc, fac']\n  \u00b7 simp only [comp\u2080, assoc, \u2190 reassoc_of% fac]\n    exact W.comp_mem _ _ z\u2082.hs (W.comp_mem _ _ z\u2083'.hs (W.comp_mem _ _ z\u2084.hs ht))\n\nvariable (W)\n\n/-- The morphisms in the constructed localized category for a morphism property `W`\nthat has left calculus of fractions are equivalence classes of left fractions. -/\ndef Localization.Hom (X Y : C) :=\n  Quot (LeftFractionRel : W.LeftFraction X Y \u2192 W.LeftFraction X Y \u2192 Prop)\n\nvariable {W}\n\n/-- The morphism in the constructed localized category that is induced by a left fraction. -/\ndef Localization.Hom.mk {X Y : C} (z : W.LeftFraction X Y) : Localization.Hom W X Y :=\n  Quot.mk _ z\n\nlemma Localization.Hom.mk_surjective {X Y : C} (f : Localization.Hom W X Y) :\n    \u2203 (z : W.LeftFraction X Y), f = mk z := by\n  obtain \u27e8z\u27e9 := f\n  exact \u27e8z, rfl\u27e9\n\n/-- Auxiliary definition towards the definition of the composition of morphisms\nin the constructed localized category for a morphism property that has\nleft calculus of fractions. -/\nnoncomputable def comp {X Y Z : C} (z\u2081 : W.LeftFraction X Y) (z\u2082 : W.LeftFraction Y Z) :\n    Localization.Hom W X Z :=\n  Localization.Hom.mk (z\u2081.comp\u2080 z\u2082 (RightFraction.mk z\u2081.s z\u2081.hs z\u2082.f).leftFraction)\n\nlemma comp_eq {X Y Z : C} (z\u2081 : W.LeftFraction X Y) (z\u2082 : W.LeftFraction Y Z)\n    (z\u2083 : W.LeftFraction z\u2081.Y' z\u2082.Y') (h\u2083 : z\u2082.f \u226b z\u2083.s = z\u2081.s \u226b z\u2083.f) :\n    z\u2081.comp z\u2082 = Localization.Hom.mk (z\u2081.comp\u2080 z\u2082 z\u2083) :=\n  Quot.sound (LeftFraction.comp\u2080_rel _ _ _ _\n    (RightFraction.leftFraction_fac (RightFraction.mk z\u2081.s z\u2081.hs z\u2082.f)) h\u2083)\n\nnamespace Localization\n\n/-- Composition of morphisms in the constructed localized category\nfor a morphism property that has left calculus of fractions. -/\nnoncomputable def Hom.comp {X Y Z : C} (z\u2081 : Hom W X Y) (z\u2082 : Hom W Y Z) : Hom W X Z := by\n  refine Quot.lift\u2082 (fun a b => a.comp b) ?_ ?_ z\u2081 z\u2082\n  \u00b7 rintro a b\u2081 b\u2082 \u27e8U, t\u2081, t\u2082, hst, hft, ht\u27e9\n    obtain \u27e8z\u2081, fac\u2081\u27e9 := exists_leftFraction (RightFraction.mk a.s a.hs b\u2081.f)\n    obtain \u27e8z\u2082, fac\u2082\u27e9 := exists_leftFraction (RightFraction.mk a.s a.hs b\u2082.f)\n    obtain \u27e8w\u2081, fac\u2081'\u27e9 := exists_leftFraction (RightFraction.mk z\u2081.s z\u2081.hs t\u2081)\n    obtain \u27e8w\u2082, fac\u2082'\u27e9 := exists_leftFraction (RightFraction.mk z\u2082.s z\u2082.hs t\u2082)\n    obtain \u27e8u, fac\u2083\u27e9 := exists_leftFraction (RightFraction.mk w\u2081.s w\u2081.hs w\u2082.s)\n    dsimp at fac\u2081 fac\u2082 fac\u2081' fac\u2082' fac\u2083 \u22a2\n    have eq : a.s \u226b z\u2081.f \u226b w\u2081.f \u226b u.f = a.s \u226b z\u2082.f \u226b w\u2082.f \u226b u.s := by\n      rw [\u2190 reassoc_of% fac\u2081, \u2190 reassoc_of% fac\u2082, \u2190 reassoc_of% fac\u2081', \u2190 reassoc_of% fac\u2082',\n        reassoc_of% hft, fac\u2083]\n    obtain \u27e8Z, p, hp, fac\u2084\u27e9 := HasLeftCalculusOfFractions.ext _ _ _ a.hs eq\n    simp only [assoc] at fac\u2084\n    rw [comp_eq _ _ z\u2081 fac\u2081, comp_eq _ _ z\u2082 fac\u2082]\n    apply Quot.sound\n    refine \u27e8Z, w\u2081.f \u226b u.f \u226b p, w\u2082.f \u226b u.s \u226b p, ?_, ?_, ?_\u27e9\n    \u00b7 dsimp\n      simp only [assoc, \u2190 reassoc_of% fac\u2081', \u2190 reassoc_of% fac\u2082',\n        reassoc_of% hst, reassoc_of% fac\u2083]\n    \u00b7 dsimp\n      simp only [assoc, fac\u2084]\n    \u00b7 dsimp\n      simp only [assoc]\n      rw [\u2190 reassoc_of% fac\u2081', \u2190 reassoc_of% fac\u2083, \u2190 assoc]\n      exact W.comp_mem _ _ ht (W.comp_mem _ _ w\u2082.hs (W.comp_mem _ _ u.hs hp))\n  \u00b7 rintro a\u2081 a\u2082 b \u27e8U, t\u2081, t\u2082, hst, hft, ht\u27e9\n    obtain \u27e8z\u2081, fac\u2081\u27e9 := exists_leftFraction (RightFraction.mk a\u2081.s a\u2081.hs b.f)\n    obtain \u27e8z\u2082, fac\u2082\u27e9 := exists_leftFraction (RightFraction.mk a\u2082.s a\u2082.hs b.f)\n    obtain \u27e8w\u2081, fac\u2081'\u27e9 := exists_leftFraction (RightFraction.mk (a\u2081.s \u226b t\u2081) ht (b.f \u226b z\u2081.s))\n    obtain \u27e8w\u2082, fac\u2082'\u27e9 := exists_leftFraction (RightFraction.mk (a\u2082.s \u226b t\u2082)\n      (show W _ by rw [\u2190 hst]; exact ht) (b.f \u226b z\u2082.s))\n    let p\u2081 : W.LeftFraction X Z := LeftFraction.mk (a\u2081.f \u226b t\u2081 \u226b w\u2081.f) (b.s \u226b z\u2081.s \u226b w\u2081.s)\n      (W.comp_mem _ _ b.hs (W.comp_mem _ _ z\u2081.hs w\u2081.hs))\n    let p\u2082 : W.LeftFraction X Z := LeftFraction.mk (a\u2082.f \u226b t\u2082 \u226b w\u2082.f) (b.s \u226b z\u2082.s \u226b w\u2082.s)\n      (W.comp_mem _ _ b.hs (W.comp_mem _ _ z\u2082.hs w\u2082.hs))\n    dsimp at fac\u2081 fac\u2082 fac\u2081' fac\u2082' \u22a2\n    simp only [assoc] at fac\u2081' fac\u2082'\n    rw [comp_eq _ _ z\u2081 fac\u2081, comp_eq _ _ z\u2082 fac\u2082]\n    apply Quot.sound\n    refine LeftFractionRel.trans ?_ ((?_ : LeftFractionRel p\u2081 p\u2082).trans ?_)\n    \u00b7 have eq : a\u2081.s \u226b z\u2081.f \u226b w\u2081.s = a\u2081.s \u226b t\u2081 \u226b w\u2081.f := by rw [\u2190 fac\u2081', reassoc_of% fac\u2081]\n      obtain \u27e8Z, u, hu, fac\u2083\u27e9 := HasLeftCalculusOfFractions.ext _ _ _ a\u2081.hs eq\n      simp only [assoc] at fac\u2083\n      refine \u27e8Z, w\u2081.s \u226b u, u, ?_, ?_, ?_\u27e9\n      \u00b7 dsimp\n        simp only [assoc]\n      \u00b7 dsimp\n        simp only [assoc, fac\u2083]\n      \u00b7 dsimp\n        simp only [assoc]\n        exact W.comp_mem _ _ b.hs (W.comp_mem _ _ z\u2081.hs (W.comp_mem _ _ w\u2081.hs hu))\n    \u00b7 obtain \u27e8q, fac\u2083\u27e9 := exists_leftFraction (RightFraction.mk (z\u2081.s \u226b w\u2081.s)\n        (W.comp_mem _ _ z\u2081.hs w\u2081.hs) (z\u2082.s \u226b w\u2082.s))\n      dsimp at fac\u2083\n      simp only [assoc] at fac\u2083\n      have eq : a\u2081.s \u226b t\u2081 \u226b w\u2081.f \u226b q.f = a\u2081.s \u226b t\u2081 \u226b w\u2082.f \u226b q.s := by\n        rw [\u2190 reassoc_of% fac\u2081', \u2190 fac\u2083, reassoc_of% hst, reassoc_of% fac\u2082']\n      obtain \u27e8Z, u, hu, fac\u2084\u27e9 := HasLeftCalculusOfFractions.ext _ _ _ a\u2081.hs eq\n      simp only [assoc] at fac\u2084\n      refine \u27e8Z, q.f \u226b u, q.s \u226b u, ?_, ?_, ?_\u27e9\n      \u00b7 simp only [assoc, reassoc_of% fac\u2083]\n      \u00b7 rw [assoc, assoc, assoc, assoc, fac\u2084, reassoc_of% hft]\n      \u00b7 simp only [assoc, \u2190 reassoc_of% fac\u2083]\n        exact W.comp_mem _ _ b.hs (W.comp_mem _ _ z\u2082.hs\n          (W.comp_mem _ _ w\u2082.hs (W.comp_mem _ _ q.hs hu)))\n    \u00b7 have eq : a\u2082.s \u226b z\u2082.f \u226b w\u2082.s = a\u2082.s \u226b t\u2082 \u226b w\u2082.f := by\n        rw [\u2190 fac\u2082', reassoc_of% fac\u2082]\n      obtain \u27e8Z, u, hu, fac\u2084\u27e9 := HasLeftCalculusOfFractions.ext _ _ _ a\u2082.hs eq\n      simp only [assoc] at fac\u2084\n      refine \u27e8Z, u, w\u2082.s \u226b u, ?_, ?_, ?_\u27e9\n      \u00b7 dsimp\n        simp only [assoc]\n      \u00b7 dsimp\n        simp only [assoc, fac\u2084]\n      \u00b7 dsimp\n        simp only [assoc]\n        exact W.comp_mem _ _ b.hs (W.comp_mem _ _ z\u2082.hs (W.comp_mem _ _ w\u2082.hs hu))\n\nlemma Hom.comp_eq {X Y Z : C} (z\u2081 : W.LeftFraction X Y) (z\u2082 : W.LeftFraction Y Z) :\n    Hom.comp (mk z\u2081) (mk z\u2082) = z\u2081.comp z\u2082 := rfl\n\nend Localization\n\n/-- The constructed localized category for a morphism property\nthat has left calculus of fractions. -/\n@[nolint unusedArguments]\ndef Localization (_ : MorphismProperty C) := C\n\nnamespace Localization\n\nnoncomputable instance : Category (Localization W) where\n  Hom X Y := Localization.Hom W X Y\n  id X := Localization.Hom.mk (ofHom W (\ud835\udfd9 _))\n  comp f g := f.comp g\n  comp_id := by\n    rintro (X Y : C) f\n    obtain \u27e8z, rfl\u27e9 := Hom.mk_surjective f\n    change (Hom.mk z).comp (Hom.mk (ofHom W (\ud835\udfd9 Y))) = Hom.mk z\n    rw [Hom.comp_eq, comp_eq z (ofHom W (\ud835\udfd9 Y)) (ofInv z.s z.hs) (by simp)]\n    dsimp [comp\u2080]\n    simp only [comp_id, id_comp]\n  id_comp := by\n    rintro (X Y : C) f\n    obtain \u27e8z, rfl\u27e9 := Hom.mk_surjective f\n    change (Hom.mk (ofHom W (\ud835\udfd9 X))).comp (Hom.mk z) = Hom.mk z\n    rw [Hom.comp_eq, comp_eq (ofHom W (\ud835\udfd9 X)) z (ofHom W z.f) (by simp)]\n    dsimp\n    simp only [comp\u2080, id_comp, comp_id]\n  assoc := by\n    rintro (X\u2081 X\u2082 X\u2083 X\u2084 : C) f\u2081 f\u2082 f\u2083\n    obtain \u27e8z\u2081, rfl\u27e9 := Hom.mk_surjective f\u2081\n    obtain \u27e8z\u2082, rfl\u27e9 := Hom.mk_surjective f\u2082\n    obtain \u27e8z\u2083, rfl\u27e9 := Hom.mk_surjective f\u2083\n    change ((Hom.mk z\u2081).comp (Hom.mk z\u2082)).comp (Hom.mk z\u2083) =\n      (Hom.mk z\u2081).comp ((Hom.mk z\u2082).comp (Hom.mk z\u2083))\n    rw [Hom.comp_eq z\u2081 z\u2082, Hom.comp_eq z\u2082 z\u2083]\n    obtain \u27e8z\u2081\u2082, fac\u2081\u2082\u27e9 := exists_leftFraction (RightFraction.mk z\u2081.s z\u2081.hs z\u2082.f)\n    obtain \u27e8z\u2082\u2083, fac\u2082\u2083\u27e9 := exists_leftFraction (RightFraction.mk z\u2082.s z\u2082.hs z\u2083.f)\n    obtain \u27e8z', fac\u27e9 := exists_leftFraction (RightFraction.mk z\u2081\u2082.s z\u2081\u2082.hs z\u2082\u2083.f)\n    dsimp at fac\u2081\u2082 fac\u2082\u2083 fac\n    rw [comp_eq z\u2081 z\u2082 z\u2081\u2082 fac\u2081\u2082, comp_eq z\u2082 z\u2083 z\u2082\u2083 fac\u2082\u2083, comp\u2080, comp\u2080,\n      Hom.comp_eq, Hom.comp_eq,\n      comp_eq _ z\u2083 (mk z'.f (z\u2082\u2083.s \u226b z'.s) (W.comp_mem _ _ z\u2082\u2083.hs z'.hs))\n        (by dsimp; rw [assoc, reassoc_of% fac\u2082\u2083, fac]),\n      comp_eq z\u2081 _ (mk (z\u2081\u2082.f \u226b z'.f) z'.s z'.hs)\n        (by dsimp; rw [assoc, \u2190 reassoc_of% fac\u2081\u2082, fac])]\n    simp\n\nvariable (W)\n\n/-- The localization functor to the constructed localized category for a morphism property\nthat has left calculus of fractions. -/\n@[simps obj]\ndef Q : C \u2964 Localization W where\n  obj X := X\n  map f := Hom.mk (ofHom W f)\n  map_id _ := rfl\n  map_comp {X Y Z} f g := by\n    change _ = Hom.comp _ _\n    rw [Hom.comp_eq, comp_eq (ofHom W f) (ofHom W g) (ofHom W g) (by simp)]\n    simp only [ofHom, comp\u2080, comp_id]\n\nvariable {W}\n\n/-- The morphism on `Localization W` that is induced by a left fraction. -/\nabbrev homMk {X Y : C} (f : W.LeftFraction X Y) : (Q W).obj X \u27f6 (Q W).obj Y := Hom.mk f\n\nlemma homMk_eq_hom_mk {X Y : C} (f : W.LeftFraction X Y) : homMk f = Hom.mk f := rfl\n\nvariable (W)\n\nlemma Q_map {X Y : C} (f : X \u27f6 Y) : (Q W).map f = homMk (ofHom W f) := rfl\n\nvariable {W}\n\nlemma homMk_comp_homMk {X Y Z : C} (z\u2081 : W.LeftFraction X Y) (z\u2082 : W.LeftFraction Y Z)\n    (z\u2083 : W.LeftFraction z\u2081.Y' z\u2082.Y') (h\u2083 : z\u2082.f \u226b z\u2083.s = z\u2081.s \u226b z\u2083.f) :\n    homMk z\u2081 \u226b homMk z\u2082 = homMk (z\u2081.comp\u2080 z\u2082 z\u2083) := by\n  change Hom.comp _ _ = _\n  erw [Hom.comp_eq, comp_eq z\u2081 z\u2082 z\u2083 h\u2083]\n\nlemma homMk_eq_of_leftFractionRel {X Y : C} (z\u2081 z\u2082 : W.LeftFraction X Y)\n    (h : LeftFractionRel z\u2081 z\u2082) :\n    homMk z\u2081 = homMk z\u2082 :=\n  Quot.sound h\n\nlemma homMk_eq_iff_leftFractionRel {X Y : C} (z\u2081 z\u2082 : W.LeftFraction X Y) :\n    homMk z\u2081 = homMk z\u2082 \u2194 LeftFractionRel z\u2081 z\u2082 :=\n  @Equivalence.quot_mk_eq_iff _ _ (equivalenceLeftFractionRel W X Y) _ _\n\n/-- The morphism in `Localization W` that is the formal inverse of a morphism\nwhich belongs to `W`. -/\ndef Qinv {X Y : C} (s : X \u27f6 Y) (hs : W s) : (Q W).obj Y \u27f6 (Q W).obj X := homMk (ofInv s hs)\n\nlemma Q_map_comp_Qinv {X Y Y' : C} (f : X \u27f6 Y') (s : Y \u27f6 Y') (hs : W s) :\n    (Q W).map f \u226b Qinv s hs = homMk (mk f s hs) := by\n  dsimp only [Q_map, Qinv]\n  rw [homMk_comp_homMk (ofHom W f) (ofInv s hs) (ofHom W (\ud835\udfd9 _)) (by simp)]\n  simp\n\n/-- The isomorphism in `Localization W` that is induced by a morphism in `W`. -/\n@[simps]\ndef Qiso {X Y : C} (s : X \u27f6 Y) (hs : W s) : (Q W).obj X \u2245 (Q W).obj Y where\n  hom := (Q W).map s\n  inv := Qinv s hs\n  hom_inv_id := by\n    rw [Q_map_comp_Qinv]\n    apply homMk_eq_of_leftFractionRel\n    exact \u27e8_, \ud835\udfd9 Y, s, by simp, by simp, by simpa using hs\u27e9\n  inv_hom_id := by\n    dsimp only [Qinv, Q_map]\n    rw [homMk_comp_homMk (ofInv s hs) (ofHom W s) (ofHom W (\ud835\udfd9 Y)) (by simp)]\n    apply homMk_eq_of_leftFractionRel\n    exact \u27e8_, \ud835\udfd9 Y, \ud835\udfd9 Y, by simp, by simp, by simpa using W.id_mem Y\u27e9\n\n@[reassoc (attr := simp)]\nlemma Qiso_hom_inv_id {X Y : C} (s : X \u27f6 Y) (hs : W s) :\n    (Q W).map s \u226b Qinv s hs = \ud835\udfd9 _ := (Qiso s hs).hom_inv_id\n\n@[reassoc (attr := simp)]\nlemma Qiso_inv_hom_id {X Y : C} (s : X \u27f6 Y) (hs : W s) :\n    Qinv s hs  \u226b (Q W).map s = \ud835\udfd9 _ := (Qiso s hs).inv_hom_id\n\ninstance {X Y : C} (s : X \u27f6 Y) (hs : W s) : IsIso (Qinv s hs) :=\n  (inferInstance : IsIso (Qiso s hs).inv)\n\nsection\n\nvariable {E : Type*} [Category E]\n\n/-- The image by a functor which inverts `W` of an equivalence class of left fractions. -/\nnoncomputable def Hom.map {X Y : C} (f : Hom W X Y) (F : C \u2964 E) (hF : W.IsInvertedBy F) :\n    F.obj X \u27f6 F.obj Y :=\n  Quot.lift (fun f => f.map F hF) (by\n    intro a\u2081 a\u2082 \u27e8Z, t\u2081, t\u2082, hst, hft, h\u27e9\n    dsimp\n    have := hF _ h\n    rw [\u2190 cancel_mono (F.map (a\u2081.s \u226b t\u2081)), F.map_comp, map_comp_map_s_assoc,\n      \u2190 F.map_comp, \u2190 F.map_comp, hst, hft, F.map_comp,\n      F.map_comp, map_comp_map_s_assoc]) f\n\n@[simp]\nlemma Hom.map_mk {X Y : C} (f : LeftFraction W X Y)\n    (F : C \u2964 E) (hF : W.IsInvertedBy F) :\n  Hom.map (Hom.mk f) F hF = f.map F hF := rfl\n\nnamespace StrictUniversalPropertyFixedTarget\n\nvariable (W)\n\nlemma inverts : W.IsInvertedBy (Q W) := fun _ _ s hs =>\n  (inferInstance : IsIso (Qiso s hs).hom)\n\nvariable {W}\n\n/-- The functor `Localization W \u2964 E` that is induced by a functor `C \u2964 E` which inverts `W`,\nwhen `W` has a left calculus of fractions. -/\nnoncomputable def lift (F : C \u2964 E) (hF : W.IsInvertedBy F) :\n    Localization W \u2964 E where\n  obj X := F.obj X\n  map {X Y : C} f := f.map F hF\n  map_id := by\n    intro (X : C)\n    dsimp\n    change (Hom.mk (ofHom W (\ud835\udfd9 X))).map F hF = _\n    rw [Hom.map_mk, map_ofHom, F.map_id]\n  map_comp := by\n    rintro (X Y Z : C) f g\n    obtain \u27e8f, rfl\u27e9 := Hom.mk_surjective f\n    obtain \u27e8g, rfl\u27e9 := Hom.mk_surjective g\n    dsimp\n    obtain \u27e8z, fac\u27e9 := HasLeftCalculusOfFractions.exists_leftFraction\n      (RightFraction.mk f.s f.hs g.f)\n    rw [homMk_comp_homMk f g z fac, Hom.map_mk]\n    dsimp at fac \u22a2\n    have := hF _ g.hs\n    have := hF _ z.hs\n    rw [\u2190 cancel_mono (F.map g.s), assoc, map_comp_map_s,\n      \u2190 cancel_mono (F.map z.s), assoc, assoc, \u2190 F.map_comp,\n      \u2190 F.map_comp, map_comp_map_s, fac]\n    dsimp\n    rw [F.map_comp, F.map_comp, map_comp_map_s_assoc]\n\nlemma fac (F : C \u2964 E) (hF : W.IsInvertedBy F) : Q W \u22d9 lift F hF = F :=\n  Functor.ext (fun X => rfl) (fun X Y f => by\n    dsimp [lift]\n    rw [Q_map, Hom.map_mk, id_comp, comp_id, map_ofHom])\n\n\nlemma uniq (F\u2081 F\u2082 : Localization W \u2964 E) (h : Q W \u22d9 F\u2081 = Q W \u22d9 F\u2082) : F\u2081 = F\u2082  := by\n  exact Functor.ext (fun X => rfl) (by intro X Y f; simp [h]; erw [\u2190 cancel_epi (F\u2082.map ((Q W).map f.s)), \u2190 F\u2082.map_comp_assoc, Qiso_hom_inv_id, Functor.map_id, id_comp]; rw [F\u2081.map_comp])\n", "allTactics": true, "theorems": true, "env": 0}