repo,file,decl,method,n,metric,model,annotation,syntax_search,mathlib_search,examples,improved_context,og_correct,og_errors,og_score,new_correct,new_errors,new_score,delta,og_raw,new_raw,time
equational_theories,equational_theories/Compactness.lean,"def derive.Weak {α} {Γ Δ : Ctx α}{E : MagmaLaw α}(inc : Γ ⊆ Δ) (h : Γ ⊢ E) :
    Δ ⊢ E ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,True,True,,26,True,,7,-0.7307692307692307,"
def derive.Weak {α} {Γ Δ : Ctx α}{E : MagmaLaw α}(inc : Γ ⊆ Δ) (h : Γ ⊢ E) :
    Δ ⊢ E  := by
  cases h
  case Ax => refine derive.Ax (inc ?_); assumption
  case Ref => exact derive.Ref
  case Sym => apply derive.Sym ; apply derive.Weak _ <;> trivial
  case Trans => apply derive.Trans <;> try apply derive.Weak <;> assumption
  case Subst => apply derive.Subst ; apply derive.Weak <;> assumption
  case Cong => apply derive.Cong <;> apply derive.Weak <;> assumption","
def derive.Weak {α} {Γ Δ : Ctx α}{E : MagmaLaw α}(inc : Γ ⊆ Δ) (h : Γ ⊢ E) :
    Δ ⊢ E   := by
  induction h with
    | Ax h => exact derive.Ax (inc h)
    | Ref => exact derive.Ref
    | Sym h => exact derive.Sym (derive.Weak inc h)
    | Trans h₁ h₂ => exact derive.Trans (derive.Weak inc h₁) (derive.Weak inc h₂)
    | Subst σ h => exact derive.Subst σ (derive.Weak inc h)
    | Cong h₁ h₂ => exact derive.Cong (derive.Weak inc h₁) (derive.Weak inc h₂)",61.69551467895508
equational_theories,equational_theories/Compactness.lean,"def derive.getAxiomsEnough {α} [DecidableEq α] {Γ : Ctx α} {E : MagmaLaw α} (h : Γ ⊢ E) :
    ToCtx (derive.getAxioms h) ⊢ E ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,True,True,,19,True,,14,-0.2631578947368421,"
def derive.getAxiomsEnough {α} [DecidableEq α] {Γ : Ctx α} {E : MagmaLaw α} (h : Γ ⊢ E) :
    ToCtx (derive.getAxioms h) ⊢ E  := by
  cases h <;> simp [ToCtx, getAxioms]
  case Ax => constructor; rfl
  case Ref => exact derive.Ref
  case Sym _ _ h => exact derive.Sym (derive.getAxiomsEnough _)
  case Trans _ _ _ h₁ h₂ =>
    apply derive.Trans
    · exact derive.Weak Set.subset_union_left (derive.getAxiomsEnough h₁)
    · exact derive.Weak Set.subset_union_right (derive.getAxiomsEnough h₂)
  case Subst => exact derive.Subst _ (derive.getAxiomsEnough _)
  case Cong _ _ _ h₁ h₂ =>
    exact derive.Cong (derive.Weak Set.subset_union_left (derive.getAxiomsEnough h₁))
      (derive.Weak Set.subset_union_right (derive.getAxiomsEnough h₂))","
def derive.getAxiomsEnough {α} [DecidableEq α] {Γ : Ctx α} {E : MagmaLaw α} (h : Γ ⊢ E) :
    ToCtx (derive.getAxioms h) ⊢ E    := by
  cases h <;> simp [ToCtx, getAxioms]
  case Ax => constructor; rfl
  case Ref => exact derive.Ref
  case Sym => exact derive.Sym (derive.getAxiomsEnough _)
  case Trans => exact derive.Trans (derive.Weak Set.subset_union_left (derive.getAxiomsEnough _)) (derive.Weak Set.subset_union_right (derive.getAxiomsEnough _))
  case Subst => exact derive.Subst _ (derive.getAxiomsEnough _)
  case Cong => exact derive.Cong (derive.Weak Set.subset_union_left (derive.getAxiomsEnough _)) (derive.Weak Set.subset_union_right (derive.getAxiomsEnough _))",130.7724301815033
equational_theories,equational_theories/Compactness.lean,"def Compactness {α} [DecidableEq α] {Γ : Ctx α} {E : MagmaLaw α} (h : Γ ⊧ E) :
    ∃ (Δ : Finset (MagmaLaw α)), Nonempty <| ToCtx Δ ⊧ E ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,True,True,,2,True,,1,-0.5,"
def Compactness {α} [DecidableEq α] {Γ : Ctx α} {E : MagmaLaw α} (h : Γ ⊧ E) :
    ∃ (Δ : Finset (MagmaLaw α)), Nonempty <| ToCtx Δ ⊧ E  := by
  have ⟨h''⟩ := Completeness h
  exact ⟨derive.getAxioms h'', ⟨Soundness (derive.getAxiomsEnough _)⟩⟩","
def Compactness {α} [DecidableEq α] {Γ : Ctx α} {E : MagmaLaw α} (h : Γ ⊧ E) :
    ∃ (Δ : Finset (MagmaLaw α)), Nonempty <| ToCtx Δ ⊧ E   := by
  exact ⟨derive.getAxioms (Classical.choice (Completeness h)), ⟨Soundness (derive.getAxiomsEnough (Classical.choice (Completeness h)))⟩⟩",85.65119004249573
