repo,file,decl,method,n,metric,model,annotation,syntax_search,mathlib_search,examples,improved_context,og_correct,og_errors,og_score,new_correct,new_errors,new_score,delta,og_raw,new_raw,time
mathlib,Mathlib/AlgebraicTopology/Quasicategory.lean,"lemma quasicategory_of_filler (S : SSet)
    (filler : ‚àÄ ‚¶Én : ‚Ñï‚¶Ñ ‚¶Éi : Fin (n+3)‚¶Ñ (œÉ‚ÇÄ : Œõ[n+2, i] ‚ü∂ S)
      (_h0 : 0 < i) (_hn : i < Fin.last (n+2)),
      ‚àÉ œÉ : S _[n+2], ‚àÄ (j) (h : j ‚â† i), S.Œ¥ j œÉ = œÉ‚ÇÄ.app _ (horn.face i j h)) :
    Quasicategory S where
  hornFilling' n i œÉ‚ÇÄ h‚ÇÄ h‚Çô ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,6,True,,6,0.0,"lemma quasicategory_of_filler (S : SSet)
    (filler : ‚àÄ ‚¶Én : ‚Ñï‚¶Ñ ‚¶Éi : Fin (n+3)‚¶Ñ (œÉ‚ÇÄ : Œõ[n+2, i] ‚ü∂ S)
      (_h0 : 0 < i) (_hn : i < Fin.last (n+2)),
      ‚àÉ œÉ : S _[n+2], ‚àÄ (j) (h : j ‚â† i), S.Œ¥ j œÉ = œÉ‚ÇÄ.app _ (horn.face i j h)) :
    Quasicategory S where
  hornFilling' n i œÉ‚ÇÄ h‚ÇÄ h‚Çô := by
    obtain ‚ü®œÉ, h‚ü© := filler œÉ‚ÇÄ h‚ÇÄ h‚Çô
    refine ‚ü®(S.yonedaEquiv _).symm œÉ, ?_‚ü©
    apply horn.hom_ext
    intro j hj
    rw [‚Üê h j hj, NatTrans.comp_app]
    rfl","lemma quasicategory_of_filler (S : SSet)
    (filler : ‚àÄ ‚¶Én : ‚Ñï‚¶Ñ ‚¶Éi : Fin (n+3)‚¶Ñ (œÉ‚ÇÄ : Œõ[n+2, i] ‚ü∂ S)
      (_h0 : 0 < i) (_hn : i < Fin.last (n+2)),
      ‚àÉ œÉ : S _[n+2], ‚àÄ (j) (h : j ‚â† i), S.Œ¥ j œÉ = œÉ‚ÇÄ.app _ (horn.face i j h)) :
    Quasicategory S where
  hornFilling' n i œÉ‚ÇÄ h‚ÇÄ h‚Çô := by
    obtain ‚ü®œÉ, h‚ü© := filler œÉ‚ÇÄ h‚ÇÄ h‚Çô
    refine ‚ü®(S.yonedaEquiv _).symm œÉ, ?_‚ü©
    apply horn.hom_ext
    intro j hj
    rw [‚Üê h j hj, NatTrans.comp_app]
    rfl",35.2906391620636
mathlib,Mathlib/AlgebraicTopology/SimplexCategory.lean,theorem eq_id_of_mono {x : SimplexCategory} (i : x ‚ü∂ x) [Mono i] : i = ùüô _ ,"refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,6,True,,3,-0.5,"theorem eq_id_of_mono {x : SimplexCategory} (i : x ‚ü∂ x) [Mono i] : i = ùüô _ := by
  suffices IsIso i by
    apply eq_id_of_isIso
  apply isIso_of_bijective
  dsimp
  rw [Fintype.bijective_iff_injective_and_card i.toOrderHom, ‚Üê mono_iff_injective,
    eq_self_iff_true, and_true_iff]
  infer_instance","theorem eq_id_of_mono {x : SimplexCategory} (i : x ‚ü∂ x) [Mono i] : i = ùüô _  := by
  apply eq_id_of_isIso
  apply isIso_of_bijective
  rw [Fintype.bijective_iff_injective_and_card i.toOrderHom, ‚Üê mono_iff_injective]
  infer_instance
",177.42750191688538
mathlib,Mathlib/AlgebraicTopology/SimplexCategory.lean,"theorem len_lt_of_mono {Œî' Œî : SimplexCategory} (i : Œî' ‚ü∂ Œî) [hi : Mono i] (hi' : Œî ‚â† Œî') :
    Œî'.len < Œî.len ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,7,True,,3,-0.5714285714285714,"theorem len_lt_of_mono {Œî' Œî : SimplexCategory} (i : Œî' ‚ü∂ Œî) [hi : Mono i] (hi' : Œî ‚â† Œî') :
    Œî'.len < Œî.len := by
  rcases lt_or_eq_of_le (len_le_of_mono hi) with (h | h)
  ¬∑ exact h
  ¬∑ exfalso
    exact hi' (by ext; exact h.symm)","theorem len_lt_of_mono {Œî' Œî : SimplexCategory} (i : Œî' ‚ü∂ Œî) [hi : Mono i] (hi' : Œî ‚â† Œî') :
    Œî'.len < Œî.len   := by
  contrapose! hi'
  ext
  linarith [len_le_of_mono hi]",192.82452607154846
mathlib,Mathlib/AlgebraicTopology/DoldKan/Normalized.lean,"theorem factors_normalizedMooreComplex_PInfty (n : ‚Ñï) :
    Subobject.Factors (NormalizedMooreComplex.objX X n) (PInfty.f n) ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,6,True,,2,-0.6666666666666666,"theorem factors_normalizedMooreComplex_PInfty (n : ‚Ñï) :
    Subobject.Factors (NormalizedMooreComplex.objX X n) (PInfty.f n) := by
  rcases n with _|n
  ¬∑ apply top_factors
  ¬∑ rw [PInfty_f, NormalizedMooreComplex.objX, finset_inf_factors]
    intro i _
    apply kernelSubobject_factors
    exact (HigherFacesVanish.of_P (n + 1) n) i le_add_self","theorem factors_normalizedMooreComplex_PInfty (n : ‚Ñï) :
    Subobject.Factors (NormalizedMooreComplex.objX X n) (PInfty.f n)  := by
  cases n with _ n",31.200101137161255
mathlib,Mathlib/AlgebraicTopology/DoldKan/Projections.lean,"theorem comp_P_eq_self_iff {Y : C} {n q : ‚Ñï} {œÜ : Y ‚ü∂ X _[n + 1]} :
    œÜ ‚â´ (P q).f (n + 1) = œÜ ‚Üî HigherFacesVanish q œÜ ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,6,True,,6,0.0,"theorem comp_P_eq_self_iff {Y : C} {n q : ‚Ñï} {œÜ : Y ‚ü∂ X _[n + 1]} :
    œÜ ‚â´ (P q).f (n + 1) = œÜ ‚Üî HigherFacesVanish q œÜ := by
  constructor
  ¬∑ intro hœÜ
    rw [‚Üê hœÜ]
    apply HigherFacesVanish.of_comp
    apply HigherFacesVanish.of_P
  ¬∑ exact HigherFacesVanish.comp_P_eq_self","theorem comp_P_eq_self_iff {Y : C} {n q : ‚Ñï} {œÜ : Y ‚ü∂ X _[n + 1]} :
    œÜ ‚â´ (P q).f (n + 1) = œÜ ‚Üî HigherFacesVanish q œÜ := by
  constructor
  ¬∑ intro hœÜ
    rw [‚Üê hœÜ]
    apply HigherFacesVanish.of_comp
    apply HigherFacesVanish.of_P
  ¬∑ exact HigherFacesVanish.comp_P_eq_self",57.29748797416687
mathlib,Mathlib/AlgebraicTopology/DoldKan/Decomposition.lean,"@[simp]
theorem id_œÜ : (id X n).œÜ = ùüô _ ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,7,True,,7,0.0,"@[simp]
theorem id_œÜ : (id X n).œÜ = ùüô _ := by
  simp only [‚Üê P_add_Q_f (n + 1) (n + 1), œÜ]
  congr 1
  ¬∑ simp only [id, PInfty_f, P_f_idem]
  ¬∑ exact Eq.trans (by congr; simp) (decomposition_Q n (n + 1)).symm","@[simp]
theorem id_œÜ : (id X n).œÜ = ùüô _ := by
  simp only [‚Üê P_add_Q_f (n + 1) (n + 1), œÜ]
  congr 1
  ¬∑ simp only [id, PInfty_f, P_f_idem]
  ¬∑ exact Eq.trans (by congr; simp) (decomposition_Q n (n + 1)).symm",60.29511308670044
mathlib,Mathlib/AlgebraicTopology/DoldKan/Homotopies.lean,"theorem hœÉ'_eq {q n a m : ‚Ñï} (ha : n = a + q) (hnm : c.Rel m n) :
    (hœÉ' q n m hnm : X _[n] ‚ü∂ X _[m]) =
      ((-1 : ‚Ñ§) ^ a ‚Ä¢ X.œÉ ‚ü®a, Nat.lt_succ_iff.mpr (Nat.le.intro (Eq.symm ha))‚ü©) ‚â´
        eqToHom (by congr) ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,6,True,,6,0.0,"theorem hœÉ'_eq {q n a m : ‚Ñï} (ha : n = a + q) (hnm : c.Rel m n) :
    (hœÉ' q n m hnm : X _[n] ‚ü∂ X _[m]) =
      ((-1 : ‚Ñ§) ^ a ‚Ä¢ X.œÉ ‚ü®a, Nat.lt_succ_iff.mpr (Nat.le.intro (Eq.symm ha))‚ü©) ‚â´
        eqToHom (by congr) := by
  simp only [hœÉ', hœÉ]
  split_ifs
  ¬∑ omega
  ¬∑ have h' := tsub_eq_of_eq_add ha
    congr","theorem hœÉ'_eq {q n a m : ‚Ñï} (ha : n = a + q) (hnm : c.Rel m n) :
    (hœÉ' q n m hnm : X _[n] ‚ü∂ X _[m]) =
      ((-1 : ‚Ñ§) ^ a ‚Ä¢ X.œÉ ‚ü®a, Nat.lt_succ_iff.mpr (Nat.le.intro (Eq.symm ha))‚ü©) ‚â´
        eqToHom (by congr) := by
  simp only [hœÉ', hœÉ]
  split_ifs
  ¬∑ omega
  ¬∑ have h' := tsub_eq_of_eq_add ha
    congr",24.88035011291504
mathlib,Mathlib/AlgebraicTopology/DoldKan/Homotopies.lean,"/-- The null homotopic maps `HœÉ` are compatible with the application of additive functors. -/
theorem map_HœÉ {D : Type*} [Category D] [Preadditive D] (G : C ‚•§ D) [G.Additive]
    (X : SimplicialObject C) (q n : ‚Ñï) :
    (HœÉ q : K[((whiskering C D).obj G).obj X] ‚ü∂ _).f n = G.map ((HœÉ q : K[X] ‚ü∂ _).f n) ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,6,True,,6,0.0,"/-- The null homotopic maps `HœÉ` are compatible with the application of additive functors. -/
theorem map_HœÉ {D : Type*} [Category D] [Preadditive D] (G : C ‚•§ D) [G.Additive]
    (X : SimplicialObject C) (q n : ‚Ñï) :
    (HœÉ q : K[((whiskering C D).obj G).obj X] ‚ü∂ _).f n = G.map ((HœÉ q : K[X] ‚ü∂ _).f n) := by
  unfold HœÉ
  have eq := HomologicalComplex.congr_hom (map_nullHomotopicMap' G (@hœÉ' _ _ _ X q)) n
  simp only [Functor.mapHomologicalComplex_map_f, ‚Üê map_hœÉ'] at eq
  rw [eq]
  let h := (Functor.congr_obj (map_alternatingFaceMapComplex G) X).symm
  congr","/-- The null homotopic maps `HœÉ` are compatible with the application of additive functors. -/
theorem map_HœÉ {D : Type*} [Category D] [Preadditive D] (G : C ‚•§ D) [G.Additive]
    (X : SimplicialObject C) (q n : ‚Ñï) :
    (HœÉ q : K[((whiskering C D).obj G).obj X] ‚ü∂ _).f n = G.map ((HœÉ q : K[X] ‚ü∂ _).f n) := by
  unfold HœÉ
  have eq := HomologicalComplex.congr_hom (map_nullHomotopicMap' G (@hœÉ' _ _ _ X q)) n
  simp only [Functor.mapHomologicalComplex_map_f, ‚Üê map_hœÉ'] at eq
  rw [eq]
  let h := (Functor.congr_obj (map_alternatingFaceMapComplex G) X).symm
  congr",51.763251304626465
mathlib,Mathlib/AlgebraicTopology/DoldKan/NCompGamma.lean,"theorem compatibility_Œì‚ÇÇN‚ÇÅ_Œì‚ÇÇN‚ÇÇ_natTrans (X : SimplicialObject C) :
    Œì‚ÇÇN‚ÇÅ.natTrans.app X =
      (Œì‚ÇÇN‚ÇÇToKaroubiIso.app X).inv ‚â´
        Œì‚ÇÇN‚ÇÇ.natTrans.app ((toKaroubi (SimplicialObject C)).obj X) ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,6,True,,6,0.0,"theorem compatibility_Œì‚ÇÇN‚ÇÅ_Œì‚ÇÇN‚ÇÇ_natTrans (X : SimplicialObject C) :
    Œì‚ÇÇN‚ÇÅ.natTrans.app X =
      (Œì‚ÇÇN‚ÇÇToKaroubiIso.app X).inv ‚â´
        Œì‚ÇÇN‚ÇÇ.natTrans.app ((toKaroubi (SimplicialObject C)).obj X) := by
  rw [Œì‚ÇÇN‚ÇÇ.natTrans_app_f_app]
  dsimp only [Karoubi.decompId_i_toKaroubi, Karoubi.decompId_p_toKaroubi, Functor.comp_map,
    NatTrans.comp_app]
  rw [N‚ÇÇ.map_id, Œì‚ÇÇ.map_id, Iso.app_inv]
  dsimp only [toKaroubi]
  erw [id_comp]
  rw [comp_id, Iso.inv_hom_id_app_assoc]","theorem compatibility_Œì‚ÇÇN‚ÇÅ_Œì‚ÇÇN‚ÇÇ_natTrans (X : SimplicialObject C) :
    Œì‚ÇÇN‚ÇÅ.natTrans.app X =
      (Œì‚ÇÇN‚ÇÇToKaroubiIso.app X).inv ‚â´
        Œì‚ÇÇN‚ÇÇ.natTrans.app ((toKaroubi (SimplicialObject C)).obj X) := by
  rw [Œì‚ÇÇN‚ÇÇ.natTrans_app_f_app]
  dsimp only [Karoubi.decompId_i_toKaroubi, Karoubi.decompId_p_toKaroubi, Functor.comp_map,
    NatTrans.comp_app]
  rw [N‚ÇÇ.map_id, Œì‚ÇÇ.map_id, Iso.app_inv]
  dsimp only [toKaroubi]
  erw [id_comp]
  rw [comp_id, Iso.inv_hom_id_app_assoc]",119.69017386436462
mathlib,Mathlib/AlgebraicTopology/SplitSimplicialObject.lean,"theorem ext (A‚ÇÅ A‚ÇÇ : IndexSet Œî) (h‚ÇÅ : A‚ÇÅ.1 = A‚ÇÇ.1) (h‚ÇÇ : A‚ÇÅ.e ‚â´ eqToHom (by rw [h‚ÇÅ]) = A‚ÇÇ.e) :
    A‚ÇÅ = A‚ÇÇ ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,7,True,,2,-0.7142857142857143,"theorem ext (A‚ÇÅ A‚ÇÇ : IndexSet Œî) (h‚ÇÅ : A‚ÇÅ.1 = A‚ÇÇ.1) (h‚ÇÇ : A‚ÇÅ.e ‚â´ eqToHom (by rw [h‚ÇÅ]) = A‚ÇÇ.e) :
    A‚ÇÅ = A‚ÇÇ := by
  rcases A‚ÇÅ with ‚ü®Œî‚ÇÅ, ‚ü®Œ±‚ÇÅ, hŒ±‚ÇÅ‚ü©‚ü©
  rcases A‚ÇÇ with ‚ü®Œî‚ÇÇ, ‚ü®Œ±‚ÇÇ, hŒ±‚ÇÇ‚ü©‚ü©
  simp only at h‚ÇÅ
  subst h‚ÇÅ
  simp only [eqToHom_refl, comp_id, IndexSet.e] at h‚ÇÇ
  simp only [h‚ÇÇ]","theorem ext (A‚ÇÅ A‚ÇÇ : IndexSet Œî) (h‚ÇÅ : A‚ÇÅ.1 = A‚ÇÇ.1) (h‚ÇÇ : A‚ÇÅ.e ‚â´ eqToHom (by rw [h‚ÇÅ]) = A‚ÇÇ.e) :
    A‚ÇÅ = A‚ÇÇ  := by
  ext1 (by simp [h‚ÇÅ, h‚ÇÇ])",26.310317039489746
mathlib,Mathlib/AlgebraicTopology/MooreComplex.lean,theorem d_squared (n : ‚Ñï) : objD X (n + 1) ‚â´ objD X n = 0 ,"refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,7,True,,2,-0.7142857142857143,"theorem d_squared (n : ‚Ñï) : objD X (n + 1) ‚â´ objD X n = 0 := by
  -- It's a pity we need to do a case split here;
    -- after the first erw the proofs are almost identical
  rcases n with _ | n <;> dsimp [objD]
  ¬∑ erw [Subobject.factorThru_arrow_assoc, Category.assoc,
      ‚Üê X.Œ¥_comp_Œ¥_assoc (Fin.zero_le (0 : Fin 2)),
      ‚Üê factorThru_arrow _ _ (finset_inf_arrow_factors Finset.univ _ (0 : Fin 2) (by simp)),
      Category.assoc, kernelSubobject_arrow_comp_assoc, zero_comp, comp_zero]
  ¬∑ erw [factorThru_right, factorThru_eq_zero, factorThru_arrow_assoc, Category.assoc,
      ‚Üê X.Œ¥_comp_Œ¥ (Fin.zero_le (0 : Fin (n + 3))),
      ‚Üê factorThru_arrow _ _ (finset_inf_arrow_factors Finset.univ _ (0 : Fin (n + 3)) (by simp)),
      Category.assoc, kernelSubobject_arrow_comp_assoc, zero_comp, comp_zero]","theorem d_squared (n : ‚Ñï) : objD X (n + 1) ‚â´ objD X n = 0  := by
  induction n with _ n <;> dsimp [objD]",44.281121015548706
mathlib,Mathlib/AlgebraicTopology/SplitSimplicialObject.lean,"theorem hom_ext (f g : X ‚ü∂ Y) (h : ‚àÄ n : ‚Ñï, s.œÜ f n = s.œÜ g n) : f = g ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,7,True,,4,-0.42857142857142855,"theorem hom_ext (f g : X ‚ü∂ Y) (h : ‚àÄ n : ‚Ñï, s.œÜ f n = s.œÜ g n) : f = g := by
  ext Œî
  apply s.hom_ext'
  intro A
  induction' Œî using Opposite.rec with Œî
  induction' Œî using SimplexCategory.rec with n
  dsimp
  simp only [s.cofan_inj_comp_app, h]","theorem hom_ext (f g : X ‚ü∂ Y) (h : ‚àÄ n : ‚Ñï, s.œÜ f n = s.œÜ g n) : f = g  := by
  ext Œî
  apply s.hom_ext'
  intro A
  simp only [s.cofan_inj_comp_app, h]",43.50286388397217
mathlib,Mathlib/AlgebraicTopology/DoldKan/SplitSimplicialObject.lean,"theorem decomposition_id (Œî : SimplexCategory·µí·µñ) :
    ùüô (X.obj Œî) = ‚àë A : IndexSet Œî, s.œÄSummand A ‚â´ (s.cofan Œî).inj A ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,7,True,,2,-0.7142857142857143,"theorem decomposition_id (Œî : SimplexCategory·µí·µñ) :
    ùüô (X.obj Œî) = ‚àë A : IndexSet Œî, s.œÄSummand A ‚â´ (s.cofan Œî).inj A := by
  apply s.hom_ext'
  intro A
  dsimp
  erw [comp_id, comp_sum, Finset.sum_eq_single A, cofan_inj_œÄSummand_eq_id_assoc]
  ¬∑ intro B _ h‚ÇÇ
    rw [s.cofan_inj_œÄSummand_eq_zero_assoc _ _ h‚ÇÇ, zero_comp]
  ¬∑ simp","theorem decomposition_id (Œî : SimplexCategory·µí·µñ) :
    ùüô (X.obj Œî) = ‚àë A : IndexSet Œî, s.œÄSummand A ‚â´ (s.cofan Œî).inj A  := by
  apply s.hom_ext'; intro A
  simp [comp_sum, Finset.sum_eq_single A, cofan_inj_œÄSummand_eq_id]
  intros B _ hB; simp [s.cofan_inj_œÄSummand_eq_zero _ _ hB]",28.46649193763733
mathlib,Mathlib/AlgebraicTopology/SimplexCategory.lean,theorem iso_eq_iso_refl {x : SimplexCategory} (e : x ‚âÖ x) : e = Iso.refl x ,"refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,7,True,,7,0.0,"theorem iso_eq_iso_refl {x : SimplexCategory} (e : x ‚âÖ x) : e = Iso.refl x := by
  have h : (Finset.univ : Finset (Fin (x.len + 1))).card = x.len + 1 := Finset.card_fin (x.len + 1)
  have eq‚ÇÅ := Finset.orderEmbOfFin_unique' h fun i => Finset.mem_univ ((orderIsoOfIso e) i)
  have eq‚ÇÇ :=
    Finset.orderEmbOfFin_unique' h fun i => Finset.mem_univ ((orderIsoOfIso (Iso.refl x)) i)
  -- Porting note: the proof was rewritten from this point in #3414 (reenableeta)
  -- It could be investigated again to see if the original can be restored.
  ext x
  replace eq‚ÇÅ := congr_arg (¬∑ x) eq‚ÇÅ
  replace eq‚ÇÇ := congr_arg (¬∑ x) eq‚ÇÇ.symm
  simp_all","theorem iso_eq_iso_refl {x : SimplexCategory} (e : x ‚âÖ x) : e = Iso.refl x := by
  have h : (Finset.univ : Finset (Fin (x.len + 1))).card = x.len + 1 := Finset.card_fin (x.len + 1)
  have eq‚ÇÅ := Finset.orderEmbOfFin_unique' h fun i => Finset.mem_univ ((orderIsoOfIso e) i)
  have eq‚ÇÇ :=
    Finset.orderEmbOfFin_unique' h fun i => Finset.mem_univ ((orderIsoOfIso (Iso.refl x)) i)
  -- Porting note: the proof was rewritten from this point in #3414 (reenableeta)
  -- It could be investigated again to see if the original can be restored.
  ext x
  replace eq‚ÇÅ := congr_arg (¬∑ x) eq‚ÇÅ
  replace eq‚ÇÇ := congr_arg (¬∑ x) eq‚ÇÇ.symm
  simp_all",147.43920803070068
mathlib,Mathlib/AlgebraicTopology/SimplexCategory.lean,theorem eq_id_of_epi {x : SimplexCategory} (i : x ‚ü∂ x) [Epi i] : i = ùüô _ ,"refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,7,True,,3,-0.5714285714285714,"theorem eq_id_of_epi {x : SimplexCategory} (i : x ‚ü∂ x) [Epi i] : i = ùüô _ := by
  suffices IsIso i by
    haveI := this
    apply eq_id_of_isIso
  apply isIso_of_bijective
  dsimp
  rw [Fintype.bijective_iff_surjective_and_card i.toOrderHom, ‚Üê epi_iff_surjective,
    eq_self_iff_true, and_true_iff]
  infer_instance","theorem eq_id_of_epi {x : SimplexCategory} (i : x ‚ü∂ x) [Epi i] : i = ùüô _  := by
  apply eq_id_of_isIso
  apply isIso_of_bijective
  simp [Fintype.bijective_iff_surjective_and_card, epi_iff_surjective]

",179.79900908470154
mathlib,Mathlib/AlgebraicTopology/DoldKan/Degeneracies.lean,"theorem comp_œÉ {Y : C} {X : SimplicialObject C} {n b q : ‚Ñï} {œÜ : Y ‚ü∂ X _[n + 1]}
    (v : HigherFacesVanish q œÜ) (hnbq : n + 1 = b + q) :
    HigherFacesVanish q
      (œÜ ‚â´
        X.œÉ ‚ü®b, by
          simp only [hnbq, Nat.lt_add_one_iff, le_add_iff_nonneg_right, zero_le]‚ü©) ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,7,True,,7,0.0,"theorem HigherFacesVanish.comp_œÉ {Y : C} {X : SimplicialObject C} {n b q : ‚Ñï} {œÜ : Y ‚ü∂ X _[n + 1]}
    (v : HigherFacesVanish q œÜ) (hnbq : n + 1 = b + q) :
    HigherFacesVanish q
      (œÜ ‚â´
        X.œÉ ‚ü®b, by
          simp only [hnbq, Nat.lt_add_one_iff, le_add_iff_nonneg_right, zero_le]‚ü©) :=
  fun j hj => by
  rw [assoc, SimplicialObject.Œ¥_comp_œÉ_of_gt', Fin.pred_succ, v.comp_Œ¥_eq_zero_assoc _ _ hj,
    zero_comp]
  ¬∑ dsimp
    rw [Fin.lt_iff_val_lt_val, Fin.val_succ]
    linarith
  ¬∑ intro hj'
    simp only [hnbq, add_comm b, add_assoc, hj', Fin.val_zero, zero_add, add_le_iff_nonpos_right,
      nonpos_iff_eq_zero, add_eq_zero, false_and] at hj","theorem HigherFacesVanish.comp_œÉ {Y : C} {X : SimplicialObject C} {n b q : ‚Ñï} {œÜ : Y ‚ü∂ X _[n + 1]}
    (v : HigherFacesVanish q œÜ) (hnbq : n + 1 = b + q) :
    HigherFacesVanish q
      (œÜ ‚â´
        X.œÉ ‚ü®b, by
          simp only [hnbq, Nat.lt_add_one_iff, le_add_iff_nonneg_right, zero_le]‚ü©) :=
  fun j hj => by
  rw [assoc, SimplicialObject.Œ¥_comp_œÉ_of_gt', Fin.pred_succ, v.comp_Œ¥_eq_zero_assoc _ _ hj,
    zero_comp]
  ¬∑ dsimp
    rw [Fin.lt_iff_val_lt_val, Fin.val_succ]
    linarith
  ¬∑ intro hj'
    simp only [hnbq, add_comm b, add_assoc, hj', Fin.val_zero, zero_add, add_le_iff_nonpos_right,
      nonpos_iff_eq_zero, add_eq_zero, false_and] at hj",36.419008016586304
mathlib,Mathlib/AlgebraicTopology/DoldKan/Degeneracies.lean,"theorem HigherFacesVanish.comp_œÉ {Y : C} {X : SimplicialObject C} {n b q : ‚Ñï} {œÜ : Y ‚ü∂ X _[n + 1]}
    (v : HigherFacesVanish q œÜ) (hnbq : n + 1 = b + q) :
    HigherFacesVanish q
      (œÜ ‚â´
        X.œÉ ‚ü®b, by
          simp only [hnbq, Nat.lt_add_one_iff, le_add_iff_nonneg_right, zero_le]‚ü©) ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,7,True,,7,0.0,"theorem HigherFacesVanish.comp_œÉ {Y : C} {X : SimplicialObject C} {n b q : ‚Ñï} {œÜ : Y ‚ü∂ X _[n + 1]}
    (v : HigherFacesVanish q œÜ) (hnbq : n + 1 = b + q) :
    HigherFacesVanish q
      (œÜ ‚â´
        X.œÉ ‚ü®b, by
          simp only [hnbq, Nat.lt_add_one_iff, le_add_iff_nonneg_right, zero_le]‚ü©) :=
  fun j hj => by
  rw [assoc, SimplicialObject.Œ¥_comp_œÉ_of_gt', Fin.pred_succ, v.comp_Œ¥_eq_zero_assoc _ _ hj,
    zero_comp]
  ¬∑ dsimp
    rw [Fin.lt_iff_val_lt_val, Fin.val_succ]
    linarith
  ¬∑ intro hj'
    simp only [hnbq, add_comm b, add_assoc, hj', Fin.val_zero, zero_add, add_le_iff_nonpos_right,
      nonpos_iff_eq_zero, add_eq_zero, false_and] at hj","theorem HigherFacesVanish.comp_œÉ {Y : C} {X : SimplicialObject C} {n b q : ‚Ñï} {œÜ : Y ‚ü∂ X _[n + 1]}
    (v : HigherFacesVanish q œÜ) (hnbq : n + 1 = b + q) :
    HigherFacesVanish q
      (œÜ ‚â´
        X.œÉ ‚ü®b, by
          simp only [hnbq, Nat.lt_add_one_iff, le_add_iff_nonneg_right, zero_le]‚ü©) :=
  fun j hj => by
  rw [assoc, SimplicialObject.Œ¥_comp_œÉ_of_gt', Fin.pred_succ, v.comp_Œ¥_eq_zero_assoc _ _ hj,
    zero_comp]
  ¬∑ dsimp
    rw [Fin.lt_iff_val_lt_val, Fin.val_succ]
    linarith
  ¬∑ intro hj'
    simp only [hnbq, add_comm b, add_assoc, hj', Fin.val_zero, zero_add, add_le_iff_nonpos_right,
      nonpos_iff_eq_zero, add_eq_zero, false_and] at hj",59.82480001449585
mathlib,Mathlib/AlgebraicTopology/DoldKan/Compatibility.lean,theorem equivalenceUnitIso_eq : (equivalence hF hG).unitIso = equivalenceUnitIso hG Œµ ,"refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,7,True,,7,0.0,"theorem equivalenceUnitIso_eq : (equivalence hF hG).unitIso = equivalenceUnitIso hG Œµ := by
  ext1; apply NatTrans.ext; ext X
  dsimp [equivalence]
  simp only [assoc, comp_id, equivalenceUnitIso_hom_app]
  erw [id_comp]
  simp only [equivalence‚ÇÇUnitIso_eq eB hF, equivalence‚ÇÇUnitIso_hom_app,
    ‚Üê eA.inverse.map_comp_assoc, assoc, ‚Üê hŒµ, œÖ_hom_app]","theorem equivalenceUnitIso_eq : (equivalence hF hG).unitIso = equivalenceUnitIso hG Œµ := by
  ext1; apply NatTrans.ext; ext X
  dsimp [equivalence]
  simp only [assoc, comp_id, equivalenceUnitIso_hom_app]
  erw [id_comp]
  simp only [equivalence‚ÇÇUnitIso_eq eB hF, equivalence‚ÇÇUnitIso_hom_app,
    ‚Üê eA.inverse.map_comp_assoc, assoc, ‚Üê hŒµ, œÖ_hom_app]",65.34740924835205
mathlib,Mathlib/AlgebraicTopology/DoldKan/FunctorGamma.lean,theorem iff {j : ‚Ñï} {i : Fin (j + 2)} : IsŒ¥‚ÇÄ (SimplexCategory.Œ¥ i) ‚Üî i = 0 ,"refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,9,True,,9,0.0,"theorem iff {j : ‚Ñï} {i : Fin (j + 2)} : IsŒ¥‚ÇÄ (SimplexCategory.Œ¥ i) ‚Üî i = 0 := by
  constructor
  ¬∑ rintro ‚ü®_, h‚ÇÇ‚ü©
    by_contra h
    exact h‚ÇÇ (Fin.succAbove_ne_zero_zero h)
  ¬∑ rintro rfl
    exact ‚ü®rfl, by dsimp; exact Fin.succ_ne_zero (0 : Fin (j + 1))‚ü©","theorem iff {j : ‚Ñï} {i : Fin (j + 2)} : IsŒ¥‚ÇÄ (SimplexCategory.Œ¥ i) ‚Üî i = 0 := by
  constructor
  ¬∑ rintro ‚ü®_, h‚ÇÇ‚ü©
    by_contra h
    exact h‚ÇÇ (Fin.succAbove_ne_zero_zero h)
  ¬∑ rintro rfl
    exact ‚ü®rfl, by dsimp; exact Fin.succ_ne_zero (0 : Fin (j + 1))‚ü©",27.317443132400513
mathlib,Mathlib/AlgebraicTopology/SplitSimplicialObject.lean,theorem eqId_iff_len_eq : A.EqId ‚Üî A.1.unop.len = Œî.unop.len ,"refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,8,True,,8,0.0,"theorem eqId_iff_len_eq : A.EqId ‚Üî A.1.unop.len = Œî.unop.len := by
  rw [eqId_iff_eq]
  constructor
  ¬∑ intro h
    rw [h]
  ¬∑ intro h
    rw [‚Üê unop_inj_iff]
    ext
    exact h","theorem eqId_iff_len_eq : A.EqId ‚Üî A.1.unop.len = Œî.unop.len := by
  rw [eqId_iff_eq]
  constructor
  ¬∑ intro h
    rw [h]
  ¬∑ intro h
    rw [‚Üê unop_inj_iff]
    ext
    exact h",31.708357095718384
mathlib,Mathlib/AlgebraicTopology/DoldKan/FunctorGamma.lean,"@[reassoc]
theorem map_on_summand‚ÇÄ {Œî Œî' : SimplexCategory·µí·µñ} (A : Splitting.IndexSet Œî) {Œ∏ : Œî ‚ü∂ Œî'}
    {Œî'' : SimplexCategory} {e : Œî'.unop ‚ü∂ Œî''} {i : Œî'' ‚ü∂ A.1.unop} [Epi e] [Mono i]
    (fac : e ‚â´ i = Œ∏.unop ‚â´ A.e) :
    Sigma.Œπ (summand K Œî) A ‚â´ map K Œ∏ =
      Termwise.mapMono K i ‚â´ Sigma.Œπ (summand K Œî') (Splitting.IndexSet.mk e) ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,8,True,,8,0.0,"@[reassoc]
theorem map_on_summand‚ÇÄ {Œî Œî' : SimplexCategory·µí·µñ} (A : Splitting.IndexSet Œî) {Œ∏ : Œî ‚ü∂ Œî'}
    {Œî'' : SimplexCategory} {e : Œî'.unop ‚ü∂ Œî''} {i : Œî'' ‚ü∂ A.1.unop} [Epi e] [Mono i]
    (fac : e ‚â´ i = Œ∏.unop ‚â´ A.e) :
    Sigma.Œπ (summand K Œî) A ‚â´ map K Œ∏ =
      Termwise.mapMono K i ‚â´ Sigma.Œπ (summand K Œî') (Splitting.IndexSet.mk e) := by
  simp only [map, colimit.Œπ_desc, Cofan.mk_Œπ_app]
  have h := SimplexCategory.image_eq fac
  subst h
  congr
  ¬∑ exact SimplexCategory.image_Œπ_eq fac
  ¬∑ dsimp only [SimplicialObject.Splitting.IndexSet.pull]
    congr
    exact SimplexCategory.factorThruImage_eq fac","@[reassoc]
theorem map_on_summand‚ÇÄ {Œî Œî' : SimplexCategory·µí·µñ} (A : Splitting.IndexSet Œî) {Œ∏ : Œî ‚ü∂ Œî'}
    {Œî'' : SimplexCategory} {e : Œî'.unop ‚ü∂ Œî''} {i : Œî'' ‚ü∂ A.1.unop} [Epi e] [Mono i]
    (fac : e ‚â´ i = Œ∏.unop ‚â´ A.e) :
    Sigma.Œπ (summand K Œî) A ‚â´ map K Œ∏ =
      Termwise.mapMono K i ‚â´ Sigma.Œπ (summand K Œî') (Splitting.IndexSet.mk e) := by
  simp only [map, colimit.Œπ_desc, Cofan.mk_Œπ_app]
  have h := SimplexCategory.image_eq fac
  subst h
  congr
  ¬∑ exact SimplexCategory.image_Œπ_eq fac
  ¬∑ dsimp only [SimplicialObject.Splitting.IndexSet.pull]
    congr
    exact SimplexCategory.factorThruImage_eq fac",104.02254605293274
mathlib,Mathlib/AlgebraicTopology/DoldKan/GammaCompN.lean,"@[simp]
lemma N‚ÇÇŒì‚ÇÇToKaroubiIso_inv_app (X : ChainComplex C ‚Ñï) :
    (N‚ÇÇŒì‚ÇÇToKaroubiIso.inv.app X).f = PInfty ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,8,True,,8,0.0,"@[simp]
lemma N‚ÇÇŒì‚ÇÇToKaroubiIso_inv_app (X : ChainComplex C ‚Ñï) :
    (N‚ÇÇŒì‚ÇÇToKaroubiIso.inv.app X).f = PInfty := by
  ext n
  dsimp [N‚ÇÇŒì‚ÇÇToKaroubiIso]
  simp only [comp_id, PInfty_f_idem_assoc, AlternatingFaceMapComplex.obj_X, Œì‚ÇÄ_obj_obj]
  convert comp_id _
  apply (Œì‚ÇÄ.splitting X).hom_ext'
  intro A
  rw [Splitting.Œπ_desc]
  erw [comp_id, id_comp]","@[simp]
lemma N‚ÇÇŒì‚ÇÇToKaroubiIso_inv_app (X : ChainComplex C ‚Ñï) :
    (N‚ÇÇŒì‚ÇÇToKaroubiIso.inv.app X).f = PInfty := by
  ext n
  dsimp [N‚ÇÇŒì‚ÇÇToKaroubiIso]
  simp only [comp_id, PInfty_f_idem_assoc, AlternatingFaceMapComplex.obj_X, Œì‚ÇÄ_obj_obj]
  convert comp_id _
  apply (Œì‚ÇÄ.splitting X).hom_ext'
  intro A
  rw [Splitting.Œπ_desc]
  erw [comp_id, id_comp]",115.92975282669067
mathlib,Mathlib/AlgebraicTopology/DoldKan/FunctorGamma.lean,"@[reassoc]
theorem map_on_summand {Œî Œî' : SimplexCategory·µí·µñ} (A : Splitting.IndexSet Œî) (Œ∏ : Œî ‚ü∂ Œî')
    {Œî'' : SimplexCategory} {e : Œî'.unop ‚ü∂ Œî''} {i : Œî'' ‚ü∂ A.1.unop} [Epi e] [Mono i]
    (fac : e ‚â´ i = Œ∏.unop ‚â´ A.e) :
    ((Œì‚ÇÄ.splitting K).cofan Œî).inj A ‚â´ (Œì‚ÇÄ.obj K).map Œ∏ =
      Œì‚ÇÄ.Obj.Termwise.mapMono K i ‚â´ ((Œì‚ÇÄ.splitting K).cofan Œî').inj (Splitting.IndexSet.mk e) ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,9,True,,2,-0.7777777777777778,"@[reassoc]
theorem Obj.map_on_summand {Œî Œî' : SimplexCategory·µí·µñ} (A : Splitting.IndexSet Œî) (Œ∏ : Œî ‚ü∂ Œî')
    {Œî'' : SimplexCategory} {e : Œî'.unop ‚ü∂ Œî''} {i : Œî'' ‚ü∂ A.1.unop} [Epi e] [Mono i]
    (fac : e ‚â´ i = Œ∏.unop ‚â´ A.e) :
    ((Œì‚ÇÄ.splitting K).cofan Œî).inj A ‚â´ (Œì‚ÇÄ.obj K).map Œ∏ =
      Œì‚ÇÄ.Obj.Termwise.mapMono K i ‚â´ ((Œì‚ÇÄ.splitting K).cofan Œî').inj (Splitting.IndexSet.mk e) := by
  dsimp [Splitting.cofan]
  change (_ ‚â´ (Œì‚ÇÄ.obj K).map A.e.op) ‚â´ (Œì‚ÇÄ.obj K).map Œ∏ = _
  rw [assoc, ‚Üê Functor.map_comp]
  dsimp [splitting]
  erw [Œì‚ÇÄ.Obj.map_on_summand‚ÇÄ K (Splitting.IndexSet.id A.1)
    (show e ‚â´ i = ((Splitting.IndexSet.e A).op ‚â´ Œ∏).unop ‚â´ ùüô _ by rw [comp_id, fac]; rfl),
    Œì‚ÇÄ.Obj.map_on_summand‚ÇÄ K (Splitting.IndexSet.id (op Œî''))
      (show e ‚â´ ùüô Œî'' = e.op.unop ‚â´ ùüô _ by simp), Termwise.mapMono_id, id_comp]","@[reassoc]
theorem map_on_summand {Œî Œî' : SimplexCategory·µí·µñ} (A : Splitting.IndexSet Œî) (Œ∏ : Œî ‚ü∂ Œî')
    {Œî'' : SimplexCategory} {e : Œî'.unop ‚ü∂ Œî''} {i : Œî'' ‚ü∂ A.1.unop} [Epi e] [Mono i]
    (fac : e ‚â´ i = Œ∏.unop ‚â´ A.e) :
    ((Œì‚ÇÄ.splitting K).cofan Œî).inj A ‚â´ (Œì‚ÇÄ.obj K).map Œ∏ =
      Œì‚ÇÄ.Obj.Termwise.mapMono K i ‚â´ ((Œì‚ÇÄ.splitting K).cofan Œî').inj (Splitting.IndexSet.mk e)  := by
  dsimp [Splitting.cofan, splitting]
  rw [assoc, ‚Üê Functor.map_comp, Œì‚ÇÄ.Obj.map_on_summand‚ÇÄ K (Splitting.IndexSet.id A.1) (show e ‚â´ i = ((Splitting.IndexSet.e A).op ‚â´ Œ∏).unop ‚â´ ùüô _ by rw [comp_id, fac]; rfl),",125.2982029914856
mathlib,Mathlib/AlgebraicTopology/DoldKan/FunctorGamma.lean,"@[reassoc]
theorem Obj.map_on_summand {Œî Œî' : SimplexCategory·µí·µñ} (A : Splitting.IndexSet Œî) (Œ∏ : Œî ‚ü∂ Œî')
    {Œî'' : SimplexCategory} {e : Œî'.unop ‚ü∂ Œî''} {i : Œî'' ‚ü∂ A.1.unop} [Epi e] [Mono i]
    (fac : e ‚â´ i = Œ∏.unop ‚â´ A.e) :
    ((Œì‚ÇÄ.splitting K).cofan Œî).inj A ‚â´ (Œì‚ÇÄ.obj K).map Œ∏ =
      Œì‚ÇÄ.Obj.Termwise.mapMono K i ‚â´ ((Œì‚ÇÄ.splitting K).cofan Œî').inj (Splitting.IndexSet.mk e) ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,9,True,,1,-0.8888888888888888,"@[reassoc]
theorem Obj.map_on_summand {Œî Œî' : SimplexCategory·µí·µñ} (A : Splitting.IndexSet Œî) (Œ∏ : Œî ‚ü∂ Œî')
    {Œî'' : SimplexCategory} {e : Œî'.unop ‚ü∂ Œî''} {i : Œî'' ‚ü∂ A.1.unop} [Epi e] [Mono i]
    (fac : e ‚â´ i = Œ∏.unop ‚â´ A.e) :
    ((Œì‚ÇÄ.splitting K).cofan Œî).inj A ‚â´ (Œì‚ÇÄ.obj K).map Œ∏ =
      Œì‚ÇÄ.Obj.Termwise.mapMono K i ‚â´ ((Œì‚ÇÄ.splitting K).cofan Œî').inj (Splitting.IndexSet.mk e) := by
  dsimp [Splitting.cofan]
  change (_ ‚â´ (Œì‚ÇÄ.obj K).map A.e.op) ‚â´ (Œì‚ÇÄ.obj K).map Œ∏ = _
  rw [assoc, ‚Üê Functor.map_comp]
  dsimp [splitting]
  erw [Œì‚ÇÄ.Obj.map_on_summand‚ÇÄ K (Splitting.IndexSet.id A.1)
    (show e ‚â´ i = ((Splitting.IndexSet.e A).op ‚â´ Œ∏).unop ‚â´ ùüô _ by rw [comp_id, fac]; rfl),
    Œì‚ÇÄ.Obj.map_on_summand‚ÇÄ K (Splitting.IndexSet.id (op Œî''))
      (show e ‚â´ ùüô Œî'' = e.op.unop ‚â´ ùüô _ by simp), Termwise.mapMono_id, id_comp]","@[reassoc]
theorem Obj.map_on_summand {Œî Œî' : SimplexCategory·µí·µñ} (A : Splitting.IndexSet Œî) (Œ∏ : Œî ‚ü∂ Œî')
    {Œî'' : SimplexCategory} {e : Œî'.unop ‚ü∂ Œî''} {i : Œî'' ‚ü∂ A.1.unop} [Epi e] [Mono i]
    (fac : e ‚â´ i = Œ∏.unop ‚â´ A.e) :
    ((Œì‚ÇÄ.splitting K).cofan Œî).inj A ‚â´ (Œì‚ÇÄ.obj K).map Œ∏ =
      Œì‚ÇÄ.Obj.Termwise.mapMono K i ‚â´ ((Œì‚ÇÄ.splitting K).cofan Œî').inj (Splitting.IndexSet.mk e)  := by
  rw [assoc, ‚Üê Functor.map_comp, Œì‚ÇÄ.Obj.map_on_summand‚ÇÄ K (Splitting.IndexSet.id A.1),
  Œì‚ÇÄ.Obj.map_on_summand‚ÇÄ K (Splitting.IndexSet.id (op Œî'')),
  (show e ‚â´ i = ((Splitting.IndexSet.e A).op ‚â´ Œ∏).unop ‚â´ ùüô _ by rw [comp_id, fac]; rfl),",130.63414406776428
mathlib,Mathlib/AlgebraicTopology/SplitSimplicialObject.lean,theorem eqId_iff_mono : A.EqId ‚Üî Mono A.e ,"refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,9,True,,9,0.0,"theorem eqId_iff_mono : A.EqId ‚Üî Mono A.e := by
  constructor
  ¬∑ intro h
    dsimp at h
    subst h
    dsimp only [id, e]
    infer_instance
  ¬∑ intro h
    rw [eqId_iff_len_le]
    exact len_le_of_mono h","theorem eqId_iff_mono : A.EqId ‚Üî Mono A.e := by
  constructor
  ¬∑ intro h
    dsimp at h
    subst h
    dsimp only [id, e]
    infer_instance
  ¬∑ intro h
    rw [eqId_iff_len_le]
    exact len_le_of_mono h",29.530785083770752
mathlib,Mathlib/AlgebraicTopology/DoldKan/GammaCompN.lean,"@[simp]
 theorem N‚ÇÇŒì‚ÇÇToKaroubiIso_inv_app (X : ChainComplex C ‚Ñï) :
    (N‚ÇÇŒì‚ÇÇToKaroubiIso.inv.app X).f = PInfty ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,8,True,,8,0.0,"@[simp]
lemma N‚ÇÇŒì‚ÇÇToKaroubiIso_inv_app (X : ChainComplex C ‚Ñï) :
    (N‚ÇÇŒì‚ÇÇToKaroubiIso.inv.app X).f = PInfty := by
  ext n
  dsimp [N‚ÇÇŒì‚ÇÇToKaroubiIso]
  simp only [comp_id, PInfty_f_idem_assoc, AlternatingFaceMapComplex.obj_X, Œì‚ÇÄ_obj_obj]
  convert comp_id _
  apply (Œì‚ÇÄ.splitting X).hom_ext'
  intro A
  rw [Splitting.Œπ_desc]
  erw [comp_id, id_comp]","@[simp]
lemma N‚ÇÇŒì‚ÇÇToKaroubiIso_inv_app (X : ChainComplex C ‚Ñï) :
    (N‚ÇÇŒì‚ÇÇToKaroubiIso.inv.app X).f = PInfty := by
  ext n
  dsimp [N‚ÇÇŒì‚ÇÇToKaroubiIso]
  simp only [comp_id, PInfty_f_idem_assoc, AlternatingFaceMapComplex.obj_X, Œì‚ÇÄ_obj_obj]
  convert comp_id _
  apply (Œì‚ÇÄ.splitting X).hom_ext'
  intro A
  rw [Splitting.Œπ_desc]
  erw [comp_id, id_comp]",108.89783191680908
mathlib,Mathlib/AlgebraicTopology/SimplexCategory.lean,"theorem eq_œÉ_of_epi {n : ‚Ñï} (Œ∏ : mk (n + 1) ‚ü∂ mk n) [Epi Œ∏] : ‚àÉ i : Fin (n + 1), Œ∏ = œÉ i ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,9,True,,9,0.0,"theorem eq_œÉ_of_epi {n : ‚Ñï} (Œ∏ : mk (n + 1) ‚ü∂ mk n) [Epi Œ∏] : ‚àÉ i : Fin (n + 1), Œ∏ = œÉ i := by
  rcases eq_œÉ_comp_of_not_injective Œ∏ (by
    by_contra h
    simpa using le_of_mono (mono_iff_injective.mpr h)) with ‚ü®i, Œ∏', h‚ü©
  use i
  haveI : Epi (œÉ i ‚â´ Œ∏') := by
    rw [‚Üê h]
    infer_instance
  haveI := CategoryTheory.epi_of_epi (œÉ i) Œ∏'
  rw [h, eq_id_of_epi Œ∏', Category.comp_id]","theorem eq_œÉ_of_epi {n : ‚Ñï} (Œ∏ : mk (n + 1) ‚ü∂ mk n) [Epi Œ∏] : ‚àÉ i : Fin (n + 1), Œ∏ = œÉ i := by
  rcases eq_œÉ_comp_of_not_injective Œ∏ (by
    by_contra h
    simpa using le_of_mono (mono_iff_injective.mpr h)) with ‚ü®i, Œ∏', h‚ü©
  use i
  haveI : Epi (œÉ i ‚â´ Œ∏') := by
    rw [‚Üê h]
    infer_instance
  haveI := CategoryTheory.epi_of_epi (œÉ i) Œ∏'
  rw [h, eq_id_of_epi Œ∏', Category.comp_id]",182.6264259815216
mathlib,Mathlib/AlgebraicTopology/DoldKan/FunctorGamma.lean,"theorem on_Œì‚ÇÄ_summand_id (K : ChainComplex C ‚Ñï) (n : ‚Ñï) :
    @HigherFacesVanish C _ _ (Œì‚ÇÄ.obj K) _ n (n + 1)
      (((Œì‚ÇÄ.splitting K).cofan _).inj (Splitting.IndexSet.id (op [n + 1]))) ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,9,True,,8,-0.1111111111111111,"theorem HigherFacesVanish.on_Œì‚ÇÄ_summand_id (K : ChainComplex C ‚Ñï) (n : ‚Ñï) :
    @HigherFacesVanish C _ _ (Œì‚ÇÄ.obj K) _ n (n + 1)
      (((Œì‚ÇÄ.splitting K).cofan _).inj (Splitting.IndexSet.id (op [n + 1]))) := by
  intro j _
  have eq := Œì‚ÇÄ.Obj.mapMono_on_summand_id K (SimplexCategory.Œ¥ j.succ)
  rw [Œì‚ÇÄ.Obj.Termwise.mapMono_eq_zero K, zero_comp] at eq; rotate_left
  ¬∑ intro h
    exact (Nat.succ_ne_self n) (congr_arg SimplexCategory.len h)
  ¬∑ exact fun h => Fin.succ_ne_zero j (by simpa only [IsŒ¥‚ÇÄ.iff] using h)
  exact eq","theorem on_Œì‚ÇÄ_summand_id (K : ChainComplex C ‚Ñï) (n : ‚Ñï) :
    @HigherFacesVanish C _ _ (Œì‚ÇÄ.obj K) _ n (n + 1)
      (((Œì‚ÇÄ.splitting K).cofan _).inj (Splitting.IndexSet.id (op [n + 1])))  := by
  intro j _
  have eq := Œì‚ÇÄ.Obj.mapMono_on_summand_id K (SimplexCategory.Œ¥ j.succ)
  rw [Œì‚ÇÄ.Obj.Termwise.mapMono_eq_zero K, zero_comp] at eq
  rotate_left
  exact Nat.succ_ne_self n ‚àò congr_arg SimplexCategory.len
  exact fun h => Fin.succ_ne_zero j (by simpa [IsŒ¥‚ÇÄ.iff] using h)
  exact eq",167.3644118309021
mathlib,Mathlib/AlgebraicTopology/DoldKan/FunctorGamma.lean,"theorem HigherFacesVanish.on_Œì‚ÇÄ_summand_id (K : ChainComplex C ‚Ñï) (n : ‚Ñï) :
    @HigherFacesVanish C _ _ (Œì‚ÇÄ.obj K) _ n (n + 1)
      (((Œì‚ÇÄ.splitting K).cofan _).inj (Splitting.IndexSet.id (op [n + 1]))) ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,9,True,,8,-0.1111111111111111,"theorem HigherFacesVanish.on_Œì‚ÇÄ_summand_id (K : ChainComplex C ‚Ñï) (n : ‚Ñï) :
    @HigherFacesVanish C _ _ (Œì‚ÇÄ.obj K) _ n (n + 1)
      (((Œì‚ÇÄ.splitting K).cofan _).inj (Splitting.IndexSet.id (op [n + 1]))) := by
  intro j _
  have eq := Œì‚ÇÄ.Obj.mapMono_on_summand_id K (SimplexCategory.Œ¥ j.succ)
  rw [Œì‚ÇÄ.Obj.Termwise.mapMono_eq_zero K, zero_comp] at eq; rotate_left
  ¬∑ intro h
    exact (Nat.succ_ne_self n) (congr_arg SimplexCategory.len h)
  ¬∑ exact fun h => Fin.succ_ne_zero j (by simpa only [IsŒ¥‚ÇÄ.iff] using h)
  exact eq","theorem HigherFacesVanish.on_Œì‚ÇÄ_summand_id (K : ChainComplex C ‚Ñï) (n : ‚Ñï) :
    @HigherFacesVanish C _ _ (Œì‚ÇÄ.obj K) _ n (n + 1)
      (((Œì‚ÇÄ.splitting K).cofan _).inj (Splitting.IndexSet.id (op [n + 1])))  := by
  intro j _
  have eq := Œì‚ÇÄ.Obj.mapMono_on_summand_id K (SimplexCategory.Œ¥ j.succ)
  rw [Œì‚ÇÄ.Obj.Termwise.mapMono_eq_zero K, zero_comp] at eq
  exact eq
  intro h
  exact (Nat.succ_ne_self n) (congr_arg SimplexCategory.len h)
  exact fun h => Fin.succ_ne_zero j (by simpa [IsŒ¥‚ÇÄ.iff] using h)",176.03684902191162
mathlib,Mathlib/AlgebraicTopology/SimplexCategory.lean,"theorem eq_Œ¥_of_mono {n : ‚Ñï} (Œ∏ : mk n ‚ü∂ mk (n + 1)) [Mono Œ∏] : ‚àÉ i : Fin (n + 2), Œ∏ = Œ¥ i ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,9,True,,9,0.0,"theorem eq_Œ¥_of_mono {n : ‚Ñï} (Œ∏ : mk n ‚ü∂ mk (n + 1)) [Mono Œ∏] : ‚àÉ i : Fin (n + 2), Œ∏ = Œ¥ i := by
  rcases eq_comp_Œ¥_of_not_surjective Œ∏ (by
    by_contra h
    simpa using le_of_epi (epi_iff_surjective.mpr h)) with ‚ü®i, Œ∏', h‚ü©
  use i
  haveI : Mono (Œ∏' ‚â´ Œ¥ i) := by
    rw [‚Üê h]
    infer_instance
  haveI := CategoryTheory.mono_of_mono Œ∏' (Œ¥ i)
  rw [h, eq_id_of_mono Œ∏', Category.id_comp]","theorem eq_Œ¥_of_mono {n : ‚Ñï} (Œ∏ : mk n ‚ü∂ mk (n + 1)) [Mono Œ∏] : ‚àÉ i : Fin (n + 2), Œ∏ = Œ¥ i := by
  rcases eq_comp_Œ¥_of_not_surjective Œ∏ (by
    by_contra h
    simpa using le_of_epi (epi_iff_surjective.mpr h)) with ‚ü®i, Œ∏', h‚ü©
  use i
  haveI : Mono (Œ∏' ‚â´ Œ¥ i) := by
    rw [‚Üê h]
    infer_instance
  haveI := CategoryTheory.mono_of_mono Œ∏' (Œ¥ i)
  rw [h, eq_id_of_mono Œ∏', Category.id_comp]",201.95717406272888
mathlib,Mathlib/AlgebraicTopology/DoldKan/Homotopies.lean,"/-- The maps `hœÉ' q n m hnm` are natural on the simplicial object -/
theorem hœÉ'_naturality (q : ‚Ñï) (n m : ‚Ñï) (hnm : c.Rel m n) {X Y : SimplicialObject C} (f : X ‚ü∂ Y) :
    f.app (op [n]) ‚â´ hœÉ' q n m hnm = hœÉ' q n m hnm ‚â´ f.app (op [m]) ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,9,True,,9,0.0,"/-- The maps `hœÉ' q n m hnm` are natural on the simplicial object -/
theorem hœÉ'_naturality (q : ‚Ñï) (n m : ‚Ñï) (hnm : c.Rel m n) {X Y : SimplicialObject C} (f : X ‚ü∂ Y) :
    f.app (op [n]) ‚â´ hœÉ' q n m hnm = hœÉ' q n m hnm ‚â´ f.app (op [m]) := by
  have h : n + 1 = m := hnm
  subst h
  simp only [hœÉ', eqToHom_refl, comp_id]
  unfold hœÉ
  split_ifs
  ¬∑ rw [zero_comp, comp_zero]
  ¬∑ simp only [zsmul_comp, comp_zsmul]
    erw [f.naturality]
    rfl","/-- The maps `hœÉ' q n m hnm` are natural on the simplicial object -/
theorem hœÉ'_naturality (q : ‚Ñï) (n m : ‚Ñï) (hnm : c.Rel m n) {X Y : SimplicialObject C} (f : X ‚ü∂ Y) :
    f.app (op [n]) ‚â´ hœÉ' q n m hnm = hœÉ' q n m hnm ‚â´ f.app (op [m]) := by
  have h : n + 1 = m := hnm
  subst h
  simp only [hœÉ', eqToHom_refl, comp_id]
  unfold hœÉ
  split_ifs
  ¬∑ rw [zero_comp, comp_zero]
  ¬∑ simp only [zsmul_comp, comp_zsmul]
    erw [f.naturality]
    rfl",41.78622794151306
mathlib,Mathlib/AlgebraicTopology/DoldKan/Homotopies.lean,"/-- In degree `0`, the null homotopic map `HœÉ` is zero. -/
theorem HœÉ_eq_zero (q : ‚Ñï) : (HœÉ q : K[X] ‚ü∂ K[X]).f 0 = 0 ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,10,True,,10,0.0,"/-- In degree `0`, the null homotopic map `HœÉ` is zero. -/
theorem HœÉ_eq_zero (q : ‚Ñï) : (HœÉ q : K[X] ‚ü∂ K[X]).f 0 = 0 := by
  unfold HœÉ
  rw [nullHomotopicMap'_f_of_not_rel_left (c_mk 1 0 rfl) cs_down_0_not_rel_left]
  rcases q with (_|q)
  ¬∑ rw [hœÉ'_eq (show 0 = 0 + 0 by rfl) (c_mk 1 0 rfl)]
    simp only [pow_zero, Fin.mk_zero, one_zsmul, eqToHom_refl, Category.comp_id]
    erw [ChainComplex.of_d]
    rw [AlternatingFaceMapComplex.objD, Fin.sum_univ_two, Fin.val_zero, Fin.val_one, pow_zero,
      pow_one, one_smul, neg_smul, one_smul, comp_add, comp_neg, add_neg_eq_zero]
    erw [Œ¥_comp_œÉ_self, Œ¥_comp_œÉ_succ]
  ¬∑ rw [hœÉ'_eq_zero (Nat.succ_pos q) (c_mk 1 0 rfl), zero_comp]","/-- In degree `0`, the null homotopic map `HœÉ` is zero. -/
theorem HœÉ_eq_zero (q : ‚Ñï) : (HœÉ q : K[X] ‚ü∂ K[X]).f 0 = 0 := by
  unfold HœÉ
  rw [nullHomotopicMap'_f_of_not_rel_left (c_mk 1 0 rfl) cs_down_0_not_rel_left]
  rcases q with (_|q)
  ¬∑ rw [hœÉ'_eq (show 0 = 0 + 0 by rfl) (c_mk 1 0 rfl)]
    simp only [pow_zero, Fin.mk_zero, one_zsmul, eqToHom_refl, Category.comp_id]
    erw [ChainComplex.of_d]
    rw [AlternatingFaceMapComplex.objD, Fin.sum_univ_two, Fin.val_zero, Fin.val_one, pow_zero,
      pow_one, one_smul, neg_smul, one_smul, comp_add, comp_neg, add_neg_eq_zero]
    erw [Œ¥_comp_œÉ_self, Œ¥_comp_œÉ_succ]
  ¬∑ rw [hœÉ'_eq_zero (Nat.succ_pos q) (c_mk 1 0 rfl), zero_comp]",52.02749586105347
mathlib,Mathlib/AlgebraicTopology/SplitSimplicialObject.lean,"@[ext]
theorem Hom.ext {S‚ÇÅ S‚ÇÇ : Split C} (Œ¶‚ÇÅ Œ¶‚ÇÇ : Hom S‚ÇÅ S‚ÇÇ) (h : ‚àÄ n : ‚Ñï, Œ¶‚ÇÅ.f n = Œ¶‚ÇÇ.f n) : Œ¶‚ÇÅ = Œ¶‚ÇÇ ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,11,True,,11,0.0,"@[ext]
theorem Hom.ext {S‚ÇÅ S‚ÇÇ : Split C} (Œ¶‚ÇÅ Œ¶‚ÇÇ : Hom S‚ÇÅ S‚ÇÇ) (h : ‚àÄ n : ‚Ñï, Œ¶‚ÇÅ.f n = Œ¶‚ÇÇ.f n) : Œ¶‚ÇÅ = Œ¶‚ÇÇ := by
  rcases Œ¶‚ÇÅ with ‚ü®F‚ÇÅ, f‚ÇÅ, c‚ÇÅ‚ü©
  rcases Œ¶‚ÇÇ with ‚ü®F‚ÇÇ, f‚ÇÇ, c‚ÇÇ‚ü©
  have h' : f‚ÇÅ = f‚ÇÇ := by
    ext
    apply h
  subst h'
  simp only [mk.injEq, and_true]
  apply S‚ÇÅ.s.hom_ext
  intro n
  dsimp
  rw [c‚ÇÅ, c‚ÇÇ]","@[ext]
theorem Hom.ext {S‚ÇÅ S‚ÇÇ : Split C} (Œ¶‚ÇÅ Œ¶‚ÇÇ : Hom S‚ÇÅ S‚ÇÇ) (h : ‚àÄ n : ‚Ñï, Œ¶‚ÇÅ.f n = Œ¶‚ÇÇ.f n) : Œ¶‚ÇÅ = Œ¶‚ÇÇ := by
  rcases Œ¶‚ÇÅ with ‚ü®F‚ÇÅ, f‚ÇÅ, c‚ÇÅ‚ü©
  rcases Œ¶‚ÇÇ with ‚ü®F‚ÇÇ, f‚ÇÇ, c‚ÇÇ‚ü©
  have h' : f‚ÇÅ = f‚ÇÇ := by
    ext
    apply h
  subst h'
  simp only [mk.injEq, and_true]
  apply S‚ÇÅ.s.hom_ext
  intro n
  dsimp
  rw [c‚ÇÅ, c‚ÇÇ]",54.61383771896362
mathlib,Mathlib/AlgebraicTopology/SplitSimplicialObject.lean,"@[ext]
theorem ext {S‚ÇÅ S‚ÇÇ : Split C} (Œ¶‚ÇÅ Œ¶‚ÇÇ : Hom S‚ÇÅ S‚ÇÇ) (h : ‚àÄ n : ‚Ñï, Œ¶‚ÇÅ.f n = Œ¶‚ÇÇ.f n) : Œ¶‚ÇÅ = Œ¶‚ÇÇ ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,11,True,,3,-0.7272727272727273,"@[ext]
theorem Hom.ext {S‚ÇÅ S‚ÇÇ : Split C} (Œ¶‚ÇÅ Œ¶‚ÇÇ : Hom S‚ÇÅ S‚ÇÇ) (h : ‚àÄ n : ‚Ñï, Œ¶‚ÇÅ.f n = Œ¶‚ÇÇ.f n) : Œ¶‚ÇÅ = Œ¶‚ÇÇ := by
  rcases Œ¶‚ÇÅ with ‚ü®F‚ÇÅ, f‚ÇÅ, c‚ÇÅ‚ü©
  rcases Œ¶‚ÇÇ with ‚ü®F‚ÇÇ, f‚ÇÇ, c‚ÇÇ‚ü©
  have h' : f‚ÇÅ = f‚ÇÇ := by
    ext
    apply h
  subst h'
  simp only [mk.injEq, and_true]
  apply S‚ÇÅ.s.hom_ext
  intro n
  dsimp
  rw [c‚ÇÅ, c‚ÇÇ]","@[ext]
theorem ext {S‚ÇÅ S‚ÇÇ : Split C} (Œ¶‚ÇÅ Œ¶‚ÇÇ : Hom S‚ÇÅ S‚ÇÇ) (h : ‚àÄ n : ‚Ñï, Œ¶‚ÇÅ.f n = Œ¶‚ÇÇ.f n) : Œ¶‚ÇÅ = Œ¶‚ÇÇ  := by
  ext : 1
  apply S‚ÇÅ.s.hom_ext
  intro n
  dsimp",57.34493684768677
mathlib,Mathlib/AlgebraicTopology/AlternatingFaceMapComplex.lean,"theorem map_alternatingFaceMapComplex {D : Type*} [Category D] [Preadditive D] (F : C ‚•§ D)
    [F.Additive] :
    alternatingFaceMapComplex C ‚ãô F.mapHomologicalComplex _ =
      (SimplicialObject.whiskering C D).obj F ‚ãô alternatingFaceMapComplex D ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,12,True,,1,-0.9166666666666666,"theorem map_alternatingFaceMapComplex {D : Type*} [Category D] [Preadditive D] (F : C ‚•§ D)
    [F.Additive] :
    alternatingFaceMapComplex C ‚ãô F.mapHomologicalComplex _ =
      (SimplicialObject.whiskering C D).obj F ‚ãô alternatingFaceMapComplex D := by
  apply CategoryTheory.Functor.ext
  ¬∑ intro X Y f
    ext n
    simp only [Functor.comp_map, HomologicalComplex.comp_f, alternatingFaceMapComplex_map_f,
      Functor.mapHomologicalComplex_map_f, HomologicalComplex.eqToHom_f, eqToHom_refl, comp_id,
      id_comp, SimplicialObject.whiskering_obj_map_app]
  ¬∑ intro X
    apply HomologicalComplex.ext
    ¬∑ rintro i j (rfl : j + 1 = i)
      dsimp only [Functor.comp_obj]
      simp only [Functor.mapHomologicalComplex_obj_d, alternatingFaceMapComplex_obj_d,
        eqToHom_refl, id_comp, comp_id, AlternatingFaceMapComplex.objD, Functor.map_sum,
        Functor.map_zsmul]
      rfl
    ¬∑ ext n
      rfl","theorem map_alternatingFaceMapComplex {D : Type*} [Category D] [Preadditive D] (F : C ‚•§ D)
    [F.Additive] :
    alternatingFaceMapComplex C ‚ãô F.mapHomologicalComplex _ =
      (SimplicialObject.whiskering C D).obj F ‚ãô alternatingFaceMapComplex D  := by
  apply Functor.ext
  { intros, ext n, simp only [Functor.comp_map, HomologicalComplex.comp_f, alternatingFaceMapComplex_map_f, Functor.mapHomologicalComplex_map_f, HomologicalComplex.eqToHom_f, eqToHom_refl, comp_id, id_comp, SimplicialObject.whiskering_obj_map_app] }",60.80066728591919
mathlib,Mathlib/AlgebraicTopology/DoldKan/Degeneracies.lean,"@[reassoc]
theorem degeneracy_comp_PInfty (X : SimplicialObject C) (n : ‚Ñï) {Œî' : SimplexCategory}
    (Œ∏ : ([n] : SimplexCategory) ‚ü∂ Œî') (hŒ∏ : ¬¨Mono Œ∏) : X.map Œ∏.op ‚â´ PInfty.f n = 0 ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,11,True,,11,0.0,"@[reassoc]
theorem degeneracy_comp_PInfty (X : SimplicialObject C) (n : ‚Ñï) {Œî' : SimplexCategory}
    (Œ∏ : ([n] : SimplexCategory) ‚ü∂ Œî') (hŒ∏ : ¬¨Mono Œ∏) : X.map Œ∏.op ‚â´ PInfty.f n = 0 := by
  rw [SimplexCategory.mono_iff_injective] at hŒ∏
  cases n
  ¬∑ exfalso
    apply hŒ∏
    intro x y h
    fin_cases x
    fin_cases y
    rfl
  ¬∑ obtain ‚ü®i, Œ±, h‚ü© := SimplexCategory.eq_œÉ_comp_of_not_injective Œ∏ hŒ∏
    rw [h, op_comp, X.map_comp, assoc, show X.map (SimplexCategory.œÉ i).op = X.œÉ i by rfl,
      œÉ_comp_PInfty, comp_zero]","@[reassoc]
theorem degeneracy_comp_PInfty (X : SimplicialObject C) (n : ‚Ñï) {Œî' : SimplexCategory}
    (Œ∏ : ([n] : SimplexCategory) ‚ü∂ Œî') (hŒ∏ : ¬¨Mono Œ∏) : X.map Œ∏.op ‚â´ PInfty.f n = 0 := by
  rw [SimplexCategory.mono_iff_injective] at hŒ∏
  cases n
  ¬∑ exfalso
    apply hŒ∏
    intro x y h
    fin_cases x
    fin_cases y
    rfl
  ¬∑ obtain ‚ü®i, Œ±, h‚ü© := SimplexCategory.eq_œÉ_comp_of_not_injective Œ∏ hŒ∏
    rw [h, op_comp, X.map_comp, assoc, show X.map (SimplexCategory.œÉ i).op = X.œÉ i by rfl,
      œÉ_comp_PInfty, comp_zero]",94.48328614234924
mathlib,Mathlib/AlgebraicTopology/Quasicategory.lean," theorem hornFilling {S : SSet} [Quasicategory S] ‚¶Én : ‚Ñï‚¶Ñ ‚¶Éi : Fin (n+1)‚¶Ñ
    (h0 : 0 < i) (hn : i < Fin.last n)
    (œÉ‚ÇÄ : Œõ[n, i] ‚ü∂ S) : ‚àÉ œÉ : Œî[n] ‚ü∂ S, œÉ‚ÇÄ = hornInclusion n i ‚â´ œÉ ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,12,True,,5,-0.5833333333333334,"lemma Quasicategory.hornFilling {S : SSet} [Quasicategory S] ‚¶Én : ‚Ñï‚¶Ñ ‚¶Éi : Fin (n+1)‚¶Ñ
    (h0 : 0 < i) (hn : i < Fin.last n)
    (œÉ‚ÇÄ : Œõ[n, i] ‚ü∂ S) : ‚àÉ œÉ : Œî[n] ‚ü∂ S, œÉ‚ÇÄ = hornInclusion n i ‚â´ œÉ := by
  cases n using Nat.casesAuxOn with
  | zero => simp [Fin.lt_iff_val_lt_val] at hn
  | succ n =>
  cases n using Nat.casesAuxOn with
  | zero =>
    simp only [Fin.lt_iff_val_lt_val, Fin.val_zero, Fin.val_last, zero_add, Nat.lt_one_iff] at h0 hn
    simp [hn] at h0
  | succ n => exact Quasicategory.hornFilling' œÉ‚ÇÄ h0 hn"," theorem hornFilling {S : SSet} [Quasicategory S] ‚¶Én : ‚Ñï‚¶Ñ ‚¶Éi : Fin (n+1)‚¶Ñ
    (h0 : 0 < i) (hn : i < Fin.last n)
    (œÉ‚ÇÄ : Œõ[n, i] ‚ü∂ S) : ‚àÉ œÉ : Œî[n] ‚ü∂ S, œÉ‚ÇÄ = hornInclusion n i ‚â´ œÉ  := by
  cases n using Nat.casesAuxOn with
  | zero => cases i with ‚ü®_, h‚ü©; cases h",24.82735800743103
mathlib,Mathlib/AlgebraicTopology/Quasicategory.lean,"lemma Quasicategory.hornFilling {S : SSet} [Quasicategory S] ‚¶Én : ‚Ñï‚¶Ñ ‚¶Éi : Fin (n+1)‚¶Ñ
    (h0 : 0 < i) (hn : i < Fin.last n)
    (œÉ‚ÇÄ : Œõ[n, i] ‚ü∂ S) : ‚àÉ œÉ : Œî[n] ‚ü∂ S, œÉ‚ÇÄ = hornInclusion n i ‚â´ œÉ ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,12,True,,12,0.0,"lemma Quasicategory.hornFilling {S : SSet} [Quasicategory S] ‚¶Én : ‚Ñï‚¶Ñ ‚¶Éi : Fin (n+1)‚¶Ñ
    (h0 : 0 < i) (hn : i < Fin.last n)
    (œÉ‚ÇÄ : Œõ[n, i] ‚ü∂ S) : ‚àÉ œÉ : Œî[n] ‚ü∂ S, œÉ‚ÇÄ = hornInclusion n i ‚â´ œÉ := by
  cases n using Nat.casesAuxOn with
  | zero => simp [Fin.lt_iff_val_lt_val] at hn
  | succ n =>
  cases n using Nat.casesAuxOn with
  | zero =>
    simp only [Fin.lt_iff_val_lt_val, Fin.val_zero, Fin.val_last, zero_add, Nat.lt_one_iff] at h0 hn
    simp [hn] at h0
  | succ n => exact Quasicategory.hornFilling' œÉ‚ÇÄ h0 hn","lemma Quasicategory.hornFilling {S : SSet} [Quasicategory S] ‚¶Én : ‚Ñï‚¶Ñ ‚¶Éi : Fin (n+1)‚¶Ñ
    (h0 : 0 < i) (hn : i < Fin.last n)
    (œÉ‚ÇÄ : Œõ[n, i] ‚ü∂ S) : ‚àÉ œÉ : Œî[n] ‚ü∂ S, œÉ‚ÇÄ = hornInclusion n i ‚â´ œÉ := by
  cases n using Nat.casesAuxOn with
  | zero => simp [Fin.lt_iff_val_lt_val] at hn
  | succ n =>
  cases n using Nat.casesAuxOn with
  | zero =>
    simp only [Fin.lt_iff_val_lt_val, Fin.val_zero, Fin.val_last, zero_add, Nat.lt_one_iff] at h0 hn
    simp [hn] at h0
  | succ n => exact Quasicategory.hornFilling' œÉ‚ÇÄ h0 hn",29.93498921394348
mathlib,Mathlib/AlgebraicTopology/DoldKan/GammaCompN.lean,"@[simp]
 theorem N‚ÇÇŒì‚ÇÇToKaroubiIso_hom_app (X : ChainComplex C ‚Ñï) :
    (N‚ÇÇŒì‚ÇÇToKaroubiIso.hom.app X).f = PInfty ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,12,True,,12,0.0,"@[simp]
lemma N‚ÇÇŒì‚ÇÇToKaroubiIso_hom_app (X : ChainComplex C ‚Ñï) :
    (N‚ÇÇŒì‚ÇÇToKaroubiIso.hom.app X).f = PInfty := by
  ext n
  dsimp [N‚ÇÇŒì‚ÇÇToKaroubiIso]
  simp only [comp_id, assoc, PInfty_f_idem]
  conv_rhs =>
    rw [‚Üê PInfty_f_idem]
  congr 1
  apply (Œì‚ÇÄ.splitting X).hom_ext'
  intro A
  rw [Splitting.Œπ_desc_assoc, assoc]
  apply id_comp","@[simp]
lemma N‚ÇÇŒì‚ÇÇToKaroubiIso_hom_app (X : ChainComplex C ‚Ñï) :
    (N‚ÇÇŒì‚ÇÇToKaroubiIso.hom.app X).f = PInfty := by
  ext n
  dsimp [N‚ÇÇŒì‚ÇÇToKaroubiIso]
  simp only [comp_id, assoc, PInfty_f_idem]
  conv_rhs =>
    rw [‚Üê PInfty_f_idem]
  congr 1
  apply (Œì‚ÇÄ.splitting X).hom_ext'
  intro A
  rw [Splitting.Œπ_desc_assoc, assoc]
  apply id_comp",110.34185695648193
mathlib,Mathlib/AlgebraicTopology/DoldKan/EquivalencePseudoabelian.lean,"theorem hŒµ :
    Compatibility.œÖ (isoN‚ÇÅ) =
      (Œì‚ÇÇN‚ÇÅ : (toKaroubiEquivalence _).functor ‚âÖ
          (N‚ÇÅ : SimplicialObject C ‚•§ _) ‚ãô Preadditive.DoldKan.equivalence.inverse) ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,12,True,,12,0.0,"theorem hŒµ :
    Compatibility.œÖ (isoN‚ÇÅ) =
      (Œì‚ÇÇN‚ÇÅ : (toKaroubiEquivalence _).functor ‚âÖ
          (N‚ÇÅ : SimplicialObject C ‚•§ _) ‚ãô Preadditive.DoldKan.equivalence.inverse) := by
  dsimp only [isoN‚ÇÅ]
  ext1
  rw [‚Üê cancel_epi Œì‚ÇÇN‚ÇÅ.inv, Iso.inv_hom_id]
  ext X : 2
  rw [NatTrans.comp_app]
  erw [compatibility_Œì‚ÇÇN‚ÇÅ_Œì‚ÇÇN‚ÇÇ_natTrans X]
  rw [Compatibility.œÖ_hom_app, Preadditive.DoldKan.equivalence_unitIso, Iso.app_inv, assoc]
  erw [‚Üê NatTrans.comp_app_assoc, IsIso.hom_inv_id]
  rw [NatTrans.id_app, id_comp, NatTrans.id_app, Œì‚ÇÇN‚ÇÇToKaroubiIso_inv_app]
  dsimp only [Preadditive.DoldKan.equivalence_inverse, Preadditive.DoldKan.Œì]
  rw [‚Üê Œì‚ÇÇ.map_comp, Iso.inv_hom_id_app, Œì‚ÇÇ.map_id]
  rfl","theorem hŒµ :
    Compatibility.œÖ (isoN‚ÇÅ) =
      (Œì‚ÇÇN‚ÇÅ : (toKaroubiEquivalence _).functor ‚âÖ
          (N‚ÇÅ : SimplicialObject C ‚•§ _) ‚ãô Preadditive.DoldKan.equivalence.inverse) := by
  dsimp only [isoN‚ÇÅ]
  ext1
  rw [‚Üê cancel_epi Œì‚ÇÇN‚ÇÅ.inv, Iso.inv_hom_id]
  ext X : 2
  rw [NatTrans.comp_app]
  erw [compatibility_Œì‚ÇÇN‚ÇÅ_Œì‚ÇÇN‚ÇÇ_natTrans X]
  rw [Compatibility.œÖ_hom_app, Preadditive.DoldKan.equivalence_unitIso, Iso.app_inv, assoc]
  erw [‚Üê NatTrans.comp_app_assoc, IsIso.hom_inv_id]
  rw [NatTrans.id_app, id_comp, NatTrans.id_app, Œì‚ÇÇN‚ÇÇToKaroubiIso_inv_app]
  dsimp only [Preadditive.DoldKan.equivalence_inverse, Preadditive.DoldKan.Œì]
  rw [‚Üê Œì‚ÇÇ.map_comp, Iso.inv_hom_id_app, Œì‚ÇÇ.map_id]
  rfl",113.08041429519653
mathlib,Mathlib/AlgebraicTopology/DoldKan/GammaCompN.lean,"@[simp]
lemma N‚ÇÇŒì‚ÇÇToKaroubiIso_hom_app (X : ChainComplex C ‚Ñï) :
    (N‚ÇÇŒì‚ÇÇToKaroubiIso.hom.app X).f = PInfty ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,12,True,,12,0.0,"@[simp]
lemma N‚ÇÇŒì‚ÇÇToKaroubiIso_hom_app (X : ChainComplex C ‚Ñï) :
    (N‚ÇÇŒì‚ÇÇToKaroubiIso.hom.app X).f = PInfty := by
  ext n
  dsimp [N‚ÇÇŒì‚ÇÇToKaroubiIso]
  simp only [comp_id, assoc, PInfty_f_idem]
  conv_rhs =>
    rw [‚Üê PInfty_f_idem]
  congr 1
  apply (Œì‚ÇÄ.splitting X).hom_ext'
  intro A
  rw [Splitting.Œπ_desc_assoc, assoc]
  apply id_comp","@[simp]
lemma N‚ÇÇŒì‚ÇÇToKaroubiIso_hom_app (X : ChainComplex C ‚Ñï) :
    (N‚ÇÇŒì‚ÇÇToKaroubiIso.hom.app X).f = PInfty := by
  ext n
  dsimp [N‚ÇÇŒì‚ÇÇToKaroubiIso]
  simp only [comp_id, assoc, PInfty_f_idem]
  conv_rhs =>
    rw [‚Üê PInfty_f_idem]
  congr 1
  apply (Œì‚ÇÄ.splitting X).hom_ext'
  intro A
  rw [Splitting.Œπ_desc_assoc, assoc]
  apply id_comp",113.84412693977356
mathlib,Mathlib/AlgebraicTopology/SplitSimplicialObject.lean,theorem eqId_iff_eq : A.EqId ‚Üî A.1 = Œî ,"refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,13,True,,11,-0.15384615384615385,"theorem eqId_iff_eq : A.EqId ‚Üî A.1 = Œî := by
  constructor
  ¬∑ intro h
    dsimp at h
    rw [h]
    rfl
  ¬∑ intro h
    rcases A with ‚ü®_, ‚ü®f, hf‚ü©‚ü©
    simp only at h
    subst h
    refine ext _ _ rfl ?_
    haveI := hf
    simp only [eqToHom_refl, comp_id]
    exact eq_id_of_epi f","theorem eqId_iff_eq : A.EqId ‚Üî A.1 = Œî  := by
  constructor
  intro h; dsimp at h; rw [h]; rfl
  intro h; rcases A with ‚ü®_, ‚ü®f, hf‚ü©‚ü©; simp only at h; subst h
  refine ext _ _ rfl (by simp [eq_id_of_epi])",39.04673933982849
mathlib,Mathlib/AlgebraicTopology/DoldKan/Compatibility.lean,theorem equivalenceCounitIso_eq : (equivalence hF hG).counitIso = equivalenceCounitIso Œ∑ ,"refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,12,True,,12,0.0,"theorem equivalenceCounitIso_eq : (equivalence hF hG).counitIso = equivalenceCounitIso Œ∑ := by
  ext1; apply NatTrans.ext; ext Y
  dsimp [equivalence]
  simp only [comp_id, id_comp, Functor.map_comp, equivalence‚ÇÇCounitIso_eq,
    equivalence‚ÇÇCounitIso_hom_app, assoc, equivalenceCounitIso_hom_app]
  simp only [‚Üê eB.inverse.map_comp_assoc, ‚Üê œÑ‚ÇÄ_hom_app, hŒ∑, œÑ‚ÇÅ_hom_app]
  erw [hF.inv.naturality_assoc, hF.inv.naturality_assoc]
  dsimp
  congr 2
  simp only [‚Üê e'.functor.map_comp_assoc, Equivalence.fun_inv_map, assoc,
    Iso.inv_hom_id_app_assoc, hG.inv_hom_id_app]
  dsimp
  rw [comp_id, eA.functor_unitIso_comp, e'.functor.map_id, id_comp, hF.inv_hom_id_app_assoc]","theorem equivalenceCounitIso_eq : (equivalence hF hG).counitIso = equivalenceCounitIso Œ∑ := by
  ext1; apply NatTrans.ext; ext Y
  dsimp [equivalence]
  simp only [comp_id, id_comp, Functor.map_comp, equivalence‚ÇÇCounitIso_eq,
    equivalence‚ÇÇCounitIso_hom_app, assoc, equivalenceCounitIso_hom_app]
  simp only [‚Üê eB.inverse.map_comp_assoc, ‚Üê œÑ‚ÇÄ_hom_app, hŒ∑, œÑ‚ÇÅ_hom_app]
  erw [hF.inv.naturality_assoc, hF.inv.naturality_assoc]
  dsimp
  congr 2
  simp only [‚Üê e'.functor.map_comp_assoc, Equivalence.fun_inv_map, assoc,
    Iso.inv_hom_id_app_assoc, hG.inv_hom_id_app]
  dsimp
  rw [comp_id, eA.functor_unitIso_comp, e'.functor.map_id, id_comp, hF.inv_hom_id_app_assoc]",67.0618941783905
mathlib,Mathlib/AlgebraicTopology/SimplexCategory.lean,"/-- The second part of the third simplicial identity -/
@[reassoc]
theorem Œ¥_comp_œÉ_succ {n} {i : Fin (n + 1)} : Œ¥ i.succ ‚â´ œÉ i = ùüô ([n] : SimplexCategory) ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,13,True,,12,-0.07692307692307693,"/-- The second part of the third simplicial identity -/
@[reassoc]
theorem Œ¥_comp_œÉ_succ {n} {i : Fin (n + 1)} : Œ¥ i.succ ‚â´ œÉ i = ùüô ([n] : SimplexCategory) := by
  ext j
  rcases i with ‚ü®i, _‚ü©
  rcases j with ‚ü®j, _‚ü©
  dsimp [Œ¥, œÉ, Fin.succAbove, Fin.predAbove]
  split_ifs <;> simp <;> simp at * <;> omega","/-- The second part of the third simplicial identity -/
@[reassoc]
theorem Œ¥_comp_œÉ_succ {n} {i : Fin (n + 1)} : Œ¥ i.succ ‚â´ œÉ i = ùüô ([n] : SimplexCategory)  := by
  ext j
  rcases i with ‚ü®i, _‚ü©
  rcases j with ‚ü®j, _‚ü©
  dsimp [Œ¥, œÉ, Fin.succAbove, Fin.predAbove]
  split_ifs <;> simp <;> omega




",60.2681999206543
mathlib,Mathlib/AlgebraicTopology/DoldKan/NReflectsIso.lean,"theorem compatibility_N‚ÇÇ_N‚ÇÅ_karoubi :
    N‚ÇÇ ‚ãô (karoubiChainComplexEquivalence C ‚Ñï).functor =
      karoubiFunctorCategoryEmbedding SimplexCategory·µí·µñ C ‚ãô
        N‚ÇÅ ‚ãô (karoubiChainComplexEquivalence (Karoubi C) ‚Ñï).functor ‚ãô
            Functor.mapHomologicalComplex (KaroubiKaroubi.equivalence C).inverse _ ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,14,True,,14,0.0,"theorem compatibility_N‚ÇÇ_N‚ÇÅ_karoubi :
    N‚ÇÇ ‚ãô (karoubiChainComplexEquivalence C ‚Ñï).functor =
      karoubiFunctorCategoryEmbedding SimplexCategory·µí·µñ C ‚ãô
        N‚ÇÅ ‚ãô (karoubiChainComplexEquivalence (Karoubi C) ‚Ñï).functor ‚ãô
            Functor.mapHomologicalComplex (KaroubiKaroubi.equivalence C).inverse _ := by
  refine CategoryTheory.Functor.ext (fun P => ?_) fun P Q f => ?_
  ¬∑ refine HomologicalComplex.ext ?_ ?_
    ¬∑ ext n
      ¬∑ rfl
      ¬∑ dsimp
        simp only [karoubi_PInfty_f, comp_id, PInfty_f_naturality, id_comp, eqToHom_refl]
    ¬∑ rintro _ n (rfl : n + 1 = _)
      ext
      have h := (AlternatingFaceMapComplex.map P.p).comm (n + 1) n
      dsimp [N‚ÇÇ, karoubiChainComplexEquivalence,
        KaroubiHomologicalComplexEquivalence.Functor.obj] at h ‚ä¢
      simp only [assoc, Karoubi.eqToHom_f, eqToHom_refl, comp_id,
        karoubi_alternatingFaceMapComplex_d, karoubi_PInfty_f,
        ‚Üê HomologicalComplex.Hom.comm_assoc, ‚Üê h, app_idem_assoc]
  ¬∑ ext n
    dsimp [KaroubiKaroubi.inverse, Functor.mapHomologicalComplex]
    simp only [karoubi_PInfty_f, HomologicalComplex.eqToHom_f, Karoubi.eqToHom_f,
      assoc, comp_id, PInfty_f_naturality, app_p_comp,
      karoubiChainComplexEquivalence_functor_obj_X_p, N‚ÇÇ_obj_p_f, eqToHom_refl,
      PInfty_f_naturality_assoc, app_comp_p, PInfty_f_idem_assoc]","theorem compatibility_N‚ÇÇ_N‚ÇÅ_karoubi :
    N‚ÇÇ ‚ãô (karoubiChainComplexEquivalence C ‚Ñï).functor =
      karoubiFunctorCategoryEmbedding SimplexCategory·µí·µñ C ‚ãô
        N‚ÇÅ ‚ãô (karoubiChainComplexEquivalence (Karoubi C) ‚Ñï).functor ‚ãô
            Functor.mapHomologicalComplex (KaroubiKaroubi.equivalence C).inverse _ := by
  refine CategoryTheory.Functor.ext (fun P => ?_) fun P Q f => ?_
  ¬∑ refine HomologicalComplex.ext ?_ ?_
    ¬∑ ext n
      ¬∑ rfl
      ¬∑ dsimp
        simp only [karoubi_PInfty_f, comp_id, PInfty_f_naturality, id_comp, eqToHom_refl]
    ¬∑ rintro _ n (rfl : n + 1 = _)
      ext
      have h := (AlternatingFaceMapComplex.map P.p).comm (n + 1) n
      dsimp [N‚ÇÇ, karoubiChainComplexEquivalence,
        KaroubiHomologicalComplexEquivalence.Functor.obj] at h ‚ä¢
      simp only [assoc, Karoubi.eqToHom_f, eqToHom_refl, comp_id,
        karoubi_alternatingFaceMapComplex_d, karoubi_PInfty_f,
        ‚Üê HomologicalComplex.Hom.comm_assoc, ‚Üê h, app_idem_assoc]
  ¬∑ ext n
    dsimp [KaroubiKaroubi.inverse, Functor.mapHomologicalComplex]
    simp only [karoubi_PInfty_f, HomologicalComplex.eqToHom_f, Karoubi.eqToHom_f,
      assoc, comp_id, PInfty_f_naturality, app_p_comp,
      karoubiChainComplexEquivalence_functor_obj_X_p, N‚ÇÇ_obj_p_f, eqToHom_refl,
      PInfty_f_naturality_assoc, app_comp_p, PInfty_f_idem_assoc]",76.24908113479614
mathlib,Mathlib/AlgebraicTopology/SimplexCategory.lean,"/-- The fourth simplicial identity -/
@[reassoc]
theorem Œ¥_comp_œÉ_of_gt {n} {i : Fin (n + 2)} {j : Fin (n + 1)} (H : Fin.castSucc j < i) :
    Œ¥ i.succ ‚â´ œÉ (Fin.castSucc j) = œÉ j ‚â´ Œ¥ i ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,14,True,,13,-0.07142857142857142,"/-- The fourth simplicial identity -/
@[reassoc]
theorem Œ¥_comp_œÉ_of_gt {n} {i : Fin (n + 2)} {j : Fin (n + 1)} (H : Fin.castSucc j < i) :
    Œ¥ i.succ ‚â´ œÉ (Fin.castSucc j) = œÉ j ‚â´ Œ¥ i := by
  ext k : 3
  dsimp [Œ¥, œÉ]
  rcases le_or_lt k i with (hik | hik)
  ¬∑ rw [Fin.succAbove_of_castSucc_lt _ _ (Fin.castSucc_lt_succ_iff.mpr hik)]
    rcases le_or_lt k (j.castSucc) with (hjk | hjk)
    ¬∑ rw [Fin.predAbove_of_le_castSucc _ _
      (Fin.castSucc_le_castSucc_iff.mpr hjk), Fin.castPred_castSucc,
      Fin.predAbove_of_le_castSucc _ _ hjk, Fin.succAbove_of_castSucc_lt, Fin.castSucc_castPred]
      rw [Fin.castSucc_castPred]
      exact hjk.trans_lt H
    ¬∑ rw [Fin.predAbove_of_castSucc_lt _ _ (Fin.castSucc_lt_castSucc_iff.mpr hjk),
      Fin.predAbove_of_castSucc_lt _ _ hjk, Fin.succAbove_of_castSucc_lt,
      Fin.castSucc_pred_eq_pred_castSucc]
      rwa [Fin.castSucc_lt_iff_succ_le, Fin.succ_pred]
  ¬∑ rw [Fin.succAbove_of_le_castSucc _ _ (Fin.succ_le_castSucc_iff.mpr hik)]
    have hjk := H.trans hik
    rw [Fin.predAbove_of_castSucc_lt _ _ hjk, Fin.predAbove_of_castSucc_lt _ _
      (Fin.castSucc_lt_succ_iff.mpr hjk.le),
    Fin.pred_succ, Fin.succAbove_of_le_castSucc, Fin.succ_pred]
    rwa [Fin.le_castSucc_pred_iff]","/-- The fourth simplicial identity -/
@[reassoc]
theorem Œ¥_comp_œÉ_of_gt {n} {i : Fin (n + 2)} {j : Fin (n + 1)} (H : Fin.castSucc j < i) :
    Œ¥ i.succ ‚â´ œÉ (Fin.castSucc j) = œÉ j ‚â´ Œ¥ i  := by
  ext k : 3
  dsimp [Œ¥, œÉ]
  rcases le_or_lt k i with (hik | hik)
  ¬∑ rw [Fin.succAbove_of_castSucc_lt _ _ (Fin.castSucc_lt_succ_iff.mpr hik)]
    rcases le_or_lt k (j.castSucc) with (hjk | hjk)
    ¬∑ rw [Fin.predAbove_of_le_castSucc _ _ (Fin.castSucc_le_castSucc_iff.mpr hjk),
        Fin.castPred_castSucc, Fin.predAbove_of_le_castSucc _ _ hjk,
        Fin.succAbove_of_castSucc_lt, Fin.castSucc_castPred]
      exact hjk.trans_lt H
    ¬∑ rw [Fin.predAbove_of_castSucc_lt _ _ (Fin.castSucc_lt_castSucc_iff.mpr hjk),
        Fin.predAbove_of_castSucc_lt _ _ hjk, Fin.succAbove_of_castSucc_lt,
        Fin.castSucc_pred_eq_pred_castSucc]
      rwa [Fin.castSucc_lt_iff_succ_le, Fin.succ_pred]
  ¬∑ rw [Fin.succAbove_of_le_castSucc _ _ (Fin.succ_le_castSucc_iff.mpr hik)]
    have hjk := H.trans hik
    rw [Fin.predAbove_of_castSucc_lt _ _ hjk, Fin.predAbove_of_castSucc_lt _ _
        (Fin.castSucc_lt_succ_iff.mpr hjk.le), Fin.pred_succ, Fin.succAbove_of_le_castSucc,
        Fin.succ_pred]
    rwa [Fin.le_castSucc_pred_iff]",94.36395120620728
mathlib,Mathlib/AlgebraicTopology/DoldKan/NCompGamma.lean,"theorem identity_N‚ÇÇ_objectwise (P : Karoubi (SimplicialObject C)) :
    (N‚ÇÇŒì‚ÇÇ.inv.app (N‚ÇÇ.obj P) : N‚ÇÇ.obj P ‚ü∂ N‚ÇÇ.obj (Œì‚ÇÇ.obj (N‚ÇÇ.obj P))) ‚â´
    N‚ÇÇ.map (Œì‚ÇÇN‚ÇÇ.natTrans.app P) = ùüô (N‚ÇÇ.obj P) ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,14,True,,14,0.0,"theorem identity_N‚ÇÇ_objectwise (P : Karoubi (SimplicialObject C)) :
    (N‚ÇÇŒì‚ÇÇ.inv.app (N‚ÇÇ.obj P) : N‚ÇÇ.obj P ‚ü∂ N‚ÇÇ.obj (Œì‚ÇÇ.obj (N‚ÇÇ.obj P))) ‚â´
    N‚ÇÇ.map (Œì‚ÇÇN‚ÇÇ.natTrans.app P) = ùüô (N‚ÇÇ.obj P) := by
  ext n
  have eq‚ÇÅ : (N‚ÇÇŒì‚ÇÇ.inv.app (N‚ÇÇ.obj P)).f.f n = PInfty.f n ‚â´ P.p.app (op [n]) ‚â´
      ((Œì‚ÇÄ.splitting (N‚ÇÇ.obj P).X).cofan _).inj (Splitting.IndexSet.id (op [n])) := by
    simp only [N‚ÇÇŒì‚ÇÇ_inv_app_f_f, N‚ÇÇ_obj_p_f, assoc]
  have eq‚ÇÇ : ((Œì‚ÇÄ.splitting (N‚ÇÇ.obj P).X).cofan _).inj (Splitting.IndexSet.id (op [n])) ‚â´
      (N‚ÇÇ.map (Œì‚ÇÇN‚ÇÇ.natTrans.app P)).f.f n = PInfty.f n ‚â´ P.p.app (op [n]) := by
    dsimp
    rw [PInfty_on_Œì‚ÇÄ_splitting_summand_eq_self_assoc, Œì‚ÇÇN‚ÇÇ.natTrans_app_f_app]
    dsimp
    rw [Œì‚ÇÇN‚ÇÇToKaroubiIso_hom_app, assoc, Splitting.Œπ_desc_assoc, assoc, assoc]
    dsimp [toKaroubi]
    rw [Splitting.Œπ_desc_assoc]
    dsimp
    simp only [assoc, Splitting.Œπ_desc_assoc, unop_op, Splitting.IndexSet.id_fst,
      len_mk, NatTrans.naturality, PInfty_f_idem_assoc,
      PInfty_f_naturality_assoc, app_idem_assoc]
    erw [P.X.map_id, comp_id]
  simp only [Karoubi.comp_f, HomologicalComplex.comp_f, Karoubi.id_eq, N‚ÇÇ_obj_p_f, assoc,
    eq‚ÇÅ, eq‚ÇÇ, PInfty_f_naturality_assoc, app_idem, PInfty_f_idem_assoc]","theorem identity_N‚ÇÇ_objectwise (P : Karoubi (SimplicialObject C)) :
    (N‚ÇÇŒì‚ÇÇ.inv.app (N‚ÇÇ.obj P) : N‚ÇÇ.obj P ‚ü∂ N‚ÇÇ.obj (Œì‚ÇÇ.obj (N‚ÇÇ.obj P))) ‚â´
    N‚ÇÇ.map (Œì‚ÇÇN‚ÇÇ.natTrans.app P) = ùüô (N‚ÇÇ.obj P) := by
  ext n
  have eq‚ÇÅ : (N‚ÇÇŒì‚ÇÇ.inv.app (N‚ÇÇ.obj P)).f.f n = PInfty.f n ‚â´ P.p.app (op [n]) ‚â´
      ((Œì‚ÇÄ.splitting (N‚ÇÇ.obj P).X).cofan _).inj (Splitting.IndexSet.id (op [n])) := by
    simp only [N‚ÇÇŒì‚ÇÇ_inv_app_f_f, N‚ÇÇ_obj_p_f, assoc]
  have eq‚ÇÇ : ((Œì‚ÇÄ.splitting (N‚ÇÇ.obj P).X).cofan _).inj (Splitting.IndexSet.id (op [n])) ‚â´
      (N‚ÇÇ.map (Œì‚ÇÇN‚ÇÇ.natTrans.app P)).f.f n = PInfty.f n ‚â´ P.p.app (op [n]) := by
    dsimp
    rw [PInfty_on_Œì‚ÇÄ_splitting_summand_eq_self_assoc, Œì‚ÇÇN‚ÇÇ.natTrans_app_f_app]
    dsimp
    rw [Œì‚ÇÇN‚ÇÇToKaroubiIso_hom_app, assoc, Splitting.Œπ_desc_assoc, assoc, assoc]
    dsimp [toKaroubi]
    rw [Splitting.Œπ_desc_assoc]
    dsimp
    simp only [assoc, Splitting.Œπ_desc_assoc, unop_op, Splitting.IndexSet.id_fst,
      len_mk, NatTrans.naturality, PInfty_f_idem_assoc,
      PInfty_f_naturality_assoc, app_idem_assoc]
    erw [P.X.map_id, comp_id]
  simp only [Karoubi.comp_f, HomologicalComplex.comp_f, Karoubi.id_eq, N‚ÇÇ_obj_p_f, assoc,
    eq‚ÇÅ, eq‚ÇÇ, PInfty_f_naturality_assoc, app_idem, PInfty_f_idem_assoc]",158.71549797058105
mathlib,Mathlib/AlgebraicTopology/DoldKan/Projections.lean,"@[reassoc]
theorem comp_P_eq_self {Y : C} {n q : ‚Ñï} {œÜ : Y ‚ü∂ X _[n + 1]} (v : HigherFacesVanish q œÜ) :
    œÜ ‚â´ (P q).f (n + 1) = œÜ ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,16,True,,16,0.0,"@[reassoc]
theorem comp_P_eq_self {Y : C} {n q : ‚Ñï} {œÜ : Y ‚ü∂ X _[n + 1]} (v : HigherFacesVanish q œÜ) :
    œÜ ‚â´ (P q).f (n + 1) = œÜ := by
  induction' q with q hq
  ¬∑ simp only [P_zero]
    apply comp_id
  ¬∑ simp only [P_succ, comp_add, HomologicalComplex.comp_f, HomologicalComplex.add_f_apply,
      comp_id, ‚Üê assoc, hq v.of_succ, add_right_eq_self]
    by_cases hqn : n < q
    ¬∑ exact v.of_succ.comp_HœÉ_eq_zero hqn
    ¬∑ obtain ‚ü®a, ha‚ü© := Nat.le.dest (not_lt.mp hqn)
      have hnaq : n = a + q := by omega
      simp only [v.of_succ.comp_HœÉ_eq hnaq, neg_eq_zero, ‚Üê assoc]
      have eq := v ‚ü®a, by omega‚ü© (by
        simp only [hnaq, Nat.succ_eq_add_one, add_assoc]
        rfl)
      simp only [Fin.succ_mk] at eq
      simp only [eq, zero_comp]","@[reassoc]
theorem comp_P_eq_self {Y : C} {n q : ‚Ñï} {œÜ : Y ‚ü∂ X _[n + 1]} (v : HigherFacesVanish q œÜ) :
    œÜ ‚â´ (P q).f (n + 1) = œÜ := by
  induction' q with q hq
  ¬∑ simp only [P_zero]
    apply comp_id
  ¬∑ simp only [P_succ, comp_add, HomologicalComplex.comp_f, HomologicalComplex.add_f_apply,
      comp_id, ‚Üê assoc, hq v.of_succ, add_right_eq_self]
    by_cases hqn : n < q
    ¬∑ exact v.of_succ.comp_HœÉ_eq_zero hqn
    ¬∑ obtain ‚ü®a, ha‚ü© := Nat.le.dest (not_lt.mp hqn)
      have hnaq : n = a + q := by omega
      simp only [v.of_succ.comp_HœÉ_eq hnaq, neg_eq_zero, ‚Üê assoc]
      have eq := v ‚ü®a, by omega‚ü© (by
        simp only [hnaq, Nat.succ_eq_add_one, add_assoc]
        rfl)
      simp only [Fin.succ_mk] at eq
      simp only [eq, zero_comp]",52.12833285331726
mathlib,Mathlib/AlgebraicTopology/SimplexCategory.lean,"/-- The first part of the third simplicial identity -/
@[reassoc]
theorem Œ¥_comp_œÉ_self {n} {i : Fin (n + 1)} :
    Œ¥ (Fin.castSucc i) ‚â´ œÉ i = ùüô ([n] : SimplexCategory) ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,15,True,,12,-0.2,"/-- The first part of the third simplicial identity -/
@[reassoc]
theorem Œ¥_comp_œÉ_self {n} {i : Fin (n + 1)} :
    Œ¥ (Fin.castSucc i) ‚â´ œÉ i = ùüô ([n] : SimplexCategory) := by
  rcases i with ‚ü®i, hi‚ü©
  ext ‚ü®j, hj‚ü©
  simp? at hj says simp only [len_mk] at hj
  dsimp [œÉ, Œ¥, Fin.predAbove, Fin.succAbove]
  simp only [Fin.lt_iff_val_lt_val, Fin.dite_val, Fin.ite_val, Fin.coe_pred, ge_iff_le,
    Fin.coe_castLT, dite_eq_ite]
  split_ifs
  any_goals simp
  all_goals omega","/-- The first part of the third simplicial identity -/
@[reassoc]
theorem Œ¥_comp_œÉ_self {n} {i : Fin (n + 1)} :
    Œ¥ (Fin.castSucc i) ‚â´ œÉ i = ùüô ([n] : SimplexCategory)  := by
  ext ‚ü®j, hj‚ü©
  dsimp [œÉ, Œ¥, Fin.predAbove, Fin.succAbove]
  split_ifs; simp; linarith




",53.22467494010925
mathlib,Mathlib/AlgebraicTopology/SimplexCategory.lean,"/-- The fifth simplicial identity -/
@[reassoc]
theorem œÉ_comp_œÉ {n} {i j : Fin (n + 1)} (H : i ‚â§ j) :
    œÉ (Fin.castSucc i) ‚â´ œÉ j = œÉ j.succ ‚â´ œÉ i ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,15,True,,15,0.0,"/-- The fifth simplicial identity -/
@[reassoc]
theorem œÉ_comp_œÉ {n} {i j : Fin (n + 1)} (H : i ‚â§ j) :
    œÉ (Fin.castSucc i) ‚â´ œÉ j = œÉ j.succ ‚â´ œÉ i := by
  ext k : 3
  dsimp [œÉ]
  cases' k using Fin.lastCases with k
  ¬∑ simp only [len_mk, Fin.predAbove_right_last]
  ¬∑ cases' k using Fin.cases with k
    ¬∑ rw [Fin.castSucc_zero, Fin.predAbove_of_le_castSucc _ 0 (Fin.zero_le _),
      Fin.predAbove_of_le_castSucc _ _ (Fin.zero_le _), Fin.castPred_zero,
      Fin.predAbove_of_le_castSucc _ 0 (Fin.zero_le _),
      Fin.predAbove_of_le_castSucc _ _ (Fin.zero_le _)]
    ¬∑ rcases le_or_lt i k with (h | h)
      ¬∑ simp_rw [Fin.predAbove_of_castSucc_lt i.castSucc _ (Fin.castSucc_lt_castSucc_iff.mpr
        (Fin.castSucc_lt_succ_iff.mpr h)), ‚Üê Fin.succ_castSucc, Fin.pred_succ,
        Fin.succ_predAbove_succ]
        rw [Fin.predAbove_of_castSucc_lt i _ (Fin.castSucc_lt_succ_iff.mpr _), Fin.pred_succ]
        rcases le_or_lt k j with (hkj | hkj)
        ¬∑ rwa [Fin.predAbove_of_le_castSucc _ _ (Fin.castSucc_le_castSucc_iff.mpr hkj),
          Fin.castPred_castSucc]
        ¬∑ rw [Fin.predAbove_of_castSucc_lt _ _ (Fin.castSucc_lt_castSucc_iff.mpr hkj),
          Fin.le_pred_iff,
          Fin.succ_le_castSucc_iff]
          exact H.trans_lt hkj
      ¬∑ simp_rw [Fin.predAbove_of_le_castSucc i.castSucc _ (Fin.castSucc_le_castSucc_iff.mpr
        (Fin.succ_le_castSucc_iff.mpr h)), Fin.castPred_castSucc, ‚Üê Fin.succ_castSucc,
        Fin.succ_predAbove_succ]
        rw [Fin.predAbove_of_le_castSucc _ k.castSucc
        (Fin.castSucc_le_castSucc_iff.mpr (h.le.trans H)),
        Fin.castPred_castSucc, Fin.predAbove_of_le_castSucc _ k.succ
        (Fin.succ_le_castSucc_iff.mpr (H.trans_lt' h)), Fin.predAbove_of_le_castSucc _ k.succ
        (Fin.succ_le_castSucc_iff.mpr h)]","/-- The fifth simplicial identity -/
@[reassoc]
theorem œÉ_comp_œÉ {n} {i j : Fin (n + 1)} (H : i ‚â§ j) :
    œÉ (Fin.castSucc i) ‚â´ œÉ j = œÉ j.succ ‚â´ œÉ i := by
  ext k : 3
  dsimp [œÉ]
  cases' k using Fin.lastCases with k
  ¬∑ simp only [len_mk, Fin.predAbove_right_last]
  ¬∑ cases' k using Fin.cases with k
    ¬∑ rw [Fin.castSucc_zero, Fin.predAbove_of_le_castSucc _ 0 (Fin.zero_le _),
      Fin.predAbove_of_le_castSucc _ _ (Fin.zero_le _), Fin.castPred_zero,
      Fin.predAbove_of_le_castSucc _ 0 (Fin.zero_le _),
      Fin.predAbove_of_le_castSucc _ _ (Fin.zero_le _)]
    ¬∑ rcases le_or_lt i k with (h | h)
      ¬∑ simp_rw [Fin.predAbove_of_castSucc_lt i.castSucc _ (Fin.castSucc_lt_castSucc_iff.mpr
        (Fin.castSucc_lt_succ_iff.mpr h)), ‚Üê Fin.succ_castSucc, Fin.pred_succ,
        Fin.succ_predAbove_succ]
        rw [Fin.predAbove_of_castSucc_lt i _ (Fin.castSucc_lt_succ_iff.mpr _), Fin.pred_succ]
        rcases le_or_lt k j with (hkj | hkj)
        ¬∑ rwa [Fin.predAbove_of_le_castSucc _ _ (Fin.castSucc_le_castSucc_iff.mpr hkj),
          Fin.castPred_castSucc]
        ¬∑ rw [Fin.predAbove_of_castSucc_lt _ _ (Fin.castSucc_lt_castSucc_iff.mpr hkj),
          Fin.le_pred_iff,
          Fin.succ_le_castSucc_iff]
          exact H.trans_lt hkj
      ¬∑ simp_rw [Fin.predAbove_of_le_castSucc i.castSucc _ (Fin.castSucc_le_castSucc_iff.mpr
        (Fin.succ_le_castSucc_iff.mpr h)), Fin.castPred_castSucc, ‚Üê Fin.succ_castSucc,
        Fin.succ_predAbove_succ]
        rw [Fin.predAbove_of_le_castSucc _ k.castSucc
        (Fin.castSucc_le_castSucc_iff.mpr (h.le.trans H)),
        Fin.castPred_castSucc, Fin.predAbove_of_le_castSucc _ k.succ
        (Fin.succ_le_castSucc_iff.mpr (H.trans_lt' h)), Fin.predAbove_of_le_castSucc _ k.succ
        (Fin.succ_le_castSucc_iff.mpr h)]",111.64961218833923
mathlib,Mathlib/AlgebraicTopology/SimplicialSet.lean,"/-- Two morphisms from a horn are equal if they are equal on all suitable faces. -/
protected
 theorem hom_ext {n : ‚Ñï} {i : Fin (n+2)} {S : SSet} (œÉ‚ÇÅ œÉ‚ÇÇ : Œõ[n+1, i] ‚ü∂ S)
    (h : ‚àÄ (j) (h : j ‚â† i), œÉ‚ÇÅ.app _ (face i j h) = œÉ‚ÇÇ.app _ (face i j h)) :
    œÉ‚ÇÅ = œÉ‚ÇÇ ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,20,True,,2,-0.9,"/-- Two morphisms from a horn are equal if they are equal on all suitable faces. -/
protected
lemma hom_ext {n : ‚Ñï} {i : Fin (n+2)} {S : SSet} (œÉ‚ÇÅ œÉ‚ÇÇ : Œõ[n+1, i] ‚ü∂ S)
    (h : ‚àÄ (j) (h : j ‚â† i), œÉ‚ÇÅ.app _ (face i j h) = œÉ‚ÇÇ.app _ (face i j h)) :
    œÉ‚ÇÅ = œÉ‚ÇÇ := by
  apply NatTrans.ext; apply funext; apply Opposite.rec; apply SimplexCategory.rec
  intro m; ext f
  obtain ‚ü®f', hf‚ü© := (standardSimplex.objEquiv _ _).symm.surjective f.1
  obtain ‚ü®j, hji, hfj‚ü© : ‚àÉ j, ¬¨j = i ‚àß ‚àÄ k, f'.toOrderHom k ‚â† j := by
    obtain ‚ü®f, hf'‚ü© := f
    subst hf
    simpa [‚Üê Set.univ_subset_iff, Set.subset_def, asOrderHom, not_or] using hf'
  have H : f = (Œõ[n+1, i].map (factor_Œ¥ f' j).op) (face i j hji) := by
    apply Subtype.ext
    apply (standardSimplex.objEquiv _ _).injective
    rw [‚Üê hf]
    exact (factor_Œ¥_spec f' j hfj).symm
  have H‚ÇÅ := congrFun (œÉ‚ÇÅ.naturality (factor_Œ¥ f' j).op) (face i j hji)
  have H‚ÇÇ := congrFun (œÉ‚ÇÇ.naturality (factor_Œ¥ f' j).op) (face i j hji)
  dsimp at H‚ÇÅ H‚ÇÇ
  erw [H, H‚ÇÅ, H‚ÇÇ, h _ hji]","/-- Two morphisms from a horn are equal if they are equal on all suitable faces. -/
protected
 theorem hom_ext {n : ‚Ñï} {i : Fin (n+2)} {S : SSet} (œÉ‚ÇÅ œÉ‚ÇÇ : Œõ[n+1, i] ‚ü∂ S)
    (h : ‚àÄ (j) (h : j ‚â† i), œÉ‚ÇÅ.app _ (face i j h) = œÉ‚ÇÇ.app _ (face i j h)) :
    œÉ‚ÇÅ = œÉ‚ÇÇ  := by
  apply NatTrans.ext; intro m; ext f;
  obtain ‚ü®f', hf‚ü© := (standardSimplex.objEquiv _ _).symm.surjective f.1;
  obtain ‚ü®j, hji, hfj‚ü© : ‚àÉ j, ¬¨j = i ‚àß ‚àÄ k, f'.toOrderHom k ‚â† j :=
    by simpa [‚Üê Set.univ_subset_iff, Set.subset_def, asOrderHom, not_or] using ‚Äπf ‚ü©.2;",127.16484713554382
mathlib,Mathlib/AlgebraicTopology/SimplicialSet.lean,"/-- Two morphisms from a horn are equal if they are equal on all suitable faces. -/
protected
lemma hom_ext {n : ‚Ñï} {i : Fin (n+2)} {S : SSet} (œÉ‚ÇÅ œÉ‚ÇÇ : Œõ[n+1, i] ‚ü∂ S)
    (h : ‚àÄ (j) (h : j ‚â† i), œÉ‚ÇÅ.app _ (face i j h) = œÉ‚ÇÇ.app _ (face i j h)) :
    œÉ‚ÇÅ = œÉ‚ÇÇ ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,20,True,,5,-0.75,"/-- Two morphisms from a horn are equal if they are equal on all suitable faces. -/
protected
lemma hom_ext {n : ‚Ñï} {i : Fin (n+2)} {S : SSet} (œÉ‚ÇÅ œÉ‚ÇÇ : Œõ[n+1, i] ‚ü∂ S)
    (h : ‚àÄ (j) (h : j ‚â† i), œÉ‚ÇÅ.app _ (face i j h) = œÉ‚ÇÇ.app _ (face i j h)) :
    œÉ‚ÇÅ = œÉ‚ÇÇ := by
  apply NatTrans.ext; apply funext; apply Opposite.rec; apply SimplexCategory.rec
  intro m; ext f
  obtain ‚ü®f', hf‚ü© := (standardSimplex.objEquiv _ _).symm.surjective f.1
  obtain ‚ü®j, hji, hfj‚ü© : ‚àÉ j, ¬¨j = i ‚àß ‚àÄ k, f'.toOrderHom k ‚â† j := by
    obtain ‚ü®f, hf'‚ü© := f
    subst hf
    simpa [‚Üê Set.univ_subset_iff, Set.subset_def, asOrderHom, not_or] using hf'
  have H : f = (Œõ[n+1, i].map (factor_Œ¥ f' j).op) (face i j hji) := by
    apply Subtype.ext
    apply (standardSimplex.objEquiv _ _).injective
    rw [‚Üê hf]
    exact (factor_Œ¥_spec f' j hfj).symm
  have H‚ÇÅ := congrFun (œÉ‚ÇÅ.naturality (factor_Œ¥ f' j).op) (face i j hji)
  have H‚ÇÇ := congrFun (œÉ‚ÇÇ.naturality (factor_Œ¥ f' j).op) (face i j hji)
  dsimp at H‚ÇÅ H‚ÇÇ
  erw [H, H‚ÇÅ, H‚ÇÇ, h _ hji]","/-- Two morphisms from a horn are equal if they are equal on all suitable faces. -/
protected
lemma hom_ext {n : ‚Ñï} {i : Fin (n+2)} {S : SSet} (œÉ‚ÇÅ œÉ‚ÇÇ : Œõ[n+1, i] ‚ü∂ S)
    (h : ‚àÄ (j) (h : j ‚â† i), œÉ‚ÇÅ.app _ (face i j h) = œÉ‚ÇÇ.app _ (face i j h)) :
    œÉ‚ÇÅ = œÉ‚ÇÇ  := by
  ext m f
  obtain ‚ü®f', hf‚ü© := (standardSimplex.objEquiv _ _).symm.surjective f.1
  obtain ‚ü®j, hji, hfj‚ü© : ‚àÉ j, j ‚â† i ‚àß ‚àÄ k, f'.toOrderHom k ‚â† j := by simpa using f.2
  dsimp [factor_Œ¥] at ‚ä¢ hf",155.27048802375793
mathlib,Mathlib/AlgebraicTopology/DoldKan/SplitSimplicialObject.lean,"theorem comp_PInfty_eq_zero_iff {Z : C} {n : ‚Ñï} (f : Z ‚ü∂ X _[n]) :
    f ‚â´ PInfty.f n = 0 ‚Üî f ‚â´ s.œÄSummand (IndexSet.id (op [n])) = 0 ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,20,True,,4,-0.8,"theorem comp_PInfty_eq_zero_iff {Z : C} {n : ‚Ñï} (f : Z ‚ü∂ X _[n]) :
    f ‚â´ PInfty.f n = 0 ‚Üî f ‚â´ s.œÄSummand (IndexSet.id (op [n])) = 0 := by
  constructor
  ¬∑ intro h
    rcases n with _|n
    ¬∑ dsimp at h
      rw [comp_id] at h
      rw [h, zero_comp]
    ¬∑ have h' := f ‚â´= PInfty_f_add_QInfty_f (n + 1)
      dsimp at h'
      rw [comp_id, comp_add, h, zero_add] at h'
      rw [‚Üê h', assoc, QInfty_f, decomposition_Q, Preadditive.sum_comp, Preadditive.comp_sum,
        Finset.sum_eq_zero]
      intro i _
      simp only [assoc, œÉ_comp_œÄSummand_id_eq_zero, comp_zero]
  ¬∑ intro h
    rw [‚Üê comp_id f, assoc, s.decomposition_id, Preadditive.sum_comp, Preadditive.comp_sum,
      Fintype.sum_eq_zero]
    intro A
    by_cases hA : A.EqId
    ¬∑ dsimp at hA
      subst hA
      rw [assoc, reassoc_of% h, zero_comp]
    ¬∑ simp only [assoc, s.cofan_inj_comp_PInfty_eq_zero A hA, comp_zero]","theorem comp_PInfty_eq_zero_iff {Z : C} {n : ‚Ñï} (f : Z ‚ü∂ X _[n]) :
    f ‚â´ PInfty.f n = 0 ‚Üî f ‚â´ s.œÄSummand (IndexSet.id (op [n])) = 0   := by
  constructor
  intro h
  rcases n with _|n
  exact (comp_id f).symm ‚ñ∏ h.trans zero_comp
  dsimp at *
  exact (comp_id f).symm ‚ñ∏ ((f ‚â´= PInfty_f_add_QInfty_f (n + 1)).trans (congr_arg (Œª x, f ‚â´ x + 0) h)).mpr $ Finset.sum_zero _ $ Œª i _, (associative_comp X _).symm ‚ñ∏ (coe_quot_map i $ Fin.snd_sum.trans $ Fin.eq_symm i.to_nat_gonum).mpr $ comp_zero X.symm ‚ñ∏ comp_id i",74.1943051815033
mathlib,Mathlib/AlgebraicTopology/SimplexCategory.lean,"open Fin in
lemma factor_Œ¥_spec {m n : ‚Ñï} (f : ([m] : SimplexCategory) ‚ü∂ [n+1]) (j : Fin (n+2))
    (hj : ‚àÄ (k : Fin (m+1)), f.toOrderHom k ‚â† j) :
    factor_Œ¥ f j ‚â´ Œ¥ j = f ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,21,True,,21,0.0,"open Fin in
lemma factor_Œ¥_spec {m n : ‚Ñï} (f : ([m] : SimplexCategory) ‚ü∂ [n+1]) (j : Fin (n+2))
    (hj : ‚àÄ (k : Fin (m+1)), f.toOrderHom k ‚â† j) :
    factor_Œ¥ f j ‚â´ Œ¥ j = f := by
  ext k : 3
  specialize hj k
  dsimp [factor_Œ¥, Œ¥, œÉ]
  cases' j using cases with j
  ¬∑ rw [predAbove_of_le_castSucc _ _ (zero_le _), castPred_zero, predAbove_of_castSucc_lt 0 _
    (castSucc_zero ‚ñ∏ pos_of_ne_zero hj),
    zero_succAbove, succ_pred]
  ¬∑ rw [predAbove_of_castSucc_lt 0 _ (castSucc_zero ‚ñ∏ succ_pos _), pred_succ]
    rcases hj.lt_or_lt with (hj | hj)
    ¬∑ rw [predAbove_of_le_castSucc j _]
      swap
      ¬∑ exact (le_castSucc_iff.mpr hj)
      ¬∑ rw [succAbove_of_castSucc_lt]
        swap
        ¬∑ rwa [castSucc_lt_succ_iff, castPred_le_iff, le_castSucc_iff]
        rw [castSucc_castPred]
    ¬∑ rw [predAbove_of_castSucc_lt]
      swap
      ¬∑ exact (castSucc_lt_succ _).trans hj
      rw [succAbove_of_le_castSucc]
      swap
      ¬∑ rwa [succ_le_castSucc_iff, lt_pred_iff]
      rw [succ_pred]","open Fin in
lemma factor_Œ¥_spec {m n : ‚Ñï} (f : ([m] : SimplexCategory) ‚ü∂ [n+1]) (j : Fin (n+2))
    (hj : ‚àÄ (k : Fin (m+1)), f.toOrderHom k ‚â† j) :
    factor_Œ¥ f j ‚â´ Œ¥ j = f := by
  ext k : 3
  specialize hj k
  dsimp [factor_Œ¥, Œ¥, œÉ]
  cases' j using cases with j
  ¬∑ rw [predAbove_of_le_castSucc _ _ (zero_le _), castPred_zero, predAbove_of_castSucc_lt 0 _
    (castSucc_zero ‚ñ∏ pos_of_ne_zero hj),
    zero_succAbove, succ_pred]
  ¬∑ rw [predAbove_of_castSucc_lt 0 _ (castSucc_zero ‚ñ∏ succ_pos _), pred_succ]
    rcases hj.lt_or_lt with (hj | hj)
    ¬∑ rw [predAbove_of_le_castSucc j _]
      swap
      ¬∑ exact (le_castSucc_iff.mpr hj)
      ¬∑ rw [succAbove_of_castSucc_lt]
        swap
        ¬∑ rwa [castSucc_lt_succ_iff, castPred_le_iff, le_castSucc_iff]
        rw [castSucc_castPred]
    ¬∑ rw [predAbove_of_castSucc_lt]
      swap
      ¬∑ exact (castSucc_lt_succ _).trans hj
      rw [succAbove_of_le_castSucc]
      swap
      ¬∑ rwa [succ_le_castSucc_iff, lt_pred_iff]
      rw [succ_pred]",104.13422513008118
mathlib,Mathlib/AlgebraicTopology/DoldKan/Decomposition.lean,"/-- In each positive degree, this lemma decomposes the idempotent endomorphism
`Q q` as a sum of morphisms which are postcompositions with suitable degeneracies.
As `Q q` is the complement projection to `P q`, this implies that in the case of
simplicial abelian groups, any $(n+1)$-simplex $x$ can be decomposed as
$x = x' + \sum (i=0}^{q-1} œÉ_{n-i}(y_i)$ where $x'$ is in the image of `P q` and
the $y_i$ are in degree $n$. -/
theorem decomposition_Q (n q : ‚Ñï) :
    ((Q q).f (n + 1) : X _[n + 1] ‚ü∂ X _[n + 1]) =
      ‚àë i ‚àà Finset.filter (fun i : Fin (n + 1) => (i : ‚Ñï) < q) Finset.univ,
        (P i).f (n + 1) ‚â´ X.Œ¥ i.rev.succ ‚â´ X.œÉ (Fin.rev i) ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,28,True,,28,0.0,"/-- In each positive degree, this lemma decomposes the idempotent endomorphism
`Q q` as a sum of morphisms which are postcompositions with suitable degeneracies.
As `Q q` is the complement projection to `P q`, this implies that in the case of
simplicial abelian groups, any $(n+1)$-simplex $x$ can be decomposed as
$x = x' + \sum (i=0}^{q-1} œÉ_{n-i}(y_i)$ where $x'$ is in the image of `P q` and
the $y_i$ are in degree $n$. -/
theorem decomposition_Q (n q : ‚Ñï) :
    ((Q q).f (n + 1) : X _[n + 1] ‚ü∂ X _[n + 1]) =
      ‚àë i ‚àà Finset.filter (fun i : Fin (n + 1) => (i : ‚Ñï) < q) Finset.univ,
        (P i).f (n + 1) ‚â´ X.Œ¥ i.rev.succ ‚â´ X.œÉ (Fin.rev i) := by
  induction' q with q hq
  ¬∑ simp only [Nat.zero_eq, Q_zero, HomologicalComplex.zero_f_apply, Nat.not_lt_zero,
      Finset.filter_False, Finset.sum_empty]
  ¬∑ by_cases hqn : q + 1 ‚â§ n + 1
    swap
    ¬∑ rw [Q_is_eventually_constant (show n + 1 ‚â§ q by omega), hq]
      congr 1
      ext ‚ü®x, hx‚ü©
      simp only [Nat.succ_eq_add_one, Finset.mem_filter, Finset.mem_univ, true_and]
      omega
    ¬∑ cases' Nat.le.dest (Nat.succ_le_succ_iff.mp hqn) with a ha
      rw [Q_succ, HomologicalComplex.sub_f_apply, HomologicalComplex.comp_f, hq]
      symm
      conv_rhs => rw [sub_eq_add_neg, add_comm]
      let q' : Fin (n + 1) := ‚ü®q, Nat.succ_le_iff.mp hqn‚ü©
      rw [‚Üê @Finset.add_sum_erase _ _ _ _ _ _ q' (by simp)]
      congr
      ¬∑ have hnaq' : n = a + q := by omega
        simp only [Fin.val_mk, (HigherFacesVanish.of_P q n).comp_HœÉ_eq hnaq',
          q'.rev_eq hnaq', neg_neg]
        rfl
      ¬∑ ext ‚ü®i, hi‚ü©
        simp only [q', Nat.succ_eq_add_one, Nat.lt_succ_iff_lt_or_eq, Finset.mem_univ,
          forall_true_left, Finset.mem_filter, lt_self_iff_false, or_true, and_self, not_true,
          Finset.mem_erase, ne_eq, Fin.mk.injEq, true_and]
        aesop","/-- In each positive degree, this lemma decomposes the idempotent endomorphism
`Q q` as a sum of morphisms which are postcompositions with suitable degeneracies.
As `Q q` is the complement projection to `P q`, this implies that in the case of
simplicial abelian groups, any $(n+1)$-simplex $x$ can be decomposed as
$x = x' + \sum (i=0}^{q-1} œÉ_{n-i}(y_i)$ where $x'$ is in the image of `P q` and
the $y_i$ are in degree $n$. -/
theorem decomposition_Q (n q : ‚Ñï) :
    ((Q q).f (n + 1) : X _[n + 1] ‚ü∂ X _[n + 1]) =
      ‚àë i ‚àà Finset.filter (fun i : Fin (n + 1) => (i : ‚Ñï) < q) Finset.univ,
        (P i).f (n + 1) ‚â´ X.Œ¥ i.rev.succ ‚â´ X.œÉ (Fin.rev i) := by
  induction' q with q hq
  ¬∑ simp only [Nat.zero_eq, Q_zero, HomologicalComplex.zero_f_apply, Nat.not_lt_zero,
      Finset.filter_False, Finset.sum_empty]
  ¬∑ by_cases hqn : q + 1 ‚â§ n + 1
    swap
    ¬∑ rw [Q_is_eventually_constant (show n + 1 ‚â§ q by omega), hq]
      congr 1
      ext ‚ü®x, hx‚ü©
      simp only [Nat.succ_eq_add_one, Finset.mem_filter, Finset.mem_univ, true_and]
      omega
    ¬∑ cases' Nat.le.dest (Nat.succ_le_succ_iff.mp hqn) with a ha
      rw [Q_succ, HomologicalComplex.sub_f_apply, HomologicalComplex.comp_f, hq]
      symm
      conv_rhs => rw [sub_eq_add_neg, add_comm]
      let q' : Fin (n + 1) := ‚ü®q, Nat.succ_le_iff.mp hqn‚ü©
      rw [‚Üê @Finset.add_sum_erase _ _ _ _ _ _ q' (by simp)]
      congr
      ¬∑ have hnaq' : n = a + q := by omega
        simp only [Fin.val_mk, (HigherFacesVanish.of_P q n).comp_HœÉ_eq hnaq',
          q'.rev_eq hnaq', neg_neg]
        rfl
      ¬∑ ext ‚ü®i, hi‚ü©
        simp only [q', Nat.succ_eq_add_one, Nat.lt_succ_iff_lt_or_eq, Finset.mem_univ,
          forall_true_left, Finset.mem_filter, lt_self_iff_false, or_true, and_self, not_true,
          Finset.mem_erase, ne_eq, Fin.mk.injEq, true_and]
        aesop",80.05936408042908
mathlib,Mathlib/Computability/Primrec.lean,"theorem list_rec {f : Œ± ‚Üí List Œ≤} {g : Œ± ‚Üí œÉ} {h : Œ± ‚Üí Œ≤ √ó List Œ≤ √ó œÉ ‚Üí œÉ} (hf : Primrec f)
    (hg : Primrec g) (hh : Primrec‚ÇÇ h) :
    @Primrec _ œÉ _ _ fun a => List.recOn (f a) (g a) fun b l IH => h a (b, l, IH) ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,6,True,,1,-0.8333333333333334,"theorem list_rec {f : Œ± ‚Üí List Œ≤} {g : Œ± ‚Üí œÉ} {h : Œ± ‚Üí Œ≤ √ó List Œ≤ √ó œÉ ‚Üí œÉ} (hf : Primrec f)
    (hg : Primrec g) (hh : Primrec‚ÇÇ h) :
    @Primrec _ œÉ _ _ fun a => List.recOn (f a) (g a) fun b l IH => h a (b, l, IH) :=
  let F (a : Œ±) := (f a).foldr (fun (b : Œ≤) (s : List Œ≤ √ó œÉ) => (b :: s.1, h a (b, s))) ([], g a)
  have : Primrec F :=
    list_foldr hf (pair (const []) hg) <|
      to‚ÇÇ <| pair ((list_cons.comp fst (fst.comp snd)).comp snd) hh
  (snd.comp this).of_eq fun a => by
    suffices F a = (f a, List.recOn (f a) (g a) fun b l IH => h a (b, l, IH)) by rw [this]
    dsimp [F]
    induction' f a with b l IH <;> simp [*]","theorem list_rec {f : Œ± ‚Üí List Œ≤} {g : Œ± ‚Üí œÉ} {h : Œ± ‚Üí Œ≤ √ó List Œ≤ √ó œÉ ‚Üí œÉ} (hf : Primrec f)
    (hg : Primrec g) (hh : Primrec‚ÇÇ h) :
    @Primrec _ œÉ _ _ fun a => List.recOn (f a) (g a) fun b l IH => h a (b, l, IH)   := by
  exact (snd.comp <| list_foldr hf (pair (const []) hg) <| to‚ÇÇ <| pair (list_cons.comp fst (fst.comp snd)).comp snd hh).of_eq (Œª a, by induction (f a); simp [*])",124.4438750743866
mathlib,Mathlib/Computability/Primrec.lean,theorem listLookup [DecidableEq Œ±] : Primrec‚ÇÇ (List.lookup : Œ± ‚Üí List (Œ± √ó Œ≤) ‚Üí Option Œ≤) ,"refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,6,True,,6,0.0,"theorem listLookup [DecidableEq Œ±] : Primrec‚ÇÇ (List.lookup : Œ± ‚Üí List (Œ± √ó Œ≤) ‚Üí Option Œ≤) :=
  (to‚ÇÇ <| list_rec snd (const none) <|
    to‚ÇÇ <|
      cond (Primrec.beq.comp (fst.comp fst) (fst.comp $ fst.comp snd))
        (option_some.comp $ snd.comp $ fst.comp snd)
        (snd.comp $ snd.comp snd)).of_eq
  fun a ps => by
  induction' ps with p ps ih <;> simp [List.lookup, *]
  cases ha : a == p.1 <;> simp [ha]","theorem listLookup [DecidableEq Œ±] : Primrec‚ÇÇ (List.lookup : Œ± ‚Üí List (Œ± √ó Œ≤) ‚Üí Option Œ≤) :=
  (to‚ÇÇ <| list_rec snd (const none) <|
    to‚ÇÇ <|
      cond (Primrec.beq.comp (fst.comp fst) (fst.comp $ fst.comp snd))
        (option_some.comp $ snd.comp $ fst.comp snd)
        (snd.comp $ snd.comp snd)).of_eq
  fun a ps => by
  induction' ps with p ps ih <;> simp [List.lookup, *]
  cases ha : a == p.1 <;> simp [ha]",143.81880402565002
mathlib,Mathlib/Computability/Primrec.lean,"theorem option_get {f : Œ± ‚Üí Option Œ≤} {h : ‚àÄ a, (f a).isSome} :
    Primrec f ‚Üí Primrec fun a => (f a).get (h a) ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,6,True,,5,-0.16666666666666666,"theorem option_get {f : Œ± ‚Üí Option Œ≤} {h : ‚àÄ a, (f a).isSome} :
    Primrec f ‚Üí Primrec fun a => (f a).get (h a) := by
  intro hf
  refine (Nat.Primrec.pred.comp hf).of_eq fun n => ?_
  generalize hx : @decode Œ± _ n = x
  cases x <;> simp","theorem option_get {f : Œ± ‚Üí Option Œ≤} {h : ‚àÄ a, (f a).isSome} :
    Primrec f ‚Üí Primrec fun a => (f a).get (h a)  := by
  intro hf
  refine (Nat.Primrec.pred.comp hf).of_eq fun n => ?_
  rcases decode n with ‚ü®a‚ü© <;> simp",178.16173577308655
mathlib,Mathlib/Computability/ContextFreeGrammar.lean,"lemma rewrites_of_exists_parts (r : ContextFreeRule T N) (p q : List (Symbol T N)) :
    r.Rewrites (p ++ [Symbol.nonterminal r.input] ++ q) (p ++ r.output ++ q) ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,6,True,,6,0.0,"lemma rewrites_of_exists_parts (r : ContextFreeRule T N) (p q : List (Symbol T N)) :
    r.Rewrites (p ++ [Symbol.nonterminal r.input] ++ q) (p ++ r.output ++ q) := by
  induction p with
  | nil         => exact Rewrites.head q
  | cons d l ih => exact Rewrites.cons d ih","lemma rewrites_of_exists_parts (r : ContextFreeRule T N) (p q : List (Symbol T N)) :
    r.Rewrites (p ++ [Symbol.nonterminal r.input] ++ q) (p ++ r.output ++ q) := by
  induction p with
  | nil         => exact Rewrites.head q
  | cons d l ih => exact Rewrites.cons d ih",30.853710889816284
mathlib,Mathlib/Computability/ContextFreeGrammar.lean,"/-- Add extra prefix to context-free deriving. -/
 theorem Derives.append_left {v w : List (Symbol T g.NT)}
    (hvw : g.Derives v w) (p : List (Symbol T g.NT)) :
    g.Derives (p ++ v) (p ++ w) ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,6,True,,6,0.0,"/-- Add extra prefix to context-free deriving. -/
lemma Derives.append_left {v w : List (Symbol T g.NT)}
    (hvw : g.Derives v w) (p : List (Symbol T g.NT)) :
    g.Derives (p ++ v) (p ++ w) := by
  induction hvw with
  | refl => rfl
  | tail _ last ih => exact ih.trans_produces <| last.append_left p","/-- Add extra prefix to context-free deriving. -/
lemma Derives.append_left {v w : List (Symbol T g.NT)}
    (hvw : g.Derives v w) (p : List (Symbol T g.NT)) :
    g.Derives (p ++ v) (p ++ w) := by
  induction hvw with
  | refl => rfl
  | tail _ last ih => exact ih.trans_produces <| last.append_left p",34.17504382133484
mathlib,Mathlib/Computability/ContextFreeGrammar.lean,"/-- Add extra prefix to context-free deriving. -/
lemma Derives.append_left {v w : List (Symbol T g.NT)}
    (hvw : g.Derives v w) (p : List (Symbol T g.NT)) :
    g.Derives (p ++ v) (p ++ w) ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,6,True,,6,0.0,"/-- Add extra prefix to context-free deriving. -/
lemma Derives.append_left {v w : List (Symbol T g.NT)}
    (hvw : g.Derives v w) (p : List (Symbol T g.NT)) :
    g.Derives (p ++ v) (p ++ w) := by
  induction hvw with
  | refl => rfl
  | tail _ last ih => exact ih.trans_produces <| last.append_left p","/-- Add extra prefix to context-free deriving. -/
lemma Derives.append_left {v w : List (Symbol T g.NT)}
    (hvw : g.Derives v w) (p : List (Symbol T g.NT)) :
    g.Derives (p ++ v) (p ++ w) := by
  induction hvw with
  | refl => rfl
  | tail _ last ih => exact ih.trans_produces <| last.append_left p",49.24687099456787
mathlib,Mathlib/Computability/ContextFreeGrammar.lean,"/-- Add extra prefix to context-free deriving. -/
 theorem append_left {v w : List (Symbol T g.NT)}
    (hvw : g.Derives v w) (p : List (Symbol T g.NT)) :
    g.Derives (p ++ v) (p ++ w) ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,6,True,,6,0.0,"/-- Add extra prefix to context-free deriving. -/
lemma Derives.append_left {v w : List (Symbol T g.NT)}
    (hvw : g.Derives v w) (p : List (Symbol T g.NT)) :
    g.Derives (p ++ v) (p ++ w) := by
  induction hvw with
  | refl => rfl
  | tail _ last ih => exact ih.trans_produces <| last.append_left p","/-- Add extra prefix to context-free deriving. -/
lemma Derives.append_left {v w : List (Symbol T g.NT)}
    (hvw : g.Derives v w) (p : List (Symbol T g.NT)) :
    g.Derives (p ++ v) (p ++ w) := by
  induction hvw with
  | refl => rfl
  | tail _ last ih => exact ih.trans_produces <| last.append_left p",35.4469690322876
mathlib,Mathlib/Computability/ContextFreeGrammar.lean,"/-- Add extra prefix to context-free deriving. -/
lemma Derives.append_right {v w : List (Symbol T g.NT)}
    (hvw : g.Derives v w) (p : List (Symbol T g.NT)) :
    g.Derives (v ++ p) (w ++ p) ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,6,True,,6,0.0,"/-- Add extra prefix to context-free deriving. -/
lemma Derives.append_right {v w : List (Symbol T g.NT)}
    (hvw : g.Derives v w) (p : List (Symbol T g.NT)) :
    g.Derives (v ++ p) (w ++ p) := by
  induction hvw with
  | refl => rfl
  | tail _ last ih => exact ih.trans_produces <| last.append_right p","/-- Add extra prefix to context-free deriving. -/
lemma Derives.append_right {v w : List (Symbol T g.NT)}
    (hvw : g.Derives v w) (p : List (Symbol T g.NT)) :
    g.Derives (v ++ p) (w ++ p) := by
  induction hvw with
  | refl => rfl
  | tail _ last ih => exact ih.trans_produces <| last.append_right p",44.25492525100708
mathlib,Mathlib/Computability/ContextFreeGrammar.lean,"/-- Add extra prefix to context-free deriving. -/
 theorem Derives.append_right {v w : List (Symbol T g.NT)}
    (hvw : g.Derives v w) (p : List (Symbol T g.NT)) :
    g.Derives (v ++ p) (w ++ p) ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,6,True,,6,0.0,"/-- Add extra prefix to context-free deriving. -/
lemma Derives.append_right {v w : List (Symbol T g.NT)}
    (hvw : g.Derives v w) (p : List (Symbol T g.NT)) :
    g.Derives (v ++ p) (w ++ p) := by
  induction hvw with
  | refl => rfl
  | tail _ last ih => exact ih.trans_produces <| last.append_right p","/-- Add extra prefix to context-free deriving. -/
lemma Derives.append_right {v w : List (Symbol T g.NT)}
    (hvw : g.Derives v w) (p : List (Symbol T g.NT)) :
    g.Derives (v ++ p) (w ++ p) := by
  induction hvw with
  | refl => rfl
  | tail _ last ih => exact ih.trans_produces <| last.append_right p",44.74875807762146
mathlib,Mathlib/Computability/NFA.lean,"@[simp]
theorem toNFA_evalFrom_match (M : DFA Œ± œÉ) (start : œÉ) (s : List Œ±) :
    M.toNFA.evalFrom {start} s = {M.evalFrom start s} ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,6,True,,6,0.0,"@[simp]
theorem toNFA_evalFrom_match (M : DFA Œ± œÉ) (start : œÉ) (s : List Œ±) :
    M.toNFA.evalFrom {start} s = {M.evalFrom start s} := by
  change List.foldl M.toNFA.stepSet {start} s = {List.foldl M.step start s}
  induction' s with a s ih generalizing start
  ¬∑ tauto
  ¬∑ rw [List.foldl, List.foldl,
      show M.toNFA.stepSet {start} a = {M.step start a} by simp [NFA.stepSet] ]
    tauto","@[simp]
theorem toNFA_evalFrom_match (M : DFA Œ± œÉ) (start : œÉ) (s : List Œ±) :
    M.toNFA.evalFrom {start} s = {M.evalFrom start s} := by
  change List.foldl M.toNFA.stepSet {start} s = {List.foldl M.step start s}
  induction' s with a s ih generalizing start
  ¬∑ tauto
  ¬∑ rw [List.foldl, List.foldl,
      show M.toNFA.stepSet {start} a = {M.step start a} by simp [NFA.stepSet] ]
    tauto",27.59615683555603
mathlib,Mathlib/Computability/NFA.lean,"@[simp]
theorem toNFA_correct (M : DFA Œ± œÉ) : M.toNFA.accepts = M.accepts ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,6,True,,6,0.0,"@[simp]
theorem toNFA_correct (M : DFA Œ± œÉ) : M.toNFA.accepts = M.accepts := by
  ext x
  rw [NFA.mem_accepts, toNFA_start, toNFA_evalFrom_match]
  constructor
  ¬∑ rintro ‚ü®S, hS‚ÇÅ, hS‚ÇÇ‚ü©
    rwa [Set.mem_singleton_iff.mp hS‚ÇÇ] at hS‚ÇÅ
  ¬∑ exact fun h => ‚ü®M.eval x, h, rfl‚ü©","@[simp]
theorem toNFA_correct (M : DFA Œ± œÉ) : M.toNFA.accepts = M.accepts := by
  ext x
  rw [NFA.mem_accepts, toNFA_start, toNFA_evalFrom_match]
  constructor
  ¬∑ rintro ‚ü®S, hS‚ÇÅ, hS‚ÇÇ‚ü©
    rwa [Set.mem_singleton_iff.mp hS‚ÇÇ] at hS‚ÇÅ
  ¬∑ exact fun h => ‚ü®M.eval x, h, rfl‚ü©",38.643643856048584
mathlib,Mathlib/Computability/ContextFreeGrammar.lean,"/-- Add extra prefix to context-free deriving. -/
 theorem append_right {v w : List (Symbol T g.NT)}
    (hvw : g.Derives v w) (p : List (Symbol T g.NT)) :
    g.Derives (v ++ p) (w ++ p) ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,6,True,,6,0.0,"/-- Add extra prefix to context-free deriving. -/
lemma Derives.append_right {v w : List (Symbol T g.NT)}
    (hvw : g.Derives v w) (p : List (Symbol T g.NT)) :
    g.Derives (v ++ p) (w ++ p) := by
  induction hvw with
  | refl => rfl
  | tail _ last ih => exact ih.trans_produces <| last.append_right p","/-- Add extra prefix to context-free deriving. -/
lemma Derives.append_right {v w : List (Symbol T g.NT)}
    (hvw : g.Derives v w) (p : List (Symbol T g.NT)) :
    g.Derives (v ++ p) (w ++ p) := by
  induction hvw with
  | refl => rfl
  | tail _ last ih => exact ih.trans_produces <| last.append_right p",40.359939098358154
mathlib,Mathlib/Computability/Ackermann.lean,"theorem ack_strictMono_right : ‚àÄ m, StrictMono (ack m)
  | 0, n‚ÇÅ, n‚ÇÇ, h => by simpa using h
  | m + 1, 0, n + 1, _h => by
    rw [ack_succ_zero, ack_succ_succ]
    exact ack_strictMono_right _ (one_lt_ack_succ_left m n)
  | m + 1, n‚ÇÅ + 1, n‚ÇÇ + 1, h => by
    rw [ack_succ_succ, ack_succ_succ]
    apply ack_strictMono_right _ (ack_strictMono_right _ _)
    rwa [add_lt_add_iff_right] at  h ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,6,True,,6,0.0,"theorem ack_strictMono_right : ‚àÄ m, StrictMono (ack m)
  | 0, n‚ÇÅ, n‚ÇÇ, h => by simpa using h
  | m + 1, 0, n + 1, _h => by
    rw [ack_succ_zero, ack_succ_succ]
    exact ack_strictMono_right _ (one_lt_ack_succ_left m n)
  | m + 1, n‚ÇÅ + 1, n‚ÇÇ + 1, h => by
    rw [ack_succ_succ, ack_succ_succ]
    apply ack_strictMono_right _ (ack_strictMono_right _ _)
    rwa [add_lt_add_iff_right] at h","theorem ack_strictMono_right : ‚àÄ m, StrictMono (ack m)
  | 0, n‚ÇÅ, n‚ÇÇ, h => by simpa using h
  | m + 1, 0, n + 1, _h => by
    rw [ack_succ_zero, ack_succ_succ]
    exact ack_strictMono_right _ (one_lt_ack_succ_left m n)
  | m + 1, n‚ÇÅ + 1, n‚ÇÇ + 1, h => by
    rw [ack_succ_succ, ack_succ_succ]
    apply ack_strictMono_right _ (ack_strictMono_right _ _)
    rwa [add_lt_add_iff_right] at h",54.67256307601929
mathlib,Mathlib/Computability/Ackermann.lean,"theorem ack_add_one_sq_lt_ack_add_three : ‚àÄ m n, (ack m n + 1) ^ 2 ‚â§ ack (m + 3) n
  | 0, n => by simpa using sq_le_two_pow_add_one_minus_three (n + 2)
  | m + 1, 0 => by
    rw [ack_succ_zero, ack_succ_zero]
    apply ack_add_one_sq_lt_ack_add_three
  | m + 1, n + 1 => by
    rw [ack_succ_succ, ack_succ_succ]
    apply (ack_add_one_sq_lt_ack_add_three _ _).trans (ack_mono_right _ <| ack_mono_left _ _)
     omega ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,6,True,,6,0.0,"theorem ack_add_one_sq_lt_ack_add_three : ‚àÄ m n, (ack m n + 1) ^ 2 ‚â§ ack (m + 3) n
  | 0, n => by simpa using sq_le_two_pow_add_one_minus_three (n + 2)
  | m + 1, 0 => by
    rw [ack_succ_zero, ack_succ_zero]
    apply ack_add_one_sq_lt_ack_add_three
  | m + 1, n + 1 => by
    rw [ack_succ_succ, ack_succ_succ]
    apply (ack_add_one_sq_lt_ack_add_three _ _).trans (ack_mono_right _ <| ack_mono_left _ _)
    omega","theorem ack_add_one_sq_lt_ack_add_three : ‚àÄ m n, (ack m n + 1) ^ 2 ‚â§ ack (m + 3) n
  | 0, n => by simpa using sq_le_two_pow_add_one_minus_three (n + 2)
  | m + 1, 0 => by
    rw [ack_succ_zero, ack_succ_zero]
    apply ack_add_one_sq_lt_ack_add_three
  | m + 1, n + 1 => by
    rw [ack_succ_succ, ack_succ_succ]
    apply (ack_add_one_sq_lt_ack_add_three _ _).trans (ack_mono_right _ <| ack_mono_left _ _)
    omega",69.8919289112091
mathlib,Mathlib/Computability/Partrec.lean,theorem ofOption {f : Œ± ‚Üí Option Œ≤} (hf : Computable f) : Partrec fun a => (f a : Part Œ≤) ,"refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,6,True,,5,-0.16666666666666666,"theorem ofOption {f : Œ± ‚Üí Option Œ≤} (hf : Computable f) : Partrec fun a => (f a : Part Œ≤) :=
  (Nat.Partrec.ppred.comp hf).of_eq fun n => by
    cases' decode (Œ± := Œ±) n with a <;> simp
    cases' f a with b <;> simp","theorem ofOption {f : Œ± ‚Üí Option Œ≤} (hf : Computable f) : Partrec fun a => (f a : Part Œ≤)  := by
  cases decode (Œ± := Œ±) n with
  | some a => cases f a with; simp",168.00785398483276
mathlib,Mathlib/Computability/Encoding.lean,"theorem decode_encodeNat : ‚àÄ n, decodeNat (encodeNat n) = n ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,6,True,,2,-0.6666666666666666,"theorem decode_encodeNat : ‚àÄ n, decodeNat (encodeNat n) = n := by
  intro n
  conv_rhs => rw [‚Üê Num.to_of_nat n]
  exact congr_arg ((‚Üë) : Num ‚Üí ‚Ñï) (decode_encodeNum n)","theorem decode_encodeNat : ‚àÄ n, decodeNat (encodeNat n) = n  := by
  intro n
  simp [decodeNat, encodeNat, decode_encodeNum]",27.655591011047363
mathlib,Mathlib/Computability/Primrec.lean,theorem fst {Œ± Œ≤} [Primcodable Œ±] [Primcodable Œ≤] : Primrec (@Prod.fst Œ± Œ≤) ,"refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,7,True,,1,-0.8571428571428571,"theorem fst {Œ± Œ≤} [Primcodable Œ±] [Primcodable Œ≤] : Primrec (@Prod.fst Œ± Œ≤) :=
  ((casesOn' zero
            ((casesOn' zero (Nat.Primrec.succ.comp left)).comp
              (pair right ((@Primcodable.prim Œ≤).comp left)))).comp
        (pair right ((@Primcodable.prim Œ±).comp left))).of_eq
    fun n => by
    simp only [Nat.unpaired, Nat.unpair_pair, decode_prod_val]
    cases @decode Œ± _ n.unpair.1 <;> simp
    cases @decode Œ≤ _ n.unpair.2 <;> simp","theorem fst {Œ± Œ≤} [Primcodable Œ±] [Primcodable Œ≤] : Primrec (@Prod.fst Œ± Œ≤)  := by
  exact ((@Primcodable.prod Œ± Œ≤ _ _).prim.comp .id).of_eq $ Œª n, by",51.08869791030884
mathlib,Mathlib/Computability/Primrec.lean,theorem snd {Œ± Œ≤} [Primcodable Œ±] [Primcodable Œ≤] : Primrec (@Prod.snd Œ± Œ≤) ,"refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,7,True,,1,-0.8571428571428571,"theorem snd {Œ± Œ≤} [Primcodable Œ±] [Primcodable Œ≤] : Primrec (@Prod.snd Œ± Œ≤) :=
  ((casesOn' zero
            ((casesOn' zero (Nat.Primrec.succ.comp right)).comp
              (pair right ((@Primcodable.prim Œ≤).comp left)))).comp
        (pair right ((@Primcodable.prim Œ±).comp left))).of_eq
    fun n => by
    simp only [Nat.unpaired, Nat.unpair_pair, decode_prod_val]
    cases @decode Œ± _ n.unpair.1 <;> simp
    cases @decode Œ≤ _ n.unpair.2 <;> simp","theorem snd {Œ± Œ≤} [Primcodable Œ±] [Primcodable Œ≤] : Primrec (@Prod.snd Œ± Œ≤)  := by
  apply Primrec.of_eq _ (Œª n, by simp [decode_prod_val])",52.76377296447754
mathlib,Mathlib/Computability/Primrec.lean,theorem option_orElse : Primrec‚ÇÇ ((¬∑ <|> ¬∑) : Option Œ± ‚Üí Option Œ± ‚Üí Option Œ±) ,"refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,7,True,,4,-0.42857142857142855,"theorem option_orElse : Primrec‚ÇÇ ((¬∑ <|> ¬∑) : Option Œ± ‚Üí Option Œ± ‚Üí Option Œ±) :=
  (option_casesOn fst snd (fst.comp fst).to‚ÇÇ).of_eq fun ‚ü®o‚ÇÅ, o‚ÇÇ‚ü© => by cases o‚ÇÅ <;> cases o‚ÇÇ <;> rfl","theorem option_orElse : Primrec‚ÇÇ ((¬∑ <|> ¬∑) : Option Œ± ‚Üí Option Œ± ‚Üí Option Œ±)  := by
  exact (option_casesOn fst snd (fst.comp fst).to‚ÇÇ).of_eq (fun ‚ü®o‚ÇÅ, o‚ÇÇ‚ü© => by cases o‚ÇÅ <;> rfl)",78.39207696914673
mathlib,Mathlib/Computability/Primrec.lean,"theorem subtype_val_iff {p : Œ≤ ‚Üí Prop} [DecidablePred p] {hp : PrimrecPred p} {f : Œ± ‚Üí Subtype p} :
    haveI ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,7,True,,5,-0.2857142857142857,"theorem subtype_val_iff {p : Œ≤ ‚Üí Prop} [DecidablePred p] {hp : PrimrecPred p} {f : Œ± ‚Üí Subtype p} :
    haveI := Primcodable.subtype hp
    (Primrec fun a => (f a).1) ‚Üî Primrec f := by
  letI := Primcodable.subtype hp
  refine ‚ü®fun h => ?_, fun hf => subtype_val.comp hf‚ü©
  refine Nat.Primrec.of_eq h fun n => ?_
  cases' @decode Œ± _ n with a; ¬∑ rfl
  simp; rfl","theorem subtype_val_iff {p : Œ≤ ‚Üí Prop} [DecidablePred p] {hp : PrimrecPred p} {f : Œ± ‚Üí Subtype p} :
    haveI  := by
  letI := Primcodable.subtype hp; refine ‚ü®Nat.Primrec.of_eq ?_ fun a => rfl, fun hf => subtype_val.comp hf‚ü©
  exact id

",171.68211197853088
mathlib,Mathlib/Computability/Primrec.lean,theorem sub : @Primrec' 2 fun v => v.head - v.tail.head ,"refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,8,True,,8,0.0,"theorem sub : @Primrec' 2 fun v => v.head - v.tail.head := by
  have : @Primrec' 2 fun v ‚Ü¶ (fun a b ‚Ü¶ b - a) v.head v.tail.head := by
    refine (prec head (pred.comp‚ÇÅ _ (tail head))).of_eq fun v => ?_
    simp; induction v.head <;> simp [*, Nat.sub_add_eq]
  simpa using comp‚ÇÇ (fun a b => b - a) this (tail head) head","theorem sub : @Primrec' 2 fun v => v.head - v.tail.head := by
  have : @Primrec' 2 fun v ‚Ü¶ (fun a b ‚Ü¶ b - a) v.head v.tail.head := by
    refine (prec head (pred.comp‚ÇÅ _ (tail head))).of_eq fun v => ?_
    simp; induction v.head <;> simp [*, Nat.sub_add_eq]
  simpa using comp‚ÇÇ (fun a b => b - a) this (tail head) head",201.16019678115845
mathlib,Mathlib/Computability/Primrec.lean,theorem unpair‚ÇÅ {n f} (hf : @Primrec' n f) : @Primrec' n fun v => (f v).unpair.1 ,"refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,7,True,,6,-0.14285714285714285,"theorem unpair‚ÇÅ {n f} (hf : @Primrec' n f) : @Primrec' n fun v => (f v).unpair.1 := by
  have s := sqrt.comp‚ÇÅ _ hf
  have fss := sub.comp‚ÇÇ _ hf (mul.comp‚ÇÇ _ s s)
  refine (if_lt fss s fss s).of_eq fun v => ?_
  simp [Nat.unpair]; split_ifs <;> rfl","theorem unpair‚ÇÅ {n f} (hf : @Primrec' n f) : @Primrec' n fun v => (f v).unpair.1  := by
  exact (if_lt (sub.comp‚ÇÇ _ hf (mul.comp‚ÇÇ _ (sqrt.comp‚ÇÅ _ hf) (sqrt.comp‚ÇÅ _ hf))) (sqrt.comp‚ÇÅ _ hf) (sub.comp‚ÇÇ _ hf (mul.comp‚ÇÇ _ (sqrt.comp‚ÇÅ _ hf) (sqrt.comp‚ÇÅ _ hf))) (sqrt.comp‚ÇÅ _ hf)).of_eq fun v => by simp [Nat.unpair]; split_ifs <;> rfl",209.41095495224
mathlib,Mathlib/Computability/Primrec.lean,theorem unpair‚ÇÇ {n f} (hf : @Primrec' n f) : @Primrec' n fun v => (f v).unpair.2 ,"refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,7,True,,7,0.0,"theorem unpair‚ÇÇ {n f} (hf : @Primrec' n f) : @Primrec' n fun v => (f v).unpair.2 := by
  have s := sqrt.comp‚ÇÅ _ hf
  have fss := sub.comp‚ÇÇ _ hf (mul.comp‚ÇÇ _ s s)
  refine (if_lt fss s s (sub.comp‚ÇÇ _ fss s)).of_eq fun v => ?_
  simp [Nat.unpair]; split_ifs <;> rfl","theorem unpair‚ÇÇ {n f} (hf : @Primrec' n f) : @Primrec' n fun v => (f v).unpair.2 := by
  have s := sqrt.comp‚ÇÅ _ hf
  have fss := sub.comp‚ÇÇ _ hf (mul.comp‚ÇÇ _ s s)
  refine (if_lt fss s s (sub.comp‚ÇÇ _ fss s)).of_eq fun v => ?_
  simp [Nat.unpair]; split_ifs <;> rfl",215.32845377922058
mathlib,Mathlib/Computability/Partrec.lean,"theorem rfindOpt_dom {Œ±} {f : ‚Ñï ‚Üí Option Œ±} : (rfindOpt f).Dom ‚Üî ‚àÉ n a, a ‚àà f n ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,7,True,,1,-0.8571428571428571,"theorem rfindOpt_dom {Œ±} {f : ‚Ñï ‚Üí Option Œ±} : (rfindOpt f).Dom ‚Üî ‚àÉ n a, a ‚àà f n :=
  ‚ü®fun h => (rfindOpt_spec ‚ü®h, rfl‚ü©).imp fun n h => ‚ü®_, h‚ü©, fun h => by
    have h' : ‚àÉ n, (f n).isSome := h.imp fun n => Option.isSome_iff_exists.2
    have s := Nat.find_spec h'
    have fd : (rfind fun n => (f n).isSome).Dom :=
      ‚ü®Nat.find h', by simpa using s.symm, fun _ _ => trivial‚ü©
    refine ‚ü®fd, ?_‚ü©
    have := rfind_spec (get_mem fd)
    simpa using this‚ü©","theorem rfindOpt_dom {Œ±} {f : ‚Ñï ‚Üí Option Œ±} : (rfindOpt f).Dom ‚Üî ‚àÉ n a, a ‚àà f n  := by
  ‚ü®fun h => let ‚ü®n, hn‚ü© := rfindOpt_spec ‚ü®h, rfl‚ü© in ‚ü®n, hn‚ü©,
  fun ‚ü®n, a, ha‚ü© => by simp [rfindOpt, ha]‚ü©
",47.67420291900635
mathlib,Mathlib/Computability/Partrec.lean,theorem fix {f : Œ± ‚Üí. Sum œÉ Œ±} (hf : Partrec f) : Partrec (PFun.fix f) ,"refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,8,True,,8,0.0,"theorem fix {f : Œ± ‚Üí. Sum œÉ Œ±} (hf : Partrec f) : Partrec (PFun.fix f) := by
  let F : Œ± ‚Üí ‚Ñï ‚Üí. Sum œÉ Œ± := fun a n =>
    n.rec (some (Sum.inr a)) fun _ IH => IH.bind fun s => Sum.casesOn s (fun _ => Part.some s) f
  have hF : Partrec‚ÇÇ F :=
    Partrec.nat_rec snd (sum_inr.comp fst).partrec
      (sum_casesOn_right (snd.comp snd) (snd.comp <| snd.comp fst).to‚ÇÇ (hf.comp snd).to‚ÇÇ).to‚ÇÇ
  let p a n := @Part.map _ Bool (fun s => Sum.casesOn s (fun _ => true) fun _ => false) (F a n)
  have hp : Partrec‚ÇÇ p :=
    hF.map ((sum_casesOn Computable.id (const true).to‚ÇÇ (const false).to‚ÇÇ).comp snd).to‚ÇÇ
  exact (hp.rfind.bind (hF.bind (sum_casesOn_right snd snd.to‚ÇÇ none.to‚ÇÇ).to‚ÇÇ).to‚ÇÇ).of_eq fun a =>
    ext fun b => by simp [p]; apply fix_aux f","theorem fix {f : Œ± ‚Üí. Sum œÉ Œ±} (hf : Partrec f) : Partrec (PFun.fix f) := by
  let F : Œ± ‚Üí ‚Ñï ‚Üí. Sum œÉ Œ± := fun a n =>
    n.rec (some (Sum.inr a)) fun _ IH => IH.bind fun s => Sum.casesOn s (fun _ => Part.some s) f
  have hF : Partrec‚ÇÇ F :=
    Partrec.nat_rec snd (sum_inr.comp fst).partrec
      (sum_casesOn_right (snd.comp snd) (snd.comp <| snd.comp fst).to‚ÇÇ (hf.comp snd).to‚ÇÇ).to‚ÇÇ
  let p a n := @Part.map _ Bool (fun s => Sum.casesOn s (fun _ => true) fun _ => false) (F a n)
  have hp : Partrec‚ÇÇ p :=
    hF.map ((sum_casesOn Computable.id (const true).to‚ÇÇ (const false).to‚ÇÇ).comp snd).to‚ÇÇ
  exact (hp.rfind.bind (hF.bind (sum_casesOn_right snd snd.to‚ÇÇ none.to‚ÇÇ).to‚ÇÇ).to‚ÇÇ).of_eq fun a =>
    ext fun b => by simp [p]; apply fix_aux f",147.2319040298462
mathlib,Mathlib/Computability/PartrecCode.lean,"theorem encode_lt_pair (cf cg) :
    encode cf < encode (pair cf cg) ‚àß encode cg < encode (pair cf cg) ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,7,True,,7,0.0,"theorem encode_lt_pair (cf cg) :
    encode cf < encode (pair cf cg) ‚àß encode cg < encode (pair cf cg) := by
  simp only [encodeCode_eq, encodeCode]
  have := Nat.mul_le_mul_right (Nat.pair cf.encodeCode cg.encodeCode) (by decide : 1 ‚â§ 2 * 2)
  rw [one_mul, mul_assoc] at this
  have := lt_of_le_of_lt this (lt_add_of_pos_right _ (by decide : 0 < 4))
  exact ‚ü®lt_of_le_of_lt (Nat.left_le_pair _ _) this, lt_of_le_of_lt (Nat.right_le_pair _ _) this‚ü©","theorem encode_lt_pair (cf cg) :
    encode cf < encode (pair cf cg) ‚àß encode cg < encode (pair cf cg) := by
  simp only [encodeCode_eq, encodeCode]
  have := Nat.mul_le_mul_right (Nat.pair cf.encodeCode cg.encodeCode) (by decide : 1 ‚â§ 2 * 2)
  rw [one_mul, mul_assoc] at this
  have := lt_of_le_of_lt this (lt_add_of_pos_right _ (by decide : 0 < 4))
  exact ‚ü®lt_of_le_of_lt (Nat.left_le_pair _ _) this, lt_of_le_of_lt (Nat.right_le_pair _ _) this‚ü©",43.35381007194519
mathlib,Mathlib/Computability/Language.lean,"theorem kstar_eq_iSup_pow (l : Language Œ±) : l‚àó = ‚®Ü i : ‚Ñï, l ^ i ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,7,True,,7,0.0,"theorem kstar_eq_iSup_pow (l : Language Œ±) : l‚àó = ‚®Ü i : ‚Ñï, l ^ i := by
  ext x
  simp only [mem_kstar, mem_iSup, mem_pow]
  constructor
  ¬∑ rintro ‚ü®S, rfl, hS‚ü©
    exact ‚ü®_, S, rfl, rfl, hS‚ü©
  ¬∑ rintro ‚ü®_, S, rfl, rfl, hS‚ü©
    exact ‚ü®S, rfl, hS‚ü©","theorem kstar_eq_iSup_pow (l : Language Œ±) : l‚àó = ‚®Ü i : ‚Ñï, l ^ i := by
  ext x
  simp only [mem_kstar, mem_iSup, mem_pow]
  constructor
  ¬∑ rintro ‚ü®S, rfl, hS‚ü©
    exact ‚ü®_, S, rfl, rfl, hS‚ü©
  ¬∑ rintro ‚ü®_, S, rfl, rfl, hS‚ü©
    exact ‚ü®S, rfl, hS‚ü©",48.207639932632446
mathlib,Mathlib/Computability/PartrecCode.lean,theorem encode_lt_rfind' (cf) : encode cf < encode (rfind' cf) ,"refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,7,True,,7,0.0,"theorem encode_lt_rfind' (cf) : encode cf < encode (rfind' cf) := by
  simp only [encodeCode_eq, encodeCode]
  have := Nat.mul_le_mul_right cf.encodeCode (by decide : 1 ‚â§ 2 * 2)
  rw [one_mul, mul_assoc] at this
  refine lt_of_le_of_lt (le_trans this ?_) (lt_add_of_pos_right _ (by decide : 0 < 4))
  exact le_of_lt (Nat.lt_succ_of_le <| Nat.mul_le_mul_left _ <| le_of_lt <|
    Nat.lt_succ_of_le <| Nat.mul_le_mul_left _ <| le_rfl)","theorem encode_lt_rfind' (cf) : encode cf < encode (rfind' cf) := by
  simp only [encodeCode_eq, encodeCode]
  have := Nat.mul_le_mul_right cf.encodeCode (by decide : 1 ‚â§ 2 * 2)
  rw [one_mul, mul_assoc] at this
  refine lt_of_le_of_lt (le_trans this ?_) (lt_add_of_pos_right _ (by decide : 0 < 4))
  exact le_of_lt (Nat.lt_succ_of_le <| Nat.mul_le_mul_left _ <| le_of_lt <|
    Nat.lt_succ_of_le <| Nat.mul_le_mul_left _ <| le_rfl)",83.31697988510132
mathlib,Mathlib/Computability/Primrec.lean,"theorem nat_rec {f : Œ± ‚Üí Œ≤} {g : Œ± ‚Üí ‚Ñï √ó Œ≤ ‚Üí Œ≤} (hf : Primrec f) (hg : Primrec‚ÇÇ g) :
    Primrec‚ÇÇ fun a (n : ‚Ñï) => n.rec (motive ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,8,True,,1,-0.875,"theorem nat_rec {f : Œ± ‚Üí Œ≤} {g : Œ± ‚Üí ‚Ñï √ó Œ≤ ‚Üí Œ≤} (hf : Primrec f) (hg : Primrec‚ÇÇ g) :
    Primrec‚ÇÇ fun a (n : ‚Ñï) => n.rec (motive := fun _ => Œ≤) (f a) fun n IH => g a (n, IH) :=
  Primrec‚ÇÇ.nat_iff.2 <|
    ((Nat.Primrec.casesOn' .zero <|
              (Nat.Primrec.prec hf <|
                    .comp hg <|
                      Nat.Primrec.left.pair <|
                        (Nat.Primrec.left.comp .right).pair <|
                          Nat.Primrec.pred.comp <| Nat.Primrec.right.comp .right).comp <|
                Nat.Primrec.right.pair <| Nat.Primrec.right.comp Nat.Primrec.left).comp <|
          Nat.Primrec.id.pair <| (@Primcodable.prim Œ±).comp Nat.Primrec.left).of_eq
      fun n => by
      simp only [Nat.unpaired, id_eq, Nat.unpair_pair, decode_prod_val, decode_nat,
        Option.some_bind, Option.map_map, Option.map_some']
      cases' @decode Œ± _ n.unpair.1 with a; ¬∑ rfl
      simp only [Nat.pred_eq_sub_one, encode_some, Nat.succ_eq_add_one, encodek, Option.map_some',
        Option.some_bind, Option.map_map]
      induction' n.unpair.2 with m <;> simp [encodek]
      simp [*, encodek]","theorem nat_rec {f : Œ± ‚Üí Œ≤} {g : Œ± ‚Üí ‚Ñï √ó Œ≤ ‚Üí Œ≤} (hf : Primrec f) (hg : Primrec‚ÇÇ g) :
    Primrec‚ÇÇ fun a (n : ‚Ñï) => n.rec (motive  := by
  exact (Primrec‚ÇÇ.nat_iff.mpr (Nat.Primrec.prec hf (hg.comp (pair right (right.comp right))))).comp‚ÇÇ Primrec.fst Primrec.snd",111.30921816825867
mathlib,Mathlib/Computability/PartrecCode.lean,"private theorem evaln_map (k c n) :
    ((((List.range k).get? n).map (evaln k c)).bind fun b => b) = evaln k c n ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,7,True,,4,-0.42857142857142855,"private theorem evaln_map (k c n) :
    ((((List.range k).get? n).map (evaln k c)).bind fun b => b) = evaln k c n := by
  by_cases kn : n < k
  ¬∑ simp [List.get?_range kn]
  ¬∑ rw [List.get?_len_le]
    ¬∑ cases e : evaln k c n
      ¬∑ rfl
      exact kn.elim (evaln_bound e)
    simpa using kn","private theorem evaln_map (k c n) :
    ((((List.range k).get? n).map (evaln k c)).bind fun b => b) = evaln k c n   := by
  by_cases kn : n < k
  simp [List.get?_range, kn]
  rw [List.get?_len_le, kn] <;> cases e : evaln k c n <;> [rfl, exact kn.elim (evaln_bound e)]",514.5604150295258
mathlib,Mathlib/Computability/Ackermann.lean,"@[simp]
theorem ack_three (n : ‚Ñï) : ack 3 n = 2 ^ (n + 3) - 3 ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,8,True,,8,0.0,"@[simp]
theorem ack_three (n : ‚Ñï) : ack 3 n = 2 ^ (n + 3) - 3 := by
  induction' n with n IH
  ¬∑ rfl
  ¬∑ rw [ack_succ_succ, IH, ack_two, Nat.succ_add, Nat.pow_succ 2 (n + 3), mul_comm _ 2,
        Nat.mul_sub_left_distrib, ‚Üê Nat.sub_add_comm, two_mul 3, Nat.add_sub_add_right]
    have H : 2 * 3 ‚â§ 2 * 2 ^ 3 := by norm_num
    apply H.trans
    rw [_root_.mul_le_mul_left two_pos]
    exact pow_le_pow_right one_le_two (Nat.le_add_left 3 n)","@[simp]
theorem ack_three (n : ‚Ñï) : ack 3 n = 2 ^ (n + 3) - 3 := by
  induction' n with n IH
  ¬∑ rfl
  ¬∑ rw [ack_succ_succ, IH, ack_two, Nat.succ_add, Nat.pow_succ 2 (n + 3), mul_comm _ 2,
        Nat.mul_sub_left_distrib, ‚Üê Nat.sub_add_comm, two_mul 3, Nat.add_sub_add_right]
    have H : 2 * 3 ‚â§ 2 * 2 ^ 3 := by norm_num
    apply H.trans
    rw [_root_.mul_le_mul_left two_pos]
    exact pow_le_pow_right one_le_two (Nat.le_add_left 3 n)",31.4445538520813
mathlib,Mathlib/Computability/Halting.lean,theorem to_re {p : Œ± ‚Üí Prop} (hp : ComputablePred p) : RePred p ,"refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,8,True,,2,-0.75,"theorem to_re {p : Œ± ‚Üí Prop} (hp : ComputablePred p) : RePred p := by
  obtain ‚ü®f, hf, rfl‚ü© := computable_iff.1 hp
  unfold RePred
  dsimp only []
  refine
    (Partrec.cond hf (Decidable.Partrec.const' (Part.some ())) Partrec.none).of_eq fun n =>
      Part.ext fun a => ?_
  cases a; cases f n <;> simp","theorem to_re {p : Œ± ‚Üí Prop} (hp : ComputablePred p) : RePred p  := by
  obtain ‚ü®f, hf, rfl‚ü© := computable_iff.1 hp
  exact (Partrec.cond hf (Partrec.ret ()) Partrec.none).of_eq (Œª n, Part.ext (by simp [Part.assert]))",67.98546886444092
mathlib,Mathlib/Computability/Halting.lean,"theorem computable_iff_re_compl_re {p : Œ± ‚Üí Prop} [DecidablePred p] :
    ComputablePred p ‚Üî RePred p ‚àß RePred fun a => ¬¨p a ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,8,True,,8,0.0,"theorem computable_iff_re_compl_re {p : Œ± ‚Üí Prop} [DecidablePred p] :
    ComputablePred p ‚Üî RePred p ‚àß RePred fun a => ¬¨p a :=
  ‚ü®fun h => ‚ü®h.to_re, h.not.to_re‚ü©, fun ‚ü®h‚ÇÅ, h‚ÇÇ‚ü© =>
    ‚ü®‚Äπ_‚Ä∫, by
      obtain ‚ü®k, pk, hk‚ü© :=
        Partrec.merge (h‚ÇÅ.map (Computable.const true).to‚ÇÇ) (h‚ÇÇ.map (Computable.const false).to‚ÇÇ)
        (by
          intro a x hx y hy
          simp only [Part.mem_map_iff, Part.mem_assert_iff, Part.mem_some_iff, exists_prop,
            and_true, exists_const] at hx hy
          cases hy.1 hx.1)
      refine Partrec.of_eq pk fun n => Part.eq_some_iff.2 ?_
      rw [hk]
      simp only [Part.mem_map_iff, Part.mem_assert_iff, Part.mem_some_iff, exists_prop, and_true,
        true_eq_decide_iff, and_self, exists_const, false_eq_decide_iff]
      apply Decidable.em‚ü©‚ü©","theorem computable_iff_re_compl_re {p : Œ± ‚Üí Prop} [DecidablePred p] :
    ComputablePred p ‚Üî RePred p ‚àß RePred fun a => ¬¨p a :=
  ‚ü®fun h => ‚ü®h.to_re, h.not.to_re‚ü©, fun ‚ü®h‚ÇÅ, h‚ÇÇ‚ü© =>
    ‚ü®‚Äπ_‚Ä∫, by
      obtain ‚ü®k, pk, hk‚ü© :=
        Partrec.merge (h‚ÇÅ.map (Computable.const true).to‚ÇÇ) (h‚ÇÇ.map (Computable.const false).to‚ÇÇ)
        (by
          intro a x hx y hy
          simp only [Part.mem_map_iff, Part.mem_assert_iff, Part.mem_some_iff, exists_prop,
            and_true, exists_const] at hx hy
          cases hy.1 hx.1)
      refine Partrec.of_eq pk fun n => Part.eq_some_iff.2 ?_
      rw [hk]
      simp only [Part.mem_map_iff, Part.mem_assert_iff, Part.mem_some_iff, exists_prop, and_true,
        true_eq_decide_iff, and_self, exists_const, false_eq_decide_iff]
      apply Decidable.em‚ü©‚ü©",88.40098786354065
mathlib,Mathlib/Computability/Encoding.lean,"theorem decode_encodeNum : ‚àÄ n, decodeNum (encodeNum n) = n ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,8,True,,4,-0.5,"theorem decode_encodeNum : ‚àÄ n, decodeNum (encodeNum n) = n := by
  intro n
  cases' n with n <;> unfold encodeNum decodeNum
  ¬∑ rfl
  rw [decode_encodePosNum n]
  rw [PosNum.cast_to_num]
  exact if_neg (encodePosNum_nonempty n)","theorem decode_encodeNum : ‚àÄ n, decodeNum (encodeNum n) = n   := by
  intro n
  cases n <;> simp [decodeNum, encodeNum, decode_encodePosNum, PosNum.cast_to_num, encodePosNum_nonempty]",30.718130111694336
mathlib,Mathlib/Computability/Language.lean,"lemma mem_kstar_iff_exists_nonempty {x : List Œ±} :
    x ‚àà l‚àó ‚Üî ‚àÉ S : List (List Œ±), x = S.join ‚àß ‚àÄ y ‚àà S, y ‚àà l ‚àß y ‚â† [] ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,8,True,,8,0.0,"lemma mem_kstar_iff_exists_nonempty {x : List Œ±} :
    x ‚àà l‚àó ‚Üî ‚àÉ S : List (List Œ±), x = S.join ‚àß ‚àÄ y ‚àà S, y ‚àà l ‚àß y ‚â† [] := by
  constructor
  ¬∑ rintro ‚ü®S, rfl, h‚ü©
    refine ‚ü®S.filter fun l ‚Ü¶ !List.isEmpty l, by simp, fun y hy ‚Ü¶ ?_‚ü©
    -- Porting note: The previous code was:
    -- rw [mem_filter, empty_iff_eq_nil] at hy
    rw [mem_filter, Bool.not_eq_true', ‚Üê Bool.bool_iff_false, isEmpty_iff_eq_nil] at hy
    exact ‚ü®h y hy.1, hy.2‚ü©
  ¬∑ rintro ‚ü®S, hx, h‚ü©
    exact ‚ü®S, hx, fun y hy ‚Ü¶ (h y hy).1‚ü©","lemma mem_kstar_iff_exists_nonempty {x : List Œ±} :
    x ‚àà l‚àó ‚Üî ‚àÉ S : List (List Œ±), x = S.join ‚àß ‚àÄ y ‚àà S, y ‚àà l ‚àß y ‚â† [] := by
  constructor
  ¬∑ rintro ‚ü®S, rfl, h‚ü©
    refine ‚ü®S.filter fun l ‚Ü¶ !List.isEmpty l, by simp, fun y hy ‚Ü¶ ?_‚ü©
    -- Porting note: The previous code was:
    -- rw [mem_filter, empty_iff_eq_nil] at hy
    rw [mem_filter, Bool.not_eq_true', ‚Üê Bool.bool_iff_false, isEmpty_iff_eq_nil] at hy
    exact ‚ü®h y hy.1, hy.2‚ü©
  ¬∑ rintro ‚ü®S, hx, h‚ü©
    exact ‚ü®S, hx, fun y hy ‚Ü¶ (h y hy).1‚ü©",39.841766357421875
mathlib,Mathlib/Computability/Primrec.lean,"theorem nat_iff {f : Œ± ‚Üí Œ≤ ‚Üí œÉ} : Primrec‚ÇÇ f ‚Üî Nat.Primrec
    (.unpaired fun m n => encode <| (@decode Œ± _ m).bind fun a => (@decode Œ≤ _ n).map (f a)) ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,9,True,,9,0.0,"theorem nat_iff {f : Œ± ‚Üí Œ≤ ‚Üí œÉ} : Primrec‚ÇÇ f ‚Üî Nat.Primrec
    (.unpaired fun m n => encode <| (@decode Œ± _ m).bind fun a => (@decode Œ≤ _ n).map (f a)) := by
  have :
    ‚àÄ (a : Option Œ±) (b : Option Œ≤),
      Option.map (fun p : Œ± √ó Œ≤ => f p.1 p.2)
          (Option.bind a fun a : Œ± => Option.map (Prod.mk a) b) =
        Option.bind a fun a => Option.map (f a) b := fun a b => by
          cases a <;> cases b <;> rfl
  simp [Primrec‚ÇÇ, Primrec, this]","theorem nat_iff {f : Œ± ‚Üí Œ≤ ‚Üí œÉ} : Primrec‚ÇÇ f ‚Üî Nat.Primrec
    (.unpaired fun m n => encode <| (@decode Œ± _ m).bind fun a => (@decode Œ≤ _ n).map (f a)) := by
  have :
    ‚àÄ (a : Option Œ±) (b : Option Œ≤),
      Option.map (fun p : Œ± √ó Œ≤ => f p.1 p.2)
          (Option.bind a fun a : Œ± => Option.map (Prod.mk a) b) =
        Option.bind a fun a => Option.map (f a) b := fun a b => by
          cases a <;> cases b <;> rfl
  simp [Primrec‚ÇÇ, Primrec, this]",69.61276912689209
mathlib,Mathlib/Computability/Primrec.lean,theorem nat_div : Primrec‚ÇÇ ((¬∑ / ¬∑) : ‚Ñï ‚Üí ‚Ñï ‚Üí ‚Ñï) ,"refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,9,True,,2,-0.7777777777777778,"theorem nat_div : Primrec‚ÇÇ ((¬∑ / ¬∑) : ‚Ñï ‚Üí ‚Ñï ‚Üí ‚Ñï) := by
  refine of_graph ‚ü®_, fst, fun p => Nat.div_le_self _ _‚ü© ?_
  have : PrimrecRel fun (a : ‚Ñï √ó ‚Ñï) (b : ‚Ñï) => (a.2 = 0 ‚àß b = 0) ‚à®
      (0 < a.2 ‚àß b * a.2 ‚â§ a.1 ‚àß a.1 < (b + 1) * a.2) :=
    PrimrecPred.or
      (.and (const 0 |> Primrec.eq.comp (fst |> snd.comp)) (const 0 |> Primrec.eq.comp snd))
      (.and (nat_lt.comp (const 0) (fst |> snd.comp)) <|
          .and (nat_le.comp (nat_mul.comp snd (fst |> snd.comp)) (fst |> fst.comp))
          (nat_lt.comp (fst.comp fst) (nat_mul.comp (Primrec.succ.comp snd) (snd.comp fst))))
  refine this.of_eq ?_
  rintro ‚ü®a, k‚ü© q
  if H : k = 0 then simp [H, eq_comm]
  else
    have : q * k ‚â§ a ‚àß a < (q + 1) * k ‚Üî q = a / k := by
      rw [le_antisymm_iff, ‚Üê (@Nat.lt_succ _ q), Nat.le_div_iff_mul_le' (Nat.pos_of_ne_zero H),
          Nat.div_lt_iff_lt_mul' (Nat.pos_of_ne_zero H)]
    simpa [H, zero_lt_iff, eq_comm (b := q)]","  refine of_graph ‚ü®_, fst, fun p => Nat.div_le_self _ _‚ü© ?_
  apply (PrimrecPred.or
    (PrimrecPred.and (const 0 |> Primrec.eq.comp (fst |> snd.comp)) (const 0 |> Primrec.eq.comp snd))
    ((PrimrecPred.and (nat_lt.comp (const 0) (fst |> snd.comp)))
    ((PrimrecPred.and (nat_le.comp (nat_mul.comp snd (fst |> snd.comp)) (fst |> fst.comp))
    (nat_lt.comp (fst.comp fst) (nat_mul.comp (Primrec.succ.comp snd) (snd.comp fst)))))),
  rintro ‚ü®a, k‚ü© q
  simp [Nat.lt_succ_iff, le_antisymm_iff, Nat.le_div_iff_mul_le', Nat.div_lt_iff_lt_mul']
",121.57030916213989
mathlib,Mathlib/Computability/RegularExpressions.lean,"theorem add_rmatch_iff (P Q : RegularExpression Œ±) (x : List Œ±) :
    (P + Q).rmatch x ‚Üî P.rmatch x ‚à® Q.rmatch x ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,9,True,,2,-0.7777777777777778,"theorem add_rmatch_iff (P Q : RegularExpression Œ±) (x : List Œ±) :
    (P + Q).rmatch x ‚Üî P.rmatch x ‚à® Q.rmatch x := by
  induction' x with _ _ ih generalizing P Q
  ¬∑ simp only [rmatch, matchEpsilon, Bool.or_eq_true_iff]
  ¬∑ repeat rw [rmatch]
    rw [deriv_add]
    exact ih _ _","theorem add_rmatch_iff (P Q : RegularExpression Œ±) (x : List Œ±) :
    (P + Q).rmatch x ‚Üî P.rmatch x ‚à® Q.rmatch x  := by
  induction x with _ _ ih generalizing P Q <;> simp only [rmatch, matchEpsilon, deriv_add, Bool.or_eq_true_iff, ih]",168.25297594070435
mathlib,Mathlib/Computability/Encoding.lean,"theorem decode_encodePosNum : ‚àÄ n, decodePosNum (encodePosNum n) = n ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,9,True,,2,-0.7777777777777778,"theorem decode_encodePosNum : ‚àÄ n, decodePosNum (encodePosNum n) = n := by
  intro n
  induction' n with m hm m hm <;> unfold encodePosNum decodePosNum
  ¬∑ rfl
  ¬∑ rw [hm]
    exact if_neg (encodePosNum_nonempty m)
  ¬∑ exact congr_arg PosNum.bit0 hm","theorem decode_encodePosNum : ‚àÄ n, decodePosNum (encodePosNum n) = n   := by
  intro
  induction n with _ hm _ hm <;> unfold encodePosNum decodePosNum <;> try {rfl}",241.69617009162903
mathlib,Mathlib/Computability/Halting.lean,"theorem merge {f g : Œ± ‚Üí. œÉ} (hf : Partrec f) (hg : Partrec g)
    (H : ‚àÄ (a), ‚àÄ x ‚àà f a, ‚àÄ y ‚àà g a, x = y) :
    ‚àÉ k : Œ± ‚Üí. œÉ, Partrec k ‚àß ‚àÄ a x, x ‚àà k a ‚Üî x ‚àà f a ‚à® x ‚àà g a ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,9,True,,2,-0.7777777777777778,"theorem merge {f g : Œ± ‚Üí. œÉ} (hf : Partrec f) (hg : Partrec g)
    (H : ‚àÄ (a), ‚àÄ x ‚àà f a, ‚àÄ y ‚àà g a, x = y) :
    ‚àÉ k : Œ± ‚Üí. œÉ, Partrec k ‚àß ‚àÄ a x, x ‚àà k a ‚Üî x ‚àà f a ‚à® x ‚àà g a :=
  let ‚ü®k, hk, K‚ü© := merge' hf hg
  ‚ü®k, hk, fun a x =>
    ‚ü®(K _).1 _, fun h => by
      have : (k a).Dom := (K _).2.2 (h.imp Exists.fst Exists.fst)
      refine ‚ü®this, ?_‚ü©
      cases' h with h h <;> cases' (K _).1 _ ‚ü®this, rfl‚ü© with h' h'
      ¬∑ exact mem_unique h' h
      ¬∑ exact (H _ _ h _ h').symm
      ¬∑ exact H _ _ h' _ h
      ¬∑ exact mem_unique h' h‚ü©‚ü©","theorem merge {f g : Œ± ‚Üí. œÉ} (hf : Partrec f) (hg : Partrec g)
    (H : ‚àÄ (a), ‚àÄ x ‚àà f a, ‚àÄ y ‚àà g a, x = y) :
    ‚àÉ k : Œ± ‚Üí. œÉ, Partrec k ‚àß ‚àÄ a x, x ‚àà k a ‚Üî x ‚àà f a ‚à® x ‚àà g a  := by
  obtain ‚ü®k, hk, K‚ü© := merge' hf hg
  refine ‚ü®k, hk, Œª a x, ‚ü®K a x, Œª h, _‚ü©‚ü©",246.48490285873413
mathlib,Mathlib/Computability/RegularExpressions.lean,"/-- The language of the map is the map of the language. -/
@[simp]
theorem matches'_map (f : Œ± ‚Üí Œ≤) :
    ‚àÄ P : RegularExpression Œ±, (P.map f).matches' = Language.map f P.matches'
  | 0 => (map_zero _).symm
  | 1 => (map_one _).symm
  | char a => by
    rw [eq_comm]
    exact image_singleton
  -- Porting note: the following close with last `rw` but not with `simp`?
  | R + S => by simp only [matches'_map, map, matches'_add]; rw [map_add]
  | comp R S => by simp only [matches'_map, map, matches'_mul]; erw [map_mul]
  | star R => by
    simp_rw [map, matches', matches'_map]
    rw [Language.kstar_eq_iSup_pow, Language.kstar_eq_iSup_pow]
    simp_rw [‚Üê map_pow]
    exact  image_iUnion.symm ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,10,True,,10,0.0,"/-- The language of the map is the map of the language. -/
@[simp]
theorem matches'_map (f : Œ± ‚Üí Œ≤) :
    ‚àÄ P : RegularExpression Œ±, (P.map f).matches' = Language.map f P.matches'
  | 0 => (map_zero _).symm
  | 1 => (map_one _).symm
  | char a => by
    rw [eq_comm]
    exact image_singleton
  -- Porting note: the following close with last `rw` but not with `simp`?
  | R + S => by simp only [matches'_map, map, matches'_add]; rw [map_add]
  | comp R S => by simp only [matches'_map, map, matches'_mul]; erw [map_mul]
  | star R => by
    simp_rw [map, matches', matches'_map]
    rw [Language.kstar_eq_iSup_pow, Language.kstar_eq_iSup_pow]
    simp_rw [‚Üê map_pow]
    exact image_iUnion.symm","/-- The language of the map is the map of the language. -/
@[simp]
theorem matches'_map (f : Œ± ‚Üí Œ≤) :
    ‚àÄ P : RegularExpression Œ±, (P.map f).matches' = Language.map f P.matches'
  | 0 => (map_zero _).symm
  | 1 => (map_one _).symm
  | char a => by
    rw [eq_comm]
    exact image_singleton
  -- Porting note: the following close with last `rw` but not with `simp`?
  | R + S => by simp only [matches'_map, map, matches'_add]; rw [map_add]
  | comp R S => by simp only [matches'_map, map, matches'_mul]; erw [map_mul]
  | star R => by
    simp_rw [map, matches', matches'_map]
    rw [Language.kstar_eq_iSup_pow, Language.kstar_eq_iSup_pow]
    simp_rw [‚Üê map_pow]
    exact image_iUnion.symm",162.6230809688568
mathlib,Mathlib/Computability/Partrec.lean,"theorem nat_rec {f : Œ± ‚Üí ‚Ñï} {g : Œ± ‚Üí. œÉ} {h : Œ± ‚Üí ‚Ñï √ó œÉ ‚Üí. œÉ} (hf : Computable f) (hg : Partrec g)
    (hh : Partrec‚ÇÇ h) : Partrec fun a => (f a).rec (g a) fun y IH => IH.bind fun i => h a (y, i) ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,10,True,,10,0.0,"theorem nat_rec {f : Œ± ‚Üí ‚Ñï} {g : Œ± ‚Üí. œÉ} {h : Œ± ‚Üí ‚Ñï √ó œÉ ‚Üí. œÉ} (hf : Computable f) (hg : Partrec g)
    (hh : Partrec‚ÇÇ h) : Partrec fun a => (f a).rec (g a) fun y IH => IH.bind fun i => h a (y, i) :=
  (Nat.Partrec.prec' hf hg hh).of_eq fun n => by
    cases' e : decode (Œ± := Œ±) n with a <;> simp [e]
    induction' f a with m IH <;> simp
    rw [IH, Part.bind_map]
    congr; funext s
    simp [encodek]","theorem nat_rec {f : Œ± ‚Üí ‚Ñï} {g : Œ± ‚Üí. œÉ} {h : Œ± ‚Üí ‚Ñï √ó œÉ ‚Üí. œÉ} (hf : Computable f) (hg : Partrec g)
    (hh : Partrec‚ÇÇ h) : Partrec fun a => (f a).rec (g a) fun y IH => IH.bind fun i => h a (y, i) :=
  (Nat.Partrec.prec' hf hg hh).of_eq fun n => by
    cases' e : decode (Œ± := Œ±) n with a <;> simp [e]
    induction' f a with m IH <;> simp
    rw [IH, Part.bind_map]
    congr; funext s
    simp [encodek]",185.89065504074097
mathlib,Mathlib/Computability/Halting.lean,"theorem rice‚ÇÇ (C : Set Code) (H : ‚àÄ cf cg, eval cf = eval cg ‚Üí (cf ‚àà C ‚Üî cg ‚àà C)) :
    (ComputablePred fun c => c ‚àà C) ‚Üî C = ‚àÖ ‚à® C = Set.univ ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,10,True,,3,-0.7,"theorem rice‚ÇÇ (C : Set Code) (H : ‚àÄ cf cg, eval cf = eval cg ‚Üí (cf ‚àà C ‚Üî cg ‚àà C)) :
    (ComputablePred fun c => c ‚àà C) ‚Üî C = ‚àÖ ‚à® C = Set.univ := by
  classical exact
      have hC : ‚àÄ f, f ‚àà C ‚Üî eval f ‚àà eval '' C := fun f =>
        ‚ü®Set.mem_image_of_mem _, fun ‚ü®g, hg, e‚ü© => (H _ _ e).1 hg‚ü©
      ‚ü®fun h =>
        or_iff_not_imp_left.2 fun C0 =>
          Set.eq_univ_of_forall fun cg =>
            let ‚ü®cf, fC‚ü© := Set.nonempty_iff_ne_empty.2 C0
            (hC _).2 <|
              rice (eval '' C) (h.of_eq hC)
                (Partrec.nat_iff.1 <| eval_part.comp (const cf) Computable.id)
                (Partrec.nat_iff.1 <| eval_part.comp (const cg) Computable.id) ((hC _).1 fC),
        fun h => by {
          obtain rfl | rfl := h <;> simp [ComputablePred, Set.mem_empty_iff_false] <;>
            exact ‚ü®by infer_instance, Computable.const _‚ü© }‚ü©","theorem rice‚ÇÇ (C : Set Code) (H : ‚àÄ cf cg, eval cf = eval cg ‚Üí (cf ‚àà C ‚Üî cg ‚àà C)) :
    (ComputablePred fun c => c ‚àà C) ‚Üî C = ‚àÖ ‚à® C = Set.univ  := by
  classical
  have hC : ‚àÄ f, f ‚àà C ‚Üî eval f ‚àà eval '' C := fun f => ‚ü®Set.mem_image_of_mem _, fun ‚ü®g, hg, e‚ü© => (H _ _ e).1 hg‚ü©
  refine ‚ü®fun h => or_iff_not_imp_left.2 (fun C0 => Set.eq_univ_of_forall (fun cg => let ‚ü®cf, fC‚ü© := Set.nonempty_iff_ne_empty.2 C0 in (hC _).2 (rice (eval '' C) (h.of_eq hC) (Partrec.nat_iff.1 (eval_part.comp (const cf) Computable.id)) (Partrec.nat_iff.1 (eval_part.comp (const cg) Computable.id)) ((hC _).1 fC)))), fun h => _‚ü©",119.12025785446167
mathlib,Mathlib/Computability/Halting.lean,"/-- **Rice's Theorem** -/
theorem rice (C : Set (‚Ñï ‚Üí. ‚Ñï)) (h : ComputablePred fun c => eval c ‚àà C) {f g} (hf : Nat.Partrec f)
    (hg : Nat.Partrec g) (fC : f ‚àà C) : g ‚àà C ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,10,True,,2,-0.8,"/-- **Rice's Theorem** -/
theorem rice (C : Set (‚Ñï ‚Üí. ‚Ñï)) (h : ComputablePred fun c => eval c ‚àà C) {f g} (hf : Nat.Partrec f)
    (hg : Nat.Partrec g) (fC : f ‚àà C) : g ‚àà C := by
  cases' h with _ h
  obtain ‚ü®c, e‚ü© :=
    fixed_point‚ÇÇ
      (Partrec.cond (h.comp fst) ((Partrec.nat_iff.2 hg).comp snd).to‚ÇÇ
          ((Partrec.nat_iff.2 hf).comp snd).to‚ÇÇ).to‚ÇÇ
  simp only [Bool.cond_decide] at e
  by_cases H : eval c ‚àà C
  ¬∑ simp only [H, if_true] at e
    change (fun b => g b) ‚àà C
    rwa [‚Üê e]
  ¬∑ simp only [H, if_false] at e
    rw [e] at H
    contradiction","/-- **Rice's Theorem** -/
theorem rice (C : Set (‚Ñï ‚Üí. ‚Ñï)) (h : ComputablePred fun c => eval c ‚àà C) {f g} (hf : Nat.Partrec f)
    (hg : Nat.Partrec g) (fC : f ‚àà C) : g ‚àà C  := by
  cases h with _ h",135.92405772209167
mathlib,Mathlib/Computability/Halting.lean,theorem to_part {n f} (pf : @Partrec' n f) : _root_.Partrec f ,"refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,10,True,,10,0.0,"theorem to_part {n f} (pf : @Partrec' n f) : _root_.Partrec f := by
  induction pf with
  | prim hf => exact hf.to_prim.to_comp
  | comp _ _ _ hf hg => exact (Partrec.vector_mOfFn hg).bind (hf.comp snd)
  | rfind _ hf =>
    have := hf.comp (vector_cons.comp snd fst)
    have :=
      ((Primrec.eq.comp _root_.Primrec.id (_root_.Primrec.const 0)).to_comp.comp
        this).to‚ÇÇ.partrec‚ÇÇ
    exact _root_.Partrec.rfind this","theorem to_part {n f} (pf : @Partrec' n f) : _root_.Partrec f := by
  induction pf with
  | prim hf => exact hf.to_prim.to_comp
  | comp _ _ _ hf hg => exact (Partrec.vector_mOfFn hg).bind (hf.comp snd)
  | rfind _ hf =>
    have := hf.comp (vector_cons.comp snd fst)
    have :=
      ((Primrec.eq.comp _root_.Primrec.id (_root_.Primrec.const 0)).to_comp.comp
        this).to‚ÇÇ.partrec‚ÇÇ
    exact _root_.Partrec.rfind this",128.32716536521912
mathlib,Mathlib/Computability/EpsilonNFA.lean,"@[simp]
theorem toŒµNFA_evalFrom_match (M : NFA Œ± œÉ) (start : Set œÉ) :
    M.toŒµNFA.evalFrom start = M.evalFrom start ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,10,True,,1,-0.9,"@[simp]
theorem toŒµNFA_evalFrom_match (M : NFA Œ± œÉ) (start : Set œÉ) :
    M.toŒµNFA.evalFrom start = M.evalFrom start := by
  rw [evalFrom, ŒµNFA.evalFrom, toŒµNFA_ŒµClosure]
  suffices ŒµNFA.stepSet (toŒµNFA M) = stepSet M by rw [this]
  ext S s
  simp only [stepSet, ŒµNFA.stepSet, exists_prop, Set.mem_iUnion]
  apply exists_congr
  simp only [and_congr_right_iff]
  intro _ _
  rw [M.toŒµNFA_ŒµClosure]
  rfl","@[simp]
theorem toŒµNFA_evalFrom_match (M : NFA Œ± œÉ) (start : Set œÉ) :
    M.toŒµNFA.evalFrom start = M.evalFrom start  := by
  rw [evalFrom, ŒµNFA.evalFrom, toŒµNFA_ŒµClosure, stepSet, ŒµNFA.stepSet]
  apply List.foldl_congr rfl
  suffices : ‚àÄ S s, M.toŒµNFA.stepSet S s = M.stepSet S s from fun _ => funext this",67.9709050655365
mathlib,Mathlib/Computability/Primrec.lean,theorem list_get? : Primrec‚ÇÇ (@List.get? Œ±) ,"refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,11,True,,11,0.0,"theorem list_get? : Primrec‚ÇÇ (@List.get? Œ±) :=
  let F (l : List Œ±) (n : ‚Ñï) :=
    l.foldl
      (fun (s : Sum ‚Ñï Œ±) (a : Œ±) =>
        Sum.casesOn s (@Nat.casesOn (fun _ => Sum ‚Ñï Œ±) ¬∑ (Sum.inr a) Sum.inl) Sum.inr)
      (Sum.inl n)
  have hF : Primrec‚ÇÇ F :=
    (list_foldl fst (sum_inl.comp snd)
      ((sum_casesOn fst (nat_casesOn snd (sum_inr.comp <| snd.comp fst) (sum_inl.comp snd).to‚ÇÇ).to‚ÇÇ
              (sum_inr.comp snd).to‚ÇÇ).comp
          snd).to‚ÇÇ).to‚ÇÇ
  have :
    @Primrec _ (Option Œ±) _ _ fun p : List Œ± √ó ‚Ñï => Sum.casesOn (F p.1 p.2) (fun _ => none) some :=
    sum_casesOn hF (const none).to‚ÇÇ (option_some.comp snd).to‚ÇÇ
  this.to‚ÇÇ.of_eq fun l n => by
    dsimp; symm
    induction' l with a l IH generalizing n; ¬∑ rfl
    cases' n with n
    ¬∑ dsimp [F]
      clear IH
      induction' l with _ l IH <;> simp [*]
    ¬∑ apply IH","theorem list_get? : Primrec‚ÇÇ (@List.get? Œ±) :=
  let F (l : List Œ±) (n : ‚Ñï) :=
    l.foldl
      (fun (s : Sum ‚Ñï Œ±) (a : Œ±) =>
        Sum.casesOn s (@Nat.casesOn (fun _ => Sum ‚Ñï Œ±) ¬∑ (Sum.inr a) Sum.inl) Sum.inr)
      (Sum.inl n)
  have hF : Primrec‚ÇÇ F :=
    (list_foldl fst (sum_inl.comp snd)
      ((sum_casesOn fst (nat_casesOn snd (sum_inr.comp <| snd.comp fst) (sum_inl.comp snd).to‚ÇÇ).to‚ÇÇ
              (sum_inr.comp snd).to‚ÇÇ).comp
          snd).to‚ÇÇ).to‚ÇÇ
  have :
    @Primrec _ (Option Œ±) _ _ fun p : List Œ± √ó ‚Ñï => Sum.casesOn (F p.1 p.2) (fun _ => none) some :=
    sum_casesOn hF (const none).to‚ÇÇ (option_some.comp snd).to‚ÇÇ
  this.to‚ÇÇ.of_eq fun l n => by
    dsimp; symm
    induction' l with a l IH generalizing n; ¬∑ rfl
    cases' n with n
    ¬∑ dsimp [F]
      clear IH
      induction' l with _ l IH <;> simp [*]
    ¬∑ apply IH",177.30033922195435
mathlib,Mathlib/Computability/DFA.lean,"theorem pumping_lemma [Fintype œÉ] {x : List Œ±} (hx : x ‚àà M.accepts)
    (hlen : Fintype.card œÉ ‚â§ List.length x) :
    ‚àÉ a b c,
      x = a ++ b ++ c ‚àß
        a.length + b.length ‚â§ Fintype.card œÉ ‚àß b ‚â† [] ‚àß {a} * {b}‚àó * {c} ‚â§ M.accepts ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,11,True,,6,-0.45454545454545453,"theorem pumping_lemma [Fintype œÉ] {x : List Œ±} (hx : x ‚àà M.accepts)
    (hlen : Fintype.card œÉ ‚â§ List.length x) :
    ‚àÉ a b c,
      x = a ++ b ++ c ‚àß
        a.length + b.length ‚â§ Fintype.card œÉ ‚àß b ‚â† [] ‚àß {a} * {b}‚àó * {c} ‚â§ M.accepts := by
  obtain ‚ü®_, a, b, c, hx, hlen, hnil, rfl, hb, hc‚ü© := M.evalFrom_split (s := M.start) hlen rfl
  use a, b, c, hx, hlen, hnil
  intro y hy
  rw [Language.mem_mul] at hy
  rcases hy with ‚ü®ab, hab, c', hc', rfl‚ü©
  rw [Language.mem_mul] at hab
  rcases hab with ‚ü®a', ha', b', hb', rfl‚ü©
  rw [Set.mem_singleton_iff] at ha' hc'
  substs ha' hc'
  have h := M.evalFrom_of_pow hb hb'
  rwa [mem_accepts, evalFrom_of_append, evalFrom_of_append, h, hc]","theorem pumping_lemma [Fintype œÉ] {x : List Œ±} (hx : x ‚àà M.accepts)
    (hlen : Fintype.card œÉ ‚â§ List.length x) :
    ‚àÉ a b c,
      x = a ++ b ++ c ‚àß
        a.length + b.length ‚â§ Fintype.card œÉ ‚àß b ‚â† [] ‚àß {a} * {b}‚àó * {c} ‚â§ M.accepts    := by
  obtain ‚ü®_, a, b, c, hx, hlen, hnil, rfl, hb, hc‚ü© := M.evalFrom_split (s := M.start) hlen rfl
  refine ‚ü®a, b, c, hx, hlen, hnil, fun y hy => ?_‚ü©
  rcases Language.mem_mul.1 hy with ‚ü®ab, hab, c', hc', rfl‚ü©
  rcases Language.mem_mul.1 hab with ‚ü®a', ha', b', hb', rfl‚ü©
  substs ha' hc'
  rwa [mem_accepts, evalFrom_of_append, evalFrom_of_append, M.evalFrom_of_pow hb hb', hc]",124.42569994926453
mathlib,Mathlib/Computability/Partrec.lean,theorem ppred : Partrec fun n => ppred n ,"refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,13,True,,1,-0.9230769230769231,"theorem ppred : Partrec fun n => ppred n :=
  have : Primrec‚ÇÇ fun n m => if n = Nat.succ m then 0 else 1 :=
    (Primrec.ite
      (@PrimrecRel.comp _ _ _ _ _ _ _ _ _ _
        Primrec.eq Primrec.fst (_root_.Primrec.succ.comp Primrec.snd))
      (_root_.Primrec.const 0) (_root_.Primrec.const 1)).to‚ÇÇ
  (of_primrec (Primrec‚ÇÇ.unpaired'.2 this)).rfind.of_eq fun n => by
    cases n <;> simp
    ¬∑ exact
        eq_none_iff.2 fun a ‚ü®‚ü®m, h, _‚ü©, _‚ü© => by
          simp [show 0 ‚â† m.succ by intro h; injection h] at h
    ¬∑ refine eq_some_iff.2 ?_
      simp only [mem_rfind, not_true, IsEmpty.forall_iff, decide_True, mem_some_iff,
        false_eq_decide_iff, true_and]
      intro m h
      simp [ne_of_gt h]","theorem ppred : Partrec fun n => ppred n  := by
  cases n <;> simp
  exact eq_none_iff.2 (Œª a ‚ü®‚ü®m, h, _‚ü©, _‚ü© => by simp [show 0 ‚â† m.succ from Œª h, Nat.noConfusion h] at h)",114.86113500595093
mathlib,Mathlib/Computability/Primrec.lean,theorem to_prim {n f} (pf : @Nat.Primrec' n f) : Primrec f ,"refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,12,True,,12,0.0,"theorem to_prim {n f} (pf : @Nat.Primrec' n f) : Primrec f := by
  induction pf with
  | zero => exact .const 0
  | succ => exact _root_.Primrec.succ.comp .vector_head
  | get i => exact Primrec.vector_get.comp .id (.const i)
  | comp _ _ _ hf hg => exact hf.comp (.vector_ofFn fun i => hg i)
  | @prec n f g _ _ hf hg =>
    exact
      .nat_rec' .vector_head (hf.comp Primrec.vector_tail)
        (hg.comp <|
          Primrec.vector_cons.comp (Primrec.fst.comp .snd) <|
          Primrec.vector_cons.comp (Primrec.snd.comp .snd) <|
            (@Primrec.vector_tail _ _ (n + 1)).comp .fst).to‚ÇÇ","theorem to_prim {n f} (pf : @Nat.Primrec' n f) : Primrec f := by
  induction pf with
  | zero => exact .const 0
  | succ => exact _root_.Primrec.succ.comp .vector_head
  | get i => exact Primrec.vector_get.comp .id (.const i)
  | comp _ _ _ hf hg => exact hf.comp (.vector_ofFn fun i => hg i)
  | @prec n f g _ _ hf hg =>
    exact
      .nat_rec' .vector_head (hf.comp Primrec.vector_tail)
        (hg.comp <|
          Primrec.vector_cons.comp (Primrec.fst.comp .snd) <|
          Primrec.vector_cons.comp (Primrec.snd.comp .snd) <|
            (@Primrec.vector_tail _ _ (n + 1)).comp .fst).to‚ÇÇ",402.73463892936707
mathlib,Mathlib/Computability/EpsilonNFA.lean,"@[simp]
theorem toŒµNFA_evalFrom_match (M : NFA Œ± œÉ) (start : Set œÉ) :
    M.toŒµNFA.evalFrom start = M.evalFrom start ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,10,True,,10,0.0,"@[simp]
theorem toŒµNFA_evalFrom_match (M : NFA Œ± œÉ) (start : Set œÉ) :
    M.toŒµNFA.evalFrom start = M.evalFrom start := by
  rw [evalFrom, ŒµNFA.evalFrom, toŒµNFA_ŒµClosure]
  suffices ŒµNFA.stepSet (toŒµNFA M) = stepSet M by rw [this]
  ext S s
  simp only [stepSet, ŒµNFA.stepSet, exists_prop, Set.mem_iUnion]
  apply exists_congr
  simp only [and_congr_right_iff]
  intro _ _
  rw [M.toŒµNFA_ŒµClosure]
  rfl","@[simp]
theorem toŒµNFA_evalFrom_match (M : NFA Œ± œÉ) (start : Set œÉ) :
    M.toŒµNFA.evalFrom start = M.evalFrom start := by
  rw [evalFrom, ŒµNFA.evalFrom, toŒµNFA_ŒµClosure]
  suffices ŒµNFA.stepSet (toŒµNFA M) = stepSet M by rw [this]
  ext S s
  simp only [stepSet, ŒµNFA.stepSet, exists_prop, Set.mem_iUnion]
  apply exists_congr
  simp only [and_congr_right_iff]
  intro _ _
  rw [M.toŒµNFA_ŒµClosure]
  rfl",43.35481023788452
mathlib,Mathlib/Computability/Primrec.lean,theorem list_get? : Primrec‚ÇÇ (@List.get? Œ±) ,"refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,11,True,,11,0.0,"theorem list_get? : Primrec‚ÇÇ (@List.get? Œ±) :=
  let F (l : List Œ±) (n : ‚Ñï) :=
    l.foldl
      (fun (s : Sum ‚Ñï Œ±) (a : Œ±) =>
        Sum.casesOn s (@Nat.casesOn (fun _ => Sum ‚Ñï Œ±) ¬∑ (Sum.inr a) Sum.inl) Sum.inr)
      (Sum.inl n)
  have hF : Primrec‚ÇÇ F :=
    (list_foldl fst (sum_inl.comp snd)
      ((sum_casesOn fst (nat_casesOn snd (sum_inr.comp <| snd.comp fst) (sum_inl.comp snd).to‚ÇÇ).to‚ÇÇ
              (sum_inr.comp snd).to‚ÇÇ).comp
          snd).to‚ÇÇ).to‚ÇÇ
  have :
    @Primrec _ (Option Œ±) _ _ fun p : List Œ± √ó ‚Ñï => Sum.casesOn (F p.1 p.2) (fun _ => none) some :=
    sum_casesOn hF (const none).to‚ÇÇ (option_some.comp snd).to‚ÇÇ
  this.to‚ÇÇ.of_eq fun l n => by
    dsimp; symm
    induction' l with a l IH generalizing n; ¬∑ rfl
    cases' n with n
    ¬∑ dsimp [F]
      clear IH
      induction' l with _ l IH <;> simp [*]
    ¬∑ apply IH","theorem list_get? : Primrec‚ÇÇ (@List.get? Œ±) :=
  let F (l : List Œ±) (n : ‚Ñï) :=
    l.foldl
      (fun (s : Sum ‚Ñï Œ±) (a : Œ±) =>
        Sum.casesOn s (@Nat.casesOn (fun _ => Sum ‚Ñï Œ±) ¬∑ (Sum.inr a) Sum.inl) Sum.inr)
      (Sum.inl n)
  have hF : Primrec‚ÇÇ F :=
    (list_foldl fst (sum_inl.comp snd)
      ((sum_casesOn fst (nat_casesOn snd (sum_inr.comp <| snd.comp fst) (sum_inl.comp snd).to‚ÇÇ).to‚ÇÇ
              (sum_inr.comp snd).to‚ÇÇ).comp
          snd).to‚ÇÇ).to‚ÇÇ
  have :
    @Primrec _ (Option Œ±) _ _ fun p : List Œ± √ó ‚Ñï => Sum.casesOn (F p.1 p.2) (fun _ => none) some :=
    sum_casesOn hF (const none).to‚ÇÇ (option_some.comp snd).to‚ÇÇ
  this.to‚ÇÇ.of_eq fun l n => by
    dsimp; symm
    induction' l with a l IH generalizing n; ¬∑ rfl
    cases' n with n
    ¬∑ dsimp [F]
      clear IH
      induction' l with _ l IH <;> simp [*]
    ¬∑ apply IH",123.62775492668152
mathlib,Mathlib/Computability/DFA.lean,"theorem pumping_lemma [Fintype œÉ] {x : List Œ±} (hx : x ‚àà M.accepts)
    (hlen : Fintype.card œÉ ‚â§ List.length x) :
    ‚àÉ a b c,
      x = a ++ b ++ c ‚àß
        a.length + b.length ‚â§ Fintype.card œÉ ‚àß b ‚â† [] ‚àß {a} * {b}‚àó * {c} ‚â§ M.accepts ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,11,True,,6,-0.45454545454545453,"theorem pumping_lemma [Fintype œÉ] {x : List Œ±} (hx : x ‚àà M.accepts)
    (hlen : Fintype.card œÉ ‚â§ List.length x) :
    ‚àÉ a b c,
      x = a ++ b ++ c ‚àß
        a.length + b.length ‚â§ Fintype.card œÉ ‚àß b ‚â† [] ‚àß {a} * {b}‚àó * {c} ‚â§ M.accepts := by
  obtain ‚ü®_, a, b, c, hx, hlen, hnil, rfl, hb, hc‚ü© := M.evalFrom_split (s := M.start) hlen rfl
  use a, b, c, hx, hlen, hnil
  intro y hy
  rw [Language.mem_mul] at hy
  rcases hy with ‚ü®ab, hab, c', hc', rfl‚ü©
  rw [Language.mem_mul] at hab
  rcases hab with ‚ü®a', ha', b', hb', rfl‚ü©
  rw [Set.mem_singleton_iff] at ha' hc'
  substs ha' hc'
  have h := M.evalFrom_of_pow hb hb'
  rwa [mem_accepts, evalFrom_of_append, evalFrom_of_append, h, hc]","theorem pumping_lemma [Fintype œÉ] {x : List Œ±} (hx : x ‚àà M.accepts)
    (hlen : Fintype.card œÉ ‚â§ List.length x) :
    ‚àÉ a b c,
      x = a ++ b ++ c ‚àß
        a.length + b.length ‚â§ Fintype.card œÉ ‚àß b ‚â† [] ‚àß {a} * {b}‚àó * {c} ‚â§ M.accepts   := by
  obtain ‚ü®_, a, b, c, hx, hlen, hnil, rfl, hb, hc‚ü© := M.evalFrom_split (s := M.start) hlen rfl
  use a, b, c, hx, hlen, hnil
  rintro y ‚ü®ab, ‚ü®a', ha', b', hb', rfl‚ü©, c', hc', rfl‚ü©
  rw [Set.mem_singleton_iff] at ha' hc'
  substs ha' hc'
  rwa [mem_accepts, evalFrom_of_append, evalFrom_of_append, M.evalFrom_of_pow hb hb', hc]",58.83444619178772
mathlib,Mathlib/Computability/Partrec.lean,theorem ppred : Partrec fun n => ppred n ,"refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,13,True,,1,-0.9230769230769231,"theorem ppred : Partrec fun n => ppred n :=
  have : Primrec‚ÇÇ fun n m => if n = Nat.succ m then 0 else 1 :=
    (Primrec.ite
      (@PrimrecRel.comp _ _ _ _ _ _ _ _ _ _
        Primrec.eq Primrec.fst (_root_.Primrec.succ.comp Primrec.snd))
      (_root_.Primrec.const 0) (_root_.Primrec.const 1)).to‚ÇÇ
  (of_primrec (Primrec‚ÇÇ.unpaired'.2 this)).rfind.of_eq fun n => by
    cases n <;> simp
    ¬∑ exact
        eq_none_iff.2 fun a ‚ü®‚ü®m, h, _‚ü©, _‚ü© => by
          simp [show 0 ‚â† m.succ by intro h; injection h] at h
    ¬∑ refine eq_some_iff.2 ?_
      simp only [mem_rfind, not_true, IsEmpty.forall_iff, decide_True, mem_some_iff,
        false_eq_decide_iff, true_and]
      intro m h
      simp [ne_of_gt h]","theorem ppred : Partrec fun n => ppred n  := by
  refine Partrec.rfind (of_primrec $ Primrec‚ÇÇ.unpaired'.2 $ Primrec.ite (Primrec.eq.comp Primrec.fst (Primrec.succ.comp Primrec.snd)) (Primrec.const 0) (Primrec.const 1)).of_eq (Œª n, _)",62.914992809295654
mathlib,Mathlib/Computability/Primrec.lean,theorem to_prim {n f} (pf : @Nat.Primrec' n f) : Primrec f ,"refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,12,True,,12,0.0,"theorem to_prim {n f} (pf : @Nat.Primrec' n f) : Primrec f := by
  induction pf with
  | zero => exact .const 0
  | succ => exact _root_.Primrec.succ.comp .vector_head
  | get i => exact Primrec.vector_get.comp .id (.const i)
  | comp _ _ _ hf hg => exact hf.comp (.vector_ofFn fun i => hg i)
  | @prec n f g _ _ hf hg =>
    exact
      .nat_rec' .vector_head (hf.comp Primrec.vector_tail)
        (hg.comp <|
          Primrec.vector_cons.comp (Primrec.fst.comp .snd) <|
          Primrec.vector_cons.comp (Primrec.snd.comp .snd) <|
            (@Primrec.vector_tail _ _ (n + 1)).comp .fst).to‚ÇÇ","theorem to_prim {n f} (pf : @Nat.Primrec' n f) : Primrec f := by
  induction pf with
  | zero => exact .const 0
  | succ => exact _root_.Primrec.succ.comp .vector_head
  | get i => exact Primrec.vector_get.comp .id (.const i)
  | comp _ _ _ hf hg => exact hf.comp (.vector_ofFn fun i => hg i)
  | @prec n f g _ _ hf hg =>
    exact
      .nat_rec' .vector_head (hf.comp Primrec.vector_tail)
        (hg.comp <|
          Primrec.vector_cons.comp (Primrec.fst.comp .snd) <|
          Primrec.vector_cons.comp (Primrec.snd.comp .snd) <|
            (@Primrec.vector_tail _ _ (n + 1)).comp .fst).to‚ÇÇ",195.97320818901062
mathlib,Mathlib/Computability/RegularExpressions.lean,theorem char_rmatch_iff (a : Œ±) (x : List Œ±) : rmatch (char a) x ‚Üî x = [a] ,"refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,12,True,,2,-0.8333333333333334,"theorem char_rmatch_iff (a : Œ±) (x : List Œ±) : rmatch (char a) x ‚Üî x = [a] := by
  cases' x with _ x
  ¬∑ exact of_decide_eq_true rfl
  cases' x with head tail
  ¬∑ rw [rmatch, deriv]
    split_ifs
    ¬∑ tauto
    ¬∑ simp [List.singleton_inj]; tauto
  ¬∑ rw [rmatch, rmatch, deriv]
    split_ifs with h
    ¬∑ simp only [deriv_one, zero_rmatch, cons.injEq, and_false]
    ¬∑ simp only [deriv_zero, zero_rmatch, cons.injEq, and_false]","theorem char_rmatch_iff (a : Œ±) (x : List Œ±) : rmatch (char a) x ‚Üî x = [a]  := by
  cases x with _ | head tail",23.507604837417603
mathlib,Mathlib/Computability/Partrec.lean,"theorem nat_casesOn_right {f : Œ± ‚Üí ‚Ñï} {g : Œ± ‚Üí œÉ} {h : Œ± ‚Üí ‚Ñï ‚Üí. œÉ} (hf : Computable f)
    (hg : Computable g) (hh : Partrec‚ÇÇ h) : Partrec fun a => (f a).casesOn (some (g a)) (h a) ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,13,True,,2,-0.8461538461538461,"theorem nat_casesOn_right {f : Œ± ‚Üí ‚Ñï} {g : Œ± ‚Üí œÉ} {h : Œ± ‚Üí ‚Ñï ‚Üí. œÉ} (hf : Computable f)
    (hg : Computable g) (hh : Partrec‚ÇÇ h) : Partrec fun a => (f a).casesOn (some (g a)) (h a) :=
  (nat_rec hf hg (hh.comp fst (pred.comp <| hf.comp fst)).to‚ÇÇ).of_eq fun a => by
    simp; cases' f a with n <;> simp
    refine ext fun b => ‚ü®fun H => ?_, fun H => ?_‚ü©
    ¬∑ rcases mem_bind_iff.1 H with ‚ü®c, _, h‚ÇÇ‚ü©
      exact h‚ÇÇ
    ¬∑ have : ‚àÄ m, (Nat.rec (motive := fun _ => Part œÉ)
          (Part.some (g a)) (fun y IH => IH.bind fun _ => h a n) m).Dom := by
        intro m
        induction m <;> simp [*, H.fst]
      exact ‚ü®‚ü®this n, H.fst‚ü©, H.snd‚ü©","theorem nat_casesOn_right {f : Œ± ‚Üí ‚Ñï} {g : Œ± ‚Üí œÉ} {h : Œ± ‚Üí ‚Ñï ‚Üí. œÉ} (hf : Computable f)
    (hg : Computable g) (hh : Partrec‚ÇÇ h) : Partrec fun a => (f a).casesOn (some (g a)) (h a)   := by
  cases f a with _ n; exact Partrec.of_eq hh (fun _ => rfl)",72.1268470287323
mathlib,Mathlib/Computability/Partrec.lean,"theorem bind_decode_iff {f : Œ± ‚Üí Œ≤ ‚Üí Option œÉ} :
    (Computable‚ÇÇ fun a n => (decode (Œ± ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,13,True,,2,-0.8461538461538461,"theorem bind_decode_iff {f : Œ± ‚Üí Œ≤ ‚Üí Option œÉ} :
    (Computable‚ÇÇ fun a n => (decode (Œ± := Œ≤) n).bind (f a)) ‚Üî Computable‚ÇÇ f :=
  ‚ü®fun hf =>
    Nat.Partrec.of_eq
      (((Partrec.nat_iff.2
        (Nat.Partrec.ppred.comp <| Nat.Partrec.of_primrec <| Primcodable.prim (Œ± := Œ≤))).comp
            snd).bind
        (Computable.comp hf fst).to‚ÇÇ.partrec‚ÇÇ)
      fun n => by
        simp; cases decode (Œ± := Œ±) n.unpair.1 <;> simp;
          cases decode (Œ± := Œ≤) n.unpair.2 <;> simp,
    fun hf => by
    have :
      Partrec fun a : Œ± √ó ‚Ñï =>
        (encode (decode (Œ± := Œ≤) a.2)).casesOn (some Option.none)
          fun n => Part.map (f a.1) (decode (Œ± := Œ≤) n) :=
      Partrec.nat_casesOn_right
        (h := fun (a : Œ± √ó ‚Ñï) (n : ‚Ñï) ‚Ü¶ map (fun b ‚Ü¶ f a.1 b) (Part.ofOption (decode n)))
        (Primrec.encdec.to_comp.comp snd) (const Option.none)
        ((ofOption (Computable.decode.comp snd)).map (hf.comp (fst.comp <| fst.comp fst) snd).to‚ÇÇ)
    refine this.of_eq fun a => ?_
    simp; cases decode (Œ± := Œ≤) a.2 <;> simp [encodek]‚ü©","theorem bind_decode_iff {f : Œ± ‚Üí Œ≤ ‚Üí Option œÉ} :
    (Computable‚ÇÇ fun a n => (decode (Œ±  := by
  ‚ü®fun hf =>
    (Partrec.nat_casesOn_right
      (h := fun (a : Œ± √ó ‚Ñï) (n : ‚Ñï) => map (fun b => f a.1 b) (Part.ofOption (decode n)))
      (Primrec.encdec.to_comp.comp snd) (const Option.none)
      ((ofOption (Computable.decode.comp snd)).map (hf.comp (fst.comp <| fst.comp fst) snd).to‚ÇÇ)).of_eq
      (fun a => by simp; cases decode (Œ± := Œ≤) a.2 <;> simp [encodek])
  ‚ü©
",206.44068026542664
mathlib,Mathlib/Computability/Primrec.lean,"private theorem list_foldl' {f : Œ± ‚Üí List Œ≤} {g : Œ± ‚Üí œÉ} {h : Œ± ‚Üí œÉ √ó Œ≤ ‚Üí œÉ}
    (hf : haveI ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,18,True,,3,-0.8333333333333334,"private theorem list_foldl' {f : Œ± ‚Üí List Œ≤} {g : Œ± ‚Üí œÉ} {h : Œ± ‚Üí œÉ √ó Œ≤ ‚Üí œÉ}
    (hf : haveI := prim H; Primrec f) (hg : Primrec g) (hh : haveI := prim H; Primrec‚ÇÇ h) :
    Primrec fun a => (f a).foldl (fun s b => h a (s, b)) (g a) := by
  letI := prim H
  let G (a : Œ±) (IH : œÉ √ó List Œ≤) : œÉ √ó List Œ≤ := List.casesOn IH.2 IH fun b l => (h a (IH.1, b), l)
  have hG : Primrec‚ÇÇ G := list_casesOn' H (snd.comp snd) snd <|
    to‚ÇÇ <|
    pair (hh.comp (fst.comp fst) <| pair ((fst.comp snd).comp fst) (fst.comp snd))
      (snd.comp snd)
  let F := fun (a : Œ±) (n : ‚Ñï) => (G a)^[n] (g a, f a)
  have hF : Primrec fun a => (F a (encode (f a))).1 :=
    (fst.comp <|
      nat_iterate (encode_iff.2 hf) (pair hg hf) <|
      hG)
  suffices ‚àÄ a n, F a n = (((f a).take n).foldl (fun s b => h a (s, b)) (g a), (f a).drop n) by
    refine hF.of_eq fun a => ?_
    rw [this, List.take_all_of_le (length_le_encode _)]
  introv
  dsimp only [F]
  generalize f a = l
  generalize g a = x
  induction' n with n IH generalizing l x
  ¬∑ rfl
  simp only [iterate_succ, comp_apply]
  cases' l with b l <;> simp [IH]","private theorem list_foldl' {f : Œ± ‚Üí List Œ≤} {g : Œ± ‚Üí œÉ} {h : Œ± ‚Üí œÉ √ó Œ≤ ‚Üí œÉ}
    (hf : haveI  := by
  letI := prim H
  let G a IH := match IH.2 with
  | [] => IH
  | b :: l => (h a (IH.1, b), l)
  have hG : Primrec‚ÇÇ G := list_casesOn' H (snd.comp snd) snd <|
    to‚ÇÇ <| pair (hh.comp (fst.comp fst) <| pair ((fst.comp snd).comp fst) (fst.comp snd)) (snd.comp snd)
  let F a n := (G a)^[n] (g a, f a)
  have hF : Primrec fun a => (F a (encode (f a))).1 :=
    (fst.comp <| nat_iterate (encode_iff.2 hf) (pair hg hf) <| hG)
  suffices ‚àÄ a n, F a n = (((f a).take n).foldl (fun s b => h a (s, b)) (g a), (f a).drop n) by",93.5543417930603
mathlib,Mathlib/Computability/Primrec.lean,theorem of_prim {n f} : Primrec f ‚Üí @Primrec' n f ,"refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,17,True,,17,0.0,"theorem of_prim {n f} : Primrec f ‚Üí @Primrec' n f :=
  suffices ‚àÄ f, Nat.Primrec f ‚Üí @Primrec' 1 fun v => f v.head from fun hf =>
    (pred.comp‚ÇÅ _ <|
          (this _ hf).comp‚ÇÅ (fun m => Encodable.encode <| (@decode (Vector ‚Ñï n) _ m).map f)
            Primrec'.encode).of_eq
      fun i => by simp [encodek]
  fun f hf => by
  induction hf with
  | zero => exact const 0
  | succ => exact succ
  | left => exact unpair‚ÇÅ head
  | right => exact unpair‚ÇÇ head
  | pair _ _ hf hg => exact natPair.comp‚ÇÇ _ hf hg
  | comp _ _ hf hg => exact hf.comp‚ÇÅ _ hg
  | prec _ _ hf hg =>
    simpa using
      prec' (unpair‚ÇÇ head) (hf.comp‚ÇÅ _ (unpair‚ÇÅ head))
        (hg.comp‚ÇÅ _ <|
          natPair.comp‚ÇÇ _ (unpair‚ÇÅ <| tail <| tail head) (natPair.comp‚ÇÇ _ head (tail head)))","theorem of_prim {n f} : Primrec f ‚Üí @Primrec' n f :=
  suffices ‚àÄ f, Nat.Primrec f ‚Üí @Primrec' 1 fun v => f v.head from fun hf =>
    (pred.comp‚ÇÅ _ <|
          (this _ hf).comp‚ÇÅ (fun m => Encodable.encode <| (@decode (Vector ‚Ñï n) _ m).map f)
            Primrec'.encode).of_eq
      fun i => by simp [encodek]
  fun f hf => by
  induction hf with
  | zero => exact const 0
  | succ => exact succ
  | left => exact unpair‚ÇÅ head
  | right => exact unpair‚ÇÇ head
  | pair _ _ hf hg => exact natPair.comp‚ÇÇ _ hf hg
  | comp _ _ hf hg => exact hf.comp‚ÇÅ _ hg
  | prec _ _ hf hg =>
    simpa using
      prec' (unpair‚ÇÇ head) (hf.comp‚ÇÅ _ (unpair‚ÇÅ head))
        (hg.comp‚ÇÅ _ <|
          natPair.comp‚ÇÇ _ (unpair‚ÇÅ <| tail <| tail head) (natPair.comp‚ÇÇ _ head (tail head)))",215.46635103225708
mathlib,Mathlib/Computability/RegularExpressions.lean,"@[simp]
theorem rmatch_iff_matches' (P : RegularExpression Œ±) (x : List Œ±) :
    P.rmatch x ‚Üî x ‚àà P.matches' ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,18,True,,18,0.0,"@[simp]
theorem rmatch_iff_matches' (P : RegularExpression Œ±) (x : List Œ±) :
    P.rmatch x ‚Üî x ‚àà P.matches' := by
  induction P generalizing x with
  | zero =>
    rw [zero_def, zero_rmatch]
    tauto
  | epsilon =>
    rw [one_def, one_rmatch_iff, matches'_epsilon, Language.mem_one]
  | char =>
    rw [char_rmatch_iff]
    rfl
  | plus _ _ ih‚ÇÅ ih‚ÇÇ =>
    rw [plus_def, add_rmatch_iff, ih‚ÇÅ, ih‚ÇÇ]
    rfl
  | comp P Q ih‚ÇÅ ih‚ÇÇ =>
    simp only [comp_def, mul_rmatch_iff, matches'_mul, Language.mem_mul, *]
    tauto
  | star _ ih =>
    simp only [star_rmatch_iff, matches'_star, ih, Language.mem_kstar_iff_exists_nonempty, and_comm]","@[simp]
theorem rmatch_iff_matches' (P : RegularExpression Œ±) (x : List Œ±) :
    P.rmatch x ‚Üî x ‚àà P.matches' := by
  induction P generalizing x with
  | zero =>
    rw [zero_def, zero_rmatch]
    tauto
  | epsilon =>
    rw [one_def, one_rmatch_iff, matches'_epsilon, Language.mem_one]
  | char =>
    rw [char_rmatch_iff]
    rfl
  | plus _ _ ih‚ÇÅ ih‚ÇÇ =>
    rw [plus_def, add_rmatch_iff, ih‚ÇÅ, ih‚ÇÇ]
    rfl
  | comp P Q ih‚ÇÅ ih‚ÇÇ =>
    simp only [comp_def, mul_rmatch_iff, matches'_mul, Language.mem_mul, *]
    tauto
  | star _ ih =>
    simp only [star_rmatch_iff, matches'_star, ih, Language.mem_kstar_iff_exists_nonempty, and_comm]",66.13761878013611
mathlib,Mathlib/Computability/Primrec.lean,theorem sqrt : @Primrec' 1 fun v => v.head.sqrt ,"refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,23,True,,1,-0.9565217391304348,"theorem sqrt : @Primrec' 1 fun v => v.head.sqrt := by
  suffices H : ‚àÄ n : ‚Ñï, n.sqrt =
      n.rec 0 fun x y => if x.succ < y.succ * y.succ then y else y.succ by
    simp [H]
    have :=
      @prec' 1 _ _
        (fun v => by
          have x := v.head; have y := v.tail.head;
            exact if x.succ < y.succ * y.succ then y else y.succ)
        head (const 0) ?_
    ¬∑ exact this
    have x1 : @Primrec' 3 fun v => v.head.succ := succ.comp‚ÇÅ _ head
    have y1 : @Primrec' 3 fun v => v.tail.head.succ := succ.comp‚ÇÅ _ (tail head)
    exact if_lt x1 (mul.comp‚ÇÇ _ y1 y1) (tail head) y1
  introv; symm
  induction' n with n IH; ¬∑ simp
  dsimp; rw [IH]; split_ifs with h
  ¬∑ exact le_antisymm (Nat.sqrt_le_sqrt (Nat.le_succ _)) (Nat.lt_succ_iff.1 <| Nat.sqrt_lt.2 h)
  ¬∑ exact
      Nat.eq_sqrt.2 ‚ü®not_lt.1 h, Nat.sqrt_lt.1 <| Nat.lt_succ_iff.2 <| Nat.sqrt_succ_le_succ_sqrt _‚ü©","theorem sqrt : @Primrec' 1 fun v => v.head.sqrt  := by
  suffices H : ‚àÄ n : ‚Ñï, n.sqrt = n.rec 0 (Œª x y, if x.succ < y.succ * y.succ then y else y.succ) by",205.24771690368652
mathlib,Mathlib/Computability/PartrecCode.lean,"/-- Proof that `Nat.Partrec.Code.ofNatCode` is the inverse of `Nat.Partrec.Code.encodeCode`-/
private theorem encode_ofNatCode : ‚àÄ n, encodeCode (ofNatCode n) = n
  | 0 => by simp [ofNatCode, encodeCode]
  | 1 => by simp [ofNatCode, encodeCode]
  | 2 => by simp [ofNatCode, encodeCode]
  | 3 => by simp [ofNatCode, encodeCode]
  | n + 4 => by
    let m ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,25,True,,25,0.0,"/-- Proof that `Nat.Partrec.Code.ofNatCode` is the inverse of `Nat.Partrec.Code.encodeCode`-/
private theorem encode_ofNatCode : ‚àÄ n, encodeCode (ofNatCode n) = n
  | 0 => by simp [ofNatCode, encodeCode]
  | 1 => by simp [ofNatCode, encodeCode]
  | 2 => by simp [ofNatCode, encodeCode]
  | 3 => by simp [ofNatCode, encodeCode]
  | n + 4 => by
    let m := n.div2.div2
    have hm : m < n + 4 := by
      simp only [m, div2_val]
      exact
        lt_of_le_of_lt (le_trans (Nat.div_le_self _ _) (Nat.div_le_self _ _))
          (Nat.succ_le_succ (Nat.le_add_right _ _))
    have _m1 : m.unpair.1 < n + 4 := lt_of_le_of_lt m.unpair_left_le hm
    have _m2 : m.unpair.2 < n + 4 := lt_of_le_of_lt m.unpair_right_le hm
    have IH := encode_ofNatCode m
    have IH1 := encode_ofNatCode m.unpair.1
    have IH2 := encode_ofNatCode m.unpair.2
    conv_rhs => rw [‚Üê Nat.bit_decomp n, ‚Üê Nat.bit_decomp n.div2]
    simp only [ofNatCode.eq_5]
    cases n.bodd <;> cases n.div2.bodd <;>
      simp [encodeCode, ofNatCode, IH, IH1, IH2, Nat.bit_val]","/-- Proof that `Nat.Partrec.Code.ofNatCode` is the inverse of `Nat.Partrec.Code.encodeCode`-/
private theorem encode_ofNatCode : ‚àÄ n, encodeCode (ofNatCode n) = n
  | 0 => by simp [ofNatCode, encodeCode]
  | 1 => by simp [ofNatCode, encodeCode]
  | 2 => by simp [ofNatCode, encodeCode]
  | 3 => by simp [ofNatCode, encodeCode]
  | n + 4 => by
    let m := n.div2.div2
    have hm : m < n + 4 := by
      simp only [m, div2_val]
      exact
        lt_of_le_of_lt (le_trans (Nat.div_le_self _ _) (Nat.div_le_self _ _))
          (Nat.succ_le_succ (Nat.le_add_right _ _))
    have _m1 : m.unpair.1 < n + 4 := lt_of_le_of_lt m.unpair_left_le hm
    have _m2 : m.unpair.2 < n + 4 := lt_of_le_of_lt m.unpair_right_le hm
    have IH := encode_ofNatCode m
    have IH1 := encode_ofNatCode m.unpair.1
    have IH2 := encode_ofNatCode m.unpair.2
    conv_rhs => rw [‚Üê Nat.bit_decomp n, ‚Üê Nat.bit_decomp n.div2]
    simp only [ofNatCode.eq_5]
    cases n.bodd <;> cases n.div2.bodd <;>
      simp [encodeCode, ofNatCode, IH, IH1, IH2, Nat.bit_val]",38.978760957717896
mathlib,Mathlib/Computability/PartrecCode.lean,"theorem evaln_bound : ‚àÄ {k c n x}, x ‚àà evaln k c n ‚Üí n < k
  | 0, c, n, x, h => by simp [evaln] at h
  | k + 1, c, n, x, h => by
    suffices ‚àÄ {o : Option ‚Ñï}, x ‚àà do { guard (n ‚â§ k); o } ‚Üí n < k + 1 by
      cases c <;> rw [evaln] at h <;> exact this h
    simpa [Option.bind_eq_some] using  Nat.lt_succ_of_le ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,21,True,,21,0.0,"theorem evaln_bound : ‚àÄ {k c n x}, x ‚àà evaln k c n ‚Üí n < k
  | 0, c, n, x, h => by simp [evaln] at h
  | k + 1, c, n, x, h => by
    suffices ‚àÄ {o : Option ‚Ñï}, x ‚àà do { guard (n ‚â§ k); o } ‚Üí n < k + 1 by
      cases c <;> rw [evaln] at h <;> exact this h
    simpa [Option.bind_eq_some] using Nat.lt_succ_of_le","theorem evaln_bound : ‚àÄ {k c n x}, x ‚àà evaln k c n ‚Üí n < k
  | 0, c, n, x, h => by simp [evaln] at h
  | k + 1, c, n, x, h => by
    suffices ‚àÄ {o : Option ‚Ñï}, x ‚àà do { guard (n ‚â§ k); o } ‚Üí n < k + 1 by
      cases c <;> rw [evaln] at h <;> exact this h
    simpa [Option.bind_eq_some] using Nat.lt_succ_of_le",179.93134379386902
mathlib,Mathlib/Computability/Partrec.lean,theorem of_primrec {f : ‚Ñï ‚Üí ‚Ñï} (hf : Nat.Primrec f) : Partrec f ,"refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,26,True,,26,0.0,"theorem of_primrec {f : ‚Ñï ‚Üí ‚Ñï} (hf : Nat.Primrec f) : Partrec f := by
  induction hf with
  | zero => exact zero
  | succ => exact succ
  | left => exact left
  | right => exact right
  | pair _ _ pf pg =>
    refine (pf.pair pg).of_eq_tot fun n => ?_
    simp [Seq.seq]
  | comp _ _ pf pg =>
    refine (pf.comp pg).of_eq_tot fun n => ?_
    simp
  | prec _ _ pf pg =>
    refine (pf.prec pg).of_eq_tot fun n => ?_
    simp only [unpaired, PFun.coe_val, bind_eq_bind]
    induction n.unpair.2 with
    | zero => simp
    | succ m IH =>
      simp only [mem_bind_iff, mem_some_iff]
      exact ‚ü®_, IH, rfl‚ü©","theorem of_primrec {f : ‚Ñï ‚Üí ‚Ñï} (hf : Nat.Primrec f) : Partrec f := by
  induction hf with
  | zero => exact zero
  | succ => exact succ
  | left => exact left
  | right => exact right
  | pair _ _ pf pg =>
    refine (pf.pair pg).of_eq_tot fun n => ?_
    simp [Seq.seq]
  | comp _ _ pf pg =>
    refine (pf.comp pg).of_eq_tot fun n => ?_
    simp
  | prec _ _ pf pg =>
    refine (pf.prec pg).of_eq_tot fun n => ?_
    simp only [unpaired, PFun.coe_val, bind_eq_bind]
    induction n.unpair.2 with
    | zero => simp
    | succ m IH =>
      simp only [mem_bind_iff, mem_some_iff]
      exact ‚ü®_, IH, rfl‚ü©",55.41949224472046
mathlib,Mathlib/Computability/Halting.lean,"theorem merge' {f g : Œ± ‚Üí. œÉ} (hf : Partrec f) (hg : Partrec g) :
    ‚àÉ k : Œ± ‚Üí. œÉ,
      Partrec k ‚àß ‚àÄ a, (‚àÄ x ‚àà k a, x ‚àà f a ‚à® x ‚àà g a) ‚àß ((k a).Dom ‚Üî (f a).Dom ‚à® (g a).Dom) ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,26,True,,2,-0.9230769230769231,"theorem merge' {f g : Œ± ‚Üí. œÉ} (hf : Partrec f) (hg : Partrec g) :
    ‚àÉ k : Œ± ‚Üí. œÉ,
      Partrec k ‚àß ‚àÄ a, (‚àÄ x ‚àà k a, x ‚àà f a ‚à® x ‚àà g a) ‚àß ((k a).Dom ‚Üî (f a).Dom ‚à® (g a).Dom) := by
  let ‚ü®k, hk, H‚ü© := Nat.Partrec.merge' (bind_decode‚ÇÇ_iff.1 hf) (bind_decode‚ÇÇ_iff.1 hg)
  let k' (a : Œ±) := (k (encode a)).bind fun n => (decode (Œ± := œÉ) n : Part œÉ)
  refine
    ‚ü®k', ((nat_iff.2 hk).comp Computable.encode).bind (Computable.decode.ofOption.comp snd).to‚ÇÇ,
      fun a => ?_‚ü©
  have : ‚àÄ x ‚àà k' a, x ‚àà f a ‚à® x ‚àà g a := by
    intro x h'
    simp only [k', exists_prop, mem_coe, mem_bind_iff, Option.mem_def] at h'
    obtain ‚ü®n, hn, hx‚ü© := h'
    have := (H _).1 _ hn
    simp [mem_decode‚ÇÇ, encode_injective.eq_iff] at this
    obtain ‚ü®a', ha, rfl‚ü© | ‚ü®a', ha, rfl‚ü© := this <;> simp only [encodek, Option.some_inj] at hx <;>
      rw [hx] at ha
    ¬∑ exact Or.inl ha
    ¬∑ exact Or.inr ha
  refine ‚ü®this, ‚ü®fun h => (this _ ‚ü®h, rfl‚ü©).imp Exists.fst Exists.fst, ?_‚ü©‚ü©
  intro h
  rw [bind_dom]
  have hk : (k (encode a)).Dom :=
    (H _).2.2 (by simpa only [encodek‚ÇÇ, bind_some, coe_some] using h)
  exists hk
  simp only [exists_prop, mem_map_iff, mem_coe, mem_bind_iff, Option.mem_def] at H
  obtain ‚ü®a', _, y, _, e‚ü© | ‚ü®a', _, y, _, e‚ü© := (H _).1 _ ‚ü®hk, rfl‚ü© <;>
    simp only [e.symm, encodek, coe_some, some_dom]","theorem merge' {f g : Œ± ‚Üí. œÉ} (hf : Partrec f) (hg : Partrec g) :
    ‚àÉ k : Œ± ‚Üí. œÉ,
      Partrec k ‚àß ‚àÄ a, (‚àÄ x ‚àà k a, x ‚àà f a ‚à® x ‚àà g a) ‚àß ((k a).Dom ‚Üî (f a).Dom ‚à® (g a).Dom)  := by
  let ‚ü®k, hk, H‚ü© := Nat.Partrec.merge' (bind_decode‚ÇÇ_iff.1 hf) (bind_decode‚ÇÇ_iff.1 hg)
  let k' (a : Œ±) := (k (encode a)).bind fun n => decode n
  refine ‚ü®k', ((nat_iff.2 hk).comp Computable.encode).bind (Computable.decode.ofOption.comp snd).to‚ÇÇ, fun a => ‚ü®_, _‚ü©‚ü©
  have : ‚àÄ x ‚àà k' a, x ‚àà f a ‚à® x ‚àà g a := by
    intro x h'
    obtain ‚ü®n, hn, hx‚ü© := h'
    have := (H _).1 _ hn
    simp [mem_decode‚ÇÇ, encode_injective.eq_iff] at this
    obtain ‚ü®a', ha, rfl‚ü© | ‚ü®a', ha, rfl‚ü© := this <;> rw [hx] at ha; exact Or.inl ha <|> exact Or.inr ha
  exact ‚ü®this, ‚ü®fun h => (this _ ‚ü®h, rfl‚ü©).imp Exists.fst Exists.fst, fun h =>
    rw [bind_dom]",83.29568409919739
