repo,file,decl,method,n,metric,model,annotation,syntax_search,mathlib_search,examples,improved_context,og_correct,og_errors,og_score,new_correct,new_errors,new_score,delta,og_raw,new_raw,time
mathlib,Mathlib/CategoryTheory/Limits/Shapes/Images.lean,"@[ext]
theorem image.ext [HasImage f] {W : C} {g h : image f âŸ¶ W} [HasLimit (parallelPair g h)]
    (w : factorThruImage f â‰« g = factorThruImage f â‰« h) : g = h ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",3,LENGTH,gpt-4o,True,True,True,10,False,True,,15,True,,1,-0.9333333333333333,"@[ext]
theorem image.ext [HasImage f] {W : C} {g h : image f âŸ¶ W} [HasLimit (parallelPair g h)]
    (w : factorThruImage f â‰« g = factorThruImage f â‰« h) : g = h := by
  let q := equalizer.Î¹ g h
  let e' := equalizer.lift _ w
  let F' : MonoFactorisation f :=
    { I := equalizer g h
      m := q â‰« image.Î¹ f
      m_mono := by apply mono_comp
      e := e' }
  let v := image.lift F'
  have tâ‚€ : v â‰« q â‰« image.Î¹ f = image.Î¹ f := image.lift_fac F'
  have t : v â‰« q = ğŸ™ (image f) :=
    (cancel_mono_id (image.Î¹ f)).1
      (by
        convert tâ‚€ using 1
        rw [Category.assoc])
  -- The proof from wikipedia next proves `q â‰« v = ğŸ™ _`,
  -- and concludes that `equalizer g h â‰… image f`,
  -- but this isn't necessary.
  calc
    g = ğŸ™ (image f) â‰« g := by rw [Category.id_comp]
    _ = v â‰« q â‰« g := by rw [â† t, Category.assoc]
    _ = v â‰« q â‰« h := by rw [equalizer.condition g h]
    _ = ğŸ™ (image f) â‰« h := by rw [â† Category.assoc, t]
    _ = h := by rw [Category.id_comp]","theorem image.ext [HasImage f] {W : C} {g h : image f âŸ¶ W} [HasLimit (parallelPair g h)]
    (w : factorThruImage f â‰« g = factorThruImage f â‰« h) : g = h  := by
  ext1 t
  let q := equalizer.Î¹ g h
  let e' := equalizer.lift (factorThruImage f) w
  let v := image.lift { I := equalizer g h, m := q â‰« image.Î¹ f, m_mono := mono_comp _ _, e := e' }
  have : v â‰« q = ğŸ™ (image f) := (cancel_mono (image.Î¹ f)).1 (eq.trans (image.lift_fac _) (Category.id_comp _).symm)
  simpa using congr_arg (Î» t, t t) (Category.eq_of_id_comp_eq_id _ _ this (equalizer.condition _ _))",44.6449248790741
mathlib,Mathlib/CategoryTheory/Localization/CalculusOfFractions.lean,lemma uniq (Fâ‚ Fâ‚‚ : Localization W â¥¤ E) (h : Q W â‹™ Fâ‚ = Q W â‹™ Fâ‚‚) : Fâ‚ = Fâ‚‚ ,"refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",3,LENGTH,gpt-4o,True,True,True,10,False,True,,14,True,,1,-0.9285714285714286,"lemma uniq (Fâ‚ Fâ‚‚ : Localization W â¥¤ E) (h : Q W â‹™ Fâ‚ = Q W â‹™ Fâ‚‚) : Fâ‚ = Fâ‚‚ :=
  Functor.ext (fun X => Functor.congr_obj h X) (by
    rintro (X Y : C) f
    obtain âŸ¨f, rflâŸ© := Hom.mk_surjective f
    rw [show Hom.mk f = homMk (mk f.f f.s f.hs) by rfl,
      â† Q_map_comp_Qinv f.f f.s f.hs, Fâ‚.map_comp, Fâ‚‚.map_comp, assoc]
    erw [Functor.congr_hom h f.f]
    rw [assoc, assoc]
    congr 2
    have := inverts W _ f.hs
    rw [â† cancel_epi (Fâ‚‚.map ((Q W).map f.s)), â† Fâ‚‚.map_comp_assoc,
      Qiso_hom_inv_id, Functor.map_id, id_comp]
    erw [Functor.congr_hom h.symm f.s]
    dsimp
    rw [assoc, assoc, eqToHom_trans_assoc, eqToHom_refl, id_comp, â† Fâ‚.map_comp,
      Qiso_hom_inv_id]
    dsimp
    rw [Fâ‚.map_id, comp_id])","lemma uniq (Fâ‚ Fâ‚‚ : Localization W â¥¤ E) (h : Q W â‹™ Fâ‚ = Q W â‹™ Fâ‚‚) : Fâ‚ = Fâ‚‚  := by
  funext (Î» X Y f =>
    obtain âŸ¨f, rflâŸ© : âˆƒ f', f = (Localization.Hom.mk f') := Hom.mk_surjective f",140.71357703208923
mathlib,Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean,"theorem WalkingParallelPairHom.assoc {X Y Z W : WalkingParallelPair}
    (f : WalkingParallelPairHom X Y) (g: WalkingParallelPairHom Y Z)
    (h : WalkingParallelPairHom Z W) : comp (comp f g) h = comp f (comp g h) ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",3,LENGTH,gpt-4o,True,True,True,10,False,True,,16,True,,16,0.0,"theorem WalkingParallelPairHom.assoc {X Y Z W : WalkingParallelPair}
    (f : WalkingParallelPairHom X Y) (g: WalkingParallelPairHom Y Z)
    (h : WalkingParallelPairHom Z W) : comp (comp f g) h = comp f (comp g h) := by
  cases f <;> cases g <;> cases h <;> rfl","theorem WalkingParallelPairHom.assoc {X Y Z W : WalkingParallelPair}
    (f : WalkingParallelPairHom X Y) (g: WalkingParallelPairHom Y Z)
    (h : WalkingParallelPairHom Z W) : comp (comp f g) h = comp f (comp g h) := by
  cases f <;> cases g <;> cases h <;> rfl",21.29560399055481
mathlib,Mathlib/CategoryTheory/Limits/Shapes/Images.lean,"@[ext]
theorem ext [HasImage f] {W : C} {g h : image f âŸ¶ W} [HasLimit (parallelPair g h)]
    (w : factorThruImage f â‰« g = factorThruImage f â‰« h) : g = h ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",3,LENGTH,gpt-4o,True,True,True,10,False,True,,15,True,,1,-0.9333333333333333,"@[ext]
theorem image.ext [HasImage f] {W : C} {g h : image f âŸ¶ W} [HasLimit (parallelPair g h)]
    (w : factorThruImage f â‰« g = factorThruImage f â‰« h) : g = h := by
  let q := equalizer.Î¹ g h
  let e' := equalizer.lift _ w
  let F' : MonoFactorisation f :=
    { I := equalizer g h
      m := q â‰« image.Î¹ f
      m_mono := by apply mono_comp
      e := e' }
  let v := image.lift F'
  have tâ‚€ : v â‰« q â‰« image.Î¹ f = image.Î¹ f := image.lift_fac F'
  have t : v â‰« q = ğŸ™ (image f) :=
    (cancel_mono_id (image.Î¹ f)).1
      (by
        convert tâ‚€ using 1
        rw [Category.assoc])
  -- The proof from wikipedia next proves `q â‰« v = ğŸ™ _`,
  -- and concludes that `equalizer g h â‰… image f`,
  -- but this isn't necessary.
  calc
    g = ğŸ™ (image f) â‰« g := by rw [Category.id_comp]
    _ = v â‰« q â‰« g := by rw [â† t, Category.assoc]
    _ = v â‰« q â‰« h := by rw [equalizer.condition g h]
    _ = ğŸ™ (image f) â‰« h := by rw [â† Category.assoc, t]
    _ = h := by rw [Category.id_comp]","theorem ext [HasImage f] {W : C} {g h : image f âŸ¶ W} [HasLimit (parallelPair g h)]
    (w : factorThruImage f â‰« g = factorThruImage f â‰« h) : g = h  := by
  suffices : equalizer.Î¹ g h â‰« g = equalizer.Î¹ g h â‰« h by exact (cancel_mono_id h).1 this
  rw [â† Category.assoc, â† Category.assoc, w, equalizer.condition]",33.61011505126953
mathlib,Mathlib/CategoryTheory/ComposableArrows.lean,"lemma mkOfObjOfMapSucc_exists : âˆƒ (F : ComposableArrows C n) (e : âˆ€ i, F.obj i â‰… obj i),
    âˆ€ (i : â„•) (hi : i < n), mapSucc âŸ¨i, hiâŸ© =
      (e âŸ¨i, _âŸ©).inv â‰« F.map' i (i + 1) â‰« (e âŸ¨i + 1, _âŸ©).hom ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",3,LENGTH,gpt-4o,True,True,True,10,False,True,,15,True,,15,0.0,"lemma mkOfObjOfMapSucc_exists : âˆƒ (F : ComposableArrows C n) (e : âˆ€ i, F.obj i â‰… obj i),
    âˆ€ (i : â„•) (hi : i < n), mapSucc âŸ¨i, hiâŸ© =
      (e âŸ¨i, _âŸ©).inv â‰« F.map' i (i + 1) â‰« (e âŸ¨i + 1, _âŸ©).hom := by
  clear F G
  revert obj mapSucc
  induction' n with n hn
  Â· intro obj _
    exact âŸ¨mkâ‚€ (obj 0), fun 0 => Iso.refl _, fun i hi => by simp at hiâŸ©
  Â· intro obj mapSucc
    obtain âŸ¨F, e, hâŸ© := hn (fun i => obj i.succ) (fun i => mapSucc i.succ)
    refine âŸ¨F.precomp (mapSucc 0 â‰« (e 0).inv), fun i => match i with
      | 0 => Iso.refl _
      | âŸ¨i + 1, hiâŸ© => e _, fun i hi => ?_âŸ©
    obtain _ | i := i
    Â· dsimp
      rw [assoc, Iso.inv_hom_id, comp_id]
      erw [id_comp]
    Â· exact h i (by valid)","lemma mkOfObjOfMapSucc_exists : âˆƒ (F : ComposableArrows C n) (e : âˆ€ i, F.obj i â‰… obj i),
    âˆ€ (i : â„•) (hi : i < n), mapSucc âŸ¨i, hiâŸ© =
      (e âŸ¨i, _âŸ©).inv â‰« F.map' i (i + 1) â‰« (e âŸ¨i + 1, _âŸ©).hom := by
  clear F G
  revert obj mapSucc
  induction' n with n hn
  Â· intro obj _
    exact âŸ¨mkâ‚€ (obj 0), fun 0 => Iso.refl _, fun i hi => by simp at hiâŸ©
  Â· intro obj mapSucc
    obtain âŸ¨F, e, hâŸ© := hn (fun i => obj i.succ) (fun i => mapSucc i.succ)
    refine âŸ¨F.precomp (mapSucc 0 â‰« (e 0).inv), fun i => match i with
      | 0 => Iso.refl _
      | âŸ¨i + 1, hiâŸ© => e _, fun i hi => ?_âŸ©
    obtain _ | i := i
    Â· dsimp
      rw [assoc, Iso.inv_hom_id, comp_id]
      erw [id_comp]
    Â· exact h i (by valid)",191.094251871109
mathlib,Mathlib/CategoryTheory/Limits/Shapes/Equalizers.lean,"theorem assoc {X Y Z W : WalkingParallelPair}
    (f : WalkingParallelPairHom X Y) (g: WalkingParallelPairHom Y Z)
    (h : WalkingParallelPairHom Z W) : comp (comp f g) h = comp f (comp g h) ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",3,LENGTH,gpt-4o,True,True,True,10,False,True,,16,True,,16,0.0,"theorem WalkingParallelPairHom.assoc {X Y Z W : WalkingParallelPair}
    (f : WalkingParallelPairHom X Y) (g: WalkingParallelPairHom Y Z)
    (h : WalkingParallelPairHom Z W) : comp (comp f g) h = comp f (comp g h) := by
  cases f <;> cases g <;> cases h <;> rfl","theorem WalkingParallelPairHom.assoc {X Y Z W : WalkingParallelPair}
    (f : WalkingParallelPairHom X Y) (g: WalkingParallelPairHom Y Z)
    (h : WalkingParallelPairHom Z W) : comp (comp f g) h = comp f (comp g h) := by
  cases f <;> cases g <;> cases h <;> rfl",15.280200004577637
mathlib,Mathlib/CategoryTheory/ComposableArrows.lean,"lemma map_comp {i j k : Fin (n + 1 + 1)} (hij : i â‰¤ j) (hjk : j â‰¤ k) :
    map F f i k (hij.trans hjk) = map F f i j hij â‰« map F f j k hjk ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",3,LENGTH,gpt-4o,True,True,True,10,False,True,,23,True,,23,0.0,"lemma map_comp {i j k : Fin (n + 1 + 1)} (hij : i â‰¤ j) (hjk : j â‰¤ k) :
    map F f i k (hij.trans hjk) = map F f i j hij â‰« map F f j k hjk := by
  obtain âŸ¨i, hiâŸ© := i
  obtain âŸ¨j, hjâŸ© := j
  obtain âŸ¨k, hkâŸ© := k
  cases i
  Â· obtain _ | _ | j := j
    Â· dsimp
      rw [id_comp]
    Â· obtain _ | _ | k := k
      Â· simp [Nat.succ.injEq] at hjk
      Â· simp
      Â· rfl
    Â· obtain _ | _ | k := k
      Â· simp [Fin.ext_iff] at hjk
      Â· simp [Fin.le_def] at hjk
        omega
      Â· dsimp
        rw [assoc, â† F.map_comp, homOfLE_comp]
  Â· obtain _ | j := j
    Â· simp [Fin.ext_iff] at hij
    Â· obtain _ | k := k
      Â· simp [Fin.ext_iff] at hjk
      Â· dsimp
        rw [â† F.map_comp, homOfLE_comp]","lemma map_comp {i j k : Fin (n + 1 + 1)} (hij : i â‰¤ j) (hjk : j â‰¤ k) :
    map F f i k (hij.trans hjk) = map F f i j hij â‰« map F f j k hjk := by
  obtain âŸ¨i, hiâŸ© := i
  obtain âŸ¨j, hjâŸ© := j
  obtain âŸ¨k, hkâŸ© := k
  cases i
  Â· obtain _ | _ | j := j
    Â· dsimp
      rw [id_comp]
    Â· obtain _ | _ | k := k
      Â· simp [Nat.succ.injEq] at hjk
      Â· simp
      Â· rfl
    Â· obtain _ | _ | k := k
      Â· simp [Fin.ext_iff] at hjk
      Â· simp [Fin.le_def] at hjk
        omega
      Â· dsimp
        rw [assoc, â† F.map_comp, homOfLE_comp]
  Â· obtain _ | j := j
    Â· simp [Fin.ext_iff] at hij
    Â· obtain _ | k := k
      Â· simp [Fin.ext_iff] at hjk
      Â· dsimp
        rw [â† F.map_comp, homOfLE_comp]",73.28126192092896
mathlib,Mathlib/CategoryTheory/ComposableArrows.lean,"lemma ext_succ {F G : ComposableArrows C (n + 1)} (hâ‚€ : F.obj' 0 = G.obj' 0)
    (h : F.Î´â‚€ = G.Î´â‚€) (w : F.map' 0 1 = eqToHom hâ‚€ â‰« G.map' 0 1 â‰«
      eqToHom (Functor.congr_obj h.symm 0)): F = G ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",3,LENGTH,gpt-4o,True,True,True,10,False,True,,17,True,,1,-0.9411764705882353,"lemma ext_succ {F G : ComposableArrows C (n + 1)} (hâ‚€ : F.obj' 0 = G.obj' 0)
    (h : F.Î´â‚€ = G.Î´â‚€) (w : F.map' 0 1 = eqToHom hâ‚€ â‰« G.map' 0 1 â‰«
      eqToHom (Functor.congr_obj h.symm 0)): F = G := by
  have : âˆ€ i, F.obj i = G.obj i := by
    intro âŸ¨i, hiâŸ©
    cases' i with i
    Â· exact hâ‚€
    Â· exact Functor.congr_obj h âŸ¨i, by validâŸ©
  exact Functor.ext_of_iso (isoMkSucc (eqToIso hâ‚€) (eqToIso h) (by
      rw [w]
      dsimp [app']
      erw [eqToHom_app, assoc, assoc, eqToHom_trans, eqToHom_refl, comp_id])) this (by
    rintro âŸ¨i, hiâŸ©
    dsimp
    cases' i with i
    Â· erw [homMkSucc_app_zero]
    Â· erw [homMkSucc_app_succ]
      dsimp [app']
      erw [eqToHom_app])","lemma ext_succ {F G : ComposableArrows C (n + 1)} (hâ‚€ : F.obj' 0 = G.obj' 0)
    (h : F.Î´â‚€ = G.Î´â‚€) (w : F.map' 0 1 = eqToHom hâ‚€ â‰« G.map' 0 1 â‰«
      eqToHom (Functor.congr_obj h.symm 0)): F = G  := by
  ext (isoMkSucc (eqToIso hâ‚€) (eqToIso h) (by simp [w])) (fun i => by cases i; assumption) (by",93.7262122631073
mathlib,Mathlib/CategoryTheory/Preadditive/Biproducts.lean,"theorem column_nonzero_of_iso' {Ïƒ Ï„ : Type} [Finite Ï„] {S : Ïƒ â†’ C} [HasBiproduct S]
    {T : Ï„ â†’ C} [HasBiproduct T] (s : Ïƒ) (f : â¨ S âŸ¶ â¨ T) [IsIso f] :
    (âˆ€ t : Ï„, biproduct.Î¹ S s â‰« f â‰« biproduct.Ï€ T t = 0) â†’ ğŸ™ (S s) = 0 ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",3,LENGTH,gpt-4o,True,True,True,10,False,True,,31,True,,2,-0.9354838709677419,"theorem Biproduct.column_nonzero_of_iso' {Ïƒ Ï„ : Type} [Finite Ï„] {S : Ïƒ â†’ C} [HasBiproduct S]
    {T : Ï„ â†’ C} [HasBiproduct T] (s : Ïƒ) (f : â¨ S âŸ¶ â¨ T) [IsIso f] :
    (âˆ€ t : Ï„, biproduct.Î¹ S s â‰« f â‰« biproduct.Ï€ T t = 0) â†’ ğŸ™ (S s) = 0 := by
  cases nonempty_fintype Ï„
  intro z
  have reassoced {t : Ï„} {W : C} (h : _ âŸ¶ W) :
    biproduct.Î¹ S s â‰« f â‰« biproduct.Ï€ T t â‰« h = 0 â‰« h := by
    simp only [â† Category.assoc]
    apply eq_whisker
    simp only [Category.assoc]
    apply z
  set x := biproduct.Î¹ S s â‰« f â‰« inv f â‰« biproduct.Ï€ S s
  have hâ‚ : x = ğŸ™ (S s) := by simp [x]
  have hâ‚€ : x = 0 := by
    dsimp [x]
    rw [â† Category.id_comp (inv f), Category.assoc, â† biproduct.total]
    simp only [comp_sum_assoc]
    conv_lhs =>
      congr
      congr
      next => skip
      intro j; simp only [reassoced]
    simp
  exact hâ‚.symm.trans hâ‚€","theorem column_nonzero_of_iso' {Ïƒ Ï„ : Type} [Finite Ï„] {S : Ïƒ â†’ C} [HasBiproduct S]
    {T : Ï„ â†’ C} [HasBiproduct T] (s : Ïƒ) (f : â¨ S âŸ¶ â¨ T) [IsIso f] :
    (âˆ€ t : Ï„, biproduct.Î¹ S s â‰« f â‰« biproduct.Ï€ T t = 0) â†’ ğŸ™ (S s) = 0  := by
  cases nonempty_fintype Ï„
  intro z
  have : biproduct.Î¹ S s â‰« f â‰« inv f â‰« biproduct.Ï€ S s = 0 := by
    simp [â† Category.id_comp (inv f), Category.assoc, â† biproduct.total, comp_sum_assoc]
    exact Finset.sum_eq_zero (fun j _ => by simp [z j])
  simpa using this


",120.83467102050781
mathlib,Mathlib/CategoryTheory/Preadditive/Biproducts.lean,"theorem Biproduct.column_nonzero_of_iso' {Ïƒ Ï„ : Type} [Finite Ï„] {S : Ïƒ â†’ C} [HasBiproduct S]
    {T : Ï„ â†’ C} [HasBiproduct T] (s : Ïƒ) (f : â¨ S âŸ¶ â¨ T) [IsIso f] :
    (âˆ€ t : Ï„, biproduct.Î¹ S s â‰« f â‰« biproduct.Ï€ T t = 0) â†’ ğŸ™ (S s) = 0 ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",3,LENGTH,gpt-4o,True,True,True,10,False,True,,31,True,,2,-0.9354838709677419,"theorem Biproduct.column_nonzero_of_iso' {Ïƒ Ï„ : Type} [Finite Ï„] {S : Ïƒ â†’ C} [HasBiproduct S]
    {T : Ï„ â†’ C} [HasBiproduct T] (s : Ïƒ) (f : â¨ S âŸ¶ â¨ T) [IsIso f] :
    (âˆ€ t : Ï„, biproduct.Î¹ S s â‰« f â‰« biproduct.Ï€ T t = 0) â†’ ğŸ™ (S s) = 0 := by
  cases nonempty_fintype Ï„
  intro z
  have reassoced {t : Ï„} {W : C} (h : _ âŸ¶ W) :
    biproduct.Î¹ S s â‰« f â‰« biproduct.Ï€ T t â‰« h = 0 â‰« h := by
    simp only [â† Category.assoc]
    apply eq_whisker
    simp only [Category.assoc]
    apply z
  set x := biproduct.Î¹ S s â‰« f â‰« inv f â‰« biproduct.Ï€ S s
  have hâ‚ : x = ğŸ™ (S s) := by simp [x]
  have hâ‚€ : x = 0 := by
    dsimp [x]
    rw [â† Category.id_comp (inv f), Category.assoc, â† biproduct.total]
    simp only [comp_sum_assoc]
    conv_lhs =>
      congr
      congr
      next => skip
      intro j; simp only [reassoced]
    simp
  exact hâ‚.symm.trans hâ‚€","theorem Biproduct.column_nonzero_of_iso' {Ïƒ Ï„ : Type} [Finite Ï„] {S : Ïƒ â†’ C} [HasBiproduct S]
    {T : Ï„ â†’ C} [HasBiproduct T] (s : Ïƒ) (f : â¨ S âŸ¶ â¨ T) [IsIso f] :
    (âˆ€ t : Ï„, biproduct.Î¹ S s â‰« f â‰« biproduct.Ï€ T t = 0) â†’ ğŸ™ (S s) = 0  := by
  cases nonempty_fintype Ï„
  intro z
  set x := biproduct.Î¹ S s â‰« f â‰« inv f â‰« biproduct.Ï€ S s
  have : x = 0 := by
    dsimp [x]
    rw [â† Category.id_comp (inv f), Category.assoc, â† biproduct.total, comp_sum_assoc]
    simp [z]
  simp [x] at this
  exact this",122.28869676589966
