repo,file,decl,method,n,metric,model,annotation,syntax_search,mathlib_search,examples,improved_context,og_correct,og_errors,og_score,new_correct,new_errors,new_score,delta,og_raw,new_raw,time
mathlib,Mathlib/CategoryTheory/Limits/Shapes/Pullbacks.lean,"theorem mono_fst_of_is_pullback_of_mono {t : PullbackCone f g} (ht : IsLimit t) [Mono g] :
    Mono t.fst ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",3,LENGTH,gpt-4o,True,True,True,10,False,True,,5,True,,1,-0.8,"theorem mono_fst_of_is_pullback_of_mono {t : PullbackCone f g} (ht : IsLimit t) [Mono g] :
    Mono t.fst := by
  refine ‚ü®fun {W} h k i => IsLimit.hom_ext ht i ?_‚ü©
  rw [‚Üê cancel_mono g, Category.assoc, Category.assoc, ‚Üê condition]
  have := congrArg (¬∑ ‚â´ f) i; dsimp at this
  rwa [Category.assoc, Category.assoc] at this","theorem mono_fst_of_is_pullback_of_mono {t : PullbackCone f g} (ht : IsLimit t) [Mono g] :
    Mono t.fst  := by
  exact ‚ü®Œª {W} h k i, IsLimit.hom_ext ht i ((cancel_mono g).1 (i.trans condition.symm))‚ü©",102.4380829334259
mathlib,Mathlib/CategoryTheory/Limits/Shapes/Biproducts.lean,"@[simp]
theorem biprod.isoProd_hom {X Y : C} [HasBinaryBiproduct X Y] :
    (biprod.isoProd X Y).hom = prod.lift biprod.fst biprod.snd ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",3,LENGTH,gpt-4o,True,True,True,10,False,True,,5,True,,5,0.0,"@[simp]
theorem biprod.isoProd_hom {X Y : C} [HasBinaryBiproduct X Y] :
    (biprod.isoProd X Y).hom = prod.lift biprod.fst biprod.snd := by
      ext <;> simp [biprod.isoProd]","@[simp]
theorem biprod.isoProd_hom {X Y : C} [HasBinaryBiproduct X Y] :
    (biprod.isoProd X Y).hom = prod.lift biprod.fst biprod.snd := by
      ext <;> simp [biprod.isoProd]",162.52572917938232
mathlib,Mathlib/CategoryTheory/Limits/Shapes/Biproducts.lean,"@[simp]
theorem isoProd_hom {X Y : C} [HasBinaryBiproduct X Y] :
    (biprod.isoProd X Y).hom = prod.lift biprod.fst biprod.snd ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",3,LENGTH,gpt-4o,True,True,True,10,False,True,,5,True,,5,0.0,"@[simp]
theorem biprod.isoProd_hom {X Y : C} [HasBinaryBiproduct X Y] :
    (biprod.isoProd X Y).hom = prod.lift biprod.fst biprod.snd := by
      ext <;> simp [biprod.isoProd]","@[simp]
theorem biprod.isoProd_hom {X Y : C} [HasBinaryBiproduct X Y] :
    (biprod.isoProd X Y).hom = prod.lift biprod.fst biprod.snd := by
      ext <;> simp [biprod.isoProd]",222.76860690116882
mathlib,Mathlib/CategoryTheory/Limits/Shapes/Biproducts.lean,"@[simp]
theorem biprod.isoCoprod_inv {X Y : C} [HasBinaryBiproduct X Y] :
    (biprod.isoCoprod X Y).inv = coprod.desc biprod.inl biprod.inr ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",3,LENGTH,gpt-4o,True,True,True,10,False,True,,5,True,,5,0.0,"@[simp]
theorem biprod.isoCoprod_inv {X Y : C} [HasBinaryBiproduct X Y] :
    (biprod.isoCoprod X Y).inv = coprod.desc biprod.inl biprod.inr := by
  ext <;> simp [biprod.isoCoprod]","@[simp]
theorem biprod.isoCoprod_inv {X Y : C} [HasBinaryBiproduct X Y] :
    (biprod.isoCoprod X Y).inv = coprod.desc biprod.inl biprod.inr := by
  ext <;> simp [biprod.isoCoprod]",230.74454188346863
mathlib,Mathlib/CategoryTheory/Limits/Shapes/Biproducts.lean,"@[simp]
theorem isoCoprod_inv {X Y : C} [HasBinaryBiproduct X Y] :
    (biprod.isoCoprod X Y).inv = coprod.desc biprod.inl biprod.inr ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",3,LENGTH,gpt-4o,True,True,True,10,False,True,,5,True,,5,0.0,"@[simp]
theorem biprod.isoCoprod_inv {X Y : C} [HasBinaryBiproduct X Y] :
    (biprod.isoCoprod X Y).inv = coprod.desc biprod.inl biprod.inr := by
  ext <;> simp [biprod.isoCoprod]","@[simp]
theorem biprod.isoCoprod_inv {X Y : C} [HasBinaryBiproduct X Y] :
    (biprod.isoCoprod X Y).inv = coprod.desc biprod.inl biprod.inr := by
  ext <;> simp [biprod.isoCoprod]",231.04151701927185
mathlib,Mathlib/CategoryTheory/Limits/Shapes/Images.lean,"theorem hasStrongEpiMonoFactorisations_imp_of_isEquivalence (F : C ‚•§ D) [IsEquivalence F]
    [h : HasStrongEpiMonoFactorisations C] : HasStrongEpiMonoFactorisations D ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",3,LENGTH,gpt-4o,True,True,True,10,False,True,,5,True,,1,-0.8,"theorem hasStrongEpiMonoFactorisations_imp_of_isEquivalence (F : C ‚•§ D) [IsEquivalence F]
    [h : HasStrongEpiMonoFactorisations C] : HasStrongEpiMonoFactorisations D :=
  ‚ü®fun {X} {Y} f => by
    let em : StrongEpiMonoFactorisation (F.inv.map f) :=
      (HasStrongEpiMonoFactorisations.has_fac (F.inv.map f)).some
    haveI : Mono (F.map em.m ‚â´ F.asEquivalence.counitIso.hom.app Y) := mono_comp _ _
    haveI : StrongEpi (F.asEquivalence.counitIso.inv.app X ‚â´ F.map em.e) := strongEpi_comp _ _
    exact
      Nonempty.intro
        { I := F.obj em.I
          e := F.asEquivalence.counitIso.inv.app X ‚â´ F.map em.e
          m := F.map em.m ‚â´ F.asEquivalence.counitIso.hom.app Y
          fac := by
            simp only [asEquivalence_functor, Category.assoc, ‚Üê F.map_comp_assoc,
              MonoFactorisation.fac, fun_inv_map, id_obj, Iso.inv_hom_id_app, Category.comp_id,
              Iso.inv_hom_id_app_assoc] }‚ü©","theorem hasStrongEpiMonoFactorisations_imp_of_isEquivalence (F : C ‚•§ D) [IsEquivalence F]
    [h : HasStrongEpiMonoFactorisations C] : HasStrongEpiMonoFactorisations D  := by
  intro X Y f
  let em := Classical.choice (h.has_fac (F.inv.map f))
  exact ‚ü®{ I := F.obj em.I,",116.160227060318
mathlib,Mathlib/CategoryTheory/Limits/Shapes/Kernels.lean,"@[reassoc]
theorem kernelComparison_comp_kernel_map {X' Y' : C} [HasKernel f] [HasKernel (G.map f)]
    (g : X' ‚ü∂ Y') [HasKernel g] [HasKernel (G.map g)] (p : X ‚ü∂ X') (q : Y ‚ü∂ Y')
    (hpq : f ‚â´ q = p ‚â´ g) :
    kernelComparison f G ‚â´
        kernel.map (G.map f) (G.map g) (G.map p) (G.map q) (by rw [‚Üê G.map_comp, hpq, G.map_comp]) =
      G.map (kernel.map f g p q hpq) ‚â´ kernelComparison g G ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",3,LENGTH,gpt-4o,True,True,True,10,False,True,,5,True,,3,-0.4,"@[reassoc]
theorem kernelComparison_comp_kernel_map {X' Y' : C} [HasKernel f] [HasKernel (G.map f)]
    (g : X' ‚ü∂ Y') [HasKernel g] [HasKernel (G.map g)] (p : X ‚ü∂ X') (q : Y ‚ü∂ Y')
    (hpq : f ‚â´ q = p ‚â´ g) :
    kernelComparison f G ‚â´
        kernel.map (G.map f) (G.map g) (G.map p) (G.map q) (by rw [‚Üê G.map_comp, hpq, G.map_comp]) =
      G.map (kernel.map f g p q hpq) ‚â´ kernelComparison g G :=
  kernel.lift_map _ _ (by rw [‚Üê G.map_comp, kernel.condition, G.map_zero]) _ _
    (by rw [‚Üê G.map_comp, kernel.condition, G.map_zero]) _ _ _
    (by simp only [‚Üê G.map_comp]; exact G.congr_map (kernel.lift_Œπ _ _ _).symm) _","@[reassoc]
theorem kernelComparison_comp_kernel_map {X' Y' : C} [HasKernel f] [HasKernel (G.map f)]
    (g : X' ‚ü∂ Y') [HasKernel g] [HasKernel (G.map g)] (p : X ‚ü∂ X') (q : Y ‚ü∂ Y')
    (hpq : f ‚â´ q = p ‚â´ g) :
    kernelComparison f G ‚â´
        kernel.map (G.map f) (G.map g) (G.map p) (G.map q) (by rw [‚Üê G.map_comp, hpq, G.map_comp]) =
      G.map (kernel.map f g p q hpq) ‚â´ kernelComparison g G  := by
  ext; simp",139.46618509292603
mathlib,Mathlib/CategoryTheory/Limits/Shapes/Kernels.lean,"@[reassoc]
theorem cokernel_map_comp_cokernelComparison {X' Y' : C} [HasCokernel f] [HasCokernel (G.map f)]
    (g : X' ‚ü∂ Y') [HasCokernel g] [HasCokernel (G.map g)] (p : X ‚ü∂ X') (q : Y ‚ü∂ Y')
    (hpq : f ‚â´ q = p ‚â´ g) :
    cokernel.map (G.map f) (G.map g) (G.map p) (G.map q) (by rw [‚Üê G.map_comp, hpq, G.map_comp]) ‚â´
        cokernelComparison _ G =
      cokernelComparison _ G ‚â´ G.map (cokernel.map f g p q hpq) ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",3,LENGTH,gpt-4o,True,True,True,10,False,True,,5,True,,5,0.0,"@[reassoc]
theorem cokernel_map_comp_cokernelComparison {X' Y' : C} [HasCokernel f] [HasCokernel (G.map f)]
    (g : X' ‚ü∂ Y') [HasCokernel g] [HasCokernel (G.map g)] (p : X ‚ü∂ X') (q : Y ‚ü∂ Y')
    (hpq : f ‚â´ q = p ‚â´ g) :
    cokernel.map (G.map f) (G.map g) (G.map p) (G.map q) (by rw [‚Üê G.map_comp, hpq, G.map_comp]) ‚â´
        cokernelComparison _ G =
      cokernelComparison _ G ‚â´ G.map (cokernel.map f g p q hpq) :=
  cokernel.map_desc _ _ (by rw [‚Üê G.map_comp, cokernel.condition, G.map_zero]) _ _
    (by rw [‚Üê G.map_comp, cokernel.condition, G.map_zero]) _ _ _ _
    (by simp only [‚Üê G.map_comp]; exact G.congr_map (cokernel.œÄ_desc _ _ _))","@[reassoc]
theorem cokernel_map_comp_cokernelComparison {X' Y' : C} [HasCokernel f] [HasCokernel (G.map f)]
    (g : X' ‚ü∂ Y') [HasCokernel g] [HasCokernel (G.map g)] (p : X ‚ü∂ X') (q : Y ‚ü∂ Y')
    (hpq : f ‚â´ q = p ‚â´ g) :
    cokernel.map (G.map f) (G.map g) (G.map p) (G.map q) (by rw [‚Üê G.map_comp, hpq, G.map_comp]) ‚â´
        cokernelComparison _ G =
      cokernelComparison _ G ‚â´ G.map (cokernel.map f g p q hpq) :=
  cokernel.map_desc _ _ (by rw [‚Üê G.map_comp, cokernel.condition, G.map_zero]) _ _
    (by rw [‚Üê G.map_comp, cokernel.condition, G.map_zero]) _ _ _ _
    (by simp only [‚Üê G.map_comp]; exact G.congr_map (cokernel.œÄ_desc _ _ _))",141.63741779327393
mathlib,Mathlib/CategoryTheory/Preadditive/Biproducts.lean,"/-- In any preadditive category, any binary biproduct satsifies
`biprod.fst ‚â´ biprod.inl + biprod.snd ‚â´ biprod.inr = ùüô (X ‚äû Y)`.
-/
@[simp]
theorem total : biprod.fst ‚â´ biprod.inl + biprod.snd ‚â´ biprod.inr = ùüô (X ‚äû Y) ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",3,LENGTH,gpt-4o,True,True,True,10,False,True,,5,True,,5,0.0,"/-- In any preadditive category, any binary biproduct satsifies
`biprod.fst ‚â´ biprod.inl + biprod.snd ‚â´ biprod.inr = ùüô (X ‚äû Y)`.
-/
@[simp]
theorem biprod.total : biprod.fst ‚â´ biprod.inl + biprod.snd ‚â´ biprod.inr = ùüô (X ‚äû Y) := by
  ext <;> simp [add_comp]","/-- In any preadditive category, any binary biproduct satsifies
`biprod.fst ‚â´ biprod.inl + biprod.snd ‚â´ biprod.inr = ùüô (X ‚äû Y)`.
-/
@[simp]
theorem biprod.total : biprod.fst ‚â´ biprod.inl + biprod.snd ‚â´ biprod.inr = ùüô (X ‚äû Y) := by
  ext <;> simp [add_comp]",50.553678035736084
mathlib,Mathlib/CategoryTheory/Preadditive/Biproducts.lean,"/-- In any preadditive category, any binary biproduct satsifies
`biprod.fst ‚â´ biprod.inl + biprod.snd ‚â´ biprod.inr = ùüô (X ‚äû Y)`.
-/
@[simp]
theorem biprod.total : biprod.fst ‚â´ biprod.inl + biprod.snd ‚â´ biprod.inr = ùüô (X ‚äû Y) ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",3,LENGTH,gpt-4o,True,True,True,10,False,True,,5,True,,5,0.0,"/-- In any preadditive category, any binary biproduct satsifies
`biprod.fst ‚â´ biprod.inl + biprod.snd ‚â´ biprod.inr = ùüô (X ‚äû Y)`.
-/
@[simp]
theorem biprod.total : biprod.fst ‚â´ biprod.inl + biprod.snd ‚â´ biprod.inr = ùüô (X ‚äû Y) := by
  ext <;> simp [add_comp]","/-- In any preadditive category, any binary biproduct satsifies
`biprod.fst ‚â´ biprod.inl + biprod.snd ‚â´ biprod.inr = ùüô (X ‚äû Y)`.
-/
@[simp]
theorem biprod.total : biprod.fst ‚â´ biprod.inl + biprod.snd ‚â´ biprod.inr = ùüô (X ‚äû Y) := by
  ext <;> simp [add_comp]",50.798112869262695
mathlib,Mathlib/CategoryTheory/Preadditive/Biproducts.lean,"theorem biprod.map_eq [HasBinaryBiproducts C] {W X Y Z : C} {f : W ‚ü∂ Y} {g : X ‚ü∂ Z} :
    biprod.map f g = biprod.fst ‚â´ f ‚â´ biprod.inl + biprod.snd ‚â´ g ‚â´ biprod.inr ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",3,LENGTH,gpt-4o,True,True,True,10,False,True,,5,True,,5,0.0,"theorem biprod.map_eq [HasBinaryBiproducts C] {W X Y Z : C} {f : W ‚ü∂ Y} {g : X ‚ü∂ Z} :
    biprod.map f g = biprod.fst ‚â´ f ‚â´ biprod.inl + biprod.snd ‚â´ g ‚â´ biprod.inr := by
  ext <;> simp","theorem biprod.map_eq [HasBinaryBiproducts C] {W X Y Z : C} {f : W ‚ü∂ Y} {g : X ‚ü∂ Z} :
    biprod.map f g = biprod.fst ‚â´ f ‚â´ biprod.inl + biprod.snd ‚â´ g ‚â´ biprod.inr := by
  ext <;> simp",53.889188051223755
mathlib,Mathlib/CategoryTheory/Preadditive/Biproducts.lean,"theorem map_eq [HasBinaryBiproducts C] {W X Y Z : C} {f : W ‚ü∂ Y} {g : X ‚ü∂ Z} :
    biprod.map f g = biprod.fst ‚â´ f ‚â´ biprod.inl + biprod.snd ‚â´ g ‚â´ biprod.inr ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",3,LENGTH,gpt-4o,True,True,True,10,False,True,,5,True,,5,0.0,"theorem biprod.map_eq [HasBinaryBiproducts C] {W X Y Z : C} {f : W ‚ü∂ Y} {g : X ‚ü∂ Z} :
    biprod.map f g = biprod.fst ‚â´ f ‚â´ biprod.inl + biprod.snd ‚â´ g ‚â´ biprod.inr := by
  ext <;> simp","theorem biprod.map_eq [HasBinaryBiproducts C] {W X Y Z : C} {f : W ‚ü∂ Y} {g : X ‚ü∂ Z} :
    biprod.map f g = biprod.fst ‚â´ f ‚â´ biprod.inl + biprod.snd ‚â´ g ‚â´ biprod.inr := by
  ext <;> simp",59.90295886993408
mathlib,Mathlib/CategoryTheory/Preadditive/Biproducts.lean,"@[simp]
theorem Biprod.ofComponents_eq (f : X‚ÇÅ ‚äû X‚ÇÇ ‚ü∂ Y‚ÇÅ ‚äû Y‚ÇÇ) :
    Biprod.ofComponents (biprod.inl ‚â´ f ‚â´ biprod.fst) (biprod.inl ‚â´ f ‚â´ biprod.snd)
        (biprod.inr ‚â´ f ‚â´ biprod.fst) (biprod.inr ‚â´ f ‚â´ biprod.snd) =
      f ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",3,LENGTH,gpt-4o,True,True,True,10,False,True,,5,True,,5,0.0,"@[simp]
theorem Biprod.ofComponents_eq (f : X‚ÇÅ ‚äû X‚ÇÇ ‚ü∂ Y‚ÇÅ ‚äû Y‚ÇÇ) :
    Biprod.ofComponents (biprod.inl ‚â´ f ‚â´ biprod.fst) (biprod.inl ‚â´ f ‚â´ biprod.snd)
        (biprod.inr ‚â´ f ‚â´ biprod.fst) (biprod.inr ‚â´ f ‚â´ biprod.snd) =
      f := by
  ext <;>
    simp only [Category.comp_id, biprod.inr_fst, biprod.inr_snd, biprod.inl_snd, add_zero, zero_add,
      Biprod.inl_ofComponents, Biprod.inr_ofComponents, eq_self_iff_true, Category.assoc,
      comp_zero, biprod.inl_fst, Preadditive.add_comp]","@[simp]
theorem Biprod.ofComponents_eq (f : X‚ÇÅ ‚äû X‚ÇÇ ‚ü∂ Y‚ÇÅ ‚äû Y‚ÇÇ) :
    Biprod.ofComponents (biprod.inl ‚â´ f ‚â´ biprod.fst) (biprod.inl ‚â´ f ‚â´ biprod.snd)
        (biprod.inr ‚â´ f ‚â´ biprod.fst) (biprod.inr ‚â´ f ‚â´ biprod.snd) =
      f := by
  ext <;>
    simp only [Category.comp_id, biprod.inr_fst, biprod.inr_snd, biprod.inl_snd, add_zero, zero_add,
      Biprod.inl_ofComponents, Biprod.inr_ofComponents, eq_self_iff_true, Category.assoc,
      comp_zero, biprod.inl_fst, Preadditive.add_comp]",111.77027916908264
mathlib,Mathlib/CategoryTheory/Preadditive/Biproducts.lean,"@[simp]
theorem ofComponents_eq (f : X‚ÇÅ ‚äû X‚ÇÇ ‚ü∂ Y‚ÇÅ ‚äû Y‚ÇÇ) :
    Biprod.ofComponents (biprod.inl ‚â´ f ‚â´ biprod.fst) (biprod.inl ‚â´ f ‚â´ biprod.snd)
        (biprod.inr ‚â´ f ‚â´ biprod.fst) (biprod.inr ‚â´ f ‚â´ biprod.snd) =
      f ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",3,LENGTH,gpt-4o,True,True,True,10,False,True,,5,True,,5,0.0,"@[simp]
theorem Biprod.ofComponents_eq (f : X‚ÇÅ ‚äû X‚ÇÇ ‚ü∂ Y‚ÇÅ ‚äû Y‚ÇÇ) :
    Biprod.ofComponents (biprod.inl ‚â´ f ‚â´ biprod.fst) (biprod.inl ‚â´ f ‚â´ biprod.snd)
        (biprod.inr ‚â´ f ‚â´ biprod.fst) (biprod.inr ‚â´ f ‚â´ biprod.snd) =
      f := by
  ext <;>
    simp only [Category.comp_id, biprod.inr_fst, biprod.inr_snd, biprod.inl_snd, add_zero, zero_add,
      Biprod.inl_ofComponents, Biprod.inr_ofComponents, eq_self_iff_true, Category.assoc,
      comp_zero, biprod.inl_fst, Preadditive.add_comp]","@[simp]
theorem Biprod.ofComponents_eq (f : X‚ÇÅ ‚äû X‚ÇÇ ‚ü∂ Y‚ÇÅ ‚äû Y‚ÇÇ) :
    Biprod.ofComponents (biprod.inl ‚â´ f ‚â´ biprod.fst) (biprod.inl ‚â´ f ‚â´ biprod.snd)
        (biprod.inr ‚â´ f ‚â´ biprod.fst) (biprod.inr ‚â´ f ‚â´ biprod.snd) =
      f := by
  ext <;>
    simp only [Category.comp_id, biprod.inr_fst, biprod.inr_snd, biprod.inl_snd, add_zero, zero_add,
      Biprod.inl_ofComponents, Biprod.inr_ofComponents, eq_self_iff_true, Category.assoc,
      comp_zero, biprod.inl_fst, Preadditive.add_comp]",113.79707288742065
mathlib,Mathlib/CategoryTheory/ComposableArrows.lean,lemma map_id (i : Fin (n + 1 + 1)) : map F f i i (by simp) = ùüô _ ,"refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",3,LENGTH,gpt-4o,True,True,True,10,False,True,,5,True,,5,0.0,"lemma map_id (i : Fin (n + 1 + 1)) : map F f i i (by simp) = ùüô _ := by
  obtain ‚ü®i, hi‚ü© := i
  cases i
  ¬∑ rfl
  ¬∑ apply F.map_id","lemma map_id (i : Fin (n + 1 + 1)) : map F f i i (by simp) = ùüô _ := by
  obtain ‚ü®i, hi‚ü© := i
  cases i
  ¬∑ rfl
  ¬∑ apply F.map_id",102.12432408332825
mathlib,Mathlib/CategoryTheory/ComposableArrows.lean,"lemma hom_ext_succ {F G : ComposableArrows C (n + 1)} {f g : F ‚ü∂ G}
    (h‚ÇÄ : app' f 0 = app' g 0) (h‚ÇÅ : Œ¥‚ÇÄFunctor.map f = Œ¥‚ÇÄFunctor.map g) : f = g ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",3,LENGTH,gpt-4o,True,True,True,10,False,True,,5,True,,5,0.0,"lemma hom_ext_succ {F G : ComposableArrows C (n + 1)} {f g : F ‚ü∂ G}
    (h‚ÇÄ : app' f 0 = app' g 0) (h‚ÇÅ : Œ¥‚ÇÄFunctor.map f = Œ¥‚ÇÄFunctor.map g) : f = g := by
  ext ‚ü®i, hi‚ü©
  obtain _ | i := i
  ¬∑ exact h‚ÇÄ
  ¬∑ exact congr_app h‚ÇÅ ‚ü®i, by valid‚ü©","lemma hom_ext_succ {F G : ComposableArrows C (n + 1)} {f g : F ‚ü∂ G}
    (h‚ÇÄ : app' f 0 = app' g 0) (h‚ÇÅ : Œ¥‚ÇÄFunctor.map f = Œ¥‚ÇÄFunctor.map g) : f = g := by
  ext ‚ü®i, hi‚ü©
  obtain _ | i := i
  ¬∑ exact h‚ÇÄ
  ¬∑ exact congr_app h‚ÇÅ ‚ü®i, by valid‚ü©",120.04502725601196
mathlib,Mathlib/CategoryTheory/ComposableArrows.lean,"lemma mk‚ÇÖ_surjective (X : ComposableArrows C 5) :
    ‚àÉ (X‚ÇÄ X‚ÇÅ X‚ÇÇ X‚ÇÉ X‚ÇÑ X‚ÇÖ : C) (f‚ÇÄ : X‚ÇÄ ‚ü∂ X‚ÇÅ) (f‚ÇÅ : X‚ÇÅ ‚ü∂ X‚ÇÇ) (f‚ÇÇ : X‚ÇÇ ‚ü∂ X‚ÇÉ)
      (f‚ÇÉ : X‚ÇÉ ‚ü∂ X‚ÇÑ) (f‚ÇÑ : X‚ÇÑ ‚ü∂ X‚ÇÖ), X = mk‚ÇÖ f‚ÇÄ f‚ÇÅ f‚ÇÇ f‚ÇÉ f‚ÇÑ ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",3,LENGTH,gpt-4o,True,True,True,10,False,True,,5,True,,5,0.0,"lemma mk‚ÇÖ_surjective (X : ComposableArrows C 5) :
    ‚àÉ (X‚ÇÄ X‚ÇÅ X‚ÇÇ X‚ÇÉ X‚ÇÑ X‚ÇÖ : C) (f‚ÇÄ : X‚ÇÄ ‚ü∂ X‚ÇÅ) (f‚ÇÅ : X‚ÇÅ ‚ü∂ X‚ÇÇ) (f‚ÇÇ : X‚ÇÇ ‚ü∂ X‚ÇÉ)
      (f‚ÇÉ : X‚ÇÉ ‚ü∂ X‚ÇÑ) (f‚ÇÑ : X‚ÇÑ ‚ü∂ X‚ÇÖ), X = mk‚ÇÖ f‚ÇÄ f‚ÇÅ f‚ÇÇ f‚ÇÉ f‚ÇÑ :=
  ‚ü®_, _, _, _, _, _, X.map' 0 1, X.map' 1 2, X.map' 2 3, X.map' 3 4, X.map' 4 5,
    ext‚ÇÖ rfl rfl rfl rfl rfl rfl (by simp) (by simp) (by simp) (by simp) (by simp)‚ü©","lemma mk‚ÇÖ_surjective (X : ComposableArrows C 5) :
    ‚àÉ (X‚ÇÄ X‚ÇÅ X‚ÇÇ X‚ÇÉ X‚ÇÑ X‚ÇÖ : C) (f‚ÇÄ : X‚ÇÄ ‚ü∂ X‚ÇÅ) (f‚ÇÅ : X‚ÇÅ ‚ü∂ X‚ÇÇ) (f‚ÇÇ : X‚ÇÇ ‚ü∂ X‚ÇÉ)
      (f‚ÇÉ : X‚ÇÉ ‚ü∂ X‚ÇÑ) (f‚ÇÑ : X‚ÇÑ ‚ü∂ X‚ÇÖ), X = mk‚ÇÖ f‚ÇÄ f‚ÇÅ f‚ÇÇ f‚ÇÉ f‚ÇÑ :=
  ‚ü®_, _, _, _, _, _, X.map' 0 1, X.map' 1 2, X.map' 2 3, X.map' 3 4, X.map' 4 5,
    ext‚ÇÖ rfl rfl rfl rfl rfl rfl (by simp) (by simp) (by simp) (by simp) (by simp)‚ü©",237.08714699745178
mathlib,Mathlib/CategoryTheory/Limits/Shapes/Kernels.lean," theorem isIso_Œπ {X Y : C} {f : X ‚ü∂ Y} (c : KernelFork f)
    (hc : IsLimit c) (hf : f = 0) : IsIso c.Œπ ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",3,LENGTH,gpt-4o,True,True,True,10,False,True,,6,True,,1,-0.8333333333333334,"lemma KernelFork.IsLimit.isIso_Œπ {X Y : C} {f : X ‚ü∂ Y} (c : KernelFork f)
    (hc : IsLimit c) (hf : f = 0) : IsIso c.Œπ := by
  let e : c.pt ‚âÖ X := IsLimit.conePointUniqueUpToIso hc
    (KernelFork.IsLimit.ofId (f : X ‚ü∂ Y) hf)
  have eq : e.inv ‚â´ c.Œπ = ùüô X := Fork.IsLimit.lift_Œπ hc
  haveI : IsIso (e.inv ‚â´ c.Œπ) := by
    rw [eq]
    infer_instance
  exact IsIso.of_isIso_comp_left e.inv c.Œπ"," theorem isIso_Œπ {X Y : C} {f : X ‚ü∂ Y} (c : KernelFork f)
    (hc : IsLimit c) (hf : f = 0) : IsIso c.Œπ  := by
  let e : c.pt ‚âÖ X := IsLimit.conePointUniqueUpToIso hc (KernelFork.IsLimit.ofId f hf)
  have : e.inv ‚â´ c.Œπ = ùüô X := Fork.IsLimit.lift_Œπ hc",40.453701972961426
mathlib,Mathlib/CategoryTheory/Limits/Shapes/Kernels.lean,"lemma KernelFork.IsLimit.isIso_Œπ {X Y : C} {f : X ‚ü∂ Y} (c : KernelFork f)
    (hc : IsLimit c) (hf : f = 0) : IsIso c.Œπ ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",3,LENGTH,gpt-4o,True,True,True,10,False,True,,6,True,,1,-0.8333333333333334,"lemma KernelFork.IsLimit.isIso_Œπ {X Y : C} {f : X ‚ü∂ Y} (c : KernelFork f)
    (hc : IsLimit c) (hf : f = 0) : IsIso c.Œπ := by
  let e : c.pt ‚âÖ X := IsLimit.conePointUniqueUpToIso hc
    (KernelFork.IsLimit.ofId (f : X ‚ü∂ Y) hf)
  have eq : e.inv ‚â´ c.Œπ = ùüô X := Fork.IsLimit.lift_Œπ hc
  haveI : IsIso (e.inv ‚â´ c.Œπ) := by
    rw [eq]
    infer_instance
  exact IsIso.of_isIso_comp_left e.inv c.Œπ","lemma KernelFork.IsLimit.isIso_Œπ {X Y : C} {f : X ‚ü∂ Y} (c : KernelFork f)
    (hc : IsLimit c) (hf : f = 0) : IsIso c.Œπ  := by
  let e : c.pt ‚âÖ X := IsLimit.conePointUniqueUpToIso hc (KernelFork.IsLimit.ofId f hf)
  have : e.inv ‚â´ c.Œπ = ùüô X := Fork.IsLimit.lift_Œπ hc",42.00815391540527
mathlib,Mathlib/CategoryTheory/Preadditive/Biproducts.lean,"theorem inl_of_isLimit {X Y : C} {t : BinaryBicone X Y} (ht : IsLimit t.toCone) :
    t.inl = ht.lift (BinaryFan.mk (ùüô X) 0) ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",3,LENGTH,gpt-4o,True,True,True,10,False,True,,6,True,,6,0.0,"theorem inl_of_isLimit {X Y : C} {t : BinaryBicone X Y} (ht : IsLimit t.toCone) :
    t.inl = ht.lift (BinaryFan.mk (ùüô X) 0) := by
  apply ht.uniq (BinaryFan.mk (ùüô X) 0); rintro ‚ü®‚ü®‚ü©‚ü© <;> dsimp <;> simp","theorem inl_of_isLimit {X Y : C} {t : BinaryBicone X Y} (ht : IsLimit t.toCone) :
    t.inl = ht.lift (BinaryFan.mk (ùüô X) 0) := by
  apply ht.uniq (BinaryFan.mk (ùüô X) 0); rintro ‚ü®‚ü®‚ü©‚ü© <;> dsimp <;> simp",44.42605996131897
mathlib,Mathlib/CategoryTheory/Preadditive/Biproducts.lean,"theorem inr_of_isLimit {X Y : C} {t : BinaryBicone X Y} (ht : IsLimit t.toCone) :
    t.inr = ht.lift (BinaryFan.mk 0 (ùüô Y)) ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",3,LENGTH,gpt-4o,True,True,True,10,False,True,,6,True,,6,0.0,"theorem inr_of_isLimit {X Y : C} {t : BinaryBicone X Y} (ht : IsLimit t.toCone) :
    t.inr = ht.lift (BinaryFan.mk 0 (ùüô Y)) := by
  apply ht.uniq (BinaryFan.mk 0 (ùüô Y)); rintro ‚ü®‚ü®‚ü©‚ü© <;> dsimp <;> simp","theorem inr_of_isLimit {X Y : C} {t : BinaryBicone X Y} (ht : IsLimit t.toCone) :
    t.inr = ht.lift (BinaryFan.mk 0 (ùüô Y)) := by
  apply ht.uniq (BinaryFan.mk 0 (ùüô Y)); rintro ‚ü®‚ü®‚ü©‚ü© <;> dsimp <;> simp",47.52415490150452
mathlib,Mathlib/CategoryTheory/Preadditive/Biproducts.lean,"theorem snd_of_isColimit {X Y : C} {t : BinaryBicone X Y} (ht : IsColimit t.toCocone) :
    t.snd = ht.desc (BinaryCofan.mk 0 (ùüô Y)) ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",3,LENGTH,gpt-4o,True,True,True,10,False,True,,6,True,,6,0.0,"theorem snd_of_isColimit {X Y : C} {t : BinaryBicone X Y} (ht : IsColimit t.toCocone) :
    t.snd = ht.desc (BinaryCofan.mk 0 (ùüô Y)) := by
  apply ht.uniq (BinaryCofan.mk 0 (ùüô Y))
  rintro ‚ü®‚ü®‚ü©‚ü© <;> dsimp <;> simp","theorem snd_of_isColimit {X Y : C} {t : BinaryBicone X Y} (ht : IsColimit t.toCocone) :
    t.snd = ht.desc (BinaryCofan.mk 0 (ùüô Y)) := by
  apply ht.uniq (BinaryCofan.mk 0 (ùüô Y))
  rintro ‚ü®‚ü®‚ü©‚ü© <;> dsimp <;> simp",51.01223921775818
mathlib,Mathlib/CategoryTheory/Preadditive/Biproducts.lean,"theorem fst_of_isColimit {X Y : C} {t : BinaryBicone X Y} (ht : IsColimit t.toCocone) :
    t.fst = ht.desc (BinaryCofan.mk (ùüô X) 0) ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",3,LENGTH,gpt-4o,True,True,True,10,False,True,,6,True,,6,0.0,"theorem fst_of_isColimit {X Y : C} {t : BinaryBicone X Y} (ht : IsColimit t.toCocone) :
    t.fst = ht.desc (BinaryCofan.mk (ùüô X) 0) := by
  apply ht.uniq (BinaryCofan.mk (ùüô X) 0)
  rintro ‚ü®‚ü®‚ü©‚ü© <;> dsimp <;> simp","theorem fst_of_isColimit {X Y : C} {t : BinaryBicone X Y} (ht : IsColimit t.toCocone) :
    t.fst = ht.desc (BinaryCofan.mk (ùüô X) 0) := by
  apply ht.uniq (BinaryCofan.mk (ùüô X) 0)
  rintro ‚ü®‚ü®‚ü©‚ü© <;> dsimp <;> simp",51.406461238861084
mathlib,Mathlib/CategoryTheory/Preadditive/Biproducts.lean,"@[simp]
theorem Biprod.ofComponents_comp {X‚ÇÅ X‚ÇÇ Y‚ÇÅ Y‚ÇÇ Z‚ÇÅ Z‚ÇÇ : C} (f‚ÇÅ‚ÇÅ : X‚ÇÅ ‚ü∂ Y‚ÇÅ) (f‚ÇÅ‚ÇÇ : X‚ÇÅ ‚ü∂ Y‚ÇÇ)
    (f‚ÇÇ‚ÇÅ : X‚ÇÇ ‚ü∂ Y‚ÇÅ) (f‚ÇÇ‚ÇÇ : X‚ÇÇ ‚ü∂ Y‚ÇÇ) (g‚ÇÅ‚ÇÅ : Y‚ÇÅ ‚ü∂ Z‚ÇÅ) (g‚ÇÅ‚ÇÇ : Y‚ÇÅ ‚ü∂ Z‚ÇÇ) (g‚ÇÇ‚ÇÅ : Y‚ÇÇ ‚ü∂ Z‚ÇÅ)
    (g‚ÇÇ‚ÇÇ : Y‚ÇÇ ‚ü∂ Z‚ÇÇ) :
    Biprod.ofComponents f‚ÇÅ‚ÇÅ f‚ÇÅ‚ÇÇ f‚ÇÇ‚ÇÅ f‚ÇÇ‚ÇÇ ‚â´ Biprod.ofComponents g‚ÇÅ‚ÇÅ g‚ÇÅ‚ÇÇ g‚ÇÇ‚ÇÅ g‚ÇÇ‚ÇÇ =
      Biprod.ofComponents (f‚ÇÅ‚ÇÅ ‚â´ g‚ÇÅ‚ÇÅ + f‚ÇÅ‚ÇÇ ‚â´ g‚ÇÇ‚ÇÅ) (f‚ÇÅ‚ÇÅ ‚â´ g‚ÇÅ‚ÇÇ + f‚ÇÅ‚ÇÇ ‚â´ g‚ÇÇ‚ÇÇ) (f‚ÇÇ‚ÇÅ ‚â´ g‚ÇÅ‚ÇÅ + f‚ÇÇ‚ÇÇ ‚â´ g‚ÇÇ‚ÇÅ)
        (f‚ÇÇ‚ÇÅ ‚â´ g‚ÇÅ‚ÇÇ + f‚ÇÇ‚ÇÇ ‚â´ g‚ÇÇ‚ÇÇ) ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",3,LENGTH,gpt-4o,True,True,True,10,False,True,,6,True,,5,-0.16666666666666666,"@[simp]
theorem Biprod.ofComponents_comp {X‚ÇÅ X‚ÇÇ Y‚ÇÅ Y‚ÇÇ Z‚ÇÅ Z‚ÇÇ : C} (f‚ÇÅ‚ÇÅ : X‚ÇÅ ‚ü∂ Y‚ÇÅ) (f‚ÇÅ‚ÇÇ : X‚ÇÅ ‚ü∂ Y‚ÇÇ)
    (f‚ÇÇ‚ÇÅ : X‚ÇÇ ‚ü∂ Y‚ÇÅ) (f‚ÇÇ‚ÇÇ : X‚ÇÇ ‚ü∂ Y‚ÇÇ) (g‚ÇÅ‚ÇÅ : Y‚ÇÅ ‚ü∂ Z‚ÇÅ) (g‚ÇÅ‚ÇÇ : Y‚ÇÅ ‚ü∂ Z‚ÇÇ) (g‚ÇÇ‚ÇÅ : Y‚ÇÇ ‚ü∂ Z‚ÇÅ)
    (g‚ÇÇ‚ÇÇ : Y‚ÇÇ ‚ü∂ Z‚ÇÇ) :
    Biprod.ofComponents f‚ÇÅ‚ÇÅ f‚ÇÅ‚ÇÇ f‚ÇÇ‚ÇÅ f‚ÇÇ‚ÇÇ ‚â´ Biprod.ofComponents g‚ÇÅ‚ÇÅ g‚ÇÅ‚ÇÇ g‚ÇÇ‚ÇÅ g‚ÇÇ‚ÇÇ =
      Biprod.ofComponents (f‚ÇÅ‚ÇÅ ‚â´ g‚ÇÅ‚ÇÅ + f‚ÇÅ‚ÇÇ ‚â´ g‚ÇÇ‚ÇÅ) (f‚ÇÅ‚ÇÅ ‚â´ g‚ÇÅ‚ÇÇ + f‚ÇÅ‚ÇÇ ‚â´ g‚ÇÇ‚ÇÇ) (f‚ÇÇ‚ÇÅ ‚â´ g‚ÇÅ‚ÇÅ + f‚ÇÇ‚ÇÇ ‚â´ g‚ÇÇ‚ÇÅ)
        (f‚ÇÇ‚ÇÅ ‚â´ g‚ÇÅ‚ÇÇ + f‚ÇÇ‚ÇÇ ‚â´ g‚ÇÇ‚ÇÇ) := by
  dsimp [Biprod.ofComponents]
  ext <;>
    simp only [add_comp, comp_add, add_comp_assoc, add_zero, zero_add, biprod.inl_fst,
      biprod.inl_snd, biprod.inr_fst, biprod.inr_snd, biprod.inl_fst_assoc, biprod.inl_snd_assoc,
      biprod.inr_fst_assoc, biprod.inr_snd_assoc, comp_zero, zero_comp, Category.assoc]","@[simp]
theorem Biprod.ofComponents_comp {X‚ÇÅ X‚ÇÇ Y‚ÇÅ Y‚ÇÇ Z‚ÇÅ Z‚ÇÇ : C} (f‚ÇÅ‚ÇÅ : X‚ÇÅ ‚ü∂ Y‚ÇÅ) (f‚ÇÅ‚ÇÇ : X‚ÇÅ ‚ü∂ Y‚ÇÇ)
    (f‚ÇÇ‚ÇÅ : X‚ÇÇ ‚ü∂ Y‚ÇÅ) (f‚ÇÇ‚ÇÇ : X‚ÇÇ ‚ü∂ Y‚ÇÇ) (g‚ÇÅ‚ÇÅ : Y‚ÇÅ ‚ü∂ Z‚ÇÅ) (g‚ÇÅ‚ÇÇ : Y‚ÇÅ ‚ü∂ Z‚ÇÇ) (g‚ÇÇ‚ÇÅ : Y‚ÇÇ ‚ü∂ Z‚ÇÅ)
    (g‚ÇÇ‚ÇÇ : Y‚ÇÇ ‚ü∂ Z‚ÇÇ) :
    Biprod.ofComponents f‚ÇÅ‚ÇÅ f‚ÇÅ‚ÇÇ f‚ÇÇ‚ÇÅ f‚ÇÇ‚ÇÇ ‚â´ Biprod.ofComponents g‚ÇÅ‚ÇÅ g‚ÇÅ‚ÇÇ g‚ÇÇ‚ÇÅ g‚ÇÇ‚ÇÇ =
      Biprod.ofComponents (f‚ÇÅ‚ÇÅ ‚â´ g‚ÇÅ‚ÇÅ + f‚ÇÅ‚ÇÇ ‚â´ g‚ÇÇ‚ÇÅ) (f‚ÇÅ‚ÇÅ ‚â´ g‚ÇÅ‚ÇÇ + f‚ÇÅ‚ÇÇ ‚â´ g‚ÇÇ‚ÇÇ) (f‚ÇÇ‚ÇÅ ‚â´ g‚ÇÅ‚ÇÅ + f‚ÇÇ‚ÇÇ ‚â´ g‚ÇÇ‚ÇÅ)
        (f‚ÇÇ‚ÇÅ ‚â´ g‚ÇÅ‚ÇÇ + f‚ÇÇ‚ÇÇ ‚â´ g‚ÇÇ‚ÇÇ)  := by
  ext <;> simp [Biprod.ofComponents, add_comp, comp_add, Category.assoc]",136.257826089859
mathlib,Mathlib/CategoryTheory/Preadditive/Biproducts.lean,"@[simp]
theorem ofComponents_comp {X‚ÇÅ X‚ÇÇ Y‚ÇÅ Y‚ÇÇ Z‚ÇÅ Z‚ÇÇ : C} (f‚ÇÅ‚ÇÅ : X‚ÇÅ ‚ü∂ Y‚ÇÅ) (f‚ÇÅ‚ÇÇ : X‚ÇÅ ‚ü∂ Y‚ÇÇ)
    (f‚ÇÇ‚ÇÅ : X‚ÇÇ ‚ü∂ Y‚ÇÅ) (f‚ÇÇ‚ÇÇ : X‚ÇÇ ‚ü∂ Y‚ÇÇ) (g‚ÇÅ‚ÇÅ : Y‚ÇÅ ‚ü∂ Z‚ÇÅ) (g‚ÇÅ‚ÇÇ : Y‚ÇÅ ‚ü∂ Z‚ÇÇ) (g‚ÇÇ‚ÇÅ : Y‚ÇÇ ‚ü∂ Z‚ÇÅ)
    (g‚ÇÇ‚ÇÇ : Y‚ÇÇ ‚ü∂ Z‚ÇÇ) :
    Biprod.ofComponents f‚ÇÅ‚ÇÅ f‚ÇÅ‚ÇÇ f‚ÇÇ‚ÇÅ f‚ÇÇ‚ÇÇ ‚â´ Biprod.ofComponents g‚ÇÅ‚ÇÅ g‚ÇÅ‚ÇÇ g‚ÇÇ‚ÇÅ g‚ÇÇ‚ÇÇ =
      Biprod.ofComponents (f‚ÇÅ‚ÇÅ ‚â´ g‚ÇÅ‚ÇÅ + f‚ÇÅ‚ÇÇ ‚â´ g‚ÇÇ‚ÇÅ) (f‚ÇÅ‚ÇÅ ‚â´ g‚ÇÅ‚ÇÇ + f‚ÇÅ‚ÇÇ ‚â´ g‚ÇÇ‚ÇÇ) (f‚ÇÇ‚ÇÅ ‚â´ g‚ÇÅ‚ÇÅ + f‚ÇÇ‚ÇÇ ‚â´ g‚ÇÇ‚ÇÅ)
        (f‚ÇÇ‚ÇÅ ‚â´ g‚ÇÅ‚ÇÇ + f‚ÇÇ‚ÇÇ ‚â´ g‚ÇÇ‚ÇÇ) ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",3,LENGTH,gpt-4o,True,True,True,10,False,True,,6,True,,5,-0.16666666666666666,"@[simp]
theorem Biprod.ofComponents_comp {X‚ÇÅ X‚ÇÇ Y‚ÇÅ Y‚ÇÇ Z‚ÇÅ Z‚ÇÇ : C} (f‚ÇÅ‚ÇÅ : X‚ÇÅ ‚ü∂ Y‚ÇÅ) (f‚ÇÅ‚ÇÇ : X‚ÇÅ ‚ü∂ Y‚ÇÇ)
    (f‚ÇÇ‚ÇÅ : X‚ÇÇ ‚ü∂ Y‚ÇÅ) (f‚ÇÇ‚ÇÇ : X‚ÇÇ ‚ü∂ Y‚ÇÇ) (g‚ÇÅ‚ÇÅ : Y‚ÇÅ ‚ü∂ Z‚ÇÅ) (g‚ÇÅ‚ÇÇ : Y‚ÇÅ ‚ü∂ Z‚ÇÇ) (g‚ÇÇ‚ÇÅ : Y‚ÇÇ ‚ü∂ Z‚ÇÅ)
    (g‚ÇÇ‚ÇÇ : Y‚ÇÇ ‚ü∂ Z‚ÇÇ) :
    Biprod.ofComponents f‚ÇÅ‚ÇÅ f‚ÇÅ‚ÇÇ f‚ÇÇ‚ÇÅ f‚ÇÇ‚ÇÇ ‚â´ Biprod.ofComponents g‚ÇÅ‚ÇÅ g‚ÇÅ‚ÇÇ g‚ÇÇ‚ÇÅ g‚ÇÇ‚ÇÇ =
      Biprod.ofComponents (f‚ÇÅ‚ÇÅ ‚â´ g‚ÇÅ‚ÇÅ + f‚ÇÅ‚ÇÇ ‚â´ g‚ÇÇ‚ÇÅ) (f‚ÇÅ‚ÇÅ ‚â´ g‚ÇÅ‚ÇÇ + f‚ÇÅ‚ÇÇ ‚â´ g‚ÇÇ‚ÇÇ) (f‚ÇÇ‚ÇÅ ‚â´ g‚ÇÅ‚ÇÅ + f‚ÇÇ‚ÇÇ ‚â´ g‚ÇÇ‚ÇÅ)
        (f‚ÇÇ‚ÇÅ ‚â´ g‚ÇÅ‚ÇÇ + f‚ÇÇ‚ÇÇ ‚â´ g‚ÇÇ‚ÇÇ) := by
  dsimp [Biprod.ofComponents]
  ext <;>
    simp only [add_comp, comp_add, add_comp_assoc, add_zero, zero_add, biprod.inl_fst,
      biprod.inl_snd, biprod.inr_fst, biprod.inr_snd, biprod.inl_fst_assoc, biprod.inl_snd_assoc,
      biprod.inr_fst_assoc, biprod.inr_snd_assoc, comp_zero, zero_comp, Category.assoc]","@[simp]
theorem ofComponents_comp {X‚ÇÅ X‚ÇÇ Y‚ÇÅ Y‚ÇÇ Z‚ÇÅ Z‚ÇÇ : C} (f‚ÇÅ‚ÇÅ : X‚ÇÅ ‚ü∂ Y‚ÇÅ) (f‚ÇÅ‚ÇÇ : X‚ÇÅ ‚ü∂ Y‚ÇÇ)
    (f‚ÇÇ‚ÇÅ : X‚ÇÇ ‚ü∂ Y‚ÇÅ) (f‚ÇÇ‚ÇÇ : X‚ÇÇ ‚ü∂ Y‚ÇÇ) (g‚ÇÅ‚ÇÅ : Y‚ÇÅ ‚ü∂ Z‚ÇÅ) (g‚ÇÅ‚ÇÇ : Y‚ÇÅ ‚ü∂ Z‚ÇÇ) (g‚ÇÇ‚ÇÅ : Y‚ÇÇ ‚ü∂ Z‚ÇÅ)
    (g‚ÇÇ‚ÇÇ : Y‚ÇÇ ‚ü∂ Z‚ÇÇ) :
    Biprod.ofComponents f‚ÇÅ‚ÇÅ f‚ÇÅ‚ÇÇ f‚ÇÇ‚ÇÅ f‚ÇÇ‚ÇÇ ‚â´ Biprod.ofComponents g‚ÇÅ‚ÇÅ g‚ÇÅ‚ÇÇ g‚ÇÇ‚ÇÅ g‚ÇÇ‚ÇÇ =
      Biprod.ofComponents (f‚ÇÅ‚ÇÅ ‚â´ g‚ÇÅ‚ÇÅ + f‚ÇÅ‚ÇÇ ‚â´ g‚ÇÇ‚ÇÅ) (f‚ÇÅ‚ÇÅ ‚â´ g‚ÇÅ‚ÇÇ + f‚ÇÅ‚ÇÇ ‚â´ g‚ÇÇ‚ÇÇ) (f‚ÇÇ‚ÇÅ ‚â´ g‚ÇÅ‚ÇÅ + f‚ÇÇ‚ÇÇ ‚â´ g‚ÇÇ‚ÇÅ)
        (f‚ÇÇ‚ÇÅ ‚â´ g‚ÇÅ‚ÇÇ + f‚ÇÇ‚ÇÇ ‚â´ g‚ÇÇ‚ÇÇ)  := by
  ext <;> simp [Biprod.ofComponents, comp_add, add_comp, Category.assoc]",139.33663988113403
mathlib,Mathlib/CategoryTheory/Limits/Shapes/Biproducts.lean,"theorem biprod.isIso_inl_iff_id_eq_fst_comp_inl (X Y : C) [HasBinaryBiproduct X Y] :
    IsIso (biprod.inl : X ‚ü∂ X ‚äû Y) ‚Üî ùüô (X ‚äû Y) = biprod.fst ‚â´ biprod.inl ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",3,LENGTH,gpt-4o,True,True,True,10,False,True,,7,True,,2,-0.7142857142857143,"theorem biprod.isIso_inl_iff_id_eq_fst_comp_inl (X Y : C) [HasBinaryBiproduct X Y] :
    IsIso (biprod.inl : X ‚ü∂ X ‚äû Y) ‚Üî ùüô (X ‚äû Y) = biprod.fst ‚â´ biprod.inl := by
  constructor
  ¬∑ intro h
    have := (cancel_epi (inv biprod.inl : X ‚äû Y ‚ü∂ X)).2 <| @biprod.inl_fst _ _ _ X Y _
    rw [IsIso.inv_hom_id_assoc, Category.comp_id] at this
    rw [this, IsIso.inv_hom_id]
  ¬∑ intro h
    exact ‚ü®‚ü®biprod.fst, biprod.inl_fst, h.symm‚ü©‚ü©","    IsIso (biprod.inl : X ‚ü∂ X ‚äû Y) ‚Üî ùüô (X ‚äû Y) = biprod.fst ‚â´ biprod.inl  := by
  constructor
  ¬∑ intro h
    have := (cancel_epi (inv biprod.inl)).2 biprod.inl_fst
    rw [IsIso.inv_hom_id_assoc, Category.comp_id] at this
    rw [this, IsIso.inv_hom_id]
  ¬∑ exact Œª h => ‚ü®‚ü®biprod.fst, biprod.inl_fst, h.symm‚ü©‚ü©




",200.41464495658875
mathlib,Mathlib/CategoryTheory/Limits/Shapes/Kernels.lean,"lemma CokernelCofork.IsColimit.isIso_œÄ {X Y : C} {f : X ‚ü∂ Y} (c : CokernelCofork f)
    (hc : IsColimit c) (hf : f = 0) : IsIso c.œÄ ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",3,LENGTH,gpt-4o,True,True,True,10,False,True,,7,True,,7,0.0,"lemma CokernelCofork.IsColimit.isIso_œÄ {X Y : C} {f : X ‚ü∂ Y} (c : CokernelCofork f)
    (hc : IsColimit c) (hf : f = 0) : IsIso c.œÄ := by
  let e : c.pt ‚âÖ Y := IsColimit.coconePointUniqueUpToIso hc
    (CokernelCofork.IsColimit.ofId (f : X ‚ü∂ Y) hf)
  have eq : c.œÄ ‚â´ e.hom = ùüô Y := Cofork.IsColimit.œÄ_desc hc
  haveI : IsIso (c.œÄ ‚â´ e.hom) := by
    rw [eq]
    dsimp
    infer_instance
  exact IsIso.of_isIso_comp_right c.œÄ e.hom","lemma CokernelCofork.IsColimit.isIso_œÄ {X Y : C} {f : X ‚ü∂ Y} (c : CokernelCofork f)
    (hc : IsColimit c) (hf : f = 0) : IsIso c.œÄ := by
  let e : c.pt ‚âÖ Y := IsColimit.coconePointUniqueUpToIso hc
    (CokernelCofork.IsColimit.ofId (f : X ‚ü∂ Y) hf)
  have eq : c.œÄ ‚â´ e.hom = ùüô Y := Cofork.IsColimit.œÄ_desc hc
  haveI : IsIso (c.œÄ ‚â´ e.hom) := by
    rw [eq]
    dsimp
    infer_instance
  exact IsIso.of_isIso_comp_right c.œÄ e.hom",99.57002687454224
mathlib,Mathlib/CategoryTheory/Limits/Shapes/Biproducts.lean,"theorem isIso_inl_iff_id_eq_fst_comp_inl (X Y : C) [HasBinaryBiproduct X Y] :
    IsIso (biprod.inl : X ‚ü∂ X ‚äû Y) ‚Üî ùüô (X ‚äû Y) = biprod.fst ‚â´ biprod.inl ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",3,LENGTH,gpt-4o,True,True,True,10,False,True,,7,True,,2,-0.7142857142857143,"theorem biprod.isIso_inl_iff_id_eq_fst_comp_inl (X Y : C) [HasBinaryBiproduct X Y] :
    IsIso (biprod.inl : X ‚ü∂ X ‚äû Y) ‚Üî ùüô (X ‚äû Y) = biprod.fst ‚â´ biprod.inl := by
  constructor
  ¬∑ intro h
    have := (cancel_epi (inv biprod.inl : X ‚äû Y ‚ü∂ X)).2 <| @biprod.inl_fst _ _ _ X Y _
    rw [IsIso.inv_hom_id_assoc, Category.comp_id] at this
    rw [this, IsIso.inv_hom_id]
  ¬∑ intro h
    exact ‚ü®‚ü®biprod.fst, biprod.inl_fst, h.symm‚ü©‚ü©","    IsIso (biprod.inl : X ‚ü∂ X ‚äû Y) ‚Üî ùüô (X ‚äû Y) = biprod.fst ‚â´ biprod.inl  := by
  constructor
  intro h
  have : biprod.fst = inv biprod.inl := (cancel_epi biprod.inl).1 biprod.inl_fst
  simpa using this
  exact ‚ü®‚ü®biprod.fst, biprod.inl_fst, h.symm‚ü©‚ü©




",195.44091701507568
mathlib,Mathlib/CategoryTheory/Limits/Shapes/Biproducts.lean,"/-- If
```
(f 0)
(0 g)
```
is invertible, then `f` is invertible.
-/
theorem isIso_left_of_isIso_biprod_map {W X Y Z : C} (f : W ‚ü∂ Y) (g : X ‚ü∂ Z)
    [IsIso (biprod.map f g)] : IsIso f ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",3,LENGTH,gpt-4o,True,True,True,10,False,True,,7,True,,7,0.0,"/-- If
```
(f 0)
(0 g)
```
is invertible, then `f` is invertible.
-/
theorem isIso_left_of_isIso_biprod_map {W X Y Z : C} (f : W ‚ü∂ Y) (g : X ‚ü∂ Z)
    [IsIso (biprod.map f g)] : IsIso f :=
  ‚ü®‚ü®biprod.inl ‚â´ inv (biprod.map f g) ‚â´ biprod.fst,
      ‚ü®by
        have t := congrArg (fun p : W ‚äû X ‚ü∂ W ‚äû X => biprod.inl ‚â´ p ‚â´ biprod.fst)
          (IsIso.hom_inv_id (biprod.map f g))
        simp only [Category.id_comp, Category.assoc, biprod.inl_map_assoc] at t
        simp [t], by
        have t := congrArg (fun p : Y ‚äû Z ‚ü∂ Y ‚äû Z => biprod.inl ‚â´ p ‚â´ biprod.fst)
          (IsIso.inv_hom_id (biprod.map f g))
        simp only [Category.id_comp, Category.assoc, biprod.map_fst] at t
        simp only [Category.assoc]
        simp [t]‚ü©‚ü©‚ü©","/-- If
```
(f 0)
(0 g)
```
is invertible, then `f` is invertible.
-/
theorem isIso_left_of_isIso_biprod_map {W X Y Z : C} (f : W ‚ü∂ Y) (g : X ‚ü∂ Z)
    [IsIso (biprod.map f g)] : IsIso f :=
  ‚ü®‚ü®biprod.inl ‚â´ inv (biprod.map f g) ‚â´ biprod.fst,
      ‚ü®by
        have t := congrArg (fun p : W ‚äû X ‚ü∂ W ‚äû X => biprod.inl ‚â´ p ‚â´ biprod.fst)
          (IsIso.hom_inv_id (biprod.map f g))
        simp only [Category.id_comp, Category.assoc, biprod.inl_map_assoc] at t
        simp [t], by
        have t := congrArg (fun p : Y ‚äû Z ‚ü∂ Y ‚äû Z => biprod.inl ‚â´ p ‚â´ biprod.fst)
          (IsIso.inv_hom_id (biprod.map f g))
        simp only [Category.id_comp, Category.assoc, biprod.map_fst] at t
        simp only [Category.assoc]
        simp [t]‚ü©‚ü©‚ü©",228.24665212631226
mathlib,Mathlib/CategoryTheory/Limits/Shapes/Images.lean,"/-- The two step comparison map
  `image (f ‚â´ (g ‚â´ h)) ‚ü∂ image (g ‚â´ h) ‚ü∂ image h`
agrees with the one step comparison map
  `image (f ‚â´ (g ‚â´ h)) ‚âÖ image ((f ‚â´ g) ‚â´ h) ‚ü∂ image h`.
 -/
theorem preComp_comp {W : C} (h : Z ‚ü∂ W) [HasImage (g ‚â´ h)] [HasImage (f ‚â´ g ‚â´ h)]
    [HasImage h] [HasImage ((f ‚â´ g) ‚â´ h)] :
    image.preComp f (g ‚â´ h) ‚â´ image.preComp g h =
      image.eqToHom (Category.assoc f g h).symm ‚â´ image.preComp (f ‚â´ g) h ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",3,LENGTH,gpt-4o,True,True,True,10,False,True,,7,True,,7,0.0,"/-- The two step comparison map
  `image (f ‚â´ (g ‚â´ h)) ‚ü∂ image (g ‚â´ h) ‚ü∂ image h`
agrees with the one step comparison map
  `image (f ‚â´ (g ‚â´ h)) ‚âÖ image ((f ‚â´ g) ‚â´ h) ‚ü∂ image h`.
 -/
theorem image.preComp_comp {W : C} (h : Z ‚ü∂ W) [HasImage (g ‚â´ h)] [HasImage (f ‚â´ g ‚â´ h)]
    [HasImage h] [HasImage ((f ‚â´ g) ‚â´ h)] :
    image.preComp f (g ‚â´ h) ‚â´ image.preComp g h =
      image.eqToHom (Category.assoc f g h).symm ‚â´ image.preComp (f ‚â´ g) h := by
  apply (cancel_mono (image.Œπ h)).1
  dsimp [image.preComp, image.eqToHom]
  repeat (rw [Category.assoc,image.lift_fac])
  rw [image.lift_fac,image.lift_fac]","/-- The two step comparison map
  `image (f ‚â´ (g ‚â´ h)) ‚ü∂ image (g ‚â´ h) ‚ü∂ image h`
agrees with the one step comparison map
  `image (f ‚â´ (g ‚â´ h)) ‚âÖ image ((f ‚â´ g) ‚â´ h) ‚ü∂ image h`.
 -/
theorem image.preComp_comp {W : C} (h : Z ‚ü∂ W) [HasImage (g ‚â´ h)] [HasImage (f ‚â´ g ‚â´ h)]
    [HasImage h] [HasImage ((f ‚â´ g) ‚â´ h)] :
    image.preComp f (g ‚â´ h) ‚â´ image.preComp g h =
      image.eqToHom (Category.assoc f g h).symm ‚â´ image.preComp (f ‚â´ g) h := by
  apply (cancel_mono (image.Œπ h)).1
  dsimp [image.preComp, image.eqToHom]
  repeat (rw [Category.assoc,image.lift_fac])
  rw [image.lift_fac,image.lift_fac]",55.635396242141724
mathlib,Mathlib/CategoryTheory/Limits/Shapes/Images.lean,"/-- The two step comparison map
  `image (f ‚â´ (g ‚â´ h)) ‚ü∂ image (g ‚â´ h) ‚ü∂ image h`
agrees with the one step comparison map
  `image (f ‚â´ (g ‚â´ h)) ‚âÖ image ((f ‚â´ g) ‚â´ h) ‚ü∂ image h`.
 -/
theorem image.preComp_comp {W : C} (h : Z ‚ü∂ W) [HasImage (g ‚â´ h)] [HasImage (f ‚â´ g ‚â´ h)]
    [HasImage h] [HasImage ((f ‚â´ g) ‚â´ h)] :
    image.preComp f (g ‚â´ h) ‚â´ image.preComp g h =
      image.eqToHom (Category.assoc f g h).symm ‚â´ image.preComp (f ‚â´ g) h ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",3,LENGTH,gpt-4o,True,True,True,10,False,True,,7,True,,7,0.0,"/-- The two step comparison map
  `image (f ‚â´ (g ‚â´ h)) ‚ü∂ image (g ‚â´ h) ‚ü∂ image h`
agrees with the one step comparison map
  `image (f ‚â´ (g ‚â´ h)) ‚âÖ image ((f ‚â´ g) ‚â´ h) ‚ü∂ image h`.
 -/
theorem image.preComp_comp {W : C} (h : Z ‚ü∂ W) [HasImage (g ‚â´ h)] [HasImage (f ‚â´ g ‚â´ h)]
    [HasImage h] [HasImage ((f ‚â´ g) ‚â´ h)] :
    image.preComp f (g ‚â´ h) ‚â´ image.preComp g h =
      image.eqToHom (Category.assoc f g h).symm ‚â´ image.preComp (f ‚â´ g) h := by
  apply (cancel_mono (image.Œπ h)).1
  dsimp [image.preComp, image.eqToHom]
  repeat (rw [Category.assoc,image.lift_fac])
  rw [image.lift_fac,image.lift_fac]","/-- The two step comparison map
  `image (f ‚â´ (g ‚â´ h)) ‚ü∂ image (g ‚â´ h) ‚ü∂ image h`
agrees with the one step comparison map
  `image (f ‚â´ (g ‚â´ h)) ‚âÖ image ((f ‚â´ g) ‚â´ h) ‚ü∂ image h`.
 -/
theorem image.preComp_comp {W : C} (h : Z ‚ü∂ W) [HasImage (g ‚â´ h)] [HasImage (f ‚â´ g ‚â´ h)]
    [HasImage h] [HasImage ((f ‚â´ g) ‚â´ h)] :
    image.preComp f (g ‚â´ h) ‚â´ image.preComp g h =
      image.eqToHom (Category.assoc f g h).symm ‚â´ image.preComp (f ‚â´ g) h := by
  apply (cancel_mono (image.Œπ h)).1
  dsimp [image.preComp, image.eqToHom]
  repeat (rw [Category.assoc,image.lift_fac])
  rw [image.lift_fac,image.lift_fac]",59.73315095901489
mathlib,Mathlib/CategoryTheory/Limits/Shapes/Kernels.lean," theorem isIso_œÄ {X Y : C} {f : X ‚ü∂ Y} (c : CokernelCofork f)
    (hc : IsColimit c) (hf : f = 0) : IsIso c.œÄ ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",3,LENGTH,gpt-4o,True,True,True,10,False,True,,7,True,,1,-0.8571428571428571,"lemma CokernelCofork.IsColimit.isIso_œÄ {X Y : C} {f : X ‚ü∂ Y} (c : CokernelCofork f)
    (hc : IsColimit c) (hf : f = 0) : IsIso c.œÄ := by
  let e : c.pt ‚âÖ Y := IsColimit.coconePointUniqueUpToIso hc
    (CokernelCofork.IsColimit.ofId (f : X ‚ü∂ Y) hf)
  have eq : c.œÄ ‚â´ e.hom = ùüô Y := Cofork.IsColimit.œÄ_desc hc
  haveI : IsIso (c.œÄ ‚â´ e.hom) := by
    rw [eq]
    dsimp
    infer_instance
  exact IsIso.of_isIso_comp_right c.œÄ e.hom"," theorem isIso_œÄ {X Y : C} {f : X ‚ü∂ Y} (c : CokernelCofork f)
    (hc : IsColimit c) (hf : f = 0) : IsIso c.œÄ  := by
  let e : c.pt ‚âÖ Y := IsColimit.coconePointUniqueUpToIso hc (CokernelCofork.IsColimit.ofId f hf)
  have : c.œÄ ‚â´ e.hom = ùüô Y := Cofork.IsColimit.œÄ_desc hc",76.49467396736145
mathlib,Mathlib/CategoryTheory/Limits/Shapes/Images.lean,"/-- The morphism `m` in a factorisation `f = e ‚â´ m` through a monomorphism is uniquely
determined. -/
@[ext]
theorem ext {F F' : MonoFactorisation f} (hI : F.I = F'.I)
    (hm : F.m = eqToHom hI ‚â´ F'.m) : F = F' ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",3,LENGTH,gpt-4o,True,True,True,10,False,True,,8,True,,8,0.0,"/-- The morphism `m` in a factorisation `f = e ‚â´ m` through a monomorphism is uniquely
determined. -/
@[ext]
theorem ext {F F' : MonoFactorisation f} (hI : F.I = F'.I)
    (hm : F.m = eqToHom hI ‚â´ F'.m) : F = F' := by
  cases' F with _ Fm _ _ Ffac; cases' F' with _ Fm' _ _ Ffac'
  cases' hI
  simp? at hm says simp only [eqToHom_refl, Category.id_comp] at hm
  congr
  apply (cancel_mono Fm).1
  rw [Ffac, hm, Ffac']","/-- The morphism `m` in a factorisation `f = e ‚â´ m` through a monomorphism is uniquely
determined. -/
@[ext]
theorem ext {F F' : MonoFactorisation f} (hI : F.I = F'.I)
    (hm : F.m = eqToHom hI ‚â´ F'.m) : F = F' := by
  cases' F with _ Fm _ _ Ffac; cases' F' with _ Fm' _ _ Ffac'
  cases' hI
  simp? at hm says simp only [eqToHom_refl, Category.id_comp] at hm
  congr
  apply (cancel_mono Fm).1
  rw [Ffac, hm, Ffac']",20.140652894973755
mathlib,Mathlib/CategoryTheory/ComposableArrows.lean,"lemma ext‚ÇÅ {F G : ComposableArrows C 1}
    (left : F.left = G.left) (right : F.right = G.right)
    (w : F.hom = eqToHom left ‚â´ G.hom ‚â´ eqToHom right.symm) : F = G ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",3,LENGTH,gpt-4o,True,True,True,10,False,True,,7,True,,1,-0.8571428571428571,"lemma ext‚ÇÅ {F G : ComposableArrows C 1}
    (left : F.left = G.left) (right : F.right = G.right)
    (w : F.hom = eqToHom left ‚â´ G.hom ‚â´ eqToHom right.symm) : F = G :=
  Functor.ext_of_iso (isoMk‚ÇÅ (eqToIso left) (eqToIso right) (by simp [map'_eq_hom‚ÇÅ, w]))
    (fun i => by fin_cases i <;> assumption)
    (fun i => by fin_cases i <;> rfl)","lemma ext‚ÇÅ {F G : ComposableArrows C 1}
    (left : F.left = G.left) (right : F.right = G.right)
    (w : F.hom = eqToHom left ‚â´ G.hom ‚â´ eqToHom right.symm) : F = G  := by
  ext (by fin_cases i <;> rfl) (by simp [map'_eq_hom‚ÇÅ, w])",64.00994396209717
mathlib,Mathlib/CategoryTheory/Localization/CalculusOfFractions.lean,"lemma map_comp_map_eq_map {X Y Z : C} (z‚ÇÅ : W.LeftFraction X Y) (z‚ÇÇ : W.LeftFraction Y Z)
    (z‚ÇÉ : W.LeftFraction z‚ÇÅ.Y' z‚ÇÇ.Y') (h‚ÇÉ : z‚ÇÇ.f ‚â´ z‚ÇÉ.s = z‚ÇÅ.s ‚â´ z‚ÇÉ.f)
    (L : C ‚•§ D) [L.IsLocalization W] :
    z‚ÇÅ.map L (Localization.inverts L W) ‚â´ z‚ÇÇ.map L (Localization.inverts L W) =
      (z‚ÇÅ.comp‚ÇÄ z‚ÇÇ z‚ÇÉ).map L (Localization.inverts L W) ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",3,LENGTH,gpt-4o,True,True,True,10,False,True,,7,True,,7,0.0,"lemma map_comp_map_eq_map {X Y Z : C} (z‚ÇÅ : W.LeftFraction X Y) (z‚ÇÇ : W.LeftFraction Y Z)
    (z‚ÇÉ : W.LeftFraction z‚ÇÅ.Y' z‚ÇÇ.Y') (h‚ÇÉ : z‚ÇÇ.f ‚â´ z‚ÇÉ.s = z‚ÇÅ.s ‚â´ z‚ÇÉ.f)
    (L : C ‚•§ D) [L.IsLocalization W] :
    z‚ÇÅ.map L (Localization.inverts L W) ‚â´ z‚ÇÇ.map L (Localization.inverts L W) =
      (z‚ÇÅ.comp‚ÇÄ z‚ÇÇ z‚ÇÉ).map L (Localization.inverts L W) := by
  have := Localization.inverts L W _ z‚ÇÇ.hs
  have := Localization.inverts L W _ z‚ÇÉ.hs
  have : IsIso (L.map (z‚ÇÇ.s ‚â´ z‚ÇÉ.s)) := by
    rw [L.map_comp]
    infer_instance
  dsimp [LeftFraction.comp‚ÇÄ]
  rw [‚Üê cancel_mono (L.map (z‚ÇÇ.s ‚â´ z‚ÇÉ.s)), map_comp_map_s,
    L.map_comp, assoc, map_comp_map_s_assoc, ‚Üê L.map_comp, h‚ÇÉ,
    L.map_comp, map_comp_map_s_assoc, L.map_comp]","lemma map_comp_map_eq_map {X Y Z : C} (z‚ÇÅ : W.LeftFraction X Y) (z‚ÇÇ : W.LeftFraction Y Z)
    (z‚ÇÉ : W.LeftFraction z‚ÇÅ.Y' z‚ÇÇ.Y') (h‚ÇÉ : z‚ÇÇ.f ‚â´ z‚ÇÉ.s = z‚ÇÅ.s ‚â´ z‚ÇÉ.f)
    (L : C ‚•§ D) [L.IsLocalization W] :
    z‚ÇÅ.map L (Localization.inverts L W) ‚â´ z‚ÇÇ.map L (Localization.inverts L W) =
      (z‚ÇÅ.comp‚ÇÄ z‚ÇÇ z‚ÇÉ).map L (Localization.inverts L W) := by
  have := Localization.inverts L W _ z‚ÇÇ.hs
  have := Localization.inverts L W _ z‚ÇÉ.hs
  have : IsIso (L.map (z‚ÇÇ.s ‚â´ z‚ÇÉ.s)) := by
    rw [L.map_comp]
    infer_instance
  dsimp [LeftFraction.comp‚ÇÄ]
  rw [‚Üê cancel_mono (L.map (z‚ÇÇ.s ‚â´ z‚ÇÉ.s)), map_comp_map_s,
    L.map_comp, assoc, map_comp_map_s_assoc, ‚Üê L.map_comp, h‚ÇÉ,
    L.map_comp, map_comp_map_s_assoc, L.map_comp]",145.69540786743164
mathlib,Mathlib/CategoryTheory/Localization/CalculusOfFractions.lean,"lemma map_eq_iff {X Y : C} (f g : LeftFraction W X Y) :
    f.map (LeftFraction.Localization.Q W) (Localization.inverts _ _) =
        g.map (LeftFraction.Localization.Q W) (Localization.inverts _ _) ‚Üî
      LeftFractionRel f g ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",3,LENGTH,gpt-4o,True,True,True,10,False,True,,8,True,,8,0.0,"lemma map_eq_iff {X Y : C} (f g : LeftFraction W X Y) :
    f.map (LeftFraction.Localization.Q W) (Localization.inverts _ _) =
        g.map (LeftFraction.Localization.Q W) (Localization.inverts _ _) ‚Üî
      LeftFractionRel f g := by
  simp only [‚Üê Hom.map_mk _ (Q W)]
  constructor
  ¬∑ intro h
    rw [‚Üê homMk_eq_iff_leftFractionRel, homMk_eq, homMk_eq]
    exact h
  ¬∑ intro h
    congr 1
    exact Quot.sound h","lemma map_eq_iff {X Y : C} (f g : LeftFraction W X Y) :
    f.map (LeftFraction.Localization.Q W) (Localization.inverts _ _) =
        g.map (LeftFraction.Localization.Q W) (Localization.inverts _ _) ‚Üî
      LeftFractionRel f g := by
  simp only [‚Üê Hom.map_mk _ (Q W)]
  constructor
  ¬∑ intro h
    rw [‚Üê homMk_eq_iff_leftFractionRel, homMk_eq, homMk_eq]
    exact h
  ¬∑ intro h
    congr 1
    exact Quot.sound h",221.69150710105896
mathlib,Mathlib/CategoryTheory/Localization/CalculusOfFractions.lean," theorem exists_leftFraction {X Y : C} (f : L.obj X ‚ü∂ L.obj Y) :
    ‚àÉ (œÜ : W.LeftFraction X Y), f = œÜ.map L (Localization.inverts L W) ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",3,LENGTH,gpt-4o,True,True,True,10,False,True,,8,True,,7,-0.125,"lemma Localization.exists_leftFraction {X Y : C} (f : L.obj X ‚ü∂ L.obj Y) :
    ‚àÉ (œÜ : W.LeftFraction X Y), f = œÜ.map L (Localization.inverts L W) := by
  let E := Localization.uniq (MorphismProperty.LeftFraction.Localization.Q W) L W
  let e : _ ‚ãô E.functor ‚âÖ L := Localization.compUniqFunctor _ _ _
  obtain ‚ü®f', rfl‚ü© : ‚àÉ (f' : E.functor.obj X ‚ü∂ E.functor.obj Y),
      f = e.inv.app _ ‚â´ f' ‚â´ e.hom.app _ := ‚ü®e.hom.app _ ‚â´ f ‚â´ e.inv.app _, by simp‚ü©
  obtain ‚ü®g, rfl‚ü© := E.functor.map_surjective f'
  obtain ‚ü®g, rfl‚ü© := MorphismProperty.LeftFraction.Localization.Hom.mk_surjective g
  refine ‚ü®g, ?_‚ü©
  rw [‚Üê MorphismProperty.LeftFraction.Localization.homMk_eq_hom_mk,
    MorphismProperty.LeftFraction.Localization.homMk_eq g,
    g.map_compatibility (MorphismProperty.LeftFraction.Localization.Q W) L,
    assoc, assoc, Iso.inv_hom_id_app, comp_id, Iso.inv_hom_id_app_assoc]"," theorem exists_leftFraction {X Y : C} (f : L.obj X ‚ü∂ L.obj Y) :
    ‚àÉ (œÜ : W.LeftFraction X Y), f = œÜ.map L (Localization.inverts L W)  := by
  let E := Localization.uniq (MorphismProperty.LeftFraction.Localization.Q W) L W
  let e : _ ‚ãô E.functor ‚âÖ L := Localization.compUniqFunctor _ _ _
  obtain ‚ü®g, rfl‚ü© := E.functor.map_surjective (E.functor.map g) where ‚ü®g', rfl‚ü© := MorphismProperty.LeftFraction.Localization.Hom.mk_surjective (E.functor.map _)‚ü©
  exact ‚ü®g, by rw [‚Üê MorphismProperty.LeftFraction.Localization.homMk_eq_hom_mk,
  MorphismProperty.LeftFraction.Localization.homMk_eq g,
  g.map_compatibility (MorphismProperty.LeftFraction.Localization.Q W) L,
  assoc, assoc, Iso.inv_hom_id_app, comp_id, Iso.inv_hom_id_app_assoc]‚ü©




",239.59367179870605
mathlib,Mathlib/CategoryTheory/Localization/CalculusOfFractions.lean,"lemma Localization.exists_leftFraction {X Y : C} (f : L.obj X ‚ü∂ L.obj Y) :
    ‚àÉ (œÜ : W.LeftFraction X Y), f = œÜ.map L (Localization.inverts L W) ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",3,LENGTH,gpt-4o,True,True,True,10,False,True,,8,True,,8,0.0,"lemma Localization.exists_leftFraction {X Y : C} (f : L.obj X ‚ü∂ L.obj Y) :
    ‚àÉ (œÜ : W.LeftFraction X Y), f = œÜ.map L (Localization.inverts L W) := by
  let E := Localization.uniq (MorphismProperty.LeftFraction.Localization.Q W) L W
  let e : _ ‚ãô E.functor ‚âÖ L := Localization.compUniqFunctor _ _ _
  obtain ‚ü®f', rfl‚ü© : ‚àÉ (f' : E.functor.obj X ‚ü∂ E.functor.obj Y),
      f = e.inv.app _ ‚â´ f' ‚â´ e.hom.app _ := ‚ü®e.hom.app _ ‚â´ f ‚â´ e.inv.app _, by simp‚ü©
  obtain ‚ü®g, rfl‚ü© := E.functor.map_surjective f'
  obtain ‚ü®g, rfl‚ü© := MorphismProperty.LeftFraction.Localization.Hom.mk_surjective g
  refine ‚ü®g, ?_‚ü©
  rw [‚Üê MorphismProperty.LeftFraction.Localization.homMk_eq_hom_mk,
    MorphismProperty.LeftFraction.Localization.homMk_eq g,
    g.map_compatibility (MorphismProperty.LeftFraction.Localization.Q W) L,
    assoc, assoc, Iso.inv_hom_id_app, comp_id, Iso.inv_hom_id_app_assoc]","lemma Localization.exists_leftFraction {X Y : C} (f : L.obj X ‚ü∂ L.obj Y) :
    ‚àÉ (œÜ : W.LeftFraction X Y), f = œÜ.map L (Localization.inverts L W) := by
  let E := Localization.uniq (MorphismProperty.LeftFraction.Localization.Q W) L W
  let e : _ ‚ãô E.functor ‚âÖ L := Localization.compUniqFunctor _ _ _
  obtain ‚ü®f', rfl‚ü© : ‚àÉ (f' : E.functor.obj X ‚ü∂ E.functor.obj Y),
      f = e.inv.app _ ‚â´ f' ‚â´ e.hom.app _ := ‚ü®e.hom.app _ ‚â´ f ‚â´ e.inv.app _, by simp‚ü©
  obtain ‚ü®g, rfl‚ü© := E.functor.map_surjective f'
  obtain ‚ü®g, rfl‚ü© := MorphismProperty.LeftFraction.Localization.Hom.mk_surjective g
  refine ‚ü®g, ?_‚ü©
  rw [‚Üê MorphismProperty.LeftFraction.Localization.homMk_eq_hom_mk,
    MorphismProperty.LeftFraction.Localization.homMk_eq g,
    g.map_compatibility (MorphismProperty.LeftFraction.Localization.Q W) L,
    assoc, assoc, Iso.inv_hom_id_app, comp_id, Iso.inv_hom_id_app_assoc]",245.98751211166382
mathlib,Mathlib/CategoryTheory/Localization/CalculusOfFractions.lean,"lemma MorphismProperty.LeftFraction.map_eq_iff
    {X Y : C} (œÜ œà : W.LeftFraction X Y) :
    œÜ.map L (Localization.inverts _ _) = œà.map L (Localization.inverts _ _) ‚Üî
      LeftFractionRel œÜ œà ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",3,LENGTH,gpt-4o,True,True,True,10,False,True,,8,True,,7,-0.125,"lemma MorphismProperty.LeftFraction.map_eq_iff
    {X Y : C} (œÜ œà : W.LeftFraction X Y) :
    œÜ.map L (Localization.inverts _ _) = œà.map L (Localization.inverts _ _) ‚Üî
      LeftFractionRel œÜ œà := by
  constructor
  ¬∑ intro h
    rw [‚Üê MorphismProperty.LeftFraction.Localization.map_eq_iff]
    apply map_eq_of_map_eq _ _ _ _ h
  ¬∑ intro h
    simp only [‚Üê Localization.Hom.map_mk _ L (Localization.inverts _ _)]
    congr 1
    exact Quot.sound h","lemma MorphismProperty.LeftFraction.map_eq_iff
    {X Y : C} (œÜ œà : W.LeftFraction X Y) :
    œÜ.map L (Localization.inverts _ _) = œà.map L (Localization.inverts _ _) ‚Üî
      LeftFractionRel œÜ œà  := by
  constructor
  ¬∑ rw [‚Üê MorphismProperty.LeftFraction.Localization.map_eq_iff]; exact map_eq_of_map_eq _ _ _ _
  ¬∑ intro h; simp only [‚Üê Localization.Hom.map_mk _ L (Localization.inverts _ _)]; congr 1; exact Quot.sound h",437.4742248058319
mathlib,Mathlib/CategoryTheory/Localization/CalculusOfFractions.lean," theorem map_eq_iff
    {X Y : C} (œÜ œà : W.LeftFraction X Y) :
    œÜ.map L (Localization.inverts _ _) = œà.map L (Localization.inverts _ _) ‚Üî
      LeftFractionRel œÜ œà ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",3,LENGTH,gpt-4o,True,True,True,10,False,True,,8,True,,8,0.0,"lemma MorphismProperty.LeftFraction.map_eq_iff
    {X Y : C} (œÜ œà : W.LeftFraction X Y) :
    œÜ.map L (Localization.inverts _ _) = œà.map L (Localization.inverts _ _) ‚Üî
      LeftFractionRel œÜ œà := by
  constructor
  ¬∑ intro h
    rw [‚Üê MorphismProperty.LeftFraction.Localization.map_eq_iff]
    apply map_eq_of_map_eq _ _ _ _ h
  ¬∑ intro h
    simp only [‚Üê Localization.Hom.map_mk _ L (Localization.inverts _ _)]
    congr 1
    exact Quot.sound h","lemma MorphismProperty.LeftFraction.map_eq_iff
    {X Y : C} (œÜ œà : W.LeftFraction X Y) :
    œÜ.map L (Localization.inverts _ _) = œà.map L (Localization.inverts _ _) ‚Üî
      LeftFractionRel œÜ œà := by
  constructor
  ¬∑ intro h
    rw [‚Üê MorphismProperty.LeftFraction.Localization.map_eq_iff]
    apply map_eq_of_map_eq _ _ _ _ h
  ¬∑ intro h
    simp only [‚Üê Localization.Hom.map_mk _ L (Localization.inverts _ _)]
    congr 1
    exact Quot.sound h",437.6100969314575
mathlib,Mathlib/CategoryTheory/Localization/CalculusOfFractions.lean,"lemma Localization.essSurj_mapArrow :
    L.mapArrow.EssSurj where
  mem_essImage f ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",3,LENGTH,gpt-4o,True,True,True,10,False,True,,8,True,,8,0.0,"lemma Localization.essSurj_mapArrow :
    L.mapArrow.EssSurj where
  mem_essImage f := by
    have := Localization.essSurj L W
    obtain ‚ü®X, ‚ü®eX‚ü©‚ü© : ‚àÉ (X : C), Nonempty (L.obj X ‚âÖ f.left) :=
      ‚ü®_, ‚ü®L.objObjPreimageIso f.left‚ü©‚ü©
    obtain ‚ü®Y, ‚ü®eY‚ü©‚ü© : ‚àÉ (Y : C), Nonempty (L.obj Y ‚âÖ f.right) :=
      ‚ü®_, ‚ü®L.objObjPreimageIso f.right‚ü©‚ü©
    obtain ‚ü®œÜ, hœÜ‚ü© := Localization.exists_leftFraction L W (eX.hom ‚â´ f.hom ‚â´ eY.inv)
    refine ‚ü®Arrow.mk œÜ.f, ‚ü®Iso.symm ?_‚ü©‚ü©
    refine Arrow.isoMk eX.symm (eY.symm ‚â™‚â´ Localization.isoOfHom L W œÜ.s œÜ.hs) ?_
    dsimp
    simp only [‚Üê cancel_epi eX.hom, Iso.hom_inv_id_assoc, reassoc_of% hœÜ,
      MorphismProperty.LeftFraction.map_comp_map_s]","lemma Localization.essSurj_mapArrow :
    L.mapArrow.EssSurj where
  mem_essImage f := by
    have := Localization.essSurj L W
    obtain ‚ü®X, ‚ü®eX‚ü©‚ü© : ‚àÉ (X : C), Nonempty (L.obj X ‚âÖ f.left) :=
      ‚ü®_, ‚ü®L.objObjPreimageIso f.left‚ü©‚ü©
    obtain ‚ü®Y, ‚ü®eY‚ü©‚ü© : ‚àÉ (Y : C), Nonempty (L.obj Y ‚âÖ f.right) :=
      ‚ü®_, ‚ü®L.objObjPreimageIso f.right‚ü©‚ü©
    obtain ‚ü®œÜ, hœÜ‚ü© := Localization.exists_leftFraction L W (eX.hom ‚â´ f.hom ‚â´ eY.inv)
    refine ‚ü®Arrow.mk œÜ.f, ‚ü®Iso.symm ?_‚ü©‚ü©
    refine Arrow.isoMk eX.symm (eY.symm ‚â™‚â´ Localization.isoOfHom L W œÜ.s œÜ.hs) ?_
    dsimp
    simp only [‚Üê cancel_epi eX.hom, Iso.hom_inv_id_assoc, reassoc_of% hœÜ,
      MorphismProperty.LeftFraction.map_comp_map_s]",452.72735714912415
mathlib,Mathlib/CategoryTheory/Localization/CalculusOfFractions.lean," theorem essSurj_mapArrow :
    L.mapArrow.EssSurj where
  mem_essImage f ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",3,LENGTH,gpt-4o,True,True,True,10,False,True,,8,True,,8,0.0,"lemma Localization.essSurj_mapArrow :
    L.mapArrow.EssSurj where
  mem_essImage f := by
    have := Localization.essSurj L W
    obtain ‚ü®X, ‚ü®eX‚ü©‚ü© : ‚àÉ (X : C), Nonempty (L.obj X ‚âÖ f.left) :=
      ‚ü®_, ‚ü®L.objObjPreimageIso f.left‚ü©‚ü©
    obtain ‚ü®Y, ‚ü®eY‚ü©‚ü© : ‚àÉ (Y : C), Nonempty (L.obj Y ‚âÖ f.right) :=
      ‚ü®_, ‚ü®L.objObjPreimageIso f.right‚ü©‚ü©
    obtain ‚ü®œÜ, hœÜ‚ü© := Localization.exists_leftFraction L W (eX.hom ‚â´ f.hom ‚â´ eY.inv)
    refine ‚ü®Arrow.mk œÜ.f, ‚ü®Iso.symm ?_‚ü©‚ü©
    refine Arrow.isoMk eX.symm (eY.symm ‚â™‚â´ Localization.isoOfHom L W œÜ.s œÜ.hs) ?_
    dsimp
    simp only [‚Üê cancel_epi eX.hom, Iso.hom_inv_id_assoc, reassoc_of% hœÜ,
      MorphismProperty.LeftFraction.map_comp_map_s]","lemma Localization.essSurj_mapArrow :
    L.mapArrow.EssSurj where
  mem_essImage f := by
    have := Localization.essSurj L W
    obtain ‚ü®X, ‚ü®eX‚ü©‚ü© : ‚àÉ (X : C), Nonempty (L.obj X ‚âÖ f.left) :=
      ‚ü®_, ‚ü®L.objObjPreimageIso f.left‚ü©‚ü©
    obtain ‚ü®Y, ‚ü®eY‚ü©‚ü© : ‚àÉ (Y : C), Nonempty (L.obj Y ‚âÖ f.right) :=
      ‚ü®_, ‚ü®L.objObjPreimageIso f.right‚ü©‚ü©
    obtain ‚ü®œÜ, hœÜ‚ü© := Localization.exists_leftFraction L W (eX.hom ‚â´ f.hom ‚â´ eY.inv)
    refine ‚ü®Arrow.mk œÜ.f, ‚ü®Iso.symm ?_‚ü©‚ü©
    refine Arrow.isoMk eX.symm (eY.symm ‚â™‚â´ Localization.isoOfHom L W œÜ.s œÜ.hs) ?_
    dsimp
    simp only [‚Üê cancel_epi eX.hom, Iso.hom_inv_id_assoc, reassoc_of% hœÜ,
      MorphismProperty.LeftFraction.map_comp_map_s]",144.12428426742554
