repo,file,decl,method,n,metric,model,annotation,syntax_search,mathlib_search,examples,improved_context,og_correct,og_errors,og_score,new_correct,new_errors,new_score,delta,og_raw,new_raw,time
mathlib,Mathlib/AlgebraicTopology/SplitSimplicialObject.lean,"@[ext]
theorem ext {S‚ÇÅ S‚ÇÇ : Split C} (Œ¶‚ÇÅ Œ¶‚ÇÇ : Hom S‚ÇÅ S‚ÇÇ) (h : ‚àÄ n : ‚Ñï, Œ¶‚ÇÅ.f n = Œ¶‚ÇÇ.f n) : Œ¶‚ÇÅ = Œ¶‚ÇÇ ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,11,True,,3,-0.7272727272727273,"@[ext]
theorem Hom.ext {S‚ÇÅ S‚ÇÇ : Split C} (Œ¶‚ÇÅ Œ¶‚ÇÇ : Hom S‚ÇÅ S‚ÇÇ) (h : ‚àÄ n : ‚Ñï, Œ¶‚ÇÅ.f n = Œ¶‚ÇÇ.f n) : Œ¶‚ÇÅ = Œ¶‚ÇÇ := by
  rcases Œ¶‚ÇÅ with ‚ü®F‚ÇÅ, f‚ÇÅ, c‚ÇÅ‚ü©
  rcases Œ¶‚ÇÇ with ‚ü®F‚ÇÇ, f‚ÇÇ, c‚ÇÇ‚ü©
  have h' : f‚ÇÅ = f‚ÇÇ := by
    ext
    apply h
  subst h'
  simp only [mk.injEq, and_true]
  apply S‚ÇÅ.s.hom_ext
  intro n
  dsimp
  rw [c‚ÇÅ, c‚ÇÇ]","@[ext]
theorem ext {S‚ÇÅ S‚ÇÇ : Split C} (Œ¶‚ÇÅ Œ¶‚ÇÇ : Hom S‚ÇÅ S‚ÇÇ) (h : ‚àÄ n : ‚Ñï, Œ¶‚ÇÅ.f n = Œ¶‚ÇÇ.f n) : Œ¶‚ÇÅ = Œ¶‚ÇÇ  := by
  ext : 1
  apply S‚ÇÅ.s.hom_ext
  intro n
  dsimp",57.34493684768677
mathlib,Mathlib/AlgebraicTopology/AlternatingFaceMapComplex.lean,"theorem map_alternatingFaceMapComplex {D : Type*} [Category D] [Preadditive D] (F : C ‚•§ D)
    [F.Additive] :
    alternatingFaceMapComplex C ‚ãô F.mapHomologicalComplex _ =
      (SimplicialObject.whiskering C D).obj F ‚ãô alternatingFaceMapComplex D ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,12,True,,1,-0.9166666666666666,"theorem map_alternatingFaceMapComplex {D : Type*} [Category D] [Preadditive D] (F : C ‚•§ D)
    [F.Additive] :
    alternatingFaceMapComplex C ‚ãô F.mapHomologicalComplex _ =
      (SimplicialObject.whiskering C D).obj F ‚ãô alternatingFaceMapComplex D := by
  apply CategoryTheory.Functor.ext
  ¬∑ intro X Y f
    ext n
    simp only [Functor.comp_map, HomologicalComplex.comp_f, alternatingFaceMapComplex_map_f,
      Functor.mapHomologicalComplex_map_f, HomologicalComplex.eqToHom_f, eqToHom_refl, comp_id,
      id_comp, SimplicialObject.whiskering_obj_map_app]
  ¬∑ intro X
    apply HomologicalComplex.ext
    ¬∑ rintro i j (rfl : j + 1 = i)
      dsimp only [Functor.comp_obj]
      simp only [Functor.mapHomologicalComplex_obj_d, alternatingFaceMapComplex_obj_d,
        eqToHom_refl, id_comp, comp_id, AlternatingFaceMapComplex.objD, Functor.map_sum,
        Functor.map_zsmul]
      rfl
    ¬∑ ext n
      rfl","theorem map_alternatingFaceMapComplex {D : Type*} [Category D] [Preadditive D] (F : C ‚•§ D)
    [F.Additive] :
    alternatingFaceMapComplex C ‚ãô F.mapHomologicalComplex _ =
      (SimplicialObject.whiskering C D).obj F ‚ãô alternatingFaceMapComplex D  := by
  apply Functor.ext
  { intros, ext n, simp only [Functor.comp_map, HomologicalComplex.comp_f, alternatingFaceMapComplex_map_f, Functor.mapHomologicalComplex_map_f, HomologicalComplex.eqToHom_f, eqToHom_refl, comp_id, id_comp, SimplicialObject.whiskering_obj_map_app] }",60.80066728591919
mathlib,Mathlib/AlgebraicTopology/DoldKan/Degeneracies.lean,"@[reassoc]
theorem degeneracy_comp_PInfty (X : SimplicialObject C) (n : ‚Ñï) {Œî' : SimplexCategory}
    (Œ∏ : ([n] : SimplexCategory) ‚ü∂ Œî') (hŒ∏ : ¬¨Mono Œ∏) : X.map Œ∏.op ‚â´ PInfty.f n = 0 ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,11,True,,11,0.0,"@[reassoc]
theorem degeneracy_comp_PInfty (X : SimplicialObject C) (n : ‚Ñï) {Œî' : SimplexCategory}
    (Œ∏ : ([n] : SimplexCategory) ‚ü∂ Œî') (hŒ∏ : ¬¨Mono Œ∏) : X.map Œ∏.op ‚â´ PInfty.f n = 0 := by
  rw [SimplexCategory.mono_iff_injective] at hŒ∏
  cases n
  ¬∑ exfalso
    apply hŒ∏
    intro x y h
    fin_cases x
    fin_cases y
    rfl
  ¬∑ obtain ‚ü®i, Œ±, h‚ü© := SimplexCategory.eq_œÉ_comp_of_not_injective Œ∏ hŒ∏
    rw [h, op_comp, X.map_comp, assoc, show X.map (SimplexCategory.œÉ i).op = X.œÉ i by rfl,
      œÉ_comp_PInfty, comp_zero]","@[reassoc]
theorem degeneracy_comp_PInfty (X : SimplicialObject C) (n : ‚Ñï) {Œî' : SimplexCategory}
    (Œ∏ : ([n] : SimplexCategory) ‚ü∂ Œî') (hŒ∏ : ¬¨Mono Œ∏) : X.map Œ∏.op ‚â´ PInfty.f n = 0 := by
  rw [SimplexCategory.mono_iff_injective] at hŒ∏
  cases n
  ¬∑ exfalso
    apply hŒ∏
    intro x y h
    fin_cases x
    fin_cases y
    rfl
  ¬∑ obtain ‚ü®i, Œ±, h‚ü© := SimplexCategory.eq_œÉ_comp_of_not_injective Œ∏ hŒ∏
    rw [h, op_comp, X.map_comp, assoc, show X.map (SimplexCategory.œÉ i).op = X.œÉ i by rfl,
      œÉ_comp_PInfty, comp_zero]",94.48328614234924
mathlib,Mathlib/AlgebraicTopology/Quasicategory.lean," theorem hornFilling {S : SSet} [Quasicategory S] ‚¶Én : ‚Ñï‚¶Ñ ‚¶Éi : Fin (n+1)‚¶Ñ
    (h0 : 0 < i) (hn : i < Fin.last n)
    (œÉ‚ÇÄ : Œõ[n, i] ‚ü∂ S) : ‚àÉ œÉ : Œî[n] ‚ü∂ S, œÉ‚ÇÄ = hornInclusion n i ‚â´ œÉ ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,12,True,,5,-0.5833333333333334,"lemma Quasicategory.hornFilling {S : SSet} [Quasicategory S] ‚¶Én : ‚Ñï‚¶Ñ ‚¶Éi : Fin (n+1)‚¶Ñ
    (h0 : 0 < i) (hn : i < Fin.last n)
    (œÉ‚ÇÄ : Œõ[n, i] ‚ü∂ S) : ‚àÉ œÉ : Œî[n] ‚ü∂ S, œÉ‚ÇÄ = hornInclusion n i ‚â´ œÉ := by
  cases n using Nat.casesAuxOn with
  | zero => simp [Fin.lt_iff_val_lt_val] at hn
  | succ n =>
  cases n using Nat.casesAuxOn with
  | zero =>
    simp only [Fin.lt_iff_val_lt_val, Fin.val_zero, Fin.val_last, zero_add, Nat.lt_one_iff] at h0 hn
    simp [hn] at h0
  | succ n => exact Quasicategory.hornFilling' œÉ‚ÇÄ h0 hn"," theorem hornFilling {S : SSet} [Quasicategory S] ‚¶Én : ‚Ñï‚¶Ñ ‚¶Éi : Fin (n+1)‚¶Ñ
    (h0 : 0 < i) (hn : i < Fin.last n)
    (œÉ‚ÇÄ : Œõ[n, i] ‚ü∂ S) : ‚àÉ œÉ : Œî[n] ‚ü∂ S, œÉ‚ÇÄ = hornInclusion n i ‚â´ œÉ  := by
  cases n using Nat.casesAuxOn with
  | zero => cases i with ‚ü®_, h‚ü©; cases h",24.82735800743103
mathlib,Mathlib/AlgebraicTopology/Quasicategory.lean,"lemma Quasicategory.hornFilling {S : SSet} [Quasicategory S] ‚¶Én : ‚Ñï‚¶Ñ ‚¶Éi : Fin (n+1)‚¶Ñ
    (h0 : 0 < i) (hn : i < Fin.last n)
    (œÉ‚ÇÄ : Œõ[n, i] ‚ü∂ S) : ‚àÉ œÉ : Œî[n] ‚ü∂ S, œÉ‚ÇÄ = hornInclusion n i ‚â´ œÉ ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,12,True,,12,0.0,"lemma Quasicategory.hornFilling {S : SSet} [Quasicategory S] ‚¶Én : ‚Ñï‚¶Ñ ‚¶Éi : Fin (n+1)‚¶Ñ
    (h0 : 0 < i) (hn : i < Fin.last n)
    (œÉ‚ÇÄ : Œõ[n, i] ‚ü∂ S) : ‚àÉ œÉ : Œî[n] ‚ü∂ S, œÉ‚ÇÄ = hornInclusion n i ‚â´ œÉ := by
  cases n using Nat.casesAuxOn with
  | zero => simp [Fin.lt_iff_val_lt_val] at hn
  | succ n =>
  cases n using Nat.casesAuxOn with
  | zero =>
    simp only [Fin.lt_iff_val_lt_val, Fin.val_zero, Fin.val_last, zero_add, Nat.lt_one_iff] at h0 hn
    simp [hn] at h0
  | succ n => exact Quasicategory.hornFilling' œÉ‚ÇÄ h0 hn","lemma Quasicategory.hornFilling {S : SSet} [Quasicategory S] ‚¶Én : ‚Ñï‚¶Ñ ‚¶Éi : Fin (n+1)‚¶Ñ
    (h0 : 0 < i) (hn : i < Fin.last n)
    (œÉ‚ÇÄ : Œõ[n, i] ‚ü∂ S) : ‚àÉ œÉ : Œî[n] ‚ü∂ S, œÉ‚ÇÄ = hornInclusion n i ‚â´ œÉ := by
  cases n using Nat.casesAuxOn with
  | zero => simp [Fin.lt_iff_val_lt_val] at hn
  | succ n =>
  cases n using Nat.casesAuxOn with
  | zero =>
    simp only [Fin.lt_iff_val_lt_val, Fin.val_zero, Fin.val_last, zero_add, Nat.lt_one_iff] at h0 hn
    simp [hn] at h0
  | succ n => exact Quasicategory.hornFilling' œÉ‚ÇÄ h0 hn",29.93498921394348
mathlib,Mathlib/AlgebraicTopology/DoldKan/GammaCompN.lean,"@[simp]
 theorem N‚ÇÇŒì‚ÇÇToKaroubiIso_hom_app (X : ChainComplex C ‚Ñï) :
    (N‚ÇÇŒì‚ÇÇToKaroubiIso.hom.app X).f = PInfty ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,12,True,,12,0.0,"@[simp]
lemma N‚ÇÇŒì‚ÇÇToKaroubiIso_hom_app (X : ChainComplex C ‚Ñï) :
    (N‚ÇÇŒì‚ÇÇToKaroubiIso.hom.app X).f = PInfty := by
  ext n
  dsimp [N‚ÇÇŒì‚ÇÇToKaroubiIso]
  simp only [comp_id, assoc, PInfty_f_idem]
  conv_rhs =>
    rw [‚Üê PInfty_f_idem]
  congr 1
  apply (Œì‚ÇÄ.splitting X).hom_ext'
  intro A
  rw [Splitting.Œπ_desc_assoc, assoc]
  apply id_comp","@[simp]
lemma N‚ÇÇŒì‚ÇÇToKaroubiIso_hom_app (X : ChainComplex C ‚Ñï) :
    (N‚ÇÇŒì‚ÇÇToKaroubiIso.hom.app X).f = PInfty := by
  ext n
  dsimp [N‚ÇÇŒì‚ÇÇToKaroubiIso]
  simp only [comp_id, assoc, PInfty_f_idem]
  conv_rhs =>
    rw [‚Üê PInfty_f_idem]
  congr 1
  apply (Œì‚ÇÄ.splitting X).hom_ext'
  intro A
  rw [Splitting.Œπ_desc_assoc, assoc]
  apply id_comp",110.34185695648193
mathlib,Mathlib/AlgebraicTopology/DoldKan/EquivalencePseudoabelian.lean,"theorem hŒµ :
    Compatibility.œÖ (isoN‚ÇÅ) =
      (Œì‚ÇÇN‚ÇÅ : (toKaroubiEquivalence _).functor ‚âÖ
          (N‚ÇÅ : SimplicialObject C ‚•§ _) ‚ãô Preadditive.DoldKan.equivalence.inverse) ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,12,True,,12,0.0,"theorem hŒµ :
    Compatibility.œÖ (isoN‚ÇÅ) =
      (Œì‚ÇÇN‚ÇÅ : (toKaroubiEquivalence _).functor ‚âÖ
          (N‚ÇÅ : SimplicialObject C ‚•§ _) ‚ãô Preadditive.DoldKan.equivalence.inverse) := by
  dsimp only [isoN‚ÇÅ]
  ext1
  rw [‚Üê cancel_epi Œì‚ÇÇN‚ÇÅ.inv, Iso.inv_hom_id]
  ext X : 2
  rw [NatTrans.comp_app]
  erw [compatibility_Œì‚ÇÇN‚ÇÅ_Œì‚ÇÇN‚ÇÇ_natTrans X]
  rw [Compatibility.œÖ_hom_app, Preadditive.DoldKan.equivalence_unitIso, Iso.app_inv, assoc]
  erw [‚Üê NatTrans.comp_app_assoc, IsIso.hom_inv_id]
  rw [NatTrans.id_app, id_comp, NatTrans.id_app, Œì‚ÇÇN‚ÇÇToKaroubiIso_inv_app]
  dsimp only [Preadditive.DoldKan.equivalence_inverse, Preadditive.DoldKan.Œì]
  rw [‚Üê Œì‚ÇÇ.map_comp, Iso.inv_hom_id_app, Œì‚ÇÇ.map_id]
  rfl","theorem hŒµ :
    Compatibility.œÖ (isoN‚ÇÅ) =
      (Œì‚ÇÇN‚ÇÅ : (toKaroubiEquivalence _).functor ‚âÖ
          (N‚ÇÅ : SimplicialObject C ‚•§ _) ‚ãô Preadditive.DoldKan.equivalence.inverse) := by
  dsimp only [isoN‚ÇÅ]
  ext1
  rw [‚Üê cancel_epi Œì‚ÇÇN‚ÇÅ.inv, Iso.inv_hom_id]
  ext X : 2
  rw [NatTrans.comp_app]
  erw [compatibility_Œì‚ÇÇN‚ÇÅ_Œì‚ÇÇN‚ÇÇ_natTrans X]
  rw [Compatibility.œÖ_hom_app, Preadditive.DoldKan.equivalence_unitIso, Iso.app_inv, assoc]
  erw [‚Üê NatTrans.comp_app_assoc, IsIso.hom_inv_id]
  rw [NatTrans.id_app, id_comp, NatTrans.id_app, Œì‚ÇÇN‚ÇÇToKaroubiIso_inv_app]
  dsimp only [Preadditive.DoldKan.equivalence_inverse, Preadditive.DoldKan.Œì]
  rw [‚Üê Œì‚ÇÇ.map_comp, Iso.inv_hom_id_app, Œì‚ÇÇ.map_id]
  rfl",113.08041429519653
mathlib,Mathlib/AlgebraicTopology/DoldKan/GammaCompN.lean,"@[simp]
lemma N‚ÇÇŒì‚ÇÇToKaroubiIso_hom_app (X : ChainComplex C ‚Ñï) :
    (N‚ÇÇŒì‚ÇÇToKaroubiIso.hom.app X).f = PInfty ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,12,True,,12,0.0,"@[simp]
lemma N‚ÇÇŒì‚ÇÇToKaroubiIso_hom_app (X : ChainComplex C ‚Ñï) :
    (N‚ÇÇŒì‚ÇÇToKaroubiIso.hom.app X).f = PInfty := by
  ext n
  dsimp [N‚ÇÇŒì‚ÇÇToKaroubiIso]
  simp only [comp_id, assoc, PInfty_f_idem]
  conv_rhs =>
    rw [‚Üê PInfty_f_idem]
  congr 1
  apply (Œì‚ÇÄ.splitting X).hom_ext'
  intro A
  rw [Splitting.Œπ_desc_assoc, assoc]
  apply id_comp","@[simp]
lemma N‚ÇÇŒì‚ÇÇToKaroubiIso_hom_app (X : ChainComplex C ‚Ñï) :
    (N‚ÇÇŒì‚ÇÇToKaroubiIso.hom.app X).f = PInfty := by
  ext n
  dsimp [N‚ÇÇŒì‚ÇÇToKaroubiIso]
  simp only [comp_id, assoc, PInfty_f_idem]
  conv_rhs =>
    rw [‚Üê PInfty_f_idem]
  congr 1
  apply (Œì‚ÇÄ.splitting X).hom_ext'
  intro A
  rw [Splitting.Œπ_desc_assoc, assoc]
  apply id_comp",113.84412693977356
mathlib,Mathlib/AlgebraicTopology/SplitSimplicialObject.lean,theorem eqId_iff_eq : A.EqId ‚Üî A.1 = Œî ,"refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,13,True,,11,-0.15384615384615385,"theorem eqId_iff_eq : A.EqId ‚Üî A.1 = Œî := by
  constructor
  ¬∑ intro h
    dsimp at h
    rw [h]
    rfl
  ¬∑ intro h
    rcases A with ‚ü®_, ‚ü®f, hf‚ü©‚ü©
    simp only at h
    subst h
    refine ext _ _ rfl ?_
    haveI := hf
    simp only [eqToHom_refl, comp_id]
    exact eq_id_of_epi f","theorem eqId_iff_eq : A.EqId ‚Üî A.1 = Œî  := by
  constructor
  intro h; dsimp at h; rw [h]; rfl
  intro h; rcases A with ‚ü®_, ‚ü®f, hf‚ü©‚ü©; simp only at h; subst h
  refine ext _ _ rfl (by simp [eq_id_of_epi])",39.04673933982849
mathlib,Mathlib/AlgebraicTopology/DoldKan/Compatibility.lean,theorem equivalenceCounitIso_eq : (equivalence hF hG).counitIso = equivalenceCounitIso Œ∑ ,"refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,12,True,,12,0.0,"theorem equivalenceCounitIso_eq : (equivalence hF hG).counitIso = equivalenceCounitIso Œ∑ := by
  ext1; apply NatTrans.ext; ext Y
  dsimp [equivalence]
  simp only [comp_id, id_comp, Functor.map_comp, equivalence‚ÇÇCounitIso_eq,
    equivalence‚ÇÇCounitIso_hom_app, assoc, equivalenceCounitIso_hom_app]
  simp only [‚Üê eB.inverse.map_comp_assoc, ‚Üê œÑ‚ÇÄ_hom_app, hŒ∑, œÑ‚ÇÅ_hom_app]
  erw [hF.inv.naturality_assoc, hF.inv.naturality_assoc]
  dsimp
  congr 2
  simp only [‚Üê e'.functor.map_comp_assoc, Equivalence.fun_inv_map, assoc,
    Iso.inv_hom_id_app_assoc, hG.inv_hom_id_app]
  dsimp
  rw [comp_id, eA.functor_unitIso_comp, e'.functor.map_id, id_comp, hF.inv_hom_id_app_assoc]","theorem equivalenceCounitIso_eq : (equivalence hF hG).counitIso = equivalenceCounitIso Œ∑ := by
  ext1; apply NatTrans.ext; ext Y
  dsimp [equivalence]
  simp only [comp_id, id_comp, Functor.map_comp, equivalence‚ÇÇCounitIso_eq,
    equivalence‚ÇÇCounitIso_hom_app, assoc, equivalenceCounitIso_hom_app]
  simp only [‚Üê eB.inverse.map_comp_assoc, ‚Üê œÑ‚ÇÄ_hom_app, hŒ∑, œÑ‚ÇÅ_hom_app]
  erw [hF.inv.naturality_assoc, hF.inv.naturality_assoc]
  dsimp
  congr 2
  simp only [‚Üê e'.functor.map_comp_assoc, Equivalence.fun_inv_map, assoc,
    Iso.inv_hom_id_app_assoc, hG.inv_hom_id_app]
  dsimp
  rw [comp_id, eA.functor_unitIso_comp, e'.functor.map_id, id_comp, hF.inv_hom_id_app_assoc]",67.0618941783905
mathlib,Mathlib/AlgebraicTopology/SimplexCategory.lean,"/-- The second part of the third simplicial identity -/
@[reassoc]
theorem Œ¥_comp_œÉ_succ {n} {i : Fin (n + 1)} : Œ¥ i.succ ‚â´ œÉ i = ùüô ([n] : SimplexCategory) ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,13,True,,12,-0.07692307692307693,"/-- The second part of the third simplicial identity -/
@[reassoc]
theorem Œ¥_comp_œÉ_succ {n} {i : Fin (n + 1)} : Œ¥ i.succ ‚â´ œÉ i = ùüô ([n] : SimplexCategory) := by
  ext j
  rcases i with ‚ü®i, _‚ü©
  rcases j with ‚ü®j, _‚ü©
  dsimp [Œ¥, œÉ, Fin.succAbove, Fin.predAbove]
  split_ifs <;> simp <;> simp at * <;> omega","/-- The second part of the third simplicial identity -/
@[reassoc]
theorem Œ¥_comp_œÉ_succ {n} {i : Fin (n + 1)} : Œ¥ i.succ ‚â´ œÉ i = ùüô ([n] : SimplexCategory)  := by
  ext j
  rcases i with ‚ü®i, _‚ü©
  rcases j with ‚ü®j, _‚ü©
  dsimp [Œ¥, œÉ, Fin.succAbove, Fin.predAbove]
  split_ifs <;> simp <;> omega




",60.2681999206543
mathlib,Mathlib/AlgebraicTopology/DoldKan/NReflectsIso.lean,"theorem compatibility_N‚ÇÇ_N‚ÇÅ_karoubi :
    N‚ÇÇ ‚ãô (karoubiChainComplexEquivalence C ‚Ñï).functor =
      karoubiFunctorCategoryEmbedding SimplexCategory·µí·µñ C ‚ãô
        N‚ÇÅ ‚ãô (karoubiChainComplexEquivalence (Karoubi C) ‚Ñï).functor ‚ãô
            Functor.mapHomologicalComplex (KaroubiKaroubi.equivalence C).inverse _ ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,14,True,,14,0.0,"theorem compatibility_N‚ÇÇ_N‚ÇÅ_karoubi :
    N‚ÇÇ ‚ãô (karoubiChainComplexEquivalence C ‚Ñï).functor =
      karoubiFunctorCategoryEmbedding SimplexCategory·µí·µñ C ‚ãô
        N‚ÇÅ ‚ãô (karoubiChainComplexEquivalence (Karoubi C) ‚Ñï).functor ‚ãô
            Functor.mapHomologicalComplex (KaroubiKaroubi.equivalence C).inverse _ := by
  refine CategoryTheory.Functor.ext (fun P => ?_) fun P Q f => ?_
  ¬∑ refine HomologicalComplex.ext ?_ ?_
    ¬∑ ext n
      ¬∑ rfl
      ¬∑ dsimp
        simp only [karoubi_PInfty_f, comp_id, PInfty_f_naturality, id_comp, eqToHom_refl]
    ¬∑ rintro _ n (rfl : n + 1 = _)
      ext
      have h := (AlternatingFaceMapComplex.map P.p).comm (n + 1) n
      dsimp [N‚ÇÇ, karoubiChainComplexEquivalence,
        KaroubiHomologicalComplexEquivalence.Functor.obj] at h ‚ä¢
      simp only [assoc, Karoubi.eqToHom_f, eqToHom_refl, comp_id,
        karoubi_alternatingFaceMapComplex_d, karoubi_PInfty_f,
        ‚Üê HomologicalComplex.Hom.comm_assoc, ‚Üê h, app_idem_assoc]
  ¬∑ ext n
    dsimp [KaroubiKaroubi.inverse, Functor.mapHomologicalComplex]
    simp only [karoubi_PInfty_f, HomologicalComplex.eqToHom_f, Karoubi.eqToHom_f,
      assoc, comp_id, PInfty_f_naturality, app_p_comp,
      karoubiChainComplexEquivalence_functor_obj_X_p, N‚ÇÇ_obj_p_f, eqToHom_refl,
      PInfty_f_naturality_assoc, app_comp_p, PInfty_f_idem_assoc]","theorem compatibility_N‚ÇÇ_N‚ÇÅ_karoubi :
    N‚ÇÇ ‚ãô (karoubiChainComplexEquivalence C ‚Ñï).functor =
      karoubiFunctorCategoryEmbedding SimplexCategory·µí·µñ C ‚ãô
        N‚ÇÅ ‚ãô (karoubiChainComplexEquivalence (Karoubi C) ‚Ñï).functor ‚ãô
            Functor.mapHomologicalComplex (KaroubiKaroubi.equivalence C).inverse _ := by
  refine CategoryTheory.Functor.ext (fun P => ?_) fun P Q f => ?_
  ¬∑ refine HomologicalComplex.ext ?_ ?_
    ¬∑ ext n
      ¬∑ rfl
      ¬∑ dsimp
        simp only [karoubi_PInfty_f, comp_id, PInfty_f_naturality, id_comp, eqToHom_refl]
    ¬∑ rintro _ n (rfl : n + 1 = _)
      ext
      have h := (AlternatingFaceMapComplex.map P.p).comm (n + 1) n
      dsimp [N‚ÇÇ, karoubiChainComplexEquivalence,
        KaroubiHomologicalComplexEquivalence.Functor.obj] at h ‚ä¢
      simp only [assoc, Karoubi.eqToHom_f, eqToHom_refl, comp_id,
        karoubi_alternatingFaceMapComplex_d, karoubi_PInfty_f,
        ‚Üê HomologicalComplex.Hom.comm_assoc, ‚Üê h, app_idem_assoc]
  ¬∑ ext n
    dsimp [KaroubiKaroubi.inverse, Functor.mapHomologicalComplex]
    simp only [karoubi_PInfty_f, HomologicalComplex.eqToHom_f, Karoubi.eqToHom_f,
      assoc, comp_id, PInfty_f_naturality, app_p_comp,
      karoubiChainComplexEquivalence_functor_obj_X_p, N‚ÇÇ_obj_p_f, eqToHom_refl,
      PInfty_f_naturality_assoc, app_comp_p, PInfty_f_idem_assoc]",76.24908113479614
mathlib,Mathlib/AlgebraicTopology/SimplexCategory.lean,"/-- The fourth simplicial identity -/
@[reassoc]
theorem Œ¥_comp_œÉ_of_gt {n} {i : Fin (n + 2)} {j : Fin (n + 1)} (H : Fin.castSucc j < i) :
    Œ¥ i.succ ‚â´ œÉ (Fin.castSucc j) = œÉ j ‚â´ Œ¥ i ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,14,True,,13,-0.07142857142857142,"/-- The fourth simplicial identity -/
@[reassoc]
theorem Œ¥_comp_œÉ_of_gt {n} {i : Fin (n + 2)} {j : Fin (n + 1)} (H : Fin.castSucc j < i) :
    Œ¥ i.succ ‚â´ œÉ (Fin.castSucc j) = œÉ j ‚â´ Œ¥ i := by
  ext k : 3
  dsimp [Œ¥, œÉ]
  rcases le_or_lt k i with (hik | hik)
  ¬∑ rw [Fin.succAbove_of_castSucc_lt _ _ (Fin.castSucc_lt_succ_iff.mpr hik)]
    rcases le_or_lt k (j.castSucc) with (hjk | hjk)
    ¬∑ rw [Fin.predAbove_of_le_castSucc _ _
      (Fin.castSucc_le_castSucc_iff.mpr hjk), Fin.castPred_castSucc,
      Fin.predAbove_of_le_castSucc _ _ hjk, Fin.succAbove_of_castSucc_lt, Fin.castSucc_castPred]
      rw [Fin.castSucc_castPred]
      exact hjk.trans_lt H
    ¬∑ rw [Fin.predAbove_of_castSucc_lt _ _ (Fin.castSucc_lt_castSucc_iff.mpr hjk),
      Fin.predAbove_of_castSucc_lt _ _ hjk, Fin.succAbove_of_castSucc_lt,
      Fin.castSucc_pred_eq_pred_castSucc]
      rwa [Fin.castSucc_lt_iff_succ_le, Fin.succ_pred]
  ¬∑ rw [Fin.succAbove_of_le_castSucc _ _ (Fin.succ_le_castSucc_iff.mpr hik)]
    have hjk := H.trans hik
    rw [Fin.predAbove_of_castSucc_lt _ _ hjk, Fin.predAbove_of_castSucc_lt _ _
      (Fin.castSucc_lt_succ_iff.mpr hjk.le),
    Fin.pred_succ, Fin.succAbove_of_le_castSucc, Fin.succ_pred]
    rwa [Fin.le_castSucc_pred_iff]","/-- The fourth simplicial identity -/
@[reassoc]
theorem Œ¥_comp_œÉ_of_gt {n} {i : Fin (n + 2)} {j : Fin (n + 1)} (H : Fin.castSucc j < i) :
    Œ¥ i.succ ‚â´ œÉ (Fin.castSucc j) = œÉ j ‚â´ Œ¥ i  := by
  ext k : 3
  dsimp [Œ¥, œÉ]
  rcases le_or_lt k i with (hik | hik)
  ¬∑ rw [Fin.succAbove_of_castSucc_lt _ _ (Fin.castSucc_lt_succ_iff.mpr hik)]
    rcases le_or_lt k (j.castSucc) with (hjk | hjk)
    ¬∑ rw [Fin.predAbove_of_le_castSucc _ _ (Fin.castSucc_le_castSucc_iff.mpr hjk),
        Fin.castPred_castSucc, Fin.predAbove_of_le_castSucc _ _ hjk,
        Fin.succAbove_of_castSucc_lt, Fin.castSucc_castPred]
      exact hjk.trans_lt H
    ¬∑ rw [Fin.predAbove_of_castSucc_lt _ _ (Fin.castSucc_lt_castSucc_iff.mpr hjk),
        Fin.predAbove_of_castSucc_lt _ _ hjk, Fin.succAbove_of_castSucc_lt,
        Fin.castSucc_pred_eq_pred_castSucc]
      rwa [Fin.castSucc_lt_iff_succ_le, Fin.succ_pred]
  ¬∑ rw [Fin.succAbove_of_le_castSucc _ _ (Fin.succ_le_castSucc_iff.mpr hik)]
    have hjk := H.trans hik
    rw [Fin.predAbove_of_castSucc_lt _ _ hjk, Fin.predAbove_of_castSucc_lt _ _
        (Fin.castSucc_lt_succ_iff.mpr hjk.le), Fin.pred_succ, Fin.succAbove_of_le_castSucc,
        Fin.succ_pred]
    rwa [Fin.le_castSucc_pred_iff]",94.36395120620728
mathlib,Mathlib/AlgebraicTopology/DoldKan/NCompGamma.lean,"theorem identity_N‚ÇÇ_objectwise (P : Karoubi (SimplicialObject C)) :
    (N‚ÇÇŒì‚ÇÇ.inv.app (N‚ÇÇ.obj P) : N‚ÇÇ.obj P ‚ü∂ N‚ÇÇ.obj (Œì‚ÇÇ.obj (N‚ÇÇ.obj P))) ‚â´
    N‚ÇÇ.map (Œì‚ÇÇN‚ÇÇ.natTrans.app P) = ùüô (N‚ÇÇ.obj P) ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,14,True,,14,0.0,"theorem identity_N‚ÇÇ_objectwise (P : Karoubi (SimplicialObject C)) :
    (N‚ÇÇŒì‚ÇÇ.inv.app (N‚ÇÇ.obj P) : N‚ÇÇ.obj P ‚ü∂ N‚ÇÇ.obj (Œì‚ÇÇ.obj (N‚ÇÇ.obj P))) ‚â´
    N‚ÇÇ.map (Œì‚ÇÇN‚ÇÇ.natTrans.app P) = ùüô (N‚ÇÇ.obj P) := by
  ext n
  have eq‚ÇÅ : (N‚ÇÇŒì‚ÇÇ.inv.app (N‚ÇÇ.obj P)).f.f n = PInfty.f n ‚â´ P.p.app (op [n]) ‚â´
      ((Œì‚ÇÄ.splitting (N‚ÇÇ.obj P).X).cofan _).inj (Splitting.IndexSet.id (op [n])) := by
    simp only [N‚ÇÇŒì‚ÇÇ_inv_app_f_f, N‚ÇÇ_obj_p_f, assoc]
  have eq‚ÇÇ : ((Œì‚ÇÄ.splitting (N‚ÇÇ.obj P).X).cofan _).inj (Splitting.IndexSet.id (op [n])) ‚â´
      (N‚ÇÇ.map (Œì‚ÇÇN‚ÇÇ.natTrans.app P)).f.f n = PInfty.f n ‚â´ P.p.app (op [n]) := by
    dsimp
    rw [PInfty_on_Œì‚ÇÄ_splitting_summand_eq_self_assoc, Œì‚ÇÇN‚ÇÇ.natTrans_app_f_app]
    dsimp
    rw [Œì‚ÇÇN‚ÇÇToKaroubiIso_hom_app, assoc, Splitting.Œπ_desc_assoc, assoc, assoc]
    dsimp [toKaroubi]
    rw [Splitting.Œπ_desc_assoc]
    dsimp
    simp only [assoc, Splitting.Œπ_desc_assoc, unop_op, Splitting.IndexSet.id_fst,
      len_mk, NatTrans.naturality, PInfty_f_idem_assoc,
      PInfty_f_naturality_assoc, app_idem_assoc]
    erw [P.X.map_id, comp_id]
  simp only [Karoubi.comp_f, HomologicalComplex.comp_f, Karoubi.id_eq, N‚ÇÇ_obj_p_f, assoc,
    eq‚ÇÅ, eq‚ÇÇ, PInfty_f_naturality_assoc, app_idem, PInfty_f_idem_assoc]","theorem identity_N‚ÇÇ_objectwise (P : Karoubi (SimplicialObject C)) :
    (N‚ÇÇŒì‚ÇÇ.inv.app (N‚ÇÇ.obj P) : N‚ÇÇ.obj P ‚ü∂ N‚ÇÇ.obj (Œì‚ÇÇ.obj (N‚ÇÇ.obj P))) ‚â´
    N‚ÇÇ.map (Œì‚ÇÇN‚ÇÇ.natTrans.app P) = ùüô (N‚ÇÇ.obj P) := by
  ext n
  have eq‚ÇÅ : (N‚ÇÇŒì‚ÇÇ.inv.app (N‚ÇÇ.obj P)).f.f n = PInfty.f n ‚â´ P.p.app (op [n]) ‚â´
      ((Œì‚ÇÄ.splitting (N‚ÇÇ.obj P).X).cofan _).inj (Splitting.IndexSet.id (op [n])) := by
    simp only [N‚ÇÇŒì‚ÇÇ_inv_app_f_f, N‚ÇÇ_obj_p_f, assoc]
  have eq‚ÇÇ : ((Œì‚ÇÄ.splitting (N‚ÇÇ.obj P).X).cofan _).inj (Splitting.IndexSet.id (op [n])) ‚â´
      (N‚ÇÇ.map (Œì‚ÇÇN‚ÇÇ.natTrans.app P)).f.f n = PInfty.f n ‚â´ P.p.app (op [n]) := by
    dsimp
    rw [PInfty_on_Œì‚ÇÄ_splitting_summand_eq_self_assoc, Œì‚ÇÇN‚ÇÇ.natTrans_app_f_app]
    dsimp
    rw [Œì‚ÇÇN‚ÇÇToKaroubiIso_hom_app, assoc, Splitting.Œπ_desc_assoc, assoc, assoc]
    dsimp [toKaroubi]
    rw [Splitting.Œπ_desc_assoc]
    dsimp
    simp only [assoc, Splitting.Œπ_desc_assoc, unop_op, Splitting.IndexSet.id_fst,
      len_mk, NatTrans.naturality, PInfty_f_idem_assoc,
      PInfty_f_naturality_assoc, app_idem_assoc]
    erw [P.X.map_id, comp_id]
  simp only [Karoubi.comp_f, HomologicalComplex.comp_f, Karoubi.id_eq, N‚ÇÇ_obj_p_f, assoc,
    eq‚ÇÅ, eq‚ÇÇ, PInfty_f_naturality_assoc, app_idem, PInfty_f_idem_assoc]",158.71549797058105
mathlib,Mathlib/AlgebraicTopology/DoldKan/Projections.lean,"@[reassoc]
theorem comp_P_eq_self {Y : C} {n q : ‚Ñï} {œÜ : Y ‚ü∂ X _[n + 1]} (v : HigherFacesVanish q œÜ) :
    œÜ ‚â´ (P q).f (n + 1) = œÜ ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,16,True,,16,0.0,"@[reassoc]
theorem comp_P_eq_self {Y : C} {n q : ‚Ñï} {œÜ : Y ‚ü∂ X _[n + 1]} (v : HigherFacesVanish q œÜ) :
    œÜ ‚â´ (P q).f (n + 1) = œÜ := by
  induction' q with q hq
  ¬∑ simp only [P_zero]
    apply comp_id
  ¬∑ simp only [P_succ, comp_add, HomologicalComplex.comp_f, HomologicalComplex.add_f_apply,
      comp_id, ‚Üê assoc, hq v.of_succ, add_right_eq_self]
    by_cases hqn : n < q
    ¬∑ exact v.of_succ.comp_HœÉ_eq_zero hqn
    ¬∑ obtain ‚ü®a, ha‚ü© := Nat.le.dest (not_lt.mp hqn)
      have hnaq : n = a + q := by omega
      simp only [v.of_succ.comp_HœÉ_eq hnaq, neg_eq_zero, ‚Üê assoc]
      have eq := v ‚ü®a, by omega‚ü© (by
        simp only [hnaq, Nat.succ_eq_add_one, add_assoc]
        rfl)
      simp only [Fin.succ_mk] at eq
      simp only [eq, zero_comp]","@[reassoc]
theorem comp_P_eq_self {Y : C} {n q : ‚Ñï} {œÜ : Y ‚ü∂ X _[n + 1]} (v : HigherFacesVanish q œÜ) :
    œÜ ‚â´ (P q).f (n + 1) = œÜ := by
  induction' q with q hq
  ¬∑ simp only [P_zero]
    apply comp_id
  ¬∑ simp only [P_succ, comp_add, HomologicalComplex.comp_f, HomologicalComplex.add_f_apply,
      comp_id, ‚Üê assoc, hq v.of_succ, add_right_eq_self]
    by_cases hqn : n < q
    ¬∑ exact v.of_succ.comp_HœÉ_eq_zero hqn
    ¬∑ obtain ‚ü®a, ha‚ü© := Nat.le.dest (not_lt.mp hqn)
      have hnaq : n = a + q := by omega
      simp only [v.of_succ.comp_HœÉ_eq hnaq, neg_eq_zero, ‚Üê assoc]
      have eq := v ‚ü®a, by omega‚ü© (by
        simp only [hnaq, Nat.succ_eq_add_one, add_assoc]
        rfl)
      simp only [Fin.succ_mk] at eq
      simp only [eq, zero_comp]",52.12833285331726
mathlib,Mathlib/AlgebraicTopology/SimplexCategory.lean,"/-- The first part of the third simplicial identity -/
@[reassoc]
theorem Œ¥_comp_œÉ_self {n} {i : Fin (n + 1)} :
    Œ¥ (Fin.castSucc i) ‚â´ œÉ i = ùüô ([n] : SimplexCategory) ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,15,True,,12,-0.2,"/-- The first part of the third simplicial identity -/
@[reassoc]
theorem Œ¥_comp_œÉ_self {n} {i : Fin (n + 1)} :
    Œ¥ (Fin.castSucc i) ‚â´ œÉ i = ùüô ([n] : SimplexCategory) := by
  rcases i with ‚ü®i, hi‚ü©
  ext ‚ü®j, hj‚ü©
  simp? at hj says simp only [len_mk] at hj
  dsimp [œÉ, Œ¥, Fin.predAbove, Fin.succAbove]
  simp only [Fin.lt_iff_val_lt_val, Fin.dite_val, Fin.ite_val, Fin.coe_pred, ge_iff_le,
    Fin.coe_castLT, dite_eq_ite]
  split_ifs
  any_goals simp
  all_goals omega","/-- The first part of the third simplicial identity -/
@[reassoc]
theorem Œ¥_comp_œÉ_self {n} {i : Fin (n + 1)} :
    Œ¥ (Fin.castSucc i) ‚â´ œÉ i = ùüô ([n] : SimplexCategory)  := by
  ext ‚ü®j, hj‚ü©
  dsimp [œÉ, Œ¥, Fin.predAbove, Fin.succAbove]
  split_ifs; simp; linarith




",53.22467494010925
mathlib,Mathlib/AlgebraicTopology/SimplexCategory.lean,"/-- The fifth simplicial identity -/
@[reassoc]
theorem œÉ_comp_œÉ {n} {i j : Fin (n + 1)} (H : i ‚â§ j) :
    œÉ (Fin.castSucc i) ‚â´ œÉ j = œÉ j.succ ‚â´ œÉ i ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,15,True,,15,0.0,"/-- The fifth simplicial identity -/
@[reassoc]
theorem œÉ_comp_œÉ {n} {i j : Fin (n + 1)} (H : i ‚â§ j) :
    œÉ (Fin.castSucc i) ‚â´ œÉ j = œÉ j.succ ‚â´ œÉ i := by
  ext k : 3
  dsimp [œÉ]
  cases' k using Fin.lastCases with k
  ¬∑ simp only [len_mk, Fin.predAbove_right_last]
  ¬∑ cases' k using Fin.cases with k
    ¬∑ rw [Fin.castSucc_zero, Fin.predAbove_of_le_castSucc _ 0 (Fin.zero_le _),
      Fin.predAbove_of_le_castSucc _ _ (Fin.zero_le _), Fin.castPred_zero,
      Fin.predAbove_of_le_castSucc _ 0 (Fin.zero_le _),
      Fin.predAbove_of_le_castSucc _ _ (Fin.zero_le _)]
    ¬∑ rcases le_or_lt i k with (h | h)
      ¬∑ simp_rw [Fin.predAbove_of_castSucc_lt i.castSucc _ (Fin.castSucc_lt_castSucc_iff.mpr
        (Fin.castSucc_lt_succ_iff.mpr h)), ‚Üê Fin.succ_castSucc, Fin.pred_succ,
        Fin.succ_predAbove_succ]
        rw [Fin.predAbove_of_castSucc_lt i _ (Fin.castSucc_lt_succ_iff.mpr _), Fin.pred_succ]
        rcases le_or_lt k j with (hkj | hkj)
        ¬∑ rwa [Fin.predAbove_of_le_castSucc _ _ (Fin.castSucc_le_castSucc_iff.mpr hkj),
          Fin.castPred_castSucc]
        ¬∑ rw [Fin.predAbove_of_castSucc_lt _ _ (Fin.castSucc_lt_castSucc_iff.mpr hkj),
          Fin.le_pred_iff,
          Fin.succ_le_castSucc_iff]
          exact H.trans_lt hkj
      ¬∑ simp_rw [Fin.predAbove_of_le_castSucc i.castSucc _ (Fin.castSucc_le_castSucc_iff.mpr
        (Fin.succ_le_castSucc_iff.mpr h)), Fin.castPred_castSucc, ‚Üê Fin.succ_castSucc,
        Fin.succ_predAbove_succ]
        rw [Fin.predAbove_of_le_castSucc _ k.castSucc
        (Fin.castSucc_le_castSucc_iff.mpr (h.le.trans H)),
        Fin.castPred_castSucc, Fin.predAbove_of_le_castSucc _ k.succ
        (Fin.succ_le_castSucc_iff.mpr (H.trans_lt' h)), Fin.predAbove_of_le_castSucc _ k.succ
        (Fin.succ_le_castSucc_iff.mpr h)]","/-- The fifth simplicial identity -/
@[reassoc]
theorem œÉ_comp_œÉ {n} {i j : Fin (n + 1)} (H : i ‚â§ j) :
    œÉ (Fin.castSucc i) ‚â´ œÉ j = œÉ j.succ ‚â´ œÉ i := by
  ext k : 3
  dsimp [œÉ]
  cases' k using Fin.lastCases with k
  ¬∑ simp only [len_mk, Fin.predAbove_right_last]
  ¬∑ cases' k using Fin.cases with k
    ¬∑ rw [Fin.castSucc_zero, Fin.predAbove_of_le_castSucc _ 0 (Fin.zero_le _),
      Fin.predAbove_of_le_castSucc _ _ (Fin.zero_le _), Fin.castPred_zero,
      Fin.predAbove_of_le_castSucc _ 0 (Fin.zero_le _),
      Fin.predAbove_of_le_castSucc _ _ (Fin.zero_le _)]
    ¬∑ rcases le_or_lt i k with (h | h)
      ¬∑ simp_rw [Fin.predAbove_of_castSucc_lt i.castSucc _ (Fin.castSucc_lt_castSucc_iff.mpr
        (Fin.castSucc_lt_succ_iff.mpr h)), ‚Üê Fin.succ_castSucc, Fin.pred_succ,
        Fin.succ_predAbove_succ]
        rw [Fin.predAbove_of_castSucc_lt i _ (Fin.castSucc_lt_succ_iff.mpr _), Fin.pred_succ]
        rcases le_or_lt k j with (hkj | hkj)
        ¬∑ rwa [Fin.predAbove_of_le_castSucc _ _ (Fin.castSucc_le_castSucc_iff.mpr hkj),
          Fin.castPred_castSucc]
        ¬∑ rw [Fin.predAbove_of_castSucc_lt _ _ (Fin.castSucc_lt_castSucc_iff.mpr hkj),
          Fin.le_pred_iff,
          Fin.succ_le_castSucc_iff]
          exact H.trans_lt hkj
      ¬∑ simp_rw [Fin.predAbove_of_le_castSucc i.castSucc _ (Fin.castSucc_le_castSucc_iff.mpr
        (Fin.succ_le_castSucc_iff.mpr h)), Fin.castPred_castSucc, ‚Üê Fin.succ_castSucc,
        Fin.succ_predAbove_succ]
        rw [Fin.predAbove_of_le_castSucc _ k.castSucc
        (Fin.castSucc_le_castSucc_iff.mpr (h.le.trans H)),
        Fin.castPred_castSucc, Fin.predAbove_of_le_castSucc _ k.succ
        (Fin.succ_le_castSucc_iff.mpr (H.trans_lt' h)), Fin.predAbove_of_le_castSucc _ k.succ
        (Fin.succ_le_castSucc_iff.mpr h)]",111.64961218833923
mathlib,Mathlib/AlgebraicTopology/SimplicialSet.lean,"/-- Two morphisms from a horn are equal if they are equal on all suitable faces. -/
protected
 theorem hom_ext {n : ‚Ñï} {i : Fin (n+2)} {S : SSet} (œÉ‚ÇÅ œÉ‚ÇÇ : Œõ[n+1, i] ‚ü∂ S)
    (h : ‚àÄ (j) (h : j ‚â† i), œÉ‚ÇÅ.app _ (face i j h) = œÉ‚ÇÇ.app _ (face i j h)) :
    œÉ‚ÇÅ = œÉ‚ÇÇ ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,20,True,,2,-0.9,"/-- Two morphisms from a horn are equal if they are equal on all suitable faces. -/
protected
lemma hom_ext {n : ‚Ñï} {i : Fin (n+2)} {S : SSet} (œÉ‚ÇÅ œÉ‚ÇÇ : Œõ[n+1, i] ‚ü∂ S)
    (h : ‚àÄ (j) (h : j ‚â† i), œÉ‚ÇÅ.app _ (face i j h) = œÉ‚ÇÇ.app _ (face i j h)) :
    œÉ‚ÇÅ = œÉ‚ÇÇ := by
  apply NatTrans.ext; apply funext; apply Opposite.rec; apply SimplexCategory.rec
  intro m; ext f
  obtain ‚ü®f', hf‚ü© := (standardSimplex.objEquiv _ _).symm.surjective f.1
  obtain ‚ü®j, hji, hfj‚ü© : ‚àÉ j, ¬¨j = i ‚àß ‚àÄ k, f'.toOrderHom k ‚â† j := by
    obtain ‚ü®f, hf'‚ü© := f
    subst hf
    simpa [‚Üê Set.univ_subset_iff, Set.subset_def, asOrderHom, not_or] using hf'
  have H : f = (Œõ[n+1, i].map (factor_Œ¥ f' j).op) (face i j hji) := by
    apply Subtype.ext
    apply (standardSimplex.objEquiv _ _).injective
    rw [‚Üê hf]
    exact (factor_Œ¥_spec f' j hfj).symm
  have H‚ÇÅ := congrFun (œÉ‚ÇÅ.naturality (factor_Œ¥ f' j).op) (face i j hji)
  have H‚ÇÇ := congrFun (œÉ‚ÇÇ.naturality (factor_Œ¥ f' j).op) (face i j hji)
  dsimp at H‚ÇÅ H‚ÇÇ
  erw [H, H‚ÇÅ, H‚ÇÇ, h _ hji]","/-- Two morphisms from a horn are equal if they are equal on all suitable faces. -/
protected
 theorem hom_ext {n : ‚Ñï} {i : Fin (n+2)} {S : SSet} (œÉ‚ÇÅ œÉ‚ÇÇ : Œõ[n+1, i] ‚ü∂ S)
    (h : ‚àÄ (j) (h : j ‚â† i), œÉ‚ÇÅ.app _ (face i j h) = œÉ‚ÇÇ.app _ (face i j h)) :
    œÉ‚ÇÅ = œÉ‚ÇÇ  := by
  apply NatTrans.ext; intro m; ext f;
  obtain ‚ü®f', hf‚ü© := (standardSimplex.objEquiv _ _).symm.surjective f.1;
  obtain ‚ü®j, hji, hfj‚ü© : ‚àÉ j, ¬¨j = i ‚àß ‚àÄ k, f'.toOrderHom k ‚â† j :=
    by simpa [‚Üê Set.univ_subset_iff, Set.subset_def, asOrderHom, not_or] using ‚Äπf ‚ü©.2;",127.16484713554382
mathlib,Mathlib/AlgebraicTopology/SimplicialSet.lean,"/-- Two morphisms from a horn are equal if they are equal on all suitable faces. -/
protected
lemma hom_ext {n : ‚Ñï} {i : Fin (n+2)} {S : SSet} (œÉ‚ÇÅ œÉ‚ÇÇ : Œõ[n+1, i] ‚ü∂ S)
    (h : ‚àÄ (j) (h : j ‚â† i), œÉ‚ÇÅ.app _ (face i j h) = œÉ‚ÇÇ.app _ (face i j h)) :
    œÉ‚ÇÅ = œÉ‚ÇÇ ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,20,True,,5,-0.75,"/-- Two morphisms from a horn are equal if they are equal on all suitable faces. -/
protected
lemma hom_ext {n : ‚Ñï} {i : Fin (n+2)} {S : SSet} (œÉ‚ÇÅ œÉ‚ÇÇ : Œõ[n+1, i] ‚ü∂ S)
    (h : ‚àÄ (j) (h : j ‚â† i), œÉ‚ÇÅ.app _ (face i j h) = œÉ‚ÇÇ.app _ (face i j h)) :
    œÉ‚ÇÅ = œÉ‚ÇÇ := by
  apply NatTrans.ext; apply funext; apply Opposite.rec; apply SimplexCategory.rec
  intro m; ext f
  obtain ‚ü®f', hf‚ü© := (standardSimplex.objEquiv _ _).symm.surjective f.1
  obtain ‚ü®j, hji, hfj‚ü© : ‚àÉ j, ¬¨j = i ‚àß ‚àÄ k, f'.toOrderHom k ‚â† j := by
    obtain ‚ü®f, hf'‚ü© := f
    subst hf
    simpa [‚Üê Set.univ_subset_iff, Set.subset_def, asOrderHom, not_or] using hf'
  have H : f = (Œõ[n+1, i].map (factor_Œ¥ f' j).op) (face i j hji) := by
    apply Subtype.ext
    apply (standardSimplex.objEquiv _ _).injective
    rw [‚Üê hf]
    exact (factor_Œ¥_spec f' j hfj).symm
  have H‚ÇÅ := congrFun (œÉ‚ÇÅ.naturality (factor_Œ¥ f' j).op) (face i j hji)
  have H‚ÇÇ := congrFun (œÉ‚ÇÇ.naturality (factor_Œ¥ f' j).op) (face i j hji)
  dsimp at H‚ÇÅ H‚ÇÇ
  erw [H, H‚ÇÅ, H‚ÇÇ, h _ hji]","/-- Two morphisms from a horn are equal if they are equal on all suitable faces. -/
protected
lemma hom_ext {n : ‚Ñï} {i : Fin (n+2)} {S : SSet} (œÉ‚ÇÅ œÉ‚ÇÇ : Œõ[n+1, i] ‚ü∂ S)
    (h : ‚àÄ (j) (h : j ‚â† i), œÉ‚ÇÅ.app _ (face i j h) = œÉ‚ÇÇ.app _ (face i j h)) :
    œÉ‚ÇÅ = œÉ‚ÇÇ  := by
  ext m f
  obtain ‚ü®f', hf‚ü© := (standardSimplex.objEquiv _ _).symm.surjective f.1
  obtain ‚ü®j, hji, hfj‚ü© : ‚àÉ j, j ‚â† i ‚àß ‚àÄ k, f'.toOrderHom k ‚â† j := by simpa using f.2
  dsimp [factor_Œ¥] at ‚ä¢ hf",155.27048802375793
mathlib,Mathlib/AlgebraicTopology/DoldKan/SplitSimplicialObject.lean,"theorem comp_PInfty_eq_zero_iff {Z : C} {n : ‚Ñï} (f : Z ‚ü∂ X _[n]) :
    f ‚â´ PInfty.f n = 0 ‚Üî f ‚â´ s.œÄSummand (IndexSet.id (op [n])) = 0 ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,20,True,,4,-0.8,"theorem comp_PInfty_eq_zero_iff {Z : C} {n : ‚Ñï} (f : Z ‚ü∂ X _[n]) :
    f ‚â´ PInfty.f n = 0 ‚Üî f ‚â´ s.œÄSummand (IndexSet.id (op [n])) = 0 := by
  constructor
  ¬∑ intro h
    rcases n with _|n
    ¬∑ dsimp at h
      rw [comp_id] at h
      rw [h, zero_comp]
    ¬∑ have h' := f ‚â´= PInfty_f_add_QInfty_f (n + 1)
      dsimp at h'
      rw [comp_id, comp_add, h, zero_add] at h'
      rw [‚Üê h', assoc, QInfty_f, decomposition_Q, Preadditive.sum_comp, Preadditive.comp_sum,
        Finset.sum_eq_zero]
      intro i _
      simp only [assoc, œÉ_comp_œÄSummand_id_eq_zero, comp_zero]
  ¬∑ intro h
    rw [‚Üê comp_id f, assoc, s.decomposition_id, Preadditive.sum_comp, Preadditive.comp_sum,
      Fintype.sum_eq_zero]
    intro A
    by_cases hA : A.EqId
    ¬∑ dsimp at hA
      subst hA
      rw [assoc, reassoc_of% h, zero_comp]
    ¬∑ simp only [assoc, s.cofan_inj_comp_PInfty_eq_zero A hA, comp_zero]","theorem comp_PInfty_eq_zero_iff {Z : C} {n : ‚Ñï} (f : Z ‚ü∂ X _[n]) :
    f ‚â´ PInfty.f n = 0 ‚Üî f ‚â´ s.œÄSummand (IndexSet.id (op [n])) = 0   := by
  constructor
  intro h
  rcases n with _|n
  exact (comp_id f).symm ‚ñ∏ h.trans zero_comp
  dsimp at *
  exact (comp_id f).symm ‚ñ∏ ((f ‚â´= PInfty_f_add_QInfty_f (n + 1)).trans (congr_arg (Œª x, f ‚â´ x + 0) h)).mpr $ Finset.sum_zero _ $ Œª i _, (associative_comp X _).symm ‚ñ∏ (coe_quot_map i $ Fin.snd_sum.trans $ Fin.eq_symm i.to_nat_gonum).mpr $ comp_zero X.symm ‚ñ∏ comp_id i",74.1943051815033
mathlib,Mathlib/AlgebraicTopology/SimplexCategory.lean,"open Fin in
lemma factor_Œ¥_spec {m n : ‚Ñï} (f : ([m] : SimplexCategory) ‚ü∂ [n+1]) (j : Fin (n+2))
    (hj : ‚àÄ (k : Fin (m+1)), f.toOrderHom k ‚â† j) :
    factor_Œ¥ f j ‚â´ Œ¥ j = f ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,21,True,,21,0.0,"open Fin in
lemma factor_Œ¥_spec {m n : ‚Ñï} (f : ([m] : SimplexCategory) ‚ü∂ [n+1]) (j : Fin (n+2))
    (hj : ‚àÄ (k : Fin (m+1)), f.toOrderHom k ‚â† j) :
    factor_Œ¥ f j ‚â´ Œ¥ j = f := by
  ext k : 3
  specialize hj k
  dsimp [factor_Œ¥, Œ¥, œÉ]
  cases' j using cases with j
  ¬∑ rw [predAbove_of_le_castSucc _ _ (zero_le _), castPred_zero, predAbove_of_castSucc_lt 0 _
    (castSucc_zero ‚ñ∏ pos_of_ne_zero hj),
    zero_succAbove, succ_pred]
  ¬∑ rw [predAbove_of_castSucc_lt 0 _ (castSucc_zero ‚ñ∏ succ_pos _), pred_succ]
    rcases hj.lt_or_lt with (hj | hj)
    ¬∑ rw [predAbove_of_le_castSucc j _]
      swap
      ¬∑ exact (le_castSucc_iff.mpr hj)
      ¬∑ rw [succAbove_of_castSucc_lt]
        swap
        ¬∑ rwa [castSucc_lt_succ_iff, castPred_le_iff, le_castSucc_iff]
        rw [castSucc_castPred]
    ¬∑ rw [predAbove_of_castSucc_lt]
      swap
      ¬∑ exact (castSucc_lt_succ _).trans hj
      rw [succAbove_of_le_castSucc]
      swap
      ¬∑ rwa [succ_le_castSucc_iff, lt_pred_iff]
      rw [succ_pred]","open Fin in
lemma factor_Œ¥_spec {m n : ‚Ñï} (f : ([m] : SimplexCategory) ‚ü∂ [n+1]) (j : Fin (n+2))
    (hj : ‚àÄ (k : Fin (m+1)), f.toOrderHom k ‚â† j) :
    factor_Œ¥ f j ‚â´ Œ¥ j = f := by
  ext k : 3
  specialize hj k
  dsimp [factor_Œ¥, Œ¥, œÉ]
  cases' j using cases with j
  ¬∑ rw [predAbove_of_le_castSucc _ _ (zero_le _), castPred_zero, predAbove_of_castSucc_lt 0 _
    (castSucc_zero ‚ñ∏ pos_of_ne_zero hj),
    zero_succAbove, succ_pred]
  ¬∑ rw [predAbove_of_castSucc_lt 0 _ (castSucc_zero ‚ñ∏ succ_pos _), pred_succ]
    rcases hj.lt_or_lt with (hj | hj)
    ¬∑ rw [predAbove_of_le_castSucc j _]
      swap
      ¬∑ exact (le_castSucc_iff.mpr hj)
      ¬∑ rw [succAbove_of_castSucc_lt]
        swap
        ¬∑ rwa [castSucc_lt_succ_iff, castPred_le_iff, le_castSucc_iff]
        rw [castSucc_castPred]
    ¬∑ rw [predAbove_of_castSucc_lt]
      swap
      ¬∑ exact (castSucc_lt_succ _).trans hj
      rw [succAbove_of_le_castSucc]
      swap
      ¬∑ rwa [succ_le_castSucc_iff, lt_pred_iff]
      rw [succ_pred]",104.13422513008118
mathlib,Mathlib/AlgebraicTopology/DoldKan/Decomposition.lean,"/-- In each positive degree, this lemma decomposes the idempotent endomorphism
`Q q` as a sum of morphisms which are postcompositions with suitable degeneracies.
As `Q q` is the complement projection to `P q`, this implies that in the case of
simplicial abelian groups, any $(n+1)$-simplex $x$ can be decomposed as
$x = x' + \sum (i=0}^{q-1} œÉ_{n-i}(y_i)$ where $x'$ is in the image of `P q` and
the $y_i$ are in degree $n$. -/
theorem decomposition_Q (n q : ‚Ñï) :
    ((Q q).f (n + 1) : X _[n + 1] ‚ü∂ X _[n + 1]) =
      ‚àë i ‚àà Finset.filter (fun i : Fin (n + 1) => (i : ‚Ñï) < q) Finset.univ,
        (P i).f (n + 1) ‚â´ X.Œ¥ i.rev.succ ‚â´ X.œÉ (Fin.rev i) ","refinement(best_of_n_n(prompt_flat), prev_data_num=1, keep_best=True)",5,LENGTH,gpt-4o,True,True,True,10,False,True,,28,True,,28,0.0,"/-- In each positive degree, this lemma decomposes the idempotent endomorphism
`Q q` as a sum of morphisms which are postcompositions with suitable degeneracies.
As `Q q` is the complement projection to `P q`, this implies that in the case of
simplicial abelian groups, any $(n+1)$-simplex $x$ can be decomposed as
$x = x' + \sum (i=0}^{q-1} œÉ_{n-i}(y_i)$ where $x'$ is in the image of `P q` and
the $y_i$ are in degree $n$. -/
theorem decomposition_Q (n q : ‚Ñï) :
    ((Q q).f (n + 1) : X _[n + 1] ‚ü∂ X _[n + 1]) =
      ‚àë i ‚àà Finset.filter (fun i : Fin (n + 1) => (i : ‚Ñï) < q) Finset.univ,
        (P i).f (n + 1) ‚â´ X.Œ¥ i.rev.succ ‚â´ X.œÉ (Fin.rev i) := by
  induction' q with q hq
  ¬∑ simp only [Nat.zero_eq, Q_zero, HomologicalComplex.zero_f_apply, Nat.not_lt_zero,
      Finset.filter_False, Finset.sum_empty]
  ¬∑ by_cases hqn : q + 1 ‚â§ n + 1
    swap
    ¬∑ rw [Q_is_eventually_constant (show n + 1 ‚â§ q by omega), hq]
      congr 1
      ext ‚ü®x, hx‚ü©
      simp only [Nat.succ_eq_add_one, Finset.mem_filter, Finset.mem_univ, true_and]
      omega
    ¬∑ cases' Nat.le.dest (Nat.succ_le_succ_iff.mp hqn) with a ha
      rw [Q_succ, HomologicalComplex.sub_f_apply, HomologicalComplex.comp_f, hq]
      symm
      conv_rhs => rw [sub_eq_add_neg, add_comm]
      let q' : Fin (n + 1) := ‚ü®q, Nat.succ_le_iff.mp hqn‚ü©
      rw [‚Üê @Finset.add_sum_erase _ _ _ _ _ _ q' (by simp)]
      congr
      ¬∑ have hnaq' : n = a + q := by omega
        simp only [Fin.val_mk, (HigherFacesVanish.of_P q n).comp_HœÉ_eq hnaq',
          q'.rev_eq hnaq', neg_neg]
        rfl
      ¬∑ ext ‚ü®i, hi‚ü©
        simp only [q', Nat.succ_eq_add_one, Nat.lt_succ_iff_lt_or_eq, Finset.mem_univ,
          forall_true_left, Finset.mem_filter, lt_self_iff_false, or_true, and_self, not_true,
          Finset.mem_erase, ne_eq, Fin.mk.injEq, true_and]
        aesop","/-- In each positive degree, this lemma decomposes the idempotent endomorphism
`Q q` as a sum of morphisms which are postcompositions with suitable degeneracies.
As `Q q` is the complement projection to `P q`, this implies that in the case of
simplicial abelian groups, any $(n+1)$-simplex $x$ can be decomposed as
$x = x' + \sum (i=0}^{q-1} œÉ_{n-i}(y_i)$ where $x'$ is in the image of `P q` and
the $y_i$ are in degree $n$. -/
theorem decomposition_Q (n q : ‚Ñï) :
    ((Q q).f (n + 1) : X _[n + 1] ‚ü∂ X _[n + 1]) =
      ‚àë i ‚àà Finset.filter (fun i : Fin (n + 1) => (i : ‚Ñï) < q) Finset.univ,
        (P i).f (n + 1) ‚â´ X.Œ¥ i.rev.succ ‚â´ X.œÉ (Fin.rev i) := by
  induction' q with q hq
  ¬∑ simp only [Nat.zero_eq, Q_zero, HomologicalComplex.zero_f_apply, Nat.not_lt_zero,
      Finset.filter_False, Finset.sum_empty]
  ¬∑ by_cases hqn : q + 1 ‚â§ n + 1
    swap
    ¬∑ rw [Q_is_eventually_constant (show n + 1 ‚â§ q by omega), hq]
      congr 1
      ext ‚ü®x, hx‚ü©
      simp only [Nat.succ_eq_add_one, Finset.mem_filter, Finset.mem_univ, true_and]
      omega
    ¬∑ cases' Nat.le.dest (Nat.succ_le_succ_iff.mp hqn) with a ha
      rw [Q_succ, HomologicalComplex.sub_f_apply, HomologicalComplex.comp_f, hq]
      symm
      conv_rhs => rw [sub_eq_add_neg, add_comm]
      let q' : Fin (n + 1) := ‚ü®q, Nat.succ_le_iff.mp hqn‚ü©
      rw [‚Üê @Finset.add_sum_erase _ _ _ _ _ _ q' (by simp)]
      congr
      ¬∑ have hnaq' : n = a + q := by omega
        simp only [Fin.val_mk, (HigherFacesVanish.of_P q n).comp_HœÉ_eq hnaq',
          q'.rev_eq hnaq', neg_neg]
        rfl
      ¬∑ ext ‚ü®i, hi‚ü©
        simp only [q', Nat.succ_eq_add_one, Nat.lt_succ_iff_lt_or_eq, Finset.mem_univ,
          forall_true_left, Finset.mem_filter, lt_self_iff_false, or_true, and_self, not_true,
          Finset.mem_erase, ne_eq, Fin.mk.injEq, true_and]
        aesop",80.05936408042908
