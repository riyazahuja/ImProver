{"cmd": "/-\nCopyright (c) 2020 Fox Thomson. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Fox Thomson\n-/\nimport Mathlib.Computability.Language\nimport Mathlib.Tactic.AdaptationNote\n\n#align_import computability.regular_expressions from \"leanprover-community/mathlib\"@\"369525b73f229ccd76a6ec0e0e0bf2be57599768\"\n\n/-!\n# Regular Expressions\n\nThis file contains the formal definition for regular expressions and basic lemmas. Note these are\nregular expressions in terms of formal language theory. Note this is different to regex's used in\ncomputer science such as the POSIX standard.\n\n## TODO\n\n* Show that this regular expressions and DFA/NFA's are equivalent. -/\n\n-- Porting note: this has been commented out\n-- * `attribute [pattern] has_mul.mul` has been added into this file, it could be moved.\n\n\n\nopen List Set\n\nopen Computability\n\nuniverse u\n\nvariable {\u03b1 \u03b2 \u03b3 : Type*} [dec : DecidableEq \u03b1]\n\n/-- This is the definition of regular expressions. The names used here is to mirror the definition\nof a Kleene algebra (https://en.wikipedia.org/wiki/Kleene_algebra).\n* `0` (`zero`) matches nothing\n* `1` (`epsilon`) matches only the empty string\n* `char a` matches only the string 'a'\n* `star P` matches any finite concatenation of strings which match `P`\n* `P + Q` (`plus P Q`) matches anything which match `P` or `Q`\n* `P * Q` (`comp P Q`) matches `x ++ y` if `x` matches `P` and `y` matches `Q`\n-/\ninductive RegularExpression (\u03b1 : Type u) : Type u\n  | zero : RegularExpression \u03b1\n  | epsilon : RegularExpression \u03b1\n  | char : \u03b1 \u2192 RegularExpression \u03b1\n  | plus : RegularExpression \u03b1 \u2192 RegularExpression \u03b1 \u2192 RegularExpression \u03b1\n  | comp : RegularExpression \u03b1 \u2192 RegularExpression \u03b1 \u2192 RegularExpression \u03b1\n  | star : RegularExpression \u03b1 \u2192 RegularExpression \u03b1\n#align regular_expression RegularExpression\n\n\n-- Porting note: `simpNF` gets grumpy about how the `foo_def`s below can simplify these..\nattribute [nolint simpNF] RegularExpression.zero.sizeOf_spec\nattribute [nolint simpNF] RegularExpression.epsilon.sizeOf_spec\nattribute [nolint simpNF] RegularExpression.plus.sizeOf_spec\nattribute [nolint simpNF] RegularExpression.plus.injEq\nattribute [nolint simpNF] RegularExpression.comp.injEq\nattribute [nolint simpNF] RegularExpression.comp.sizeOf_spec\n\nnamespace RegularExpression\n\nvariable {a b : \u03b1}\n\ninstance : Inhabited (RegularExpression \u03b1) :=\n  \u27e8zero\u27e9\n\ninstance : Add (RegularExpression \u03b1) :=\n  \u27e8plus\u27e9\n\ninstance : Mul (RegularExpression \u03b1) :=\n  \u27e8comp\u27e9\n\ninstance : One (RegularExpression \u03b1) :=\n  \u27e8epsilon\u27e9\n\ninstance : Zero (RegularExpression \u03b1) :=\n  \u27e8zero\u27e9\n\ninstance : Pow (RegularExpression \u03b1) \u2115 :=\n  \u27e8fun n r => npowRec r n\u27e9\n\n-- Porting note: declaration in an imported module\n--attribute [match_pattern] Mul.mul\n\n@[simp]\ntheorem zero_def : (zero : RegularExpression \u03b1) = 0 :=\n  rfl\n#align regular_expression.zero_def RegularExpression.zero_def\n\n@[simp]\ntheorem one_def : (epsilon : RegularExpression \u03b1) = 1 :=\n  rfl\n#align regular_expression.one_def RegularExpression.one_def\n\n@[simp]\ntheorem plus_def (P Q : RegularExpression \u03b1) : plus P Q = P + Q :=\n  rfl\n#align regular_expression.plus_def RegularExpression.plus_def\n\n@[simp]\ntheorem comp_def (P Q : RegularExpression \u03b1) : comp P Q = P * Q :=\n  rfl\n#align regular_expression.comp_def RegularExpression.comp_def\n\n-- Porting note: `matches` is reserved, moved to `matches'`\n#adaptation_note /-- around nightly-2024-02-25,\n  we need to write `comp x y` in the pattern `comp P Q`, instead of `x * y`. -/\n/-- `matches' P` provides a language which contains all strings that `P` matches -/\n-- Porting note: was '@[simp] but removed based on\n-- https://leanprover.zulipchat.com/#narrow/stream/287929-mathlib4/topic/simpNF.20issues.20in.20Computability.2ERegularExpressions.20!4.232306/near/328355362\ndef matches' : RegularExpression \u03b1 \u2192 Language \u03b1\n  | 0 => 0\n  | 1 => 1\n  | char a => {[a]}\n  | P + Q => P.matches' + Q.matches'\n  | comp P Q => P.matches' * Q.matches'\n  | star P => P.matches'\u2217\n#align regular_expression.matches RegularExpression.matches'\n\n@[simp]\ntheorem matches'_zero : (0 : RegularExpression \u03b1).matches' = 0 :=\n  rfl\n#align regular_expression.matches_zero RegularExpression.matches'_zero\n\n@[simp]\ntheorem matches'_epsilon : (1 : RegularExpression \u03b1).matches' = 1 :=\n  rfl\n#align regular_expression.matches_epsilon RegularExpression.matches'_epsilon\n\n@[simp]\ntheorem matches'_char (a : \u03b1) : (char a).matches' = {[a]} :=\n  rfl\n#align regular_expression.matches_char RegularExpression.matches'_char\n\n@[simp]\ntheorem matches'_add (P Q : RegularExpression \u03b1) : (P + Q).matches' = P.matches' + Q.matches' :=\n  rfl\n#align regular_expression.matches_add RegularExpression.matches'_add\n\n@[simp]\ntheorem matches'_mul (P Q : RegularExpression \u03b1) : (P * Q).matches' = P.matches' * Q.matches' :=\n  rfl\n#align regular_expression.matches_mul RegularExpression.matches'_mul\n\n@[simp]\ntheorem matches'_pow (P : RegularExpression \u03b1) : \u2200 n : \u2115, (P ^ n).matches' = P.matches' ^ n\n  | 0 => matches'_epsilon\n  | n + 1 => (matches'_mul _ _).trans <| Eq.trans\n      (congrFun (congrArg HMul.hMul (matches'_pow P n)) (matches' P))\n      (pow_succ _ n).symm\n#align regular_expression.matches_pow RegularExpression.matches'_pow\n\n@[simp]\ntheorem matches'_star (P : RegularExpression \u03b1) : P.star.matches' = P.matches'\u2217 :=\n  rfl\n#align regular_expression.matches_star RegularExpression.matches'_star\n\n#adaptation_note /-- around nightly-2024-02-25,\n  we need to write `comp x y` in the pattern `comp P Q`, instead of `x * y`. -/\n/-- `matchEpsilon P` is true if and only if `P` matches the empty string -/\ndef matchEpsilon : RegularExpression \u03b1 \u2192 Bool\n  | 0 => false\n  | 1 => true\n  | char _ => false\n  | P + Q => P.matchEpsilon || Q.matchEpsilon\n  | comp P Q => P.matchEpsilon && Q.matchEpsilon\n  | star _P => true\n#align regular_expression.match_epsilon RegularExpression.matchEpsilon\n\n#adaptation_note /-- around nightly-2024-02-25,\n  we need to write `comp x y` in the pattern `comp P Q`, instead of `x * y`. -/\n/-- `P.deriv a` matches `x` if `P` matches `a :: x`, the Brzozowski derivative of `P` with respect\n  to `a` -/\ndef deriv : RegularExpression \u03b1 \u2192 \u03b1 \u2192 RegularExpression \u03b1\n  | 0, _ => 0\n  | 1, _ => 0\n  | char a\u2081, a\u2082 => if a\u2081 = a\u2082 then 1 else 0\n  | P + Q, a => deriv P a + deriv Q a\n  | comp P Q, a => if P.matchEpsilon then deriv P a * Q + deriv Q a else deriv P a * Q\n  | star P, a => deriv P a * star P\n#align regular_expression.deriv RegularExpression.deriv\n\n@[simp]\ntheorem deriv_zero (a : \u03b1) : deriv 0 a = 0 :=\n  rfl\n#align regular_expression.deriv_zero RegularExpression.deriv_zero\n\n@[simp]\ntheorem deriv_one (a : \u03b1) : deriv 1 a = 0 :=\n  rfl\n#align regular_expression.deriv_one RegularExpression.deriv_one\n\n@[simp]\ntheorem deriv_char_self (a : \u03b1) : deriv (char a) a = 1 :=\n  if_pos rfl\n#align regular_expression.deriv_char_self RegularExpression.deriv_char_self\n\n@[simp]\ntheorem deriv_char_of_ne (h : a \u2260 b) : deriv (char a) b = 0 :=\n  if_neg h\n#align regular_expression.deriv_char_of_ne RegularExpression.deriv_char_of_ne\n\n@[simp]\ntheorem deriv_add (P Q : RegularExpression \u03b1) (a : \u03b1) : deriv (P + Q) a = deriv P a + deriv Q a :=\n  rfl\n#align regular_expression.deriv_add RegularExpression.deriv_add\n\n@[simp]\ntheorem deriv_star (P : RegularExpression \u03b1) (a : \u03b1) : deriv P.star a = deriv P a * star P :=\n  rfl\n#align regular_expression.deriv_star RegularExpression.deriv_star\n\n/-- `P.rmatch x` is true if and only if `P` matches `x`. This is a computable definition equivalent\n  to `matches'`. -/\ndef rmatch : RegularExpression \u03b1 \u2192 List \u03b1 \u2192 Bool\n  | P, [] => matchEpsilon P\n  | P, a :: as => rmatch (P.deriv a) as\n#align regular_expression.rmatch RegularExpression.rmatch\n"}

{"cmd": "@[simp]\ntheorem zero_rmatch (x : List \u03b1) : rmatch 0 x = false := by\n  induction x <;> simp [rmatch, matchEpsilon, *]\n#align regular_expression.zero_rmatch RegularExpression.zero_rmatch\n\ntheorem one_rmatch_iff (x : List \u03b1) : rmatch 1 x \u2194 x = [] := by\n  induction x <;> simp [rmatch, matchEpsilon, *]\n#align regular_expression.one_rmatch_iff RegularExpression.one_rmatch_iff\n\n\ntheorem char_rmatch_iff (a : \u03b1) (x : List \u03b1) : rmatch (char a) x \u2194 x = [a]  := by\n  cases x with head tail\n  rw [rmatch, deriv]\n  split_ifs\n  simp [List.singleton_inj]; tauto\n  rw [rmatch, rmatch, deriv]\n  split_ifs with h\n  simp only [deriv_one, zero_rmatch, cons.injEq, and_false]\n  simp only [deriv_zero, zero_rmatch, cons.injEq, and_false]\n  simp [List.singleton_inj]; tauto\n", "allTactics": true, "theorems": true, "env": 0}

{"cmd": "@[simp]\ntheorem zero_rmatch (x : List \u03b1) : rmatch 0 x = false := by\n  induction x <;> simp [rmatch, matchEpsilon, *]\n#align regular_expression.zero_rmatch RegularExpression.zero_rmatch\n\ntheorem one_rmatch_iff (x : List \u03b1) : rmatch 1 x \u2194 x = [] := by\n  induction x <;> simp [rmatch, matchEpsilon, *]\n#align regular_expression.one_rmatch_iff RegularExpression.one_rmatch_iff\n\n\ntheorem char_rmatch_iff (a : \u03b1) (x : List \u03b1) : rmatch (char a) x \u2194 x = [a]  := by\n  cases x\n  \u00b7 exact of_decide_eq_true rfl\n  cases x\n  \u00b7 rw [rmatch, deriv]; split_ifs; simp [List.singleton_inj]; tauto\n  \u00b7 rw [rmatch, rmatch, deriv]; split_ifs with h; simp only [deriv_one, zero_rmatch, cons.injEq, and_false, deriv_zero]\n", "allTactics": true, "theorems": true, "env": 0}

{"cmd": "@[simp]\ntheorem zero_rmatch (x : List \u03b1) : rmatch 0 x = false := by\n  induction x <;> simp [rmatch, matchEpsilon, *]\n#align regular_expression.zero_rmatch RegularExpression.zero_rmatch\n\ntheorem one_rmatch_iff (x : List \u03b1) : rmatch 1 x \u2194 x = [] := by\n  induction x <;> simp [rmatch, matchEpsilon, *]\n#align regular_expression.one_rmatch_iff RegularExpression.one_rmatch_iff\n\n\ntheorem char_rmatch_iff (a : \u03b1) (x : List \u03b1) : rmatch (char a) x \u2194 x = [a]  := by\n  cases x\n  \u00b7 exact of_decide_eq_true rfl\n  cases x with head tail <;> rw [rmatch, deriv]; split_ifs <;> simp [List.singleton_inj]; tauto\n", "allTactics": true, "theorems": true, "env": 0}