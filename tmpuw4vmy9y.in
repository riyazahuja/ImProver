{"cmd": "/-\nCopyright (c) 2019 Scott Morrison. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Scott Morrison, Markus Himmel\n-/\nimport Mathlib.CategoryTheory.Limits.Shapes.Equalizers\nimport Mathlib.CategoryTheory.Limits.Shapes.Pullbacks\nimport Mathlib.CategoryTheory.Limits.Shapes.StrongEpi\nimport Mathlib.CategoryTheory.MorphismProperty.Factorization\n\n#align_import category_theory.limits.shapes.images from \"leanprover-community/mathlib\"@\"563aed347eb59dc4181cb732cda0d124d736eaa3\"\n\n/-!\n# Categorical images\n\nWe define the categorical image of `f` as a factorisation `f = e \u226b m` through a monomorphism `m`,\nso that `m` factors through the `m'` in any other such factorisation.\n\n## Main definitions\n\n* A `MonoFactorisation` is a factorisation `f = e \u226b m`, where `m` is a monomorphism\n* `IsImage F` means that a given mono factorisation `F` has the universal property of the image.\n* `HasImage f` means that there is some image factorization for the morphism `f : X \u27f6 Y`.\n  * In this case, `image f` is some image object (selected with choice), `image.\u03b9 f : image f \u27f6 Y`\n    is the monomorphism `m` of the factorisation and `factorThruImage f : X \u27f6 image f` is the\n    morphism `e`.\n* `HasImages C` means that every morphism in `C` has an image.\n* Let `f : X \u27f6 Y` and `g : P \u27f6 Q` be morphisms in `C`, which we will represent as objects of the\n  arrow category `arrow C`. Then `sq : f \u27f6 g` is a commutative square in `C`. If `f` and `g` have\n  images, then `HasImageMap sq` represents the fact that there is a morphism\n  `i : image f \u27f6 image g` making the diagram\n\n  X ----\u2192 image f ----\u2192 Y\n  |         |           |\n  |         |           |\n  \u2193         \u2193           \u2193\n  P ----\u2192 image g ----\u2192 Q\n\n  commute, where the top row is the image factorisation of `f`, the bottom row is the image\n  factorisation of `g`, and the outer rectangle is the commutative square `sq`.\n* If a category `HasImages`, then `HasImageMaps` means that every commutative square admits an\n  image map.\n* If a category `HasImages`, then `HasStrongEpiImages` means that the morphism to the image is\n  always a strong epimorphism.\n\n## Main statements\n\n* When `C` has equalizers, the morphism `e` appearing in an image factorisation is an epimorphism.\n* When `C` has strong epi images, then these images admit image maps.\n\n## Future work\n* TODO: coimages, and abelian categories.\n* TODO: connect this with existing working in the group theory and ring theory libraries.\n\n-/\n\n\nnoncomputable section\n\nuniverse v u\n\nopen CategoryTheory\n\nopen CategoryTheory.Limits.WalkingParallelPair\n\nnamespace CategoryTheory.Limits\n\nvariable {C : Type u} [Category.{v} C]\nvariable {X Y : C} (f : X \u27f6 Y)\n\n/-- A factorisation of a morphism `f = e \u226b m`, with `m` monic. -/\nstructure MonoFactorisation (f : X \u27f6 Y) where\n  I : C -- Porting note: violates naming conventions but can't think a better replacement\n  m : I \u27f6 Y\n  [m_mono : Mono m]\n  e : X \u27f6 I\n  fac : e \u226b m = f := by aesop_cat\n#align category_theory.limits.mono_factorisation CategoryTheory.Limits.MonoFactorisation\n#align category_theory.limits.mono_factorisation.fac' CategoryTheory.Limits.MonoFactorisation.fac\n\nattribute [inherit_doc MonoFactorisation] MonoFactorisation.I MonoFactorisation.m\n  MonoFactorisation.m_mono MonoFactorisation.e MonoFactorisation.fac\n\nattribute [reassoc (attr := simp)] MonoFactorisation.fac\n\nattribute [instance] MonoFactorisation.m_mono\n\nattribute [instance] MonoFactorisation.m_mono\n\nnamespace MonoFactorisation\n\n/-- The obvious factorisation of a monomorphism through itself. -/\ndef self [Mono f] : MonoFactorisation f where\n  I := X\n  m := f\n  e := \ud835\udfd9 X\n#align category_theory.limits.mono_factorisation.self CategoryTheory.Limits.MonoFactorisation.self\n\n-- I'm not sure we really need this, but the linter says that an inhabited instance\n-- ought to exist...\ninstance [Mono f] : Inhabited (MonoFactorisation f) := \u27e8self f\u27e9\n\nvariable {f}\n"}

{"cmd": "/-- The morphism `m` in a factorisation `f = e \u226b m` through a monomorphism is uniquely\ndetermined. -/\n@[ext]\ntheorem ext {F F' : MonoFactorisation f} (hI : F.I = F'.I)\n    (hm : F.m = eqToHom hI \u226b F'.m) : F = F' := by\n  cases' F with _ Fm _ _ Ffac; cases' F' with _ Fm' _ _ Ffac'\n  cases' hI\n  simp? at hm says simp only [eqToHom_refl, Category.id_comp] at hm\n  congr\n  apply (cancel_mono Fm).1\n  rw [Ffac, hm, Ffac']\n#align category_theory.limits.mono_factorisation.ext CategoryTheory.Limits.MonoFactorisation.ext\n\n/-- Any mono factorisation of `f` gives a mono factorisation of `f \u226b g` when `g` is a mono. -/\n@[simps]\ndef compMono (F : MonoFactorisation f) {Y' : C} (g : Y \u27f6 Y') [Mono g] :\n    MonoFactorisation (f \u226b g) where\n  I := F.I\n  m := F.m \u226b g\n  m_mono := mono_comp _ _\n  e := F.e\n#align category_theory.limits.mono_factorisation.comp_mono CategoryTheory.Limits.MonoFactorisation.compMono\n\n/-- A mono factorisation of `f \u226b g`, where `g` is an isomorphism,\ngives a mono factorisation of `f`. -/\n@[simps]\ndef ofCompIso {Y' : C} {g : Y \u27f6 Y'} [IsIso g] (F : MonoFactorisation (f \u226b g)) :\n    MonoFactorisation f where\n  I := F.I\n  m := F.m \u226b inv g\n  m_mono := mono_comp _ _\n  e := F.e\n#align category_theory.limits.mono_factorisation.of_comp_iso CategoryTheory.Limits.MonoFactorisation.ofCompIso\n\n/-- Any mono factorisation of `f` gives a mono factorisation of `g \u226b f`. -/\n@[simps]\ndef isoComp (F : MonoFactorisation f) {X' : C} (g : X' \u27f6 X) : MonoFactorisation (g \u226b f) where\n  I := F.I\n  m := F.m\n  e := g \u226b F.e\n#align category_theory.limits.mono_factorisation.iso_comp CategoryTheory.Limits.MonoFactorisation.isoComp\n\n/-- A mono factorisation of `g \u226b f`, where `g` is an isomorphism,\ngives a mono factorisation of `f`. -/\n@[simps]\ndef ofIsoComp {X' : C} (g : X' \u27f6 X) [IsIso g] (F : MonoFactorisation (g \u226b f)) :\n    MonoFactorisation f where\n  I := F.I\n  m := F.m\n  e := inv g \u226b F.e\n#align category_theory.limits.mono_factorisation.of_iso_comp CategoryTheory.Limits.MonoFactorisation.ofIsoComp\n\n/-- If `f` and `g` are isomorphic arrows, then a mono factorisation of `f`\ngives a mono factorisation of `g` -/\n@[simps]\ndef ofArrowIso {f g : Arrow C} (F : MonoFactorisation f.hom) (sq : f \u27f6 g) [IsIso sq] :\n    MonoFactorisation g.hom where\n  I := F.I\n  m := F.m \u226b sq.right\n  e := inv sq.left \u226b F.e\n  m_mono := mono_comp _ _\n  fac := by simp only [fac_assoc, Arrow.w, IsIso.inv_comp_eq, Category.assoc]\n#align category_theory.limits.mono_factorisation.of_arrow_iso CategoryTheory.Limits.MonoFactorisation.ofArrowIso\n\nend MonoFactorisation\n\nvariable {f}\n\n/-- Data exhibiting that a given factorisation through a mono is initial. -/\nstructure IsImage (F : MonoFactorisation f) where\n  lift : \u2200 F' : MonoFactorisation f, F.I \u27f6 F'.I\n  lift_fac : \u2200 F' : MonoFactorisation f, lift F' \u226b F'.m = F.m := by aesop_cat\n#align category_theory.limits.is_image CategoryTheory.Limits.IsImage\n#align category_theory.limits.is_image.lift_fac' CategoryTheory.Limits.IsImage.lift_fac\n\nattribute [inherit_doc IsImage] IsImage.lift IsImage.lift_fac\n\nattribute [reassoc (attr := simp)] IsImage.lift_fac\n\nnamespace IsImage\n\n@[reassoc (attr := simp)]\ntheorem fac_lift {F : MonoFactorisation f} (hF : IsImage F) (F' : MonoFactorisation f) :\n    F.e \u226b hF.lift F' = F'.e :=\n  (cancel_mono F'.m).1 <| by simp\n#align category_theory.limits.is_image.fac_lift CategoryTheory.Limits.IsImage.fac_lift\n\nvariable (f)\n\n/-- The trivial factorisation of a monomorphism satisfies the universal property. -/\n@[simps]\ndef self [Mono f] : IsImage (MonoFactorisation.self f) where lift F' := F'.e\n#align category_theory.limits.is_image.self CategoryTheory.Limits.IsImage.self\n\ninstance [Mono f] : Inhabited (IsImage (MonoFactorisation.self f)) :=\n  \u27e8self f\u27e9\n\nvariable {f}\n\n-- TODO this is another good candidate for a future `UniqueUpToCanonicalIso`.\n/-- Two factorisations through monomorphisms satisfying the universal property\nmust factor through isomorphic objects. -/\n@[simps]\ndef isoExt {F F' : MonoFactorisation f} (hF : IsImage F) (hF' : IsImage F') :\n    F.I \u2245 F'.I where\n  hom := hF.lift F'\n  inv := hF'.lift F\n  hom_inv_id := (cancel_mono F.m).1 (by simp)\n  inv_hom_id := (cancel_mono F'.m).1 (by simp)\n#align category_theory.limits.is_image.iso_ext CategoryTheory.Limits.IsImage.isoExt\n\nvariable {F F' : MonoFactorisation f} (hF : IsImage F) (hF' : IsImage F')\n\ntheorem isoExt_hom_m : (isoExt hF hF').hom \u226b F'.m = F.m := by simp\n#align category_theory.limits.is_image.iso_ext_hom_m CategoryTheory.Limits.IsImage.isoExt_hom_m\n\ntheorem isoExt_inv_m : (isoExt hF hF').inv \u226b F.m = F'.m := by simp\n#align category_theory.limits.is_image.iso_ext_inv_m CategoryTheory.Limits.IsImage.isoExt_inv_m\n\ntheorem e_isoExt_hom : F.e \u226b (isoExt hF hF').hom = F'.e := by simp\n#align category_theory.limits.is_image.e_iso_ext_hom CategoryTheory.Limits.IsImage.e_isoExt_hom\n\ntheorem e_isoExt_inv : F'.e \u226b (isoExt hF hF').inv = F.e := by simp\n#align category_theory.limits.is_image.e_iso_ext_inv CategoryTheory.Limits.IsImage.e_isoExt_inv\n\n/-- If `f` and `g` are isomorphic arrows, then a mono factorisation of `f` that is an image\ngives a mono factorisation of `g` that is an image -/\n@[simps]\ndef ofArrowIso {f g : Arrow C} {F : MonoFactorisation f.hom} (hF : IsImage F) (sq : f \u27f6 g)\n    [IsIso sq] : IsImage (F.ofArrowIso sq) where\n  lift F' := hF.lift (F'.ofArrowIso (inv sq))\n  lift_fac F' := by\n    simpa only [MonoFactorisation.ofArrowIso_m, Arrow.inv_right, \u2190 Category.assoc,\n      IsIso.comp_inv_eq] using hF.lift_fac (F'.ofArrowIso (inv sq))\n#align category_theory.limits.is_image.of_arrow_iso CategoryTheory.Limits.IsImage.ofArrowIso\n\nend IsImage\n\nvariable (f)\n\n/-- Data exhibiting that a morphism `f` has an image. -/\nstructure ImageFactorisation (f : X \u27f6 Y) where\n  F : MonoFactorisation f -- Porting note: another violation of the naming convention\n  isImage : IsImage F\n#align category_theory.limits.image_factorisation CategoryTheory.Limits.ImageFactorisation\n#align category_theory.limits.image_factorisation.is_image CategoryTheory.Limits.ImageFactorisation.isImage\n\nattribute [inherit_doc ImageFactorisation] ImageFactorisation.F ImageFactorisation.isImage\n\nnamespace ImageFactorisation\n\ninstance [Mono f] : Inhabited (ImageFactorisation f) :=\n  \u27e8\u27e8_, IsImage.self f\u27e9\u27e9\n\n/-- If `f` and `g` are isomorphic arrows, then an image factorisation of `f`\ngives an image factorisation of `g` -/\n@[simps]\ndef ofArrowIso {f g : Arrow C} (F : ImageFactorisation f.hom) (sq : f \u27f6 g) [IsIso sq] :\n    ImageFactorisation g.hom where\n  F := F.F.ofArrowIso sq\n  isImage := F.isImage.ofArrowIso sq\n#align category_theory.limits.image_factorisation.of_arrow_iso CategoryTheory.Limits.ImageFactorisation.ofArrowIso\n\nend ImageFactorisation\n\n/-- `has_image f` means that there exists an image factorisation of `f`. -/\nclass HasImage (f : X \u27f6 Y) : Prop where mk' ::\n  exists_image : Nonempty (ImageFactorisation f)\n#align category_theory.limits.has_image CategoryTheory.Limits.HasImage\n\nattribute [inherit_doc HasImage] HasImage.exists_image\n\ntheorem HasImage.mk {f : X \u27f6 Y} (F : ImageFactorisation f) : HasImage f :=\n  \u27e8Nonempty.intro F\u27e9\n#align category_theory.limits.has_image.mk CategoryTheory.Limits.HasImage.mk\n\ntheorem HasImage.of_arrow_iso {f g : Arrow C} [h : HasImage f.hom] (sq : f \u27f6 g) [IsIso sq] :\n    HasImage g.hom :=\n  \u27e8\u27e8h.exists_image.some.ofArrowIso sq\u27e9\u27e9\n#align category_theory.limits.has_image.of_arrow_iso CategoryTheory.Limits.HasImage.of_arrow_iso\n\ninstance (priority := 100) mono_hasImage (f : X \u27f6 Y) [Mono f] : HasImage f :=\n  HasImage.mk \u27e8_, IsImage.self f\u27e9\n#align category_theory.limits.mono_has_image CategoryTheory.Limits.mono_hasImage\n\nsection\n\nvariable [HasImage f]\n\n/-- Some factorisation of `f` through a monomorphism (selected with choice). -/\ndef Image.monoFactorisation : MonoFactorisation f :=\n  (Classical.choice HasImage.exists_image).F\n#align category_theory.limits.image.mono_factorisation CategoryTheory.Limits.Image.monoFactorisation\n\n/-- The witness of the universal property for the chosen factorisation of `f` through\na monomorphism. -/\ndef Image.isImage : IsImage (Image.monoFactorisation f) :=\n  (Classical.choice HasImage.exists_image).isImage\n#align category_theory.limits.image.is_image CategoryTheory.Limits.Image.isImage\n\n/-- The categorical image of a morphism. -/\ndef image : C :=\n  (Image.monoFactorisation f).I\n#align category_theory.limits.image CategoryTheory.Limits.image\n\n/-- The inclusion of the image of a morphism into the target. -/\ndef image.\u03b9 : image f \u27f6 Y :=\n  (Image.monoFactorisation f).m\n#align category_theory.limits.image.\u03b9 CategoryTheory.Limits.image.\u03b9\n\n@[simp]\ntheorem image.as_\u03b9 : (Image.monoFactorisation f).m = image.\u03b9 f := rfl\n#align category_theory.limits.image.as_\u03b9 CategoryTheory.Limits.image.as_\u03b9\n\ninstance : Mono (image.\u03b9 f) :=\n  (Image.monoFactorisation f).m_mono\n\n/-- The map from the source to the image of a morphism. -/\ndef factorThruImage : X \u27f6 image f :=\n  (Image.monoFactorisation f).e\n#align category_theory.limits.factor_thru_image CategoryTheory.Limits.factorThruImage\n\n/-- Rewrite in terms of the `factorThruImage` interface. -/\n@[simp]\ntheorem as_factorThruImage : (Image.monoFactorisation f).e = factorThruImage f :=\n  rfl\n#align category_theory.limits.as_factor_thru_image CategoryTheory.Limits.as_factorThruImage\n\n@[reassoc (attr := simp)]\ntheorem image.fac : factorThruImage f \u226b image.\u03b9 f = f :=\n  (Image.monoFactorisation f).fac\n#align category_theory.limits.image.fac CategoryTheory.Limits.image.fac\n\nvariable {f}\n\n/-- Any other factorisation of the morphism `f` through a monomorphism receives a map from the\nimage. -/\ndef image.lift (F' : MonoFactorisation f) : image f \u27f6 F'.I :=\n  (Image.isImage f).lift F'\n#align category_theory.limits.image.lift CategoryTheory.Limits.image.lift\n\n@[reassoc (attr := simp)]\ntheorem image.lift_fac (F' : MonoFactorisation f) : image.lift F' \u226b F'.m = image.\u03b9 f :=\n  (Image.isImage f).lift_fac F'\n#align category_theory.limits.image.lift_fac CategoryTheory.Limits.image.lift_fac\n\n@[reassoc (attr := simp)]\ntheorem image.fac_lift (F' : MonoFactorisation f) : factorThruImage f \u226b image.lift F' = F'.e :=\n  (Image.isImage f).fac_lift F'\n#align category_theory.limits.image.fac_lift CategoryTheory.Limits.image.fac_lift\n\n@[simp]\ntheorem image.isImage_lift (F : MonoFactorisation f) : (Image.isImage f).lift F = image.lift F :=\n  rfl\n#align category_theory.limits.image.is_image_lift CategoryTheory.Limits.image.isImage_lift\n\n@[reassoc (attr := simp)]\ntheorem IsImage.lift_\u03b9 {F : MonoFactorisation f} (hF : IsImage F) :\n    hF.lift (Image.monoFactorisation f) \u226b image.\u03b9 f = F.m :=\n  hF.lift_fac _\n#align category_theory.limits.is_image.lift_\u03b9 CategoryTheory.Limits.IsImage.lift_\u03b9\n\n-- TODO we could put a category structure on `MonoFactorisation f`,\n-- with the morphisms being `g : I \u27f6 I'` commuting with the `m`s\n-- (they then automatically commute with the `e`s)\n-- and show that an `imageOf f` gives an initial object there\n-- (uniqueness of the lift comes for free).\ninstance image.lift_mono (F' : MonoFactorisation f) : Mono (image.lift F') := by\n  refine @mono_of_mono _ _ _ _ _ _ F'.m ?_\n  simpa using MonoFactorisation.m_mono _\n#align category_theory.limits.image.lift_mono CategoryTheory.Limits.image.lift_mono\n\ntheorem HasImage.uniq (F' : MonoFactorisation f) (l : image f \u27f6 F'.I) (w : l \u226b F'.m = image.\u03b9 f) :\n    l = image.lift F' :=\n  (cancel_mono F'.m).1 (by simp [w])\n#align category_theory.limits.has_image.uniq CategoryTheory.Limits.HasImage.uniq\n\n/-- If `has_image g`, then `has_image (f \u226b g)` when `f` is an isomorphism. -/\ninstance {X Y Z : C} (f : X \u27f6 Y) [IsIso f] (g : Y \u27f6 Z) [HasImage g] : HasImage (f \u226b g) where\n  exists_image :=\n    \u27e8{  F :=\n          { I := image g\n            m := image.\u03b9 g\n            e := f \u226b factorThruImage g }\n        isImage :=\n          { lift := fun F' => image.lift\n                { I := F'.I\n                  m := F'.m\n                  e := inv f \u226b F'.e } } }\u27e9\n\nend\n\nsection\n\nvariable (C)\n\n/-- `HasImages` asserts that every morphism has an image. -/\nclass HasImages : Prop where\n  has_image : \u2200 {X Y : C} (f : X \u27f6 Y), HasImage f\n#align category_theory.limits.has_images CategoryTheory.Limits.HasImages\n\nattribute [inherit_doc HasImages] HasImages.has_image\n\nattribute [instance 100] HasImages.has_image\n\nend\n\nsection\n\n/-- The image of a monomorphism is isomorphic to the source. -/\ndef imageMonoIsoSource [Mono f] : image f \u2245 X :=\n  IsImage.isoExt (Image.isImage f) (IsImage.self f)\n#align category_theory.limits.image_mono_iso_source CategoryTheory.Limits.imageMonoIsoSource\n\n@[reassoc (attr := simp)]\ntheorem imageMonoIsoSource_inv_\u03b9 [Mono f] : (imageMonoIsoSource f).inv \u226b image.\u03b9 f = f := by\n  simp [imageMonoIsoSource]\n#align category_theory.limits.image_mono_iso_source_inv_\u03b9 CategoryTheory.Limits.imageMonoIsoSource_inv_\u03b9\n\n@[reassoc (attr := simp)]\ntheorem imageMonoIsoSource_hom_self [Mono f] : (imageMonoIsoSource f).hom \u226b f = image.\u03b9 f := by\n  simp only [\u2190 imageMonoIsoSource_inv_\u03b9 f]\n  rw [\u2190 Category.assoc, Iso.hom_inv_id, Category.id_comp]\n#align category_theory.limits.image_mono_iso_source_hom_self CategoryTheory.Limits.imageMonoIsoSource_hom_self\n\n-- This is the proof that `factorThruImage f` is an epimorphism\n-- from https://en.wikipedia.org/wiki/Image_%28category_theory%29, which is in turn taken from:\n-- Mitchell, Barry (1965), Theory of categories, MR 0202787, p.12, Proposition 10.1\n\n@[ext]\ntheorem image.ext [HasImage f] {W : C} {g h : image f \u27f6 W} [HasLimit (parallelPair g h)]\n    (w : factorThruImage f \u226b g = factorThruImage f \u226b h) : g = h  := by\n  let q := equalizer.\u03b9 g h\n  let v := image.lift { I := equalizer g h, m := q \u226b image.\u03b9 f, e := equalizer.lift _ w }\n  have t : v \u226b q = \ud835\udfd9 (image f) := (cancel_mono_id (image.\u03b9 f)).1 (by convert image.lift_fac _; rw [Category.assoc])\n  calc\n    g = \ud835\udfd9 (image f) \u226b g := by rw [Category.id_comp]\n    _ = v \u226b q \u226b g := by rw [\u2190 t, Category.assoc]\n    _ = v \u226b q \u226b h := by rw [equalizer.condition g h]\n    _ = \ud835\udfd9 (image f) \u226b h := by rw [\u2190 Category.assoc, t]\n    _ = h := by rw [Category.id_comp]\n", "allTactics": true, "theorems": true, "env": 0}