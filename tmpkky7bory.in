{"cmd": "/- Copyright 2023 Daniel J. Velleman -/\n\nimport HTPILib.Chap3\nnamespace HTPI\n\n/- Definitions -/\ndef Dom {A B : Type} (R : Set (A \u00d7 B)) : Set A :=\n  {a : A | \u2203 (b : B), (a, b) \u2208 R}\n\ndef Ran {A B : Type} (R : Set (A \u00d7 B)) : Set B :=\n  {b : B | \u2203 (a : A), (a, b) \u2208 R}\n\ndef inv {A B : Type} (R : Set (A \u00d7 B)) : Set (B \u00d7 A) :=\n  {(b, a) : B \u00d7 A | (a, b) \u2208 R}\n\ndef comp {A B C : Type}\n    (S : Set (B \u00d7 C)) (R : Set (A \u00d7 B)) : Set (A \u00d7 C) :=\n  {(a, c) : A \u00d7 C | \u2203 (x : B), (a, x) \u2208 R \u2227 (x, c) \u2208 S}\n\ndef extension {A B : Type} (R : Rel A B) : Set (A \u00d7 B) :=\n  {(a, b) : A \u00d7 B | R a b}\n\ndef reflexive {A : Type} (R : BinRel A) : Prop :=\n  \u2200 (x : A), R x x\n\ndef symmetric {A : Type} (R : BinRel A) : Prop :=\n  \u2200 (x y : A), R x y \u2192 R y x\n\ndef transitive {A : Type} (R : BinRel A) : Prop :=\n  \u2200 (x y z : A), R x y \u2192 R y z \u2192 R x z\n\ndef elementhood (A : Type) (a : A) (X : Set A) : Prop := a \u2208 X\n\ndef RelFromExt {A B : Type}\n  (R : Set (A \u00d7 B)) (a : A) (b : B) : Prop := (a, b) \u2208 R\n\ndef antisymmetric {A : Type} (R : BinRel A) : Prop :=\n  \u2200 (x y : A), R x y \u2192 R y x \u2192 x = y\n\ndef partial_order {A : Type} (R : BinRel A) : Prop :=\n  reflexive R \u2227 transitive R \u2227 antisymmetric R\n\ndef total_order {A : Type} (R : BinRel A) : Prop :=\n  partial_order R \u2227 \u2200 (x y : A), R x y \u2228 R y x\n\ndef sub (A : Type) (X Y : Set A) : Prop := X \u2286 Y\n\ndef smallestElt {A : Type} (R : BinRel A) (b : A) (B : Set A) : Prop :=\n  b \u2208 B \u2227 \u2200 x \u2208 B, R b x\n\ndef minimalElt {A : Type} (R : BinRel A) (b : A) (B : Set A) : Prop :=\n  b \u2208 B \u2227 \u00ac\u2203 x \u2208 B, R x b \u2227 x \u2260 b\n\ndef upperBd {A : Type} (R : BinRel A) (a : A) (B : Set A) : Prop :=\n  \u2200 x \u2208 B, R x a\n\ndef lub {A : Type} (R : BinRel A) (a : A) (B : Set A) : Prop :=\n  smallestElt R a {c : A | upperBd R c B}\n\ndef equiv_rel {A : Type} (R : BinRel A) : Prop :=\n  reflexive R \u2227 symmetric R \u2227 transitive R\n\ndef equivClass {A : Type} (R : BinRel A) (x : A) : Set A :=\n  {y : A | R y x}\n\ndef mod (A : Type) (R : BinRel A) : Set (Set A) :=\n  {equivClass R x | x : A}\n\ndef empty {A : Type} (X : Set A) : Prop := \u00ac\u2203 (x : A), x \u2208 X\n\ndef pairwise_disjoint {A : Type} (F : Set (Set A)) : Prop :=\n  \u2200 X \u2208 F, \u2200 Y \u2208 F, X \u2260 Y \u2192 empty (X \u2229 Y)\n\ndef partition {A : Type} (F : Set (Set A)) : Prop :=\n  (\u2200 (x : A), x \u2208 \u22c3\u2080 F) \u2227 pairwise_disjoint F \u2227 \u2200 X \u2208 F, \u00acempty X\n\ndef EqRelFromPart {A : Type} (F : Set (Set A)) (x y : A) : Prop :=\n  \u2203 X \u2208 F, x \u2208 X \u2227 y \u2208 X\n\n/- Section 4.2 -/"}

{"cmd": "theorem Theorem_4_2_5_1 {A B : Type}\n    (R : Set (A \u00d7 B)) : inv (inv R) = R := by rfl\n\ntheorem Theorem_4_2_5_2 {A B : Type}\n    (R : Set (A \u00d7 B)) : Dom (inv R) = Ran R := by rfl\n\ntheorem Theorem_4_2_5_3 {A B : Type}\n    (R : Set (A \u00d7 B)) : Ran (inv R) = Dom R := by rfl\n\ntheorem Theorem_4_2_5_4 {A B C D : Type}\n    (R : Set (A \u00d7 B)) (S : Set (B \u00d7 C)) (T : Set (C \u00d7 D)) :\n    comp T (comp S R) = comp (comp T S) R := by\n  apply Set.ext\n  fix (a, d) : A \u00d7 D\n  apply Iff.intro\n  \u00b7 -- (\u2192)\n    assume h1 : (a, d) \u2208 comp T (comp S R)\n                     --Goal : (a, d) \u2208 comp (comp T S) R\n    define           --Goal : \u2203 (x : B), (a, x) \u2208 R \u2227 (x, d) \u2208 comp T S\n    define at h1     --h1 : \u2203 (x : C), (a, x) \u2208 comp S R \u2227 (x, d) \u2208 T\n    obtain (c : C) (h2 : (a, c) \u2208 comp S R \u2227 (c, d) \u2208 T) from h1\n    have h3 : (a, c) \u2208 comp S R := h2.left\n    define at h3     --h3 : \u2203 (x : B), (a, x) \u2208 R \u2227 (x, c) \u2208 S\n    obtain (b : B) (h4 : (a, b) \u2208 R \u2227 (b, c) \u2208 S) from h3\n    apply Exists.intro b    --Goal : (a, b) \u2208 R \u2227 (b, d) \u2208 comp T S\n    apply And.intro h4.left --Goal : (b, d) \u2208 comp T S\n    define                  --Goal : \u2203 (x : C), (b, x) \u2208 S \u2227 (x, d) \u2208 T\n    show \u2203 (x : C), (b, x) \u2208 S \u2227 (x, d) \u2208 T from\n      Exists.intro c (And.intro h4.right h2.right)\n    done\n  \u00b7 -- (\u2190)\n    assume h1 : (a, d) \u2208 comp (comp T S) R\n    define; define at h1\n    obtain (b : B) (h2 : (a, b) \u2208 R \u2227 (b, d) \u2208 comp T S) from h1\n    have h3 : (b, d) \u2208 comp T S := h2.right\n    define at h3\n    obtain (c : C) (h4 : (b, c) \u2208 S \u2227 (c, d) \u2208 T) from h3\n    apply Exists.intro c\n    apply And.intro _ h4.right\n    define\n    show \u2203 (x : B), (a, x) \u2208 R \u2227 (x, c) \u2208 S from\n      Exists.intro b (And.intro h2.left h4.left)\n    done\n  done\n\ntheorem inv_def {A B : Type} (R : Set (A \u00d7 B)) (a : A) (b : B) :\n    (b, a) \u2208 inv R \u2194 (a, b) \u2208 R := by rfl\n\ntheorem Theorem_4_2_5_5 {A B C : Type}\n    (R : Set (A \u00d7 B)) (S : Set (B \u00d7 C)) :\n    inv (comp S R) = comp (inv R) (inv S) := by\n  apply Set.ext\n  fix (c, a) : C \u00d7 A\n  apply Iff.intro\n  \u00b7 -- (\u2192)\n    assume h1 : (c, a) \u2208 inv (comp S R)\n                      --Goal : (c, a) \u2208 comp (inv R) (inv S)\n    define at h1      --h1 : \u2203 (x : B), (a, x) \u2208 R \u2227 (x, c) \u2208 S\n    define            --Goal : \u2203 (x : B), (c, x) \u2208 inv S \u2227 (x, a) \u2208 inv R\n    obtain (b : B) (h2 : (a, b) \u2208 R \u2227 (b, c) \u2208 S) from h1\n    apply Exists.intro b         --Goal : (c, b) \u2208 inv S \u2227 (b, a) \u2208 inv R\n    rewrite [inv_def, inv_def] --Goal : (b, c) \u2208 S \u2227 (a, b) \u2208 R\n    show (b, c) \u2208 S \u2227 (a, b) \u2208 R from And.intro h2.right h2.left\n    done\n  \u00b7 -- (\u2190)\n    assume h1 : (c, a) \u2208 comp (inv R) (inv S)\n    define at h1\n    define\n    obtain (b : B) (h2 : (c, b) \u2208 inv S \u2227 (b, a) \u2208 inv R) from h1\n    apply Exists.intro b\n    rewrite [inv_def, inv_def] at h2\n    show (a, b) \u2208 R \u2227 (b, c) \u2208 S from And.intro h2.right h2.left\n    done\n  done\n\n/- Section 4.3 -/\ntheorem ext_def {A B : Type} (R : Rel A B) (a : A) (b : B) :\n    (a, b) \u2208 extension R \u2194 R a b := by rfl\n\ntheorem Theorem_4_3_4_2 {A : Type} (R : BinRel A) :\n    symmetric R \u2194 extension R = inv (extension R) := by\n  apply Iff.intro\n  \u00b7 -- (\u2192)\n    assume h1 : symmetric R\n    define at h1             --h1 : \u2200 (x y : A), R x y \u2192 R y x\n    apply Set.ext\n    fix (a, b) : A \u00d7 A\n    show (a, b) \u2208 extension R \u2194 (a, b) \u2208 inv (extension R) from\n      calc (a, b) \u2208 extension R\n        _ \u2194 R a b := by rfl\n        _ \u2194 R b a := Iff.intro (h1 a b) (h1 b a)\n        _ \u2194 (a, b) \u2208 inv (extension R) := by rfl\n    done\n  \u00b7 -- (\u2190)\n    assume h1 : extension R = inv (extension R)\n    define                   --Goal : \u2200 (x y : A), R x y \u2192 R y x\n    fix a : A; fix b : A\n    assume h2 : R a b        --Goal : R b a\n    rewrite [\u2190ext_def R, h1, inv_def, ext_def] at h2\n    show R b a from h2\n    done\n  done\n\ntheorem RelFromExt_def {A B : Type}\n    (R : Set (A \u00d7 B)) (a : A) (b : B) :\n    RelFromExt R a b \u2194 (a, b) \u2208 R := by rfl\n\nexample {A B : Type} (R : Rel A B) :\n    RelFromExt (extension R) = R := by rfl\n\nexample {A B : Type} (R : Set (A \u00d7 B)) :\n    extension (RelFromExt R) = R := by rfl\n\n/- Section 4.4 -/\ntheorem Theorem_4_4_6_2 {A : Type} (R : BinRel A) (B : Set A) (b : A)\n    (h1 : partial_order R) (h2 : smallestElt R b B) :\n    minimalElt R b B \u2227 \u2200 (c : A), minimalElt R c B \u2192 b = c := by\n  define at h1     --h1 : reflexive R \u2227 transitive R \u2227 antisymmetric R\n  define at h2     --h2 : b \u2208 B \u2227 \u2200 (x : A), x \u2208 B \u2192 R b x\n  apply And.intro\n  \u00b7 -- Proof that b is minimal\n    define           --Goal : b \u2208 B \u2227 \u00ac\u2203 (x : A), x \u2208 B \u2227 R x b \u2227 x \u2260 b\n    apply And.intro h2.left\n    quant_neg        --Goal : \u2200 (x : A), \u00ac(x \u2208 B \u2227 R x b \u2227 x \u2260 b)\n    fix x : A\n    demorgan         --Goal : \u00acx \u2208 B \u2228 \u00ac(R x b \u2227 x \u2260 b)\n    or_right with h3 --h3 : x \u2208 B; Goal : \u00ac(R x b \u2227 x \u2260 b)\n    demorgan         --Goal : \u00acR x b \u2228 x = b\n    or_right with h4 --h4 : R x b; Goal : x = b\n    have h5 : R b x := h2.right x h3\n    have h6 : antisymmetric R := h1.right.right\n    define at h6     --h6 : \u2200 (x y : A), R x y \u2192 R y x \u2192 x = y\n    show x = b from h6 x b h4 h5\n    done\n  \u00b7 -- Proof that b is only minimal element\n    fix c : A\n    assume h3 : minimalElt R c B\n    define at h3    --h3 : c \u2208 B \u2227 \u00ac\u2203 (x : A), x \u2208 B \u2227 R x c \u2227 x \u2260 c\n    contradict h3.right with h4\n                  --h4 : \u00acb = c; Goal : \u2203 (x : A), x \u2208 B \u2227 R x c \u2227 x \u2260 c\n    have h5 : R b c := h2.right c h3.left\n    show \u2203 (x : A), x \u2208 B \u2227 R x c \u2227 x \u2260 c from\n      Exists.intro b (And.intro h2.left (And.intro h5 h4))\n    done\n  done\n\ntheorem Theorem_4_4_6_3 {A : Type} (R : BinRel A) (B : Set A) (b : A)\n    (h1 : total_order R) (h2 : minimalElt R b B) : smallestElt R b B := by\n  define at h1         --h1 : partial_order R \u2227 \u2200 (x y : A), R x y \u2228 R y x\n  define at h2         --h2 : b \u2208 B \u2227 \u00ac\u2203 (x : A), x \u2208 B \u2227 R x b \u2227 x \u2260 b\n  define               --Goal : b \u2208 B \u2227 \u2200 (x : A), x \u2208 B \u2192 R b x\n  apply And.intro h2.left  --Goal : \u2200 (x : A), x \u2208 B \u2192 R b x\n  fix x : A\n  assume h3 : x \u2208 B        --Goal : R b x\n  by_cases h4 : x = b\n  \u00b7 -- Case 1. h4 : x = b\n    rewrite [h4]           --Goal : R b b\n    have h5 : partial_order R := h1.left\n    define at h5\n    have h6 : reflexive R := h5.left\n    define at h6\n    show R b b from h6 b\n    done\n  \u00b7 -- Case 2. h4 : x \u2260 b\n    have h5 : \u2200 (x y : A), R x y \u2228 R y x := h1.right\n    have h6 : R x b \u2228 R b x := h5 x b\n    have h7 : \u00acR x b := by\n      contradict h2.right with h8\n      show \u2203 (x : A), x \u2208 B \u2227 R x b \u2227 x \u2260 b from\n        Exists.intro x (And.intro h3 (And.intro h8 h4))\n      done\n    disj_syll h6 h7\n    show R b x from h6\n    done\n  done\n\n/- Section 4.5 -/\nlemma Lemma_4_5_5_1 {A : Type} (R : BinRel A) (h : equiv_rel R) :\n    \u2200 (x : A), x \u2208 equivClass R x := by\n  fix x : A\n  define           --Goal : R x x\n  define at h      --h : reflexive R \u2227 symmetric R \u2227 transitive R\n  have Rref : reflexive R := h.left\n  show R x x from Rref x\n  done\n\nlemma Lemma_4_5_5_2 {A : Type} (R : BinRel A) (h : equiv_rel R) :\n    \u2200 (x y : A), y \u2208 equivClass R x \u2194\n      equivClass R y = equivClass R x := by\n  have Rsymm : symmetric R := h.right.left\n  have Rtrans : transitive R := h.right.right\n  fix x : A; fix y : A\n  apply Iff.intro\n  \u00b7 -- (\u2192)\n    assume h2 :\n      y \u2208 equivClass R x    --Goal : equivClass R y = equivClass R x\n    define at h2                        --h2 : R y x\n    apply Set.ext\n    fix z : A\n    apply Iff.intro\n    \u00b7 -- Proof that z \u2208 equivClass R y \u2192 z \u2208 equivClass R x\n      assume h3 : z \u2208 equivClass R y\n      define                            --Goal : R z x\n      define at h3                      --h3 : R z y\n      show R z x from Rtrans z y x h3 h2\n      done\n    \u00b7 -- Proof that z \u2208 equivClass R x \u2192 z \u2208 equivClass R y\n      assume h3 : z \u2208 equivClass R x\n      define                            --Goal : R z y\n      define at h3                      --h3 : R z x\n      have h4 : R x y := Rsymm y x h2\n      show R z y from Rtrans z x y h3 h4\n      done\n    done\n  \u00b7 -- (\u2190)\n    assume h2 :\n      equivClass R y = equivClass R x   --Goal : y \u2208 equivClass R x\n    rewrite [\u2190h2]                       --Goal : y \u2208 equivClass R y\n    show y \u2208 equivClass R y from Lemma_4_5_5_1 R h y\n    done\n  done\n\nlemma Theorem_4_5_4_part_1 {A : Type} (R : BinRel A) (h : equiv_rel R) :\n    \u2200 (x : A), x \u2208 \u22c3\u2080 (mod A R) := by\n  fix x : A\n  define        --Goal : \u2203 (t : Set A), t \u2208 mod A R \u2227 x \u2208 t\n  apply Exists.intro (equivClass R x)\n  apply And.intro _ (Lemma_4_5_5_1 R h x)\n                --Goal : equivClass R x \u2208 mod A R\n  define        --Goal : \u2203 (x_1 : A), equivClass R x_1 = equivClass R x\n  apply Exists.intro x\n  rfl\n  done\n\nlemma Theorem_4_5_4_part_2 {A : Type} (R : BinRel A) (h : equiv_rel R) :\n    pairwise_disjoint (mod A R) := by\n  define\n  fix X : Set A\n  assume h2 : X \u2208 mod A R\n  fix Y : Set A\n  assume h3 : Y \u2208 mod A R           --Goal : X \u2260 Y \u2192 empty (X \u2229 Y)\n  define at h2; define at h3\n  obtain (x : A) (h4 : equivClass R x = X) from h2\n  obtain (y : A) (h5 : equivClass R y = Y) from h3\n  contrapos\n  assume h6 : \u2203 (x : A), x \u2208 X \u2229 Y  --Goal : X = Y\n  obtain (z : A) (h7 : z \u2208 X \u2229 Y) from h6\n  define at h7\n  rewrite [\u2190h4, \u2190h5] at h7 --h7 : z \u2208 equivClass R x \u2227 z \u2208 equivClass R y\n  have h8 : equivClass R z = equivClass R x :=\n    (Lemma_4_5_5_2 R h x z).ltr h7.left\n  have h9 : equivClass R z = equivClass R y :=\n    (Lemma_4_5_5_2 R h y z).ltr h7.right\n  show X = Y from\n    calc X\n      _ = equivClass R x := h4.symm\n      _ = equivClass R z := h8.symm\n      _ = equivClass R y := h9\n      _ = Y              := h5\n  done\n\nlemma Theorem_4_5_4_part_3 {A : Type} (R : BinRel A) (h : equiv_rel R) :\n    \u2200 X \u2208 mod A R, \u00acempty X := by\n  fix X : Set A\n  assume h2 : X \u2208 mod A R  --Goal : \u00acempty X\n  define; double_neg       --Goal : \u2203 (x : A), x \u2208 X\n  define at h2             --h2 : \u2203 (x : A), equivClass R x = X\n  obtain (x : A) (h3 : equivClass R x = X) from h2\n  rewrite [\u2190h3]\n  show \u2203 (x_1 : A), x_1 \u2208 equivClass R x from\n    Exists.intro x (Lemma_4_5_5_1 R h x)\n  done\n\ntheorem Theorem_4_5_4 {A : Type} (R : BinRel A) (h : equiv_rel R) :\n    partition (mod A R) := And.intro (Theorem_4_5_4_part_1 R h)\n      (And.intro (Theorem_4_5_4_part_2 R h) (Theorem_4_5_4_part_3 R h))\n\nlemma overlap_implies_equal {A : Type}\n    (F : Set (Set A)) (h : partition F) :\n    \u2200 X \u2208 F, \u2200 Y \u2208 F, \u2200 (x : A), x \u2208 X \u2192 x \u2208 Y \u2192 X = Y := sorry\n\nlemma Lemma_4_5_7_ref {A : Type} (F : Set (Set A)) (h : partition F):\n    reflexive (EqRelFromPart F) := sorry\n\nlemma Lemma_4_5_7_symm {A : Type} (F : Set (Set A)) (h : partition F):\n    symmetric (EqRelFromPart F) := sorry\n\nlemma Lemma_4_5_7_trans {A : Type} (F : Set (Set A)) (h : partition F):\n    transitive (EqRelFromPart F) := sorry\n\nlemma Lemma_4_5_7 {A : Type} (F : Set (Set A)) (h : partition F) :\n    equiv_rel (EqRelFromPart F) := And.intro (Lemma_4_5_7_ref F h)\n      (And.intro (Lemma_4_5_7_symm F h) (Lemma_4_5_7_trans F h))\n\nlemma Lemma_4_5_8 {A : Type} (F : Set (Set A)) (h : partition F) :\n    \u2200 X \u2208 F, \u2200 x \u2208 X, equivClass (EqRelFromPart F) x = X := sorry\n\n\ntheorem Theorem_4_5_6 {A : Type} (F : Set (Set A)) (h: partition F) :\n    \u2203 (R : BinRel A), equiv_rel R \u2227 mod A R = F    := by\n  exact \u27e8EqRelFromPart F, Lemma_4_5_7 F h, Set.ext (\u03bb X, \u27e8\u03bb \u27e8x, _\u27e9, Lemma_4_5_8 F h X (h.right.right X \u2039_\u203a).some \u2039_\u203a, \u03bb hX, let \u27e8x, hx\u27e9 := h.right.right X hX in \u27e8x, Lemma_4_5_8 F h X hX x hx\u27e9\u27e9)\u27e9\n", "allTactics": true, "theorems": true, "env": 0}