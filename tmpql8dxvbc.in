{"cmd": "/- Copyright 2023 Daniel J. Velleman -/\n\nimport HTPILib.Chap7\nset_option linter.style.longFile 0\nnamespace HTPI\n\n/- Definitions -/\ndef fnz (n : Nat) : Int := if 2 \u2223 n then \u2191(n / 2) else -\u2191((n + 1) / 2)\n\ndef fzn (a : Int) : Nat := if a \u2265 0 then 2 * Int.toNat a else 2 * Int.toNat (-a) - 1\n\ndef tri (k : Nat) : Nat := k * (k + 1) / 2\n\ndef fnnn (p : Nat \u00d7 Nat) : Nat := tri (p.1 + p.2) + p.1\n\ndef num_elts_below (A : Set Nat) (m s : Nat) : Prop :=\n  match m with\n    | 0 => s = 0\n    | n + 1 => (n \u2208 A \u2227 1 \u2264 s \u2227 num_elts_below A n (s - 1)) \u2228\n                (n \u2209 A \u2227 num_elts_below A n s)\n\ndef enum (A : Set Nat) (s n : Nat) : Prop := n \u2208 A \u2227 num_elts_below A n s\n\ndef unique_val_on_N {U : Type} (R : Rel Nat U) : Prop :=\n  \u2200 \u2983n : Nat\u2984 \u2983x1 x2 : U\u2984, R n x1 \u2192 R n x2 \u2192 x1 = x2\n\ndef nat_rel_onto {U : Type} (R : Rel Nat U) (A : Set U) : Prop :=\n  \u2200 \u2983x : U\u2984, x \u2208 A \u2192 \u2203 (n : Nat), R n x\n\ndef fcnl_onto_from_nat {U : Type} (R : Rel Nat U) (A : Set U) : Prop :=\n  unique_val_on_N R \u2227 nat_rel_onto R A\n\ndef fcnl_one_one_to_nat {U : Type} (R : Rel U Nat) (A : Set U) : Prop :=\n  fcnl_on R A \u2227 \u2200 \u2983x1 x2 : U\u2984 \u2983n : Nat\u2984,\n    (x1 \u2208 A \u2227 R x1 n) \u2192 (x2 \u2208 A \u2227 R x2 n) \u2192 x1 = x2\n\ndef least_rel_to {U : Type} (S : Rel Nat U) (x : U) (n : Nat) : Prop :=\n  S n x \u2227 \u2200 (m : Nat), S m x \u2192 n \u2264 m\n\ndef restrict_to {U V : Type} (S : Rel U V) (A : Set U)\n  (x : U) (y : V) : Prop := x \u2208 A \u2227 S x y\n\ndef fqn (q : Rat) : Nat := fnnn (fzn q.num, q.den)\n\ndef Set_rp_below (m : Nat) : Set Nat := {n : Nat | rel_prime m n \u2227 n < m}\n\ndef Set_prod {U V : Type} (A : Set U) (B : Set V) : Set (U \u00d7 V) :=\n  {(a, b) : U \u00d7 V | a \u2208 A \u2227 b \u2208 B}\n\nnotation:75 A:75 \" \u00d7\u209b \" B:75 => Set_prod A B\n\ndef Rel_prod {U V W X : Type} (R : Rel U V) (S : Rel W X)\n  (p : U \u00d7 W) (q : V \u00d7 X) : Prop := R p.1 q.1 \u2227 S p.2 q.2\n\nnotation:75 R:75 \" \u00d7\u1d63 \" S:75 => Rel_prod R S\n\ndef qr (n a : Nat) : Nat \u00d7 Nat := (a / n, a % n)\n\ndef mod_mod (m n a : Nat) : Nat \u00d7 Nat := (a % m, a % n)\n\ndef enum_union_fam {U : Type}\n  (F : Set (Set U)) (f : Set U \u2192 Rel Nat U) (R : Rel Nat (Set U))\n  (n : Nat) (a : U) : Prop := \u2203 (p : Nat \u00d7 Nat), fnnn p = n \u2227\n    \u2203 A \u2208 F, R p.1 A \u2227 (f A) p.2 a\n\ndef seq {U : Type} (A : Set U) : Set (List U) :=\n  {l : List U | \u2200 x \u2208 l, x \u2208 A}\n\ndef seq_by_length {U : Type} (A : Set U) (n : Nat) : Set (List U) :=\n  {l : List U | l \u2208 seq A \u2227 l.length = n}\n\ndef seq_cons (U : Type) (p : U \u00d7 (List U)) : List U := p.1 :: p.2\n\ndef sbl_set {U : Type} (A : Set U) : Set (Set (List U)) :=\n  {S : Set (List U) | \u2203 (n : Nat), seq_by_length A n = S}\n\ndef rep_common_image\n  {U V : Type} (R S : Rel U V) (X0 : Set U) (n : Nat) : Set U :=\n  match n with\n    | 0 => X0\n    | m + 1 => {a : U | \u2203 x \u2208 rep_common_image R S X0 m,\n                          \u2203 (y : V), R x y \u2227 S a y}\n\ndef cum_rep_image {U V : Type} (R S : Rel U V) (X0 : Set U) : Set U :=\n  {a : U | \u2203 (n : Nat), a \u2208 rep_common_image R S X0 n}\n\ndef csb_match {U V : Type} (R S : Rel U V) (X0 : Set U)\n  (x : U) (y : V) : Prop := x \u2208 cum_rep_image R S X0 \u2227 R x y \u2228\n    x \u2209 cum_rep_image R S X0 \u2227 S x y\n\n/- Section 8.1 -/\n#eval [fnz 0, fnz 1, fnz 2, fnz 3, fnz 4, fnz 5, fnz 6]\n  --Answer: [0, -1, 1, -2, 2, -3, 3]\n\n#eval [fzn 0, fzn (-1), fzn 1, fzn (-2), fzn 2, fzn (-3), fzn 3]\n  --Answer: [0, 1, 2, 3, 4, 5, 6]\n"}

{"cmd": "lemma fnz_even (k : Nat) : fnz (2 * k) = \u2191k := by\n  have h1 : 2 \u2223 2 * k := by\n    apply Exists.intro k\n    rfl\n    done\n  have h2 : fnz (2 * k) = if 2 \u2223 2 * k then \u2191(2 * k / 2)\n    else -\u2191((2 * k + 1) / 2) := by rfl\n  rewrite [if_pos h1] at h2  --h2 : fnz (2 * k) = \u2191(2 * k / 2)\n  have h3 : 0 < 2 := by linarith\n  rewrite [Nat.mul_div_cancel_left k h3] at h2\n  show fnz (2 * k) = \u2191k from h2\n  done\n\nlemma fnz_odd (k : Nat) : fnz (2 * k + 1) = -\u2191(k + 1) := sorry\n\nlemma fzn_nat (k : Nat) : fzn \u2191k = 2 * k := by rfl\n\nlemma fzn_neg_succ_nat (k : Nat) : fzn (-\u2191(k + 1)) = 2 * k + 1 := by rfl\n\n--From exercises of Section 6.1\ntheorem Exercise_6_1_16a1 : \u2200 (n : Nat), nat_even n \u2228 nat_odd n := sorry\n\n\n theorem fzn_fnz : fzn \u2218 fnz = id   := by\n  funext n\n  cases Exercise_6_1_16a1 n with\n    | \u27e8k, hk\u27e9 => rw [hk, fnz_even, fzn_nat]\n", "allTactics": true, "theorems": true, "env": 0}