{"cmd": "/-\nCopyright (c) 2021 Jo\u00ebl Riou. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Jo\u00ebl Riou, Adam Topaz, Johan Commelin\n-/\nimport Mathlib.Algebra.Homology.Additive\nimport Mathlib.AlgebraicTopology.MooreComplex\nimport Mathlib.Algebra.BigOperators.Fin\nimport Mathlib.CategoryTheory.Preadditive.Opposite\nimport Mathlib.CategoryTheory.Idempotents.FunctorCategories\n\n#align_import algebraic_topology.alternating_face_map_complex from \"leanprover-community/mathlib\"@\"88bca0ce5d22ebfd9e73e682e51d60ea13b48347\"\n\n/-!\n\n# The alternating face map complex of a simplicial object in a preadditive category\n\nWe construct the alternating face map complex, as a\nfunctor `alternatingFaceMapComplex : SimplicialObject C \u2964 ChainComplex C \u2115`\nfor any preadditive category `C`. For any simplicial object `X` in `C`,\nthis is the homological complex `... \u2192 X_2 \u2192 X_1 \u2192 X_0`\nwhere the differentials are alternating sums of faces.\n\nThe dual version `alternatingCofaceMapComplex : CosimplicialObject C \u2964 CochainComplex C \u2115`\nis also constructed.\n\nWe also construct the natural transformation\n`inclusionOfMooreComplex : normalizedMooreComplex A \u27f6 alternatingFaceMapComplex A`\nwhen `A` is an abelian category.\n\n## References\n* https://stacks.math.columbia.edu/tag/0194\n* https://ncatlab.org/nlab/show/Moore+complex\n\n-/\n\n\nopen CategoryTheory CategoryTheory.Limits CategoryTheory.Subobject\n\nopen CategoryTheory.Preadditive CategoryTheory.Category CategoryTheory.Idempotents\n\nopen Opposite\n\nopen Simplicial\n\nnoncomputable section\n\nnamespace AlgebraicTopology\n\nnamespace AlternatingFaceMapComplex\n\n/-!\n## Construction of the alternating face map complex\n-/\n\n\nvariable {C : Type*} [Category C] [Preadditive C]\nvariable (X : SimplicialObject C)\nvariable (Y : SimplicialObject C)\n\n/-- The differential on the alternating face map complex is the alternate\nsum of the face maps -/\n@[simp]\ndef objD (n : \u2115) : X _[n + 1] \u27f6 X _[n] :=\n  \u2211 i : Fin (n + 2), (-1 : \u2124) ^ (i : \u2115) \u2022 X.\u03b4 i\n#align algebraic_topology.alternating_face_map_complex.obj_d AlgebraicTopology.AlternatingFaceMapComplex.objD\n"}

{"cmd": "/-- ## The chain complex relation `d \u226b d`\n-/\ntheorem d_squared (n : \u2115) : objD X (n + 1) \u226b objD X n = 0 := by\n  -- we start by expanding d \u226b d as a double sum\n  dsimp\n  simp only [comp_sum, sum_comp, \u2190 Finset.sum_product']\n  -- then, we decompose the index set P into a subset S and its complement S\u1d9c\n  let P := Fin (n + 2) \u00d7 Fin (n + 3)\n  let S := Finset.univ.filter fun ij : P => (ij.2 : \u2115) \u2264 (ij.1 : \u2115)\n  erw [\u2190 Finset.sum_add_sum_compl S, \u2190 eq_neg_iff_add_eq_zero, \u2190 Finset.sum_neg_distrib]\n  /- we are reduced to showing that two sums are equal, and this is obtained\n    by constructing a bijection \u03c6 : S -> S\u1d9c, which maps (i,j) to (j,i+1),\n    and by comparing the terms -/\n  let \u03c6 : \u2200 ij : P, ij \u2208 S \u2192 P := fun ij hij =>\n    (Fin.castLT ij.2 (lt_of_le_of_lt (Finset.mem_filter.mp hij).right (Fin.is_lt ij.1)), ij.1.succ)\n  apply Finset.sum_bij \u03c6\n  \u00b7 -- \u03c6(S) is contained in S\u1d9c\n    intro ij hij\n    simp only [S, Finset.mem_univ, Finset.compl_filter, Finset.mem_filter, true_and_iff,\n      Fin.val_succ, Fin.coe_castLT] at hij \u22a2\n    linarith\n  \u00b7 -- \u03c6 : S \u2192 S\u1d9c is injective\n    rintro \u27e8i, j\u27e9 hij \u27e8i', j'\u27e9 hij' h\n    rw [Prod.mk.inj_iff]\n    exact \u27e8by simpa using congr_arg Prod.snd h,\n      by simpa [Fin.castSucc_castLT] using congr_arg Fin.castSucc (congr_arg Prod.fst h)\u27e9\n  \u00b7 -- \u03c6 : S \u2192 S\u1d9c is surjective\n    rintro \u27e8i', j'\u27e9 hij'\n    simp only [S, Finset.mem_univ, forall_true_left, Prod.forall, ge_iff_le, Finset.compl_filter,\n      not_le, Finset.mem_filter, true_and] at hij'\n    refine \u27e8(j'.pred <| ?_, Fin.castSucc i'), ?_, ?_\u27e9\n    \u00b7 rintro rfl\n      simp only [Fin.val_zero, not_lt_zero'] at hij'\n    \u00b7 simpa only [S, Finset.mem_univ, forall_true_left, Prod.forall, ge_iff_le, Finset.mem_filter,\n        Fin.coe_castSucc, Fin.coe_pred, true_and] using Nat.le_sub_one_of_lt hij'\n    \u00b7 simp only [\u03c6, Fin.castLT_castSucc, Fin.succ_pred]\n  \u00b7 -- identification of corresponding terms in both sums\n    rintro \u27e8i, j\u27e9 hij\n    dsimp\n    simp only [zsmul_comp, comp_zsmul, smul_smul, \u2190 neg_smul]\n    congr 1\n    \u00b7 simp only [Fin.val_succ, pow_add, pow_one, mul_neg, neg_neg, mul_one]\n      apply mul_comm\n    \u00b7 rw [CategoryTheory.SimplicialObject.\u03b4_comp_\u03b4'']\n      simpa [S] using hij\n#align algebraic_topology.alternating_face_map_complex.d_squared AlgebraicTopology.AlternatingFaceMapComplex.d_squared\n\n/-!\n## Construction of the alternating face map complex functor\n-/\n\n\n/-- The alternating face map complex, on objects -/\ndef obj : ChainComplex C \u2115 :=\n  ChainComplex.of (fun n => X _[n]) (objD X) (d_squared X)\n#align algebraic_topology.alternating_face_map_complex.obj AlgebraicTopology.AlternatingFaceMapComplex.obj\n\n@[simp]\ntheorem obj_X (X : SimplicialObject C) (n : \u2115) : (AlternatingFaceMapComplex.obj X).X n = X _[n] :=\n  rfl\nset_option linter.uppercaseLean3 false in\n#align algebraic_topology.alternating_face_map_complex.obj_X AlgebraicTopology.AlternatingFaceMapComplex.obj_X\n\n@[simp]\ntheorem obj_d_eq (X : SimplicialObject C) (n : \u2115) :\n    (AlternatingFaceMapComplex.obj X).d (n + 1) n\n      = \u2211 i : Fin (n + 2), (-1 : \u2124) ^ (i : \u2115) \u2022 X.\u03b4 i := by\n  apply ChainComplex.of_d\n#align algebraic_topology.alternating_face_map_complex.obj_d_eq AlgebraicTopology.AlternatingFaceMapComplex.obj_d_eq\n\nvariable {X} {Y}\n\n/-- The alternating face map complex, on morphisms -/\ndef map (f : X \u27f6 Y) : obj X \u27f6 obj Y :=\n  ChainComplex.ofHom _ _ _ _ _ _ (fun n => f.app (op [n])) fun n => by\n    dsimp\n    rw [comp_sum, sum_comp]\n    refine Finset.sum_congr rfl fun _ _ => ?_\n    rw [comp_zsmul, zsmul_comp]\n    congr 1\n    symm\n    apply f.naturality\n#align algebraic_topology.alternating_face_map_complex.map AlgebraicTopology.AlternatingFaceMapComplex.map\n\n@[simp]\ntheorem map_f (f : X \u27f6 Y) (n : \u2115) : (map f).f n = f.app (op [n]) :=\n  rfl\n#align algebraic_topology.alternating_face_map_complex.map_f AlgebraicTopology.AlternatingFaceMapComplex.map_f\n\nend AlternatingFaceMapComplex\n\nvariable (C : Type*) [Category C] [Preadditive C]\n\n/-- The alternating face map complex, as a functor -/\ndef alternatingFaceMapComplex : SimplicialObject C \u2964 ChainComplex C \u2115 where\n  obj := AlternatingFaceMapComplex.obj\n  map f := AlternatingFaceMapComplex.map f\n#align algebraic_topology.alternating_face_map_complex AlgebraicTopology.alternatingFaceMapComplex\n\nvariable {C}\n\n@[simp]\ntheorem alternatingFaceMapComplex_obj_X (X : SimplicialObject C) (n : \u2115) :\n    ((alternatingFaceMapComplex C).obj X).X n = X _[n] :=\n  rfl\nset_option linter.uppercaseLean3 false in\n#align algebraic_topology.alternating_face_map_complex_obj_X AlgebraicTopology.alternatingFaceMapComplex_obj_X\n\n@[simp]\ntheorem alternatingFaceMapComplex_obj_d (X : SimplicialObject C) (n : \u2115) :\n    ((alternatingFaceMapComplex C).obj X).d (n + 1) n = AlternatingFaceMapComplex.objD X n := by\n dsimp only [alternatingFaceMapComplex, AlternatingFaceMapComplex.obj]\n apply ChainComplex.of_d\n#align algebraic_topology.alternating_face_map_complex_obj_d AlgebraicTopology.alternatingFaceMapComplex_obj_d\n\n@[simp]\ntheorem alternatingFaceMapComplex_map_f {X Y : SimplicialObject C} (f : X \u27f6 Y) (n : \u2115) :\n    ((alternatingFaceMapComplex C).map f).f n = f.app (op [n]) :=\n  rfl\n#align algebraic_topology.alternating_face_map_complex_map_f AlgebraicTopology.alternatingFaceMapComplex_map_f\n\n\ntheorem map_alternatingFaceMapComplex {D : Type*} [Category D] [Preadditive D] (F : C \u2964 D)\n    [F.Additive] :\n    alternatingFaceMapComplex C \u22d9 F.mapHomologicalComplex _ =\n      (SimplicialObject.whiskering C D).obj F \u22d9 alternatingFaceMapComplex D  := by\n  apply CategoryTheory.Functor.ext; { intros; ext n; simp }, { intros; apply HomologicalComplex.ext; { intros; dsimp; simp }, { intros; rfl } }\n", "allTactics": true, "theorems": true, "env": 0}

{"cmd": "/-- ## The chain complex relation `d \u226b d`\n-/\ntheorem d_squared (n : \u2115) : objD X (n + 1) \u226b objD X n = 0 := by\n  -- we start by expanding d \u226b d as a double sum\n  dsimp\n  simp only [comp_sum, sum_comp, \u2190 Finset.sum_product']\n  -- then, we decompose the index set P into a subset S and its complement S\u1d9c\n  let P := Fin (n + 2) \u00d7 Fin (n + 3)\n  let S := Finset.univ.filter fun ij : P => (ij.2 : \u2115) \u2264 (ij.1 : \u2115)\n  erw [\u2190 Finset.sum_add_sum_compl S, \u2190 eq_neg_iff_add_eq_zero, \u2190 Finset.sum_neg_distrib]\n  /- we are reduced to showing that two sums are equal, and this is obtained\n    by constructing a bijection \u03c6 : S -> S\u1d9c, which maps (i,j) to (j,i+1),\n    and by comparing the terms -/\n  let \u03c6 : \u2200 ij : P, ij \u2208 S \u2192 P := fun ij hij =>\n    (Fin.castLT ij.2 (lt_of_le_of_lt (Finset.mem_filter.mp hij).right (Fin.is_lt ij.1)), ij.1.succ)\n  apply Finset.sum_bij \u03c6\n  \u00b7 -- \u03c6(S) is contained in S\u1d9c\n    intro ij hij\n    simp only [S, Finset.mem_univ, Finset.compl_filter, Finset.mem_filter, true_and_iff,\n      Fin.val_succ, Fin.coe_castLT] at hij \u22a2\n    linarith\n  \u00b7 -- \u03c6 : S \u2192 S\u1d9c is injective\n    rintro \u27e8i, j\u27e9 hij \u27e8i', j'\u27e9 hij' h\n    rw [Prod.mk.inj_iff]\n    exact \u27e8by simpa using congr_arg Prod.snd h,\n      by simpa [Fin.castSucc_castLT] using congr_arg Fin.castSucc (congr_arg Prod.fst h)\u27e9\n  \u00b7 -- \u03c6 : S \u2192 S\u1d9c is surjective\n    rintro \u27e8i', j'\u27e9 hij'\n    simp only [S, Finset.mem_univ, forall_true_left, Prod.forall, ge_iff_le, Finset.compl_filter,\n      not_le, Finset.mem_filter, true_and] at hij'\n    refine \u27e8(j'.pred <| ?_, Fin.castSucc i'), ?_, ?_\u27e9\n    \u00b7 rintro rfl\n      simp only [Fin.val_zero, not_lt_zero'] at hij'\n    \u00b7 simpa only [S, Finset.mem_univ, forall_true_left, Prod.forall, ge_iff_le, Finset.mem_filter,\n        Fin.coe_castSucc, Fin.coe_pred, true_and] using Nat.le_sub_one_of_lt hij'\n    \u00b7 simp only [\u03c6, Fin.castLT_castSucc, Fin.succ_pred]\n  \u00b7 -- identification of corresponding terms in both sums\n    rintro \u27e8i, j\u27e9 hij\n    dsimp\n    simp only [zsmul_comp, comp_zsmul, smul_smul, \u2190 neg_smul]\n    congr 1\n    \u00b7 simp only [Fin.val_succ, pow_add, pow_one, mul_neg, neg_neg, mul_one]\n      apply mul_comm\n    \u00b7 rw [CategoryTheory.SimplicialObject.\u03b4_comp_\u03b4'']\n      simpa [S] using hij\n#align algebraic_topology.alternating_face_map_complex.d_squared AlgebraicTopology.AlternatingFaceMapComplex.d_squared\n\n/-!\n## Construction of the alternating face map complex functor\n-/\n\n\n/-- The alternating face map complex, on objects -/\ndef obj : ChainComplex C \u2115 :=\n  ChainComplex.of (fun n => X _[n]) (objD X) (d_squared X)\n#align algebraic_topology.alternating_face_map_complex.obj AlgebraicTopology.AlternatingFaceMapComplex.obj\n\n@[simp]\ntheorem obj_X (X : SimplicialObject C) (n : \u2115) : (AlternatingFaceMapComplex.obj X).X n = X _[n] :=\n  rfl\nset_option linter.uppercaseLean3 false in\n#align algebraic_topology.alternating_face_map_complex.obj_X AlgebraicTopology.AlternatingFaceMapComplex.obj_X\n\n@[simp]\ntheorem obj_d_eq (X : SimplicialObject C) (n : \u2115) :\n    (AlternatingFaceMapComplex.obj X).d (n + 1) n\n      = \u2211 i : Fin (n + 2), (-1 : \u2124) ^ (i : \u2115) \u2022 X.\u03b4 i := by\n  apply ChainComplex.of_d\n#align algebraic_topology.alternating_face_map_complex.obj_d_eq AlgebraicTopology.AlternatingFaceMapComplex.obj_d_eq\n\nvariable {X} {Y}\n\n/-- The alternating face map complex, on morphisms -/\ndef map (f : X \u27f6 Y) : obj X \u27f6 obj Y :=\n  ChainComplex.ofHom _ _ _ _ _ _ (fun n => f.app (op [n])) fun n => by\n    dsimp\n    rw [comp_sum, sum_comp]\n    refine Finset.sum_congr rfl fun _ _ => ?_\n    rw [comp_zsmul, zsmul_comp]\n    congr 1\n    symm\n    apply f.naturality\n#align algebraic_topology.alternating_face_map_complex.map AlgebraicTopology.AlternatingFaceMapComplex.map\n\n@[simp]\ntheorem map_f (f : X \u27f6 Y) (n : \u2115) : (map f).f n = f.app (op [n]) :=\n  rfl\n#align algebraic_topology.alternating_face_map_complex.map_f AlgebraicTopology.AlternatingFaceMapComplex.map_f\n\nend AlternatingFaceMapComplex\n\nvariable (C : Type*) [Category C] [Preadditive C]\n\n/-- The alternating face map complex, as a functor -/\ndef alternatingFaceMapComplex : SimplicialObject C \u2964 ChainComplex C \u2115 where\n  obj := AlternatingFaceMapComplex.obj\n  map f := AlternatingFaceMapComplex.map f\n#align algebraic_topology.alternating_face_map_complex AlgebraicTopology.alternatingFaceMapComplex\n\nvariable {C}\n\n@[simp]\ntheorem alternatingFaceMapComplex_obj_X (X : SimplicialObject C) (n : \u2115) :\n    ((alternatingFaceMapComplex C).obj X).X n = X _[n] :=\n  rfl\nset_option linter.uppercaseLean3 false in\n#align algebraic_topology.alternating_face_map_complex_obj_X AlgebraicTopology.alternatingFaceMapComplex_obj_X\n\n@[simp]\ntheorem alternatingFaceMapComplex_obj_d (X : SimplicialObject C) (n : \u2115) :\n    ((alternatingFaceMapComplex C).obj X).d (n + 1) n = AlternatingFaceMapComplex.objD X n := by\n dsimp only [alternatingFaceMapComplex, AlternatingFaceMapComplex.obj]\n apply ChainComplex.of_d\n#align algebraic_topology.alternating_face_map_complex_obj_d AlgebraicTopology.alternatingFaceMapComplex_obj_d\n\n@[simp]\ntheorem alternatingFaceMapComplex_map_f {X Y : SimplicialObject C} (f : X \u27f6 Y) (n : \u2115) :\n    ((alternatingFaceMapComplex C).map f).f n = f.app (op [n]) :=\n  rfl\n#align algebraic_topology.alternating_face_map_complex_map_f AlgebraicTopology.alternatingFaceMapComplex_map_f\n\n\ntheorem map_alternatingFaceMapComplex {D : Type*} [Category D] [Preadditive D] (F : C \u2964 D)\n    [F.Additive] :\n    alternatingFaceMapComplex C \u22d9 F.mapHomologicalComplex _ =\n      (SimplicialObject.whiskering C D).obj F \u22d9 alternatingFaceMapComplex D  := by\n  apply CategoryTheory.Functor.ext; {intros, ext, simp}; intro; apply HomologicalComplex.ext; intros; dsimp; try { simp }, ext\n", "allTactics": true, "theorems": true, "env": 0}

{"cmd": "/-- ## The chain complex relation `d \u226b d`\n-/\ntheorem d_squared (n : \u2115) : objD X (n + 1) \u226b objD X n = 0 := by\n  -- we start by expanding d \u226b d as a double sum\n  dsimp\n  simp only [comp_sum, sum_comp, \u2190 Finset.sum_product']\n  -- then, we decompose the index set P into a subset S and its complement S\u1d9c\n  let P := Fin (n + 2) \u00d7 Fin (n + 3)\n  let S := Finset.univ.filter fun ij : P => (ij.2 : \u2115) \u2264 (ij.1 : \u2115)\n  erw [\u2190 Finset.sum_add_sum_compl S, \u2190 eq_neg_iff_add_eq_zero, \u2190 Finset.sum_neg_distrib]\n  /- we are reduced to showing that two sums are equal, and this is obtained\n    by constructing a bijection \u03c6 : S -> S\u1d9c, which maps (i,j) to (j,i+1),\n    and by comparing the terms -/\n  let \u03c6 : \u2200 ij : P, ij \u2208 S \u2192 P := fun ij hij =>\n    (Fin.castLT ij.2 (lt_of_le_of_lt (Finset.mem_filter.mp hij).right (Fin.is_lt ij.1)), ij.1.succ)\n  apply Finset.sum_bij \u03c6\n  \u00b7 -- \u03c6(S) is contained in S\u1d9c\n    intro ij hij\n    simp only [S, Finset.mem_univ, Finset.compl_filter, Finset.mem_filter, true_and_iff,\n      Fin.val_succ, Fin.coe_castLT] at hij \u22a2\n    linarith\n  \u00b7 -- \u03c6 : S \u2192 S\u1d9c is injective\n    rintro \u27e8i, j\u27e9 hij \u27e8i', j'\u27e9 hij' h\n    rw [Prod.mk.inj_iff]\n    exact \u27e8by simpa using congr_arg Prod.snd h,\n      by simpa [Fin.castSucc_castLT] using congr_arg Fin.castSucc (congr_arg Prod.fst h)\u27e9\n  \u00b7 -- \u03c6 : S \u2192 S\u1d9c is surjective\n    rintro \u27e8i', j'\u27e9 hij'\n    simp only [S, Finset.mem_univ, forall_true_left, Prod.forall, ge_iff_le, Finset.compl_filter,\n      not_le, Finset.mem_filter, true_and] at hij'\n    refine \u27e8(j'.pred <| ?_, Fin.castSucc i'), ?_, ?_\u27e9\n    \u00b7 rintro rfl\n      simp only [Fin.val_zero, not_lt_zero'] at hij'\n    \u00b7 simpa only [S, Finset.mem_univ, forall_true_left, Prod.forall, ge_iff_le, Finset.mem_filter,\n        Fin.coe_castSucc, Fin.coe_pred, true_and] using Nat.le_sub_one_of_lt hij'\n    \u00b7 simp only [\u03c6, Fin.castLT_castSucc, Fin.succ_pred]\n  \u00b7 -- identification of corresponding terms in both sums\n    rintro \u27e8i, j\u27e9 hij\n    dsimp\n    simp only [zsmul_comp, comp_zsmul, smul_smul, \u2190 neg_smul]\n    congr 1\n    \u00b7 simp only [Fin.val_succ, pow_add, pow_one, mul_neg, neg_neg, mul_one]\n      apply mul_comm\n    \u00b7 rw [CategoryTheory.SimplicialObject.\u03b4_comp_\u03b4'']\n      simpa [S] using hij\n#align algebraic_topology.alternating_face_map_complex.d_squared AlgebraicTopology.AlternatingFaceMapComplex.d_squared\n\n/-!\n## Construction of the alternating face map complex functor\n-/\n\n\n/-- The alternating face map complex, on objects -/\ndef obj : ChainComplex C \u2115 :=\n  ChainComplex.of (fun n => X _[n]) (objD X) (d_squared X)\n#align algebraic_topology.alternating_face_map_complex.obj AlgebraicTopology.AlternatingFaceMapComplex.obj\n\n@[simp]\ntheorem obj_X (X : SimplicialObject C) (n : \u2115) : (AlternatingFaceMapComplex.obj X).X n = X _[n] :=\n  rfl\nset_option linter.uppercaseLean3 false in\n#align algebraic_topology.alternating_face_map_complex.obj_X AlgebraicTopology.AlternatingFaceMapComplex.obj_X\n\n@[simp]\ntheorem obj_d_eq (X : SimplicialObject C) (n : \u2115) :\n    (AlternatingFaceMapComplex.obj X).d (n + 1) n\n      = \u2211 i : Fin (n + 2), (-1 : \u2124) ^ (i : \u2115) \u2022 X.\u03b4 i := by\n  apply ChainComplex.of_d\n#align algebraic_topology.alternating_face_map_complex.obj_d_eq AlgebraicTopology.AlternatingFaceMapComplex.obj_d_eq\n\nvariable {X} {Y}\n\n/-- The alternating face map complex, on morphisms -/\ndef map (f : X \u27f6 Y) : obj X \u27f6 obj Y :=\n  ChainComplex.ofHom _ _ _ _ _ _ (fun n => f.app (op [n])) fun n => by\n    dsimp\n    rw [comp_sum, sum_comp]\n    refine Finset.sum_congr rfl fun _ _ => ?_\n    rw [comp_zsmul, zsmul_comp]\n    congr 1\n    symm\n    apply f.naturality\n#align algebraic_topology.alternating_face_map_complex.map AlgebraicTopology.AlternatingFaceMapComplex.map\n\n@[simp]\ntheorem map_f (f : X \u27f6 Y) (n : \u2115) : (map f).f n = f.app (op [n]) :=\n  rfl\n#align algebraic_topology.alternating_face_map_complex.map_f AlgebraicTopology.AlternatingFaceMapComplex.map_f\n\nend AlternatingFaceMapComplex\n\nvariable (C : Type*) [Category C] [Preadditive C]\n\n/-- The alternating face map complex, as a functor -/\ndef alternatingFaceMapComplex : SimplicialObject C \u2964 ChainComplex C \u2115 where\n  obj := AlternatingFaceMapComplex.obj\n  map f := AlternatingFaceMapComplex.map f\n#align algebraic_topology.alternating_face_map_complex AlgebraicTopology.alternatingFaceMapComplex\n\nvariable {C}\n\n@[simp]\ntheorem alternatingFaceMapComplex_obj_X (X : SimplicialObject C) (n : \u2115) :\n    ((alternatingFaceMapComplex C).obj X).X n = X _[n] :=\n  rfl\nset_option linter.uppercaseLean3 false in\n#align algebraic_topology.alternating_face_map_complex_obj_X AlgebraicTopology.alternatingFaceMapComplex_obj_X\n\n@[simp]\ntheorem alternatingFaceMapComplex_obj_d (X : SimplicialObject C) (n : \u2115) :\n    ((alternatingFaceMapComplex C).obj X).d (n + 1) n = AlternatingFaceMapComplex.objD X n := by\n dsimp only [alternatingFaceMapComplex, AlternatingFaceMapComplex.obj]\n apply ChainComplex.of_d\n#align algebraic_topology.alternating_face_map_complex_obj_d AlgebraicTopology.alternatingFaceMapComplex_obj_d\n\n@[simp]\ntheorem alternatingFaceMapComplex_map_f {X Y : SimplicialObject C} (f : X \u27f6 Y) (n : \u2115) :\n    ((alternatingFaceMapComplex C).map f).f n = f.app (op [n]) :=\n  rfl\n#align algebraic_topology.alternating_face_map_complex_map_f AlgebraicTopology.alternatingFaceMapComplex_map_f\n\n\ntheorem map_alternatingFaceMapComplex {D : Type*} [Category D] [Preadditive D] (F : C \u2964 D)\n    [F.Additive] :\n    alternatingFaceMapComplex C \u22d9 F.mapHomologicalComplex _ =\n      (SimplicialObject.whiskering C D).obj F \u22d9 alternatingFaceMapComplex D  := by\n  apply CategoryTheory.Functor.ext; { intros; ext n; simp },\n  { intros X, apply HomologicalComplex.ext; { intros i j (rfl : j + 1 = i); dsimp; simp }, { ext n; rfl } }\n", "allTactics": true, "theorems": true, "env": 0}