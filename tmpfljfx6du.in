{"cmd": "import Mathlib.Analysis.Fourier.FourierTransform\nimport Mathlib.Analysis.Fourier.FourierTransformDeriv\nimport Mathlib.NumberTheory.ArithmeticFunction\nimport Mathlib.NumberTheory.LSeries.PrimesInAP\nimport Mathlib.Topology.Algebra.Support\nimport Mathlib.Analysis.Calculus.ContDiff.Defs\nimport Mathlib.Geometry.Manifold.PartitionOfUnity\nimport Mathlib.Tactic.FunProp\nimport Mathlib.Tactic.FunProp\nimport Mathlib.Analysis.Normed.Group.Tannery\nimport Mathlib.Algebra.Order.Field.Basic\nimport Mathlib.Order.Filter.ZeroAndBoundedAtFilter\nimport Mathlib.Analysis.Fourier.RiemannLebesgueLemma\nimport Mathlib.Analysis.SumIntegralComparisons\nimport Mathlib.Algebra.GroupWithZero.Units.Basic\nimport Mathlib.Analysis.Distribution.FourierSchwartz\nimport Mathlib.Topology.UniformSpace.UniformConvergence\nimport Mathlib.MeasureTheory.Measure.Haar.Disintegration\nimport Mathlib.NumberTheory.MulChar.Lemmas\n\nimport PrimeNumberTheoremAnd.Fourier\nimport PrimeNumberTheoremAnd.BrunTitchmarsh\nimport PrimeNumberTheoremAnd.Mathlib.Analysis.Asymptotics.Asymptotics\n\nset_option lang.lemmaCmd true\n\n-- note: the opening of ArithmeticFunction introduces a notation \u03c3 that seems\n-- impossible to hide, and hence parameters that are traditionally called \u03c3 will\n-- have to be called \u03c3' instead in this file.\n\nopen Real BigOperators ArithmeticFunction MeasureTheory Filter Set FourierTransform LSeries Asymptotics SchwartzMap\nopen Complex hiding log\nopen scoped Topology\nopen scoped ContDiff\n\nvariable {n : \u2115} {A a b c d u x y t \u03c3' : \u211d} {\u03c8 \u03a8 : \u211d \u2192 \u2102} {F G : \u2102 \u2192 \u2102} {f : \u2115 \u2192 \u2102} {\ud835\udd5c : Type} [RCLike \ud835\udd5c]\n\n-- This version makes the support of \u03a8 explicit, and this is easier for some later proofs"}

{"cmd": "lemma smooth_urysohn_support_Ioo (h1 : a < b) (h3: c < d) :\n    \u2203 \u03a8 : \u211d \u2192 \u211d, (ContDiff \u211d \u221e \u03a8) \u2227 (HasCompactSupport \u03a8) \u2227 Set.indicator (Set.Icc b c) 1 \u2264 \u03a8 \u2227\n    \u03a8 \u2264 Set.indicator (Set.Ioo a d) 1 \u2227 (Function.support \u03a8 = Set.Ioo a d) := by\n\n  have := exists_msmooth_zero_iff_one_iff_of_isClosed\n    (modelWithCornersSelf \u211d \u211d) (s := Set.Iic a \u222a Set.Ici d) (t := Set.Icc b c)\n    (IsClosed.union isClosed_Iic isClosed_Ici)\n    (isClosed_Icc)\n    (by\n      simp_rw [Set.disjoint_union_left, Set.disjoint_iff, Set.subset_def, Set.mem_inter_iff, Set.mem_Iic, Set.mem_Icc,\n        Set.mem_empty_iff_false, and_imp, imp_false, not_le, Set.mem_Ici]\n      constructor <;> intros <;> linarith)\n\n  rcases this with \u27e8\u03a8, h\u03a8Smooth, h\u03a8range, h\u03a80, h\u03a81\u27e9\n\n  simp only [Set.EqOn, Set.mem_setOf_eq, Set.mem_union, Set.mem_Iic, Set.mem_Ici,\n    ContMDiffMap.coeFn_mk, Pi.zero_apply, Set.mem_Icc, Pi.one_apply, and_imp] at *\n  use \u03a8\n  constructor\n  \u00b7 exact ContMDiff.contDiff h\u03a8Smooth\n  \u00b7 constructor\n    \u00b7 rw [hasCompactSupport_def]\n      apply IsCompact.closure_of_subset (K := Set.Icc a d) isCompact_Icc\n      simp_rw [Function.support_subset_iff, ne_eq, <-h\u03a80]\n      intro x hx\n      contrapose! hx\n      simp only [Set.mem_Icc, not_and_or] at hx\n      by_contra! h'\n      cases' hx <;> linarith\n    \u00b7 constructor\n      \u00b7 intro x\n        rw [Set.indicator_apply]\n        split_ifs with h\n        \u00b7 simp only [Set.mem_Icc, Pi.one_apply] at *\n          simp_rw [h\u03a81 x] at h\n          exact Eq.le (_root_.id h.symm)\n        \u00b7 have : \u03a8 x \u2208 Set.range \u03a8 := by simp only [Set.mem_range, exists_apply_eq_apply]\n          have : \u03a8 x \u2208 Set.Icc 0 1 := h\u03a8range this\n          exact this.left\n      \u00b7 constructor\n        \u00b7 intro x\n          rw [Set.indicator_apply]\n          split_ifs with h\n          \u00b7 have : \u03a8 x \u2208 Set.range \u03a8 := by simp only [Set.mem_range, exists_apply_eq_apply]\n            have : \u03a8 x \u2208 Set.Icc 0 1 := h\u03a8range this\n            simpa using this.2\n          \u00b7 simp only [Set.mem_Ioo, Pi.one_apply] at *\n            simp only [not_and_or, not_lt] at h\n            simp_rw [h\u03a80 x] at h\n            exact Eq.le h\n        \u00b7 simp_rw [Function.support, ne_eq, \u2190h\u03a80]\n          push_neg\n          simp [Set.ext_iff]\n\n\n/-%%\nThe Fourier transform of an absolutely integrable function $\\psi: \\R \\to \\C$ is defined by the formula\n$$ \\hat \\psi(u) := \\int_\\R e(-tu) \\psi(t)\\ dt$$\nwhere $e(\\theta) := e^{2\\pi i \\theta}$.\n\nLet $f: \\N \\to \\C$ be an arithmetic function such that $\\sum_{n=1}^\\infty \\frac{|f(n)|}{n^\\sigma} < \\infty$ for all $\\sigma>1$.  Then the Dirichlet series\n$$ F(s) := \\sum_{n=1}^\\infty \\frac{f(n)}{n^s}$$\nis absolutely convergent for $\\sigma>1$.\n%%-/\n\nnoncomputable\ndef nterm (f : \u2115 \u2192 \u2102) (\u03c3' : \u211d) (n : \u2115) : \u211d := if n = 0 then 0 else \u2016f n\u2016 / n ^ \u03c3'\n\nlemma nterm_eq_norm_term {f : \u2115 \u2192 \u2102} : nterm f \u03c3' n = \u2016term f \u03c3' n\u2016 := by\n  by_cases h : n = 0 <;> simp [nterm, term, h]\n\nlemma hf_coe1 (hf : \u2200 (\u03c3' : \u211d), 1 < \u03c3' \u2192 Summable (nterm f \u03c3')) (h\u03c3 : 1 < \u03c3') :\n    \u2211' i, (\u2016term f \u03c3' i\u2016\u208a : ENNReal) \u2260 \u22a4 := by\n  simp_rw [ENNReal.tsum_coe_ne_top_iff_summable_coe, \u2190 norm_toNNReal]\n  norm_cast\n  apply Summable.toNNReal\n  convert hf \u03c3' h\u03c3 with i\n  simp [nterm_eq_norm_term]\n\ninstance instMeasurableSpace : MeasurableSpace Circle :=\n  inferInstanceAs <| MeasurableSpace <| Subtype _\ninstance instBorelSpace : BorelSpace Circle :=\n  inferInstanceAs <| BorelSpace <| Subtype (\u00b7 \u2208 Metric.sphere (0 : \u2102) 1)\n\nlemma first_fourier_aux1 (h\u03c8: Continuous \u03c8) {x : \u211d} (n : \u2115) : Measurable fun (u : \u211d) \u21a6\n    (\u2016fourierChar (-(u * ((1 : \u211d) / ((2 : \u211d) * \u03c0) * (n / x).log))) \u2022 \u03c8 u\u2016\u208a : ENNReal) := by\n  -- TODO: attribute [fun_prop] Real.continuous_fourierChar once `fun_prop` bugfix is merged\n  refine Measurable.comp ?_ (by fun_prop) |>.smul (by fun_prop)\n    |>.nnnorm |>.coe_nnreal_ennreal\n  exact Continuous.measurable Real.continuous_fourierChar\n\nlemma first_fourier_aux2a :\n    (2 : \u2102) * \u03c0 * -(y * (1 / (2 * \u03c0) * Real.log ((n) / x))) = -(y * ((n) / x).log) := by\n  calc\n    _ = -(y * (((2 : \u2102) * \u03c0) / (2 * \u03c0) * Real.log ((n) / x))) := by ring\n    _ = _ := by rw [div_self (by norm_num; exact pi_ne_zero), one_mul]\n\nlemma first_fourier_aux2 (hx : 0 < x) (n : \u2115) :\n    term f \u03c3' n * \ud835\udc1e (-(y * (1 / (2 * \u03c0) * Real.log (n / x)))) \u2022 \u03c8 y =\n    term f (\u03c3' + y * I) n \u2022 (\u03c8 y * x ^ (y * I)) := by\n  by_cases hn : n = 0 ; simp [term, hn]\n  simp only [term, hn, \u2193reduceIte, fourierChar_apply]\n  calc\n    _ = (f n * (cexp ((2 * \u03c0 * -(y * (1 / (2 * \u03c0) * Real.log (n / x)))) * I) / \u2191((n : \u211d) ^ \u03c3'))) \u2022 \u03c8 y := by\n      have : ((\u2191n : \u2102) ^ (\u03c3' : \u2102) : \u2102) = ((\u2191n : \u211d) ^ (\u03c3' : \u211d) : \u211d) := by\n        rw [Complex.cpow_def_of_ne_zero (by simp [hn]), Real.rpow_def_of_nonneg (Nat.cast_nonneg n)]\n        simp [hn]\n      simp [Real.fourierChar, Circle.exp, smul_eq_mul, mul_assoc, this]\n      rw [Submonoid.mk_smul]\n      simp [Real.fourierChar, Circle.exp, smul_eq_mul, mul_assoc, this]\n      ring\n    _ = (f n * (x ^ (y * I) / n ^ (\u03c3' + y * I))) \u2022 \u03c8 y := by\n      congr 2\n      have l1 : 0 < (n : \u211d) := by simpa using Nat.pos_iff_ne_zero.mpr hn\n      have l2 : (x : \u2102) \u2260 0 := by simp [hx.ne.symm]\n      have l3 : (n : \u2102) \u2260 0 := by simp [hn]\n      rw [Real.rpow_def_of_pos l1, Complex.cpow_def_of_ne_zero l2, Complex.cpow_def_of_ne_zero l3]\n      push_cast\n      simp_rw [\u2190 Complex.exp_sub]\n      congr 1\n      rw [first_fourier_aux2a, Real.log_div l1.ne.symm hx.ne.symm]\n      push_cast\n      rw [Complex.ofReal_log hx.le]\n      ring\n    _ = _ := by simp ; group\n\n/-%%\n\\begin{lemma}[First Fourier identity]\\label{first-fourier}\\lean{first_fourier}\\leanok  If $\\psi: \\R \\to \\C$ is continuous and integrable and $x > 0$, then for any $\\sigma>1$\n  $$ \\sum_{n=1}^\\infty \\frac{f(n)}{n^\\sigma} \\hat \\psi( \\frac{1}{2\\pi} \\log \\frac{n}{x} ) = \\int_\\R F(\\sigma + it) \\psi(t) x^{it}\\ dt.$$\n\\end{lemma}\n%%-/\nlemma first_fourier (hf : \u2200 (\u03c3' : \u211d), 1 < \u03c3' \u2192 Summable (nterm f \u03c3')) (hcont: Continuous \u03c8)\n    (hsupp: Integrable \u03c8) (hx : 0 < x) (h\u03c3 : 1 < \u03c3') :\n    \u2211' n : \u2115, term f \u03c3' n * (\ud835\udcd5 \u03c8 (1 / (2 * \u03c0) * log (n / x))) =\n    \u222b t : \u211d, LSeries f (\u03c3' + t * I) * \u03c8 t * x ^ (t * I) := by\n/-%%\n\\begin{proof}\\leanok  By the definition of the Fourier transform, the left-hand side expands as\n$$ \\sum_{n=1}^\\infty \\int_\\R \\frac{f(n)}{n^\\sigma} \\psi(t) e( - \\frac{1}{2\\pi} t \\log \\frac{n}{x})\\ dt$$\nwhile the right-hand side expands as\n$$ \\int_\\R \\sum_{n=1}^\\infty \\frac{f(n)}{n^{\\sigma+it}} \\psi(t) x^{it}\\ dt.$$\nSince\n$$\\frac{f(n)}{n^\\sigma} \\psi(t) e( - \\frac{1}{2\\pi} t \\log \\frac{n}{x}) = \\frac{f(n)}{n^{\\sigma+it}} \\psi(t) x^{it}$$\nthe claim then follows from Fubini's theorem.\n\\end{proof}\n%%-/\n  calc\n    _ = \u2211' n, term f \u03c3' n * \u222b (v : \u211d), \ud835\udc1e (-(v * ((1 : \u211d) / ((2 : \u211d) * \u03c0) * Real.log (n / x)))) \u2022 \u03c8 v := by rfl\n    _ = \u2211' n, \u222b (v : \u211d), term f \u03c3' n * \ud835\udc1e (-(v * ((1 : \u211d) / ((2 : \u211d) * \u03c0) * Real.log (n / x)))) \u2022 \u03c8 v := by\n      simp [integral_mul_left]\n    _ = \u222b (v : \u211d), \u2211' (n : \u2115), term f \u03c3' n * \ud835\udc1e (-(v * ((1 : \u211d) / ((2 : \u211d) * \u03c0) * Real.log (n / x)))) \u2022 \u03c8 v := by\n      refine (integral_tsum ?_ ?_).symm\n      \u00b7 -- TODO: attribute [fun_prop] Real.continuous_fourierChar once `fun_prop` bugfix is merged\n        refine fun _ \u21a6 Measurable.aestronglyMeasurable ?_\n        refine Measurable.mul (by fun_prop) ((Measurable.comp ?_ (by fun_prop)).smul (by fun_prop))\n        exact Continuous.measurable Real.continuous_fourierChar\n      \u00b7 simp_rw [nnnorm_mul]\n        push_cast\n        simp_rw [lintegral_const_mul _ (first_fourier_aux1 hcont _)]\n        calc\n          _ = (\u2211' (i : \u2115), (\u2016term f \u03c3' i\u2016\u208a : ENNReal)) * \u222b\u207b (a : \u211d), \u2016\u03c8 a\u2016\u208a \u2202volume := by\n            simp [ENNReal.tsum_mul_right]\n          _ \u2260 \u22a4 := ENNReal.mul_ne_top (hf_coe1 hf h\u03c3)\n            (ne_top_of_lt hsupp.2)\n    _ = _ := by\n      congr 1; ext y\n      simp_rw [mul_assoc (LSeries _ _), \u2190 smul_eq_mul (a := (LSeries _ _)), LSeries]\n      rw [\u2190 tsum_smul_const]\n      \u00b7 congr with n ; exact first_fourier_aux2 hx n\n      \u00b7 apply Summable.of_norm\n        convert hf \u03c3' h\u03c3 with n\n        by_cases h : n = 0\n        \u00b7 simp [nterm, term, h]\n        \u00b7 simp [nterm, term, h]\n          have : (n : \u2102) \u2260 0 := by simp [h]\n          simp [Complex.abs_cpow_of_ne_zero this]\n\n/-%%\n\\begin{lemma}[Second Fourier identity]\\label{second-fourier}\\lean{second_fourier}\\leanok If $\\psi: \\R \\to \\C$ is continuous and compactly supported and $x > 0$, then for any $\\sigma>1$\n$$ \\int_{-\\log x}^\\infty e^{-u(\\sigma-1)} \\hat \\psi(\\frac{u}{2\\pi})\\ du = x^{\\sigma - 1} \\int_\\R \\frac{1}{\\sigma+it-1} \\psi(t) x^{it}\\ dt.$$\n\\end{lemma}\n%%-/\n\n@[continuity]\nlemma continuous_multiplicative_ofAdd : Continuous (\u21d1Multiplicative.ofAdd : \u211d \u2192 \u211d) := \u27e8fun _ \u21a6 id\u27e9\n\nattribute [fun_prop] measurable_coe_nnreal_ennreal\n\nlemma second_fourier_integrable_aux1a (h\u03c3 : 1 < \u03c3') :\n    IntegrableOn (fun (x : \u211d) \u21a6 cexp (-((x : \u2102) * ((\u03c3' : \u2102) - 1)))) (Ici (-Real.log x)) := by\n  norm_cast\n  suffices IntegrableOn (fun (x : \u211d) \u21a6 (rexp (-(x * (\u03c3' - 1))))) (Ici (-x.log)) _ from this.ofReal\n  simp_rw [fun (a x : \u211d) \u21a6 (by ring : -(x * a) = -a * x), integrableOn_Ici_iff_integrableOn_Ioi]\n  apply exp_neg_integrableOn_Ioi\n  linarith\n\nlemma second_fourier_integrable_aux1 (hcont: Continuous \u03c8) (hsupp: Integrable \u03c8) (h\u03c3 : 1 < \u03c3') :\n    let \u03bd : Measure (\u211d \u00d7 \u211d) := (volume.restrict (Ici (-Real.log x))).prod volume\n    Integrable (Function.uncurry fun (u : \u211d) (a : \u211d) \u21a6 ((rexp (-u * (\u03c3' - 1))) : \u2102) \u2022\n    (\ud835\udc1e (Multiplicative.ofAdd (-(a * (u / (2 * \u03c0))))) : \u2102) \u2022 \u03c8 a) \u03bd := by\n  intro \u03bd\n  constructor\n  \u00b7 apply Measurable.aestronglyMeasurable\n    apply MeasureTheory.measurable_uncurry_of_continuous_of_measurable <;> intro i\n    swap; apply Continuous.measurable\n    \u00b7 apply Continuous.smul\n      \u00b7 fun_prop\n      \u00b7 apply Continuous.smul\n        \u00b7 apply Continuous.subtype_val\n          simp [Real.fourierChar, Circle.exp, Multiplicative.ofAdd]\n          fun_prop\n        \u00b7 fun_prop\n    \u00b7 apply Continuous.smul\n      \u00b7 fun_prop\n      \u00b7 apply Continuous.smul\n        \u00b7 apply Continuous.subtype_val\n          simp [Real.fourierChar, Circle.exp, Multiplicative.ofAdd]\n          fun_prop\n        \u00b7 fun_prop\n  \u00b7 let f1 : \u211d \u2192 ENNReal := fun a1 \u21a6 \u2191\u2016cexp (-(\u2191a1 * (\u2191\u03c3' - 1)))\u2016\u208a\n    let f2 : \u211d \u2192 ENNReal := fun a2 \u21a6 \u2191\u2016\u03c8 a2\u2016\u208a\n    suffices \u222b\u207b (a : \u211d \u00d7 \u211d), f1 a.1 * f2 a.2 \u2202\u03bd < \u22a4 by simpa [Function.uncurry, HasFiniteIntegral]\n    refine (lintegral_prod_mul ?_ ?_).trans_lt ?_ <;> try fun_prop\n    exact ENNReal.mul_lt_top (second_fourier_integrable_aux1a h\u03c3).2 hsupp.2\n\nlemma second_fourier_integrable_aux2 (h\u03c3 : 1 < \u03c3') :\n    IntegrableOn (fun (u : \u211d) \u21a6 cexp ((1 - \u2191\u03c3' - \u2191t * I) * \u2191u)) (Ioi (-Real.log x)) := by\n  refine (integrable_norm_iff (Measurable.aestronglyMeasurable <| by fun_prop)).mp ?_\n  suffices IntegrableOn (fun a \u21a6 rexp (-(\u03c3' - 1) * a)) (Ioi (-x.log)) _ by simpa [Complex.abs_exp]\n  apply exp_neg_integrableOn_Ioi\n  linarith\n\nlemma second_fourier_aux (hx : 0 < x) :\n    -(cexp (-((1 - \u2191\u03c3' - \u2191t * I) * \u2191(Real.log x))) / (1 - \u2191\u03c3' - \u2191t * I)) =\n    \u2191(x ^ (\u03c3' - 1)) * (\u2191\u03c3' + \u2191t * I - 1)\u207b\u00b9 * \u2191x ^ (\u2191t * I) := by\n  calc\n    _ = cexp (\u2191(Real.log x) * ((\u2191\u03c3' - 1) + \u2191t * I)) * (\u2191\u03c3' + \u2191t * I - 1)\u207b\u00b9 := by rw [\u2190 div_neg]; ring_nf\n    _ = (x ^ ((\u2191\u03c3' - 1) + \u2191t * I)) * (\u2191\u03c3' + \u2191t * I - 1)\u207b\u00b9 := by\n      rw [Complex.cpow_def_of_ne_zero (ofReal_ne_zero.mpr (ne_of_gt hx)), Complex.ofReal_log hx.le]\n    _ = (x ^ ((\u03c3' : \u2102) - 1)) * (x ^ (\u2191t * I)) * (\u2191\u03c3' + \u2191t * I - 1)\u207b\u00b9 := by\n      rw [Complex.cpow_add _ _ (ofReal_ne_zero.mpr (ne_of_gt hx))]\n    _ = _ := by rw [ofReal_cpow hx.le]; push_cast; ring\n\nlemma second_fourier (hcont: Continuous \u03c8) (hsupp: Integrable \u03c8)\n    {x \u03c3' : \u211d} (hx : 0 < x) (h\u03c3 : 1 < \u03c3') :\n    \u222b u in Ici (-log x), Real.exp (-u * (\u03c3' - 1)) * \ud835\udcd5 \u03c8 (u / (2 * \u03c0)) =\n    (x^(\u03c3' - 1) : \u211d) * \u222b t, (1 / (\u03c3' + t * I - 1)) * \u03c8 t * x^(t * I) \u2202 volume := by\n/-%%\n\\begin{proof}\\leanok\nThe left-hand side expands as\n$$ \\int_{-\\log x}^\\infty \\int_\\R e^{-u(\\sigma-1)} \\psi(t) e(-\\frac{tu}{2\\pi})\\ dt\\ du \\atop{?}=\nx^{\\sigma - 1} \\int_\\R \\frac{1}{\\sigma+it-1} \\psi(t) x^{it}\\ dt$$\nso by Fubini's theorem it suffices to verify the identity\n\\begin{align*}\n\\int_{-\\log x}^\\infty e^{-u(\\sigma-1)} e(-\\frac{tu}{2\\pi})\\ du\n&= \\int_{-\\log x}^\\infty e^{(it - \\sigma + 1)u}\\ du \\\\\n&= \\frac{1}{it - \\sigma + 1} e^{(it - \\sigma + 1)u}\\ \\Big|_{-\\log x}^\\infty \\\\\n&= x^{\\sigma - 1} \\frac{1}{\\sigma+it-1} x^{it}\n\\end{align*}\n\\end{proof}\n%%-/\n  conv in \u2191(rexp _) * _ => { rw [Real.fourierIntegral_real_eq, \u2190 smul_eq_mul, \u2190 integral_smul] }\n  rw [MeasureTheory.integral_integral_swap] ; swap ; exact second_fourier_integrable_aux1 hcont hsupp h\u03c3\n  rw [\u2190 integral_mul_left]\n  congr 1; ext t\n  dsimp [Real.fourierChar, Circle.exp]\n\n  simp_rw [mul_smul_comm, \u2190 smul_mul_assoc, integral_mul_right]\n  rw [fun (a b d : \u2102) \u21a6 show a * (b * (\u03c8 t) * d) = (a * b * d) * \u03c8 t by ring]\n  congr 1\n  push_cast\n  conv =>\n    lhs\n    enter [2]\n    ext a\n    rw [Submonoid.mk_smul, smul_eq_mul]\n  simp_rw [\u2190 Complex.exp_add]\n  have (u : \u211d) :\n      2 * \u2191\u03c0 * -(\u2191t * (\u2191u / (2 * \u2191\u03c0))) * I + -\u2191u * (\u2191\u03c3' - 1) = (1 - \u03c3' - t * I) * u := calc\n    _ = -\u2191u * (\u2191\u03c3' - 1) + (2 * \u2191\u03c0) / (2 * \u2191\u03c0) * -(\u2191t * \u2191u) * I := by ring\n    _ = -\u2191u * (\u2191\u03c3' - 1) + 1 * -(\u2191t * \u2191u) * I := by rw [div_self (by norm_num; exact pi_ne_zero)]\n    _ = _ := by ring\n  simp_rw [this]\n  let c : \u2102 := (1 - \u2191\u03c3' - \u2191t * I)\n  have : c \u2260 0 := by simp [Complex.ext_iff, c] ; intro h ; linarith\n  let f' (u : \u211d) := cexp (c * u)\n  let f := fun (u : \u211d) \u21a6 (f' u) / c\n  have hderiv : \u2200 u \u2208 Ici (-Real.log x), HasDerivAt f (f' u) u := by\n    intro u _\n    rw [show f' u = cexp (c * u) * (c * 1) / c by field_simp]\n    exact (hasDerivAt_id' u).ofReal_comp.const_mul c |>.cexp.div_const c\n  have hf : Tendsto f atTop (\ud835\udcdd 0) := by\n    apply tendsto_zero_iff_norm_tendsto_zero.mpr\n    suffices Tendsto (fun (x : \u211d) \u21a6 abs (cexp (c * \u2191x)) / abs c) atTop (\ud835\udcdd (0 / abs c)) by simpa [f, f'] using this\n    apply Filter.Tendsto.div_const\n    suffices Tendsto (. * (1 - \u03c3')) atTop atBot by simpa [Complex.abs_exp, mul_comm (1 - \u03c3'), c]\n    exact Tendsto.atTop_mul_const_of_neg (by linarith) fun \u2983s\u2984 h \u21a6 h\n  rw [integral_Ici_eq_integral_Ioi,\n    integral_Ioi_of_hasDerivAt_of_tendsto' hderiv (second_fourier_integrable_aux2 h\u03c3) hf]\n  simpa [f, f'] using second_fourier_aux hx\n\n/-%%\nNow let $A \\in \\C$, and suppose that there is a continuous function $G(s)$ defined on $\\mathrm{Re} s \\geq 1$ such that $G(s) = F(s) - \\frac{A}{s-1}$ whenever $\\mathrm{Re} s > 1$.  We also make the Chebyshev-type hypothesis\n\\begin{equation}\\label{cheby}\n\\sum_{n \\leq x} |f(n)| \\ll x\n\\end{equation}\nfor all $x \\geq 1$ (this hypothesis is not strictly necessary, but simplifies the arguments and can be obtained fairly easily in applications).\n%%-/\n\nlemma one_add_sq_pos (u : \u211d) : 0 < 1 + u ^ 2 := zero_lt_one.trans_le (by simpa using sq_nonneg u)\n\n/-%%\n\\begin{lemma}[Decay bounds]\\label{decay}\\lean{decay_bounds}\\leanok  If $\\psi:\\R \\to \\C$ is $C^2$ and obeys the bounds\n  $$ |\\psi(t)|, |\\psi''(t)| \\leq A / (1 + |t|^2)$$\n  for all $t \\in \\R$, then\n$$ |\\hat \\psi(u)| \\leq C A / (1+|u|^2)$$\nfor all $u \\in \\R$, where $C$ is an absolute constant.\n\\end{lemma}\n%%-/\n\nlemma decay_bounds_key (f : W21) (u : \u211d) : \u2016\ud835\udcd5 f u\u2016 \u2264 \u2016f\u2016 * (1 + u ^ 2)\u207b\u00b9 := by\n  have l1 : 0 < 1 + u ^ 2 := one_add_sq_pos _\n  have l2 : 1 + u ^ 2 = \u2016(1 : \u2102) + u ^ 2\u2016 := by\n    norm_cast ; simp only [Real.norm_eq_abs, abs_eq_self.2 l1.le]\n  have l3 : \u20161 / ((4 : \u2102) * \u2191\u03c0 ^ 2)\u2016 \u2264 (4 * \u03c0 ^ 2)\u207b\u00b9 := by simp\n  have key := fourierIntegral_self_add_deriv_deriv f u\n  simp only [Function.iterate_succ _ 1, Function.iterate_one, Function.comp_apply] at key\n  rw [F_sub f.hf (f.hf''.const_mul (1 / (4 * \u2191\u03c0 ^ 2)))] at key\n  rw [\u2190 div_eq_mul_inv, le_div_iff\u2080 l1, mul_comm, l2, \u2190 norm_mul, key, sub_eq_add_neg]\n  apply norm_add_le _ _ |>.trans\n  change _ \u2264 W21.norm _\n  rw [norm_neg, F_mul, norm_mul, W21.norm]\n  gcongr <;> apply VectorFourier.norm_fourierIntegral_le_integral_norm\n\nlemma decay_bounds_aux {f : \u211d \u2192 \u2102} (hf : AEStronglyMeasurable f volume) (h : \u2200 t, \u2016f t\u2016 \u2264 A * (1 + t ^ 2)\u207b\u00b9) :\n    \u222b t, \u2016f t\u2016 \u2264 \u03c0 * A := by\n  have l1 : Integrable (fun x \u21a6 A * (1 + x ^ 2)\u207b\u00b9) := integrable_inv_one_add_sq.const_mul A\n  simp_rw [\u2190 integral_univ_inv_one_add_sq, mul_comm, \u2190 integral_mul_left]\n  exact integral_mono (l1.mono' hf (Eventually.of_forall h)).norm l1 h\n\ntheorem decay_bounds_W21 (f : W21) (hA : \u2200 t, \u2016f t\u2016 \u2264 A / (1 + t ^ 2))\n    (hA' : \u2200 t, \u2016deriv (deriv f) t\u2016 \u2264 A / (1 + t ^ 2)) (u) :\n    \u2016\ud835\udcd5 f u\u2016 \u2264 (\u03c0 + 1 / (4 * \u03c0)) * A / (1 + u ^ 2) := by\n  have l0 : 1 * (4 * \u03c0)\u207b\u00b9 * A = (4 * \u03c0 ^ 2)\u207b\u00b9 * (\u03c0 * A) := by field_simp ; ring\n  have l1 : \u222b (v : \u211d), \u2016f v\u2016 \u2264 \u03c0 * A := by\n    apply decay_bounds_aux f.continuous.aestronglyMeasurable\n    simp_rw [\u2190 div_eq_mul_inv] ; exact hA\n  have l2 : \u222b (v : \u211d), \u2016deriv (deriv f) v\u2016 \u2264 \u03c0 * A := by\n    apply decay_bounds_aux f.deriv.deriv.continuous.aestronglyMeasurable\n    simp_rw [\u2190 div_eq_mul_inv] ; exact hA'\n  apply decay_bounds_key f u |>.trans\n  change W21.norm _ * _ \u2264 _\n  simp_rw [W21.norm, div_eq_mul_inv, add_mul, l0] ; gcongr\n\nlemma decay_bounds (\u03c8 : CS 2 \u2102) (hA : \u2200 t, \u2016\u03c8 t\u2016 \u2264 A / (1 + t ^ 2)) (hA' : \u2200 t, \u2016deriv^[2] \u03c8 t\u2016 \u2264 A / (1 + t ^ 2)) :\n    \u2016\ud835\udcd5 \u03c8 u\u2016 \u2264 (\u03c0 + 1 / (4 * \u03c0)) * A / (1 + u ^ 2) := by\n  exact decay_bounds_W21 \u03c8 hA hA' u\n\nlemma decay_bounds_cor_aux (\u03c8 : CS 2 \u2102) : \u2203 C : \u211d, \u2200 u, \u2016\u03c8 u\u2016 \u2264 C / (1 + u ^ 2) := by\n  have l1 : HasCompactSupport (fun u : \u211d => ((1 + u ^ 2) : \u211d) * \u03c8 u) := by exact \u03c8.h2.mul_left\n  have := \u03c8.h1.continuous\n  obtain \u27e8C, hC\u27e9 := l1.exists_bound_of_continuous (by continuity)\n  refine \u27e8C, fun u => ?_\u27e9\n  specialize hC u\n  simp only [norm_mul, Complex.norm_eq_abs, Complex.abs_ofReal, abs_eq_self.mpr (one_add_sq_pos u).le] at hC\n  rwa [le_div_iff\u2080' (one_add_sq_pos _)]\n\nlemma decay_bounds_cor (\u03c8 : W21) :\n    \u2203 C : \u211d, \u2200 u, \u2016\ud835\udcd5 \u03c8 u\u2016 \u2264 C / (1 + u ^ 2) := by\n  simpa only [div_eq_mul_inv] using \u27e8_, decay_bounds_key \u03c8\u27e9\n\n@[continuity] lemma continuous_FourierIntegral (\u03c8 : W21) : Continuous (\ud835\udcd5 \u03c8) :=\n  VectorFourier.fourierIntegral_continuous continuous_fourierChar (by exact continuous_mul) \u03c8.hf\n\nlemma W21.integrable_fourier (\u03c8 : W21) (hc : c \u2260 0) :\n    Integrable fun u \u21a6 \ud835\udcd5 \u03c8 (u / c) := by\n  have l1 (C) : Integrable (fun u \u21a6 C / (1 + (u / c) ^ 2)) volume := by\n    simpa using (integrable_inv_one_add_sq.comp_div hc).const_mul C\n  have l2 : AEStronglyMeasurable (fun u \u21a6 \ud835\udcd5 \u03c8 (u / c)) volume := by\n    apply Continuous.aestronglyMeasurable ; continuity\n  obtain \u27e8C, h\u27e9 := decay_bounds_cor \u03c8\n  apply @Integrable.mono' \u211d \u2102 _ volume _ _ (fun u => C / (1 + (u / c) ^ 2)) (l1 C) l2 ?_\n  apply Eventually.of_forall (fun x => h _)\n\n/-%%\n\\begin{proof} \\leanok From two integration by parts we obtain the identity\n$$ (1+u^2) \\hat \\psi(u) = \\int_{\\bf R} (\\psi(t) - \\frac{u}{4\\pi^2} \\psi''(t)) e(-tu)\\ dt.$$\nNow apply the triangle inequality and the identity $\\int_{\\bf R} \\frac{dt}{1+t^2}\\ dt = \\pi$ to obtain the claim with $C = \\pi + 1 / 4 \\pi$.\n\\end{proof}\n%%-/\n\n/-%%\n\\begin{lemma}[Limiting Fourier identity]\\label{limiting}\\lean{limiting_fourier}\\leanok  If $\\psi: \\R \\to \\C$ is $C^2$ and compactly supported and $x \\geq 1$, then\n$$ \\sum_{n=1}^\\infty \\frac{f(n)}{n} \\hat \\psi( \\frac{1}{2\\pi} \\log \\frac{n}{x} ) - A \\int_{-\\log x}^\\infty \\hat \\psi(\\frac{u}{2\\pi})\\ du =  \\int_\\R G(1+it) \\psi(t) x^{it}\\ dt.$$\n\\end{lemma}\n%%-/\n\nlemma continuous_LSeries_aux (hf : Summable (nterm f \u03c3')) :\n    Continuous fun x : \u211d => LSeries f (\u03c3' + x * I) := by\n\n  have l1 i : Continuous fun x : \u211d \u21a6 term f (\u03c3' + x * I) i := by\n    by_cases h : i = 0\n    \u00b7 simpa [h] using continuous_const\n    \u00b7 simpa [h] using continuous_const.div (continuous_const.cpow (by continuity) (by simp [h])) (fun x => by simp [h])\n  have l2 n (x : \u211d) : \u2016term f (\u03c3' + x * I) n\u2016 = nterm f \u03c3' n := by\n    by_cases h : n = 0\n    \u00b7 simp [h, nterm]\n    \u00b7 field_simp [h, nterm, cpow_add _ _ (Nat.cast_ne_zero.mpr h)]\n      rw [\u2190 Complex.norm_eq_abs, Complex.norm_natCast_cpow_of_pos (Nat.pos_of_ne_zero h)]\n      simp\n  exact continuous_tsum l1 hf (fun n x => le_of_eq (l2 n x))\n\n-- Here compact support is used but perhaps it is not necessary\nlemma limiting_fourier_aux (hG' : Set.EqOn G (fun s \u21a6 LSeries f s - A / (s - 1)) {s | 1 < s.re})\n    (hf : \u2200 (\u03c3' : \u211d), 1 < \u03c3' \u2192 Summable (nterm f \u03c3')) (\u03c8 : CS 2 \u2102) (hx : 1 \u2264 x) (\u03c3' : \u211d) (h\u03c3' : 1 < \u03c3') :\n    \u2211' n, term f \u03c3' n * \ud835\udcd5 \u03c8 (1 / (2 * \u03c0) * log (n / x)) -\n    A * (x ^ (1 - \u03c3') : \u211d) * \u222b u in Ici (- log x), rexp (-u * (\u03c3' - 1)) * \ud835\udcd5 \u03c8 (u / (2 * \u03c0)) =\n    \u222b t : \u211d, G (\u03c3' + t * I) * \u03c8 t * x ^ (t * I) := by\n\n  have hint : Integrable \u03c8 := \u03c8.h1.continuous.integrable_of_hasCompactSupport \u03c8.h2\n  have l3 : 0 < x := zero_lt_one.trans_le hx\n  have l1 (\u03c3') (h\u03c3' : 1 < \u03c3') := first_fourier hf \u03c8.h1.continuous hint l3 h\u03c3'\n  have l2 (\u03c3') (h\u03c3' : 1 < \u03c3') := second_fourier \u03c8.h1.continuous hint l3 h\u03c3'\n  have l8 : Continuous fun t : \u211d \u21a6 (x : \u2102) ^ (t * I) :=\n    continuous_const.cpow (continuous_ofReal.mul continuous_const) (by simp [l3])\n  have l6 : Continuous fun t : \u211d \u21a6 LSeries f (\u2191\u03c3' + \u2191t * I) * \u03c8 t * \u2191x ^ (\u2191t * I) := by\n    apply ((continuous_LSeries_aux (hf _ h\u03c3')).mul \u03c8.h1.continuous).mul l8\n  have l4 : Integrable fun t : \u211d \u21a6 LSeries f (\u2191\u03c3' + \u2191t * I) * \u03c8 t * \u2191x ^ (\u2191t * I) := by\n    exact l6.integrable_of_hasCompactSupport \u03c8.h2.mul_left.mul_right\n  have e2 (u : \u211d) : \u03c3' + u * I - 1 \u2260 0 := by\n    intro h ; have := congr_arg Complex.re h ; simp at this ; linarith\n  have l7 : Continuous fun a \u21a6 A * \u2191(x ^ (1 - \u03c3')) * (\u2191(x ^ (\u03c3' - 1)) * (1 / (\u03c3' + a * I - 1) * \u03c8 a * x ^ (a * I))) := by\n    simp [\u2190 mul_assoc]\n    refine ((continuous_const.mul <| Continuous.inv\u2080 ?_ e2).mul \u03c8.h1.continuous).mul l8\n    fun_prop\n  have l5 : Integrable fun a \u21a6 A * \u2191(x ^ (1 - \u03c3')) * (\u2191(x ^ (\u03c3' - 1)) * (1 / (\u03c3' + a * I - 1) * \u03c8 a * x ^ (a * I))) := by\n    apply l7.integrable_of_hasCompactSupport\n    exact \u03c8.h2.mul_left.mul_right.mul_left.mul_left\n\n  simp_rw [l1 \u03c3' h\u03c3', l2 \u03c3' h\u03c3', \u2190 integral_mul_left, \u2190 integral_sub l4 l5]\n  apply integral_congr_ae\n  apply Eventually.of_forall\n  intro u\n  have e1 : 1 < ((\u03c3' : \u2102) + (u : \u2102) * I).re := by simp [h\u03c3']\n  simp_rw [hG' e1, sub_mul, \u2190 mul_assoc]\n  field_simp [e2] ; left ; left\n  norm_cast\n  simp [mul_assoc, \u2190 rpow_add l3]\n\nsection nabla\n\nvariable {\u03b1 E : Type*} [OfNat \u03b1 1] [Add \u03b1] [Sub \u03b1] {u : \u03b1 \u2192 \u2102}\n\ndef cumsum [AddCommMonoid E] (u : \u2115 \u2192 E) (n : \u2115) : E := \u2211 i in Finset.range n, u i\n\ndef nabla [Sub E] (u : \u03b1 \u2192 E) (n : \u03b1) : E := u (n + 1) - u n\n\n/- TODO nnabla is redundant -/\ndef nnabla [Sub E] (u : \u03b1 \u2192 E) (n : \u03b1) : E := u n - u (n + 1)\n\ndef shift (u : \u03b1 \u2192 E) (n : \u03b1) : E := u (n + 1)\n\n@[simp] lemma cumsum_zero [AddCommMonoid E] {u : \u2115 \u2192 E} : cumsum u 0 = 0 := by simp [cumsum]\n\nlemma cumsum_succ [AddCommMonoid E] {u : \u2115 \u2192 E} (n : \u2115) :\n    cumsum u (n + 1) = cumsum u n + u n := by\n  simp [cumsum, Finset.sum_range_succ]\n\n@[simp] lemma nabla_cumsum [AddCommGroup E] {u : \u2115 \u2192 E} : nabla (cumsum u) = u := by\n  ext n ; simp [nabla, cumsum, Finset.range_succ]\n\nlemma neg_cumsum [AddCommGroup E] {u : \u2115 \u2192 E} : -(cumsum u) = cumsum (-u) := funext (fun n => by simp [cumsum])\n\nlemma cumsum_nonneg {u : \u2115 \u2192 \u211d} (hu : 0 \u2264 u) : 0 \u2264 cumsum u := fun _ => Finset.sum_nonneg (fun i _ => hu i)\n\nomit [Sub \u03b1] in\nlemma neg_nabla [Ring E] {u : \u03b1 \u2192 E} : -(nabla u) = nnabla u := by ext n ; simp [nabla, nnabla]\n\nomit [Sub \u03b1] in\n@[simp] lemma nabla_mul [Ring E] {u : \u03b1 \u2192 E} {c : E} : nabla (fun n => c * u n) = c \u2022 nabla u := by\n  ext n ; simp [nabla, mul_sub]\n\nomit [Sub \u03b1] in\n@[simp] lemma nnabla_mul [Ring E] {u : \u03b1 \u2192 E} {c : E} : nnabla (fun n => c * u n) = c \u2022 nnabla u := by\n  ext n ; simp [nnabla, mul_sub]\n\nlemma nnabla_cast (u : \u211d \u2192 E) [Sub E] : nnabla u \u2218 ((\u2191) : \u2115 \u2192 \u211d) = nnabla (u \u2218 (\u2191)) := by\n  ext n ; simp [nnabla]\n\nend nabla\n\nlemma Finset.sum_shift_front {E : Type*} [Ring E] {u : \u2115 \u2192 E} {n : \u2115} :\n    cumsum u (n + 1) = u 0 + cumsum (shift u) n := by\n  simp_rw [add_comm n, cumsum, sum_range_add, sum_range_one, add_comm 1] ; rfl\n\nlemma Finset.sum_shift_front' {E : Type*} [Ring E] {u : \u2115 \u2192 E} :\n    shift (cumsum u) = (fun _ => u 0) + cumsum (shift u) := by\n  ext n ; apply Finset.sum_shift_front\n\nlemma Finset.sum_shift_back {E : Type*} [Ring E] {u : \u2115 \u2192 E} {n : \u2115} :\n    cumsum u (n + 1) = cumsum u n + u n := by\n  simp [cumsum, Finset.range_succ, add_comm]\n\nlemma Finset.sum_shift_back' {E : Type*} [Ring E] {u : \u2115 \u2192 E} : shift (cumsum u) = cumsum u + u := by\n  ext n ; apply Finset.sum_shift_back\n\nlemma summation_by_parts {E : Type*} [Ring E] {a A b : \u2115 \u2192 E} (ha : a = nabla A) {n : \u2115} :\n    cumsum (a * b) (n + 1) = A (n + 1) * b n - A 0 * b 0 - cumsum (shift A * fun i => (b (i + 1) - b i)) n := by\n  have l1 : \u2211 x in Finset.range (n + 1), A (x + 1) * b x = \u2211 x in Finset.range n, A (x + 1) * b x + A (n + 1) * b n :=\n    Finset.sum_shift_back\n  have l2 : \u2211 x in Finset.range (n + 1), A x * b x = A 0 * b 0 + \u2211 x in Finset.range n, A (x + 1) * b (x + 1) :=\n    Finset.sum_shift_front\n  simp [cumsum, shift, ha, nabla, sub_mul, mul_sub, l1, l2] ; abel\n\nlemma summation_by_parts' {E : Type*} [Ring E] {a b : \u2115 \u2192 E} {n : \u2115} :\n    cumsum (a * b) (n + 1) = cumsum a (n + 1) * b n - cumsum (shift (cumsum a) * nabla b) n := by\n  simpa using summation_by_parts (a := a) (b := b) (A := cumsum a) (by simp [Finset.sum_shift_back])\n\nlemma summation_by_parts'' {E : Type*} [Ring E] {a b : \u2115 \u2192 E} :\n    shift (cumsum (a * b)) = shift (cumsum a) * b - cumsum (shift (cumsum a) * nabla b) := by\n  ext n ; apply summation_by_parts'\n\nlemma summable_iff_bounded {u : \u2115 \u2192 \u211d} (hu : 0 \u2264 u) : Summable u \u2194 BoundedAtFilter atTop (cumsum u) := by\n  have l1 : (cumsum u =O[atTop] 1) \u2194 _ := isBigO_one_nat_atTop_iff\n  have l2 n : \u2016cumsum u n\u2016 = cumsum u n := by simpa using cumsum_nonneg hu n\n  simp only [BoundedAtFilter, l1, l2]\n  constructor <;> intro \u27e8C, h1\u27e9\n  \u00b7 exact \u27e8C, fun n => sum_le_hasSum _ (fun i _ => hu i) h1\u27e9\n  \u00b7 exact summable_of_sum_range_le hu h1\n\nlemma Filter.EventuallyEq.summable {u v : \u2115 \u2192 \u211d} (h : u =\u1da0[atTop] v) (hu : Summable v) : Summable u :=\n  summable_of_isBigO_nat hu h.isBigO\n\nlemma summable_congr_ae {u v : \u2115 \u2192 \u211d} (huv : u =\u1da0[atTop] v) : Summable u \u2194 Summable v := by\n  constructor <;> intro h <;> simp [huv.summable, huv.symm.summable, h]\n\nlemma BoundedAtFilter.add_const {u : \u2115 \u2192 \u211d} {c : \u211d} :\n    BoundedAtFilter atTop (fun n => u n + c) \u2194 BoundedAtFilter atTop u := by\n  have : u = fun n => (u n + c) + (-c) := by ext n ; ring\n  simp [BoundedAtFilter] ; constructor <;> intro h ; rw [this]\n  all_goals { exact h.add (const_boundedAtFilter _ _) }\n\nlemma BoundedAtFilter.comp_add {u : \u2115 \u2192 \u211d} {N : \u2115} :\n    BoundedAtFilter atTop (fun n => u (n + N)) \u2194 BoundedAtFilter atTop u := by\n  simp [BoundedAtFilter, isBigO_iff] ; constructor <;> intro \u27e8C, n\u2080, h\u27e9 <;> use C\n  \u00b7 refine \u27e8n\u2080 + N, fun n hn => ?_\u27e9\n    obtain \u27e8k, hk\u27e9 := Nat.exists_eq_add_of_le' (m := N) (by linarith) ; subst n\n    exact h _ <| Nat.add_le_add_iff_right.mp hn\n  \u00b7 exact \u27e8n\u2080, fun n hn => h _ (by linarith)\u27e9\n\nlemma summable_iff_bounded' {u : \u2115 \u2192 \u211d} (hu : \u2200\u1da0 n in atTop, 0 \u2264 u n) :\n    Summable u \u2194 BoundedAtFilter atTop (cumsum u) := by\n  obtain \u27e8N, hu\u27e9 := eventually_atTop.mp hu\n  have e2 : cumsum (fun i \u21a6 u (i + N)) = fun n => cumsum u (n + N) - cumsum u N := by\n    ext n ; simp_rw [cumsum, add_comm _ N, Finset.sum_range_add] ; ring\n  rw [\u2190 summable_nat_add_iff N, summable_iff_bounded (fun n => hu _ <| Nat.le_add_left N n), e2]\n  simp_rw [sub_eq_add_neg, BoundedAtFilter.add_const, BoundedAtFilter.comp_add]\n\nlemma bounded_of_shift {u : \u2115 \u2192 \u211d} (h : BoundedAtFilter atTop (shift u)) : BoundedAtFilter atTop u := by\n  simp only [BoundedAtFilter, isBigO_iff, eventually_atTop] at h \u22a2\n  obtain \u27e8C, N, hC\u27e9 := h\n  refine \u27e8C, N + 1, fun n hn => ?_\u27e9\n  simp only [shift] at hC\n  have r1 : n - 1 \u2265 N := Nat.le_sub_one_of_lt hn\n  have r2 : n - 1 + 1 = n := Nat.sub_add_cancel <| NeZero.one_le.trans hn.le\n  simpa [r2] using hC (n - 1) r1\n\nlemma dirichlet_test' {a b : \u2115 \u2192 \u211d} (ha : 0 \u2264 a) (hb : 0 \u2264 b)\n    (hAb : BoundedAtFilter atTop (shift (cumsum a) * b)) (hbb : \u2200\u1da0 n in atTop, b (n + 1) \u2264 b n)\n    (h : Summable (shift (cumsum a) * nnabla b)) : Summable (a * b) := by\n  have l1 : \u2200\u1da0 n in atTop, 0 \u2264 (shift (cumsum a) * nnabla b) n := by\n    filter_upwards [hbb] with n hb\n    exact mul_nonneg (by simpa [shift] using Finset.sum_nonneg' ha) (sub_nonneg.mpr hb)\n  rw [summable_iff_bounded (mul_nonneg ha hb)]\n  rw [summable_iff_bounded' l1] at h\n  apply bounded_of_shift\n  simpa only [summation_by_parts'', sub_eq_add_neg, neg_cumsum, \u2190 mul_neg, neg_nabla] using hAb.add h\n\nlemma exists_antitone_of_eventually {u : \u2115 \u2192 \u211d} (hu : \u2200\u1da0 n in atTop, u (n + 1) \u2264 u n) :\n    \u2203 v : \u2115 \u2192 \u211d, range v \u2286 range u \u2227 Antitone v \u2227 v =\u1da0[atTop] u := by\n  obtain \u27e8N, hN\u27e9 := eventually_atTop.mp hu\n  let v (n : \u2115) := u (if n < N then N else n)\n  refine \u27e8v, ?_, ?_, ?_\u27e9\n  \u00b7 exact fun x \u27e8n, hn\u27e9 => \u27e8if n < N then N else n, hn\u27e9\n  \u00b7 refine antitone_nat_of_succ_le (fun n => ?_)\n    by_cases h : n < N\n    \u00b7 by_cases h' : n + 1 < N <;> simp [v, h, h']\n      have : n + 1 = N := by linarith\n      simp [this]\n    \u00b7 have : \u00ac(n + 1 < N) := by linarith\n      simp [v, h, this] ; apply hN ; linarith\n  \u00b7 have : \u2200\u1da0 n in atTop, \u00ac(n < N) := by simpa using \u27e8N, fun b hb => by linarith\u27e9\n    filter_upwards [this] with n hn ; simp [v, hn]\n\nlemma summable_inv_mul_log_sq : Summable (fun n : \u2115 => (n * (Real.log n) ^ 2)\u207b\u00b9) := by\n  let u (n : \u2115) := (n * (Real.log n) ^ 2)\u207b\u00b9\n  have l7 : \u2200\u1da0 n : \u2115 in atTop, 1 \u2264 Real.log n := tendsto_atTop.mp (tendsto_log_atTop.comp tendsto_natCast_atTop_atTop) 1\n  have l8 : \u2200\u1da0 n : \u2115 in atTop, 1 \u2264 n := eventually_ge_atTop 1\n  have l9 : \u2200\u1da0 n in atTop, u (n + 1) \u2264 u n := by filter_upwards [l7, l8] with n l2 l8 ; dsimp [u] ; gcongr <;> simp\n  obtain \u27e8v, l1, l2, l3\u27e9 := exists_antitone_of_eventually l9\n  rw [summable_congr_ae l3.symm]\n  have l4 (n : \u2115) : 0 \u2264 v n := by obtain \u27e8k, hk\u27e9 := l1 \u27e8n, rfl\u27e9 ; rw [\u2190 hk] ; positivity\n  apply (summable_condensed_iff_of_nonneg l4 (fun _ _ _ a \u21a6 l2 a)).mp\n  suffices this : \u2200\u1da0 k : \u2115 in atTop, 2 ^ k * v (2 ^ k) = ((k : \u211d) ^ 2)\u207b\u00b9 * ((Real.log 2) ^ 2)\u207b\u00b9 by\n    exact (summable_congr_ae this).mpr <| (Real.summable_nat_pow_inv.mpr one_lt_two).mul_right _\n  have l5 : \u2200\u1da0 k in atTop, v (2 ^ k) = u (2 ^ k) := l3.comp_tendsto <| Nat.tendsto_pow_atTop_atTop_of_one_lt Nat.le.refl\n  filter_upwards [l5, l8] with k l5 l8 ; field_simp [u, l5] ; ring\n\nlemma tendsto_mul_add_atTop {a : \u211d} (ha : 0 < a) (b : \u211d) : Tendsto (fun x => a * x + b) atTop atTop :=\n  tendsto_atTop_add_const_right  _ b (tendsto_id.const_mul_atTop ha)\n\nlemma isLittleO_const_of_tendsto_atTop {\u03b1 : Type*} [Preorder \u03b1] (a : \u211d) {f : \u03b1 \u2192 \u211d} (hf : Tendsto f atTop atTop) :\n    (fun _ => a) =o[atTop] f := by\n  simp [tendsto_norm_atTop_atTop.comp hf]\n\nlemma isBigO_pow_pow_of_le {m n : \u2115} (h : m \u2264 n) : (fun x : \u211d => x ^ m) =O[atTop] (fun x : \u211d => x ^ n) := by\n  apply IsBigO.of_bound 1\n  filter_upwards [eventually_ge_atTop 1] with x l1\n  simpa [abs_eq_self.mpr (zero_le_one.trans l1)] using pow_le_pow_right\u2080 l1 h\n\nlemma isLittleO_mul_add_sq (a b : \u211d) : (fun x => a * x + b) =o[atTop] (fun x => x ^ 2) := by\n  apply IsLittleO.add\n  \u00b7 apply IsLittleO.const_mul_left ; simpa using isLittleO_pow_pow_atTop_of_lt (\ud835\udd5c := \u211d) one_lt_two\n  \u00b7 apply isLittleO_const_of_tendsto_atTop _ <| tendsto_pow_atTop (by linarith)\n\nlemma log_mul_add_isBigO_log {a : \u211d} (ha : 0 < a) (b : \u211d) : (fun x => Real.log (a * x + b)) =O[atTop] Real.log := by\n  apply IsBigO.of_bound (2 : \u2115)\n  have l2 : \u2200\u1da0 x : \u211d in atTop, 0 \u2264 log x := tendsto_atTop.mp tendsto_log_atTop 0\n  have l3 : \u2200\u1da0 x : \u211d in atTop, 0 \u2264 log (a * x + b) :=\n    tendsto_atTop.mp (tendsto_log_atTop.comp (tendsto_mul_add_atTop ha b)) 0\n  have l5 : \u2200\u1da0 x : \u211d in atTop, 1 \u2264 a * x + b := tendsto_atTop.mp (tendsto_mul_add_atTop ha b) 1\n  have l1 : \u2200\u1da0 x : \u211d in atTop, a * x + b \u2264 x ^ 2 := by\n    filter_upwards [(isLittleO_mul_add_sq a b).eventuallyLE, l5] with x r2 l5\n    simpa [abs_eq_self.mpr (zero_le_one.trans l5)] using r2\n  filter_upwards [l1, l2, l3, l5] with x l1 l2 l3 l5\n  simpa [abs_eq_self.mpr l2, abs_eq_self.mpr l3, Real.log_pow] using Real.log_le_log (by linarith) l1\n\nlemma isBigO_log_mul_add {a : \u211d} (ha : 0 < a) (b : \u211d) : Real.log =O[atTop] (fun x => Real.log (a * x + b)) := by\n  convert (log_mul_add_isBigO_log (b := -b / a) (inv_pos.mpr ha)).comp_tendsto (tendsto_mul_add_atTop (b := b) ha) using 1\n  ext x\n  field_simp [ha.ne.symm]\n\nlemma log_isbigo_log_div {d : \u211d} (hb : 0 < d) : (fun n \u21a6 Real.log n) =O[atTop] (fun n \u21a6 Real.log (n / d)) := by\n  convert isBigO_log_mul_add (inv_pos.mpr hb) 0 using 1 ; field_simp\n\nlemma Asymptotics.IsBigO.add_isLittleO_right {f g : \u211d \u2192 \u211d} (h : g =o[atTop] f) : f =O[atTop] (f + g) := by\n  rw [isLittleO_iff] at h ; specialize h (c := 2\u207b\u00b9) (by norm_num)\n  rw [isBigO_iff''] ; refine \u27e82\u207b\u00b9, by norm_num, ?_\u27e9 ; filter_upwards [h] with x h ; simp at h \u22a2\n  calc _ = |f x| - 2\u207b\u00b9 * |f x| := by ring\n       _ \u2264 |f x| - |g x| := by linarith\n       _ \u2264 |(|f x| - |g x|)| := le_abs_self _\n       _ \u2264 _ := by rw [\u2190 sub_neg_eq_add, \u2190 abs_neg (g x)] ; exact abs_abs_sub_abs_le (f x) (-g x)\n\nlemma Asymptotics.IsBigO.sq {\u03b1 : Type*} [Preorder \u03b1] {f g : \u03b1 \u2192 \u211d} (h : f =O[atTop] g) :\n    (fun n \u21a6 f n ^ 2) =O[atTop] (fun n => g n ^ 2) := by\n  simpa [pow_two] using h.mul h\n\nlemma log_sq_isbigo_mul {a b : \u211d} (hb : 0 < b) :\n    (fun x \u21a6 Real.log x ^ 2) =O[atTop] (fun x \u21a6 a + Real.log (x / b) ^ 2) := by\n  apply (log_isbigo_log_div hb).sq.trans ; simp_rw [add_comm a]\n  refine IsBigO.add_isLittleO_right <| isLittleO_const_of_tendsto_atTop _ ?_\n  exact (tendsto_pow_atTop (two_ne_zero)).comp <| tendsto_log_atTop.comp <| tendsto_id.atTop_div_const hb\n\ntheorem log_add_div_isBigO_log (a : \u211d) {b : \u211d} (hb : 0 < b) :\n    (fun x \u21a6 Real.log ((x + a) / b)) =O[atTop] fun x \u21a6 Real.log x := by\n  convert log_mul_add_isBigO_log (inv_pos.mpr hb) (a / b) using 3 ; ring\n\nlemma log_add_one_sub_log_le {x : \u211d} (hx : 0 < x) : nabla Real.log x \u2264 x\u207b\u00b9 := by\n  have l1 : ContinuousOn Real.log (Icc x (x + 1)) := by\n    apply continuousOn_log.mono ; intro t \u27e8h1, _\u27e9 ; simp ; linarith\n  have l2 t (ht : t \u2208 Ioo x (x + 1)) : HasDerivAt Real.log t\u207b\u00b9 t := Real.hasDerivAt_log (by linarith [ht.1])\n  obtain \u27e8t, \u27e8ht1, _\u27e9, htx\u27e9 := exists_hasDerivAt_eq_slope Real.log (\u00b7\u207b\u00b9) (by linarith) l1 l2\n  simp at htx ; rw [nabla, \u2190 htx, inv_le_inv\u2080 (by linarith) hx] ; linarith\n\nlemma nabla_log_main : nabla Real.log =O[atTop] fun x \u21a6 1 / x := by\n  apply IsBigO.of_bound 1\n  filter_upwards [eventually_gt_atTop 0] with x l1\n  have l2 : log x \u2264 log (x + 1) := log_le_log l1 (by linarith)\n  simpa [nabla, abs_eq_self.mpr l1.le, abs_eq_self.mpr (sub_nonneg.mpr l2)] using log_add_one_sub_log_le l1\n\nlemma nabla_log {b : \u211d} (hb : 0 < b) :\n    nabla (fun x => Real.log (x / b)) =O[atTop] (fun x => 1 / x) := by\n  refine EventuallyEq.trans_isBigO ?_ nabla_log_main\n  filter_upwards [eventually_gt_atTop 0] with x l2\n  rw [nabla, log_div (by linarith) (by linarith), log_div l2.ne.symm (by linarith), nabla] ; ring\n\nlemma nnabla_mul_log_sq (a : \u211d) {b : \u211d} (hb : 0 < b) :\n    nabla (fun x => x * (a + Real.log (x / b) ^ 2)) =O[atTop] (fun x => Real.log x ^ 2) := by\n\n  have l1 : nabla (fun n => n * (a + Real.log (n / b) ^ 2)) = fun n =>\n      a + Real.log ((n + 1) / b) ^ 2 + (n * (Real.log ((n + 1) / b) ^ 2 - Real.log (n / b) ^ 2)) := by\n    ext n ; simp [nabla] ; ring\n  have l2 := (isLittleO_const_of_tendsto_atTop a ((tendsto_pow_atTop two_ne_zero).comp tendsto_log_atTop)).isBigO\n  have l3 := (log_add_div_isBigO_log 1 hb).sq\n  have l4 : (fun x => Real.log ((x + 1) / b) + Real.log (x / b)) =O[atTop] Real.log := by\n    simpa using (log_add_div_isBigO_log _ hb).add (log_add_div_isBigO_log 0 hb)\n  have e2 : (fun x : \u211d => x * (Real.log x * (1 / x))) =\u1da0[atTop] Real.log := by\n    filter_upwards [eventually_ge_atTop 1] with x hx using by field_simp\n  have l5 : (fun n \u21a6 n * (Real.log n * (1 / n))) =O[atTop] (fun n \u21a6 (Real.log n) ^ 2) :=\n    e2.trans_isBigO (by simpa using (isLittleO_mul_add_sq 1 0).isBigO.comp_tendsto Real.tendsto_log_atTop)\n\n  simp_rw [l1, _root_.sq_sub_sq]\n  exact ((l2.add l3).add (isBigO_refl (\u00b7) atTop |>.mul (l4.mul (nabla_log hb)) |>.trans l5))\n\nlemma nnabla_bound_aux1 (a : \u211d) {b : \u211d} (hb : 0 < b) : Tendsto (fun x => x * (a + Real.log (x / b) ^ 2)) atTop atTop :=\n  tendsto_id.atTop_mul_atTop <| tendsto_atTop_add_const_left _ _ <| (tendsto_pow_atTop two_ne_zero).comp <|\n    tendsto_log_atTop.comp <| tendsto_id.atTop_div_const hb\n\nlemma nnabla_bound_aux2 (a : \u211d) {b : \u211d} (hb : 0 < b) : \u2200\u1da0 x in atTop, 0 < x * (a + Real.log (x / b) ^ 2) :=\n  (nnabla_bound_aux1 a hb).eventually (eventually_gt_atTop 0)\n\nlemma nnabla_bound_aux {x : \u211d} (hx : 0 < x) :\n    nnabla (fun n \u21a6 1 / (n * ((2 * \u03c0) ^ 2 + Real.log (n / x) ^ 2))) =O[atTop]\n    (fun n \u21a6 1 / (Real.log n ^ 2 * n ^ 2)) := by\n\n  let d n : \u211d := n * ((2 * \u03c0) ^ 2 + Real.log (n / x) ^ 2)\n  change (fun x_1 \u21a6 nnabla (fun n \u21a6 1 / d n) x_1) =O[atTop] _\n\n  have l2 : \u2200\u1da0 n in atTop, 0 < d n := (nnabla_bound_aux2 ((2 * \u03c0) ^ 2) hx)\n  have l3 : \u2200\u1da0 n in atTop, 0 < d (n + 1) :=\n    (tendsto_atTop_add_const_right atTop (1 : \u211d) tendsto_id).eventually l2\n  have l1 : \u2200\u1da0 n : \u211d in atTop, nnabla (fun n \u21a6 1 / d n) n = (d (n + 1) - d n) * (d n)\u207b\u00b9 * (d (n + 1))\u207b\u00b9 := by\n    filter_upwards [l2, l3] with n l2 l3\n    rw [nnabla, one_div, one_div, inv_sub_inv l2.ne.symm l3.ne.symm, div_eq_mul_inv, mul_inv, mul_assoc]\n\n  have l4 : (fun n => (d n)\u207b\u00b9) =O[atTop] (fun n => (n * (Real.log n) ^ 2)\u207b\u00b9) := by\n    apply IsBigO.inv_rev\n    \u00b7 refine (isBigO_refl _ _).mul <| (log_sq_isbigo_mul (by linarith))\n    \u00b7 apply eventually_of_mem (Ici_mem_atTop 2) ; intro n (hn : 2 \u2264 n)\n      have e1 : n \u2260 0 := by linarith\n      have e2 : n \u2260 1 := by linarith\n      have e3 : n \u2260 -1 := by linarith\n      simp [e1, e2, e3]\n\n  have l5 : (fun n => (d (n + 1))\u207b\u00b9) =O[atTop] (fun n => (n * (Real.log n) ^ 2)\u207b\u00b9) := by\n    refine IsBigO.trans ?_ l4\n    rw [isBigO_iff] ; use 1\n    have e1 : \u2200\u1da0 n in atTop, 0 < d n := by\n      apply eventually_of_mem (Ici_mem_atTop 1) ; intro n (hn : 1 \u2264 n)\n      have r1 : 0 < n := by linarith\n      have r2 : 0 < (2 * \u03c0) ^ 2 := by apply sq_pos_of_ne_zero ; norm_num [pi_ne_zero]\n      have r3 : 0 \u2264 Real.log (\u2191n / x) ^ 2 := sq_nonneg _\n      apply mul_pos r1 (by linarith)\n    have e2 : \u2200\u1da0 n in atTop, 0 < d (n + 1) := (tendsto_atTop_add_const_right atTop (1 : \u211d) tendsto_id).eventually e1\n    have e3 : \u2200\u1da0 n in atTop, d n \u2264 d (n + 1) := by\n      have : \u2200\u1da0 n in atTop, x \u2264 n := by simpa using eventually_ge_atTop x\n      filter_upwards [this] with n hn\n      have e2 : 1 \u2264 n / x := (one_le_div (by linarith)).mpr hn\n      have e3 : n \u2264 n + 1 := by linarith\n      have e4 : 0 \u2264 n + 1 := by linarith\n      dsimp [d]\n      gcongr\n      exact Real.log_nonneg e2\n    filter_upwards [e1, e2, e3] with n e1 e2 e3\n    simp_rw [one_mul, Real.norm_eq_abs, abs_inv, abs_eq_self.mpr e1.le, abs_eq_self.mpr e2.le, inv_le_inv\u2080 e2 e1]\n    exact e3\n\n  have l6 : (fun n => d (n + 1) - d n) =O[atTop] (fun n => (Real.log n) ^ 2) := by\n    simpa [d, nabla] using (nnabla_mul_log_sq ((2 * \u03c0) ^ 2) (by linarith))\n\n  apply EventuallyEq.trans_isBigO l1\n\n  apply ((l6.mul l4).mul l5).trans_eventuallyEq\n  apply eventually_of_mem (Ici_mem_atTop 2) ; intro n (hn : 2 \u2264 n)\n\n  have : Real.log n \u2260 0 := by\n    have e1 : n \u2260 0 := by linarith\n    have e2 : n \u2260 1 := by linarith\n    have e3 : n \u2260 -1 := by linarith\n    simp [e1, e2, e3]\n  field_simp ; ring\n\nlemma nnabla_bound (C : \u211d) {x : \u211d} (hx : 0 < x) :\n    nnabla (fun n => C / (1 + (Real.log (n / x) / (2 * \u03c0)) ^ 2) / n) =O[atTop]\n    (fun n => (n ^ 2 * (Real.log n) ^ 2)\u207b\u00b9) := by\n  field_simp\n  simp [div_eq_mul_inv]\n  apply IsBigO.const_mul_left\n  field_simp\n  exact nnabla_bound_aux hx\n\ndef chebyWith (C : \u211d) (f : \u2115 \u2192 \u2102) : Prop := \u2200 n, cumsum (\u2016f \u00b7\u2016) n \u2264 C * n\n\ndef cheby (f : \u2115 \u2192 \u2102) : Prop := \u2203 C, chebyWith C f\n\nlemma cheby.bigO (h : cheby f) : cumsum (\u2016f \u00b7\u2016) =O[atTop] ((\u2191) : \u2115 \u2192 \u211d) := by\n  have l1 : 0 \u2264 cumsum (\u2016f \u00b7\u2016) := cumsum_nonneg (fun _ => norm_nonneg _)\n  obtain \u27e8C, hC\u27e9 := h\n  apply isBigO_of_le' (c := C) atTop\n  intro n\n  rw [Real.norm_eq_abs, abs_eq_self.mpr (l1 n)]\n  simpa using hC n\n\nlemma limiting_fourier_lim1_aux (hcheby : cheby f) (hx : 0 < x) (C : \u211d) (hC : 0 \u2264 C) :\n    Summable fun n \u21a6 \u2016f n\u2016 / \u2191n * (C / (1 + (1 / (2 * \u03c0) * Real.log (\u2191n / x)) ^ 2)) := by\n\n  let a (n : \u2115) := (C / (1 + (Real.log (\u2191n / x) / (2 * \u03c0)) ^ 2) / \u2191n)\n  replace hcheby := hcheby.bigO\n\n  have l1 : shift (cumsum (\u2016f \u00b7\u2016)) =O[atTop] (fun n : \u2115 => (\u2191(n + 1) : \u211d)) :=\n    hcheby.comp_tendsto <| tendsto_add_atTop_nat 1\n  have l2 : shift (cumsum (\u2016f \u00b7\u2016)) =O[atTop] (fun n => (n : \u211d)) :=\n    l1.trans (by simpa using (isBigO_refl _ _).add <| isBigO_iff.mpr \u27e81, by simpa using \u27e81, by tauto\u27e9\u27e9)\n  have l5 : BoundedAtFilter atTop (fun n : \u2115 => C / (1 + (Real.log (\u2191n / x) / (2 * \u03c0)) ^ 2)) := by\n    field_simp [BoundedAtFilter]\n    apply isBigO_of_le' (c := C) ; intro n\n    have : 0 \u2264 (2 * \u03c0) ^ 2 + Real.log (n / x) ^ 2 := by positivity\n    simp [abs_eq_self.mpr hC, abs_eq_self.mpr pi_nonneg, abs_eq_self.mpr this]\n    apply div_le_of_le_mul\u2080 this hC\n    gcongr\n    apply le_add_of_le_of_nonneg le_rfl (sq_nonneg _)\n  have l3 : a =O[atTop] (fun n => 1 / (n : \u211d)) := by\n    simpa [a] using IsBigO.mul l5 (isBigO_refl (fun n : \u2115 => 1 / (n : \u211d)) _)\n  have l4 : nnabla a =O[atTop] (fun n : \u2115 => (n ^ 2 * (Real.log n) ^ 2)\u207b\u00b9) := by\n    convert (nnabla_bound C hx).natCast ; simp [nnabla, a]\n\n  simp_rw [div_mul_eq_mul_div, mul_div_assoc, one_mul]\n  apply dirichlet_test'\n  \u00b7 intro n ; exact norm_nonneg _\n  \u00b7 intro n ; positivity\n  \u00b7 apply (l2.mul l3).trans_eventuallyEq\n    apply eventually_of_mem (Ici_mem_atTop 1)\n    intro x (hx : 1 \u2264 x)\n    have : x \u2260 0 := by linarith\n    simp [this]\n  \u00b7 have : \u2200\u1da0 n : \u2115 in atTop, x \u2264 n := by simpa using eventually_ge_atTop \u2308x\u2309\u208a\n    filter_upwards [this] with n hn\n    have e1 : 0 < (n : \u211d) := by linarith\n    have e2 : 1 \u2264 n / x := (one_le_div (by linarith)).mpr hn\n    have e3 := Nat.le_succ n\n    gcongr\n    refine div_nonneg (Real.log_nonneg e2) (by norm_num [pi_nonneg])\n  \u00b7 apply summable_of_isBigO_nat summable_inv_mul_log_sq\n    apply (l2.mul l4).trans_eventuallyEq\n    apply eventually_of_mem (Ici_mem_atTop 2)\n    intro x (hx : 2 \u2264 x)\n    have : (x : \u211d) \u2260 0 := by simp ; linarith\n    have : Real.log x \u2260 0 := by\n      have ll : 2 \u2264 (x : \u211d) := by simp [hx]\n      simp only [ne_eq, log_eq_zero]\n      push_neg\n      refine \u27e8this, ?_, ?_\u27e9 <;> linarith\n    field_simp ; ring\n\ntheorem limiting_fourier_lim1 (hcheby : cheby f) (\u03c8 : W21) (hx : 0 < x) :\n    Tendsto (fun \u03c3' : \u211d \u21a6 \u2211' n, term f \u03c3' n * \ud835\udcd5 \u03c8 (1 / (2 * \u03c0) * Real.log (n / x))) (\ud835\udcdd[>] 1)\n      (\ud835\udcdd (\u2211' n, f n / n * \ud835\udcd5 \u03c8 (1 / (2 * \u03c0) * Real.log (n / x)))) := by\n\n  obtain \u27e8C, hC\u27e9 := decay_bounds_cor \u03c8\n  have : 0 \u2264 C := by simpa using (norm_nonneg _).trans (hC 0)\n  refine tendsto_tsum_of_dominated_convergence (limiting_fourier_lim1_aux hcheby hx C this) (fun n => ?_) ?_\n  \u00b7 apply Tendsto.mul_const\n    by_cases h : n = 0 <;> simp [term, h]\n    refine tendsto_const_nhds.div ?_ (by simp [h])\n    simpa using ((continuous_ofReal.tendsto 1).mono_left nhdsWithin_le_nhds).const_cpow\n  \u00b7 rw [eventually_nhdsWithin_iff]\n    apply Eventually.of_forall\n    intro \u03c3' (h\u03c3' : 1 < \u03c3') n\n    rw [norm_mul, \u2190 nterm_eq_norm_term]\n    refine mul_le_mul ?_ (hC _) (norm_nonneg _) (div_nonneg (norm_nonneg _) (Nat.cast_nonneg _))\n    by_cases h : n = 0 <;> simp [h, nterm]\n    have : 1 \u2264 (n : \u211d) := by simpa using Nat.pos_iff_ne_zero.mpr h\n    refine div_le_div\u2080 (by simp only [apply_nonneg]) le_rfl (by simpa [Nat.pos_iff_ne_zero]) ?_\n    simpa using Real.rpow_le_rpow_of_exponent_le this h\u03c3'.le\n\ntheorem limiting_fourier_lim2_aux (x : \u211d) (C : \u211d) :\n    Integrable (fun t \u21a6 |x| * (C / (1 + (t / (2 * \u03c0)) ^ 2))) (Measure.restrict volume (Ici (-Real.log x))) := by\n  simp_rw [div_eq_mul_inv C]\n  exact (((integrable_inv_one_add_sq.comp_div (by simp [pi_ne_zero])).const_mul _).const_mul _).restrict\n\ntheorem limiting_fourier_lim2 (A : \u211d) (\u03c8 : W21) (hx : 1 \u2264 x) :\n    Tendsto (fun \u03c3' \u21a6 A * \u2191(x ^ (1 - \u03c3')) * \u222b u in Ici (-Real.log x), rexp (-u * (\u03c3' - 1)) * \ud835\udcd5 \u03c8 (u / (2 * \u03c0)))\n      (\ud835\udcdd[>] 1) (\ud835\udcdd (A * \u222b u in Ici (-Real.log x), \ud835\udcd5 \u03c8 (u / (2 * \u03c0)))) := by\n\n  obtain \u27e8C, hC\u27e9 := decay_bounds_cor \u03c8\n  apply Tendsto.mul\n  \u00b7 suffices h : Tendsto (fun \u03c3' : \u211d \u21a6 ofReal (x ^ (1 - \u03c3'))) (\ud835\udcdd[>] 1) (\ud835\udcdd 1) by simpa using h.const_mul \u2191A\n    suffices h : Tendsto (fun \u03c3' : \u211d \u21a6 x ^ (1 - \u03c3')) (\ud835\udcdd[>] 1) (\ud835\udcdd 1) from (continuous_ofReal.tendsto 1).comp h\n    have : Tendsto (fun \u03c3' : \u211d \u21a6 \u03c3') (\ud835\udcdd 1) (\ud835\udcdd 1) := fun _ a \u21a6 a\n    have : Tendsto (fun \u03c3' : \u211d \u21a6 1 - \u03c3') (\ud835\udcdd[>] 1) (\ud835\udcdd 0) :=\n      tendsto_nhdsWithin_of_tendsto_nhds (by simpa using this.const_sub 1)\n    simpa using tendsto_const_nhds.rpow this (Or.inl (zero_lt_one.trans_le hx).ne.symm)\n  \u00b7 refine tendsto_integral_filter_of_dominated_convergence _ ?_ ?_ (limiting_fourier_lim2_aux x C) ?_\n    \u00b7 apply Eventually.of_forall ; intro \u03c3'\n      apply Continuous.aestronglyMeasurable\n      have := continuous_FourierIntegral \u03c8\n      continuity\n    \u00b7 apply eventually_of_mem (U := Ioo 1 2)\n      \u00b7 apply Ioo_mem_nhdsWithin_Ioi ; simp\n      \u00b7 intro \u03c3' \u27e8h1, h2\u27e9\n        rw [ae_restrict_iff' measurableSet_Ici]\n        apply Eventually.of_forall\n        intro t (ht : - Real.log x \u2264 t)\n        rw [norm_mul]\n        refine mul_le_mul ?_ (hC _) (norm_nonneg _) (abs_nonneg _)\n        simp [Complex.abs_exp]\n        have : -Real.log x * (\u03c3' - 1) \u2264 t * (\u03c3' - 1) := mul_le_mul_of_nonneg_right ht (by linarith)\n        have : -(t * (\u03c3' - 1)) \u2264 Real.log x * (\u03c3' - 1) := by simpa using neg_le_neg this\n        have := Real.exp_monotone this\n        apply this.trans\n        have l1 : \u03c3' - 1 \u2264 1 := by linarith\n        have : 0 \u2264 Real.log x := Real.log_nonneg hx\n        have := mul_le_mul_of_nonneg_left l1 this\n        apply (Real.exp_monotone this).trans\n        simp [Real.exp_log (zero_lt_one.trans_le hx), abs_eq_self.mpr (zero_le_one.trans hx)]\n    \u00b7 apply Eventually.of_forall\n      intro x\n      suffices h : Tendsto (fun n \u21a6 ((rexp (-x * (n - 1))) : \u2102)) (\ud835\udcdd[>] 1) (\ud835\udcdd 1) by simpa using h.mul_const _\n      apply Tendsto.mono_left ?_ nhdsWithin_le_nhds\n      suffices h : Continuous (fun n \u21a6 ((rexp (-x * (n - 1))) : \u2102)) by simpa using h.tendsto 1\n      continuity\n\ntheorem limiting_fourier_lim3 (hG : ContinuousOn G {s | 1 \u2264 s.re}) (\u03c8 : CS 2 \u2102) (hx : 1 \u2264 x) :\n    Tendsto (fun \u03c3' : \u211d \u21a6 \u222b t : \u211d, G (\u03c3' + t * I) * \u03c8 t * x ^ (t * I)) (\ud835\udcdd[>] 1)\n      (\ud835\udcdd (\u222b t : \u211d, G (1 + t * I) * \u03c8 t * x ^ (t * I))) := by\n\n  by_cases hh : tsupport \u03c8 = \u2205 ; simp [tsupport_eq_empty_iff.mp hh]\n  obtain \u27e8a\u2080, ha\u2080\u27e9 := Set.nonempty_iff_ne_empty.mpr hh\n\n  let S : Set \u2102 := Set.reProdIm (Icc 1 2) (tsupport \u03c8)\n  have l1 : IsCompact S := by\n    refine Metric.isCompact_iff_isClosed_bounded.mpr \u27e8?_, ?_\u27e9\n    \u00b7 exact isClosed_Icc.reProdIm (isClosed_tsupport \u03c8)\n    \u00b7 exact (Metric.isBounded_Icc 1 2).reProdIm \u03c8.h2.isBounded\n  have l2 : S \u2286 {s : \u2102 | 1 \u2264 s.re} := fun z hz => (mem_reProdIm.mp hz).1.1\n  have l3 : ContinuousOn (\u2016G \u00b7\u2016) S := (hG.mono l2).norm\n  have l4 : S.Nonempty := \u27e81 + a\u2080 * I, by simp [S, mem_reProdIm, ha\u2080]\u27e9\n  obtain \u27e8z, -, hmax\u27e9 := l1.exists_isMaxOn l4 l3\n  let MG := \u2016G z\u2016\n  let bound (a : \u211d) : \u211d := MG * \u2016\u03c8 a\u2016\n\n  apply tendsto_integral_filter_of_dominated_convergence (bound := bound)\n  \u00b7 apply eventually_of_mem (U := Icc 1 2) (Icc_mem_nhdsWithin_Ioi (by simp)) ; intro u hu\n    apply Continuous.aestronglyMeasurable\n    apply Continuous.mul\n    \u00b7 exact (hG.comp_continuous (by fun_prop) (by simp [hu.1])).mul \u03c8.h1.continuous\n    \u00b7 apply Continuous.const_cpow (by fun_prop) ; simp ; linarith\n  \u00b7 apply eventually_of_mem (U := Icc 1 2) (Icc_mem_nhdsWithin_Ioi (by simp))\n    intro u hu\n    apply Eventually.of_forall ; intro v\n    by_cases h : v \u2208 tsupport \u03c8\n    \u00b7 have r1 : u + v * I \u2208 S := by simp [S, mem_reProdIm, hu.1, hu.2, h]\n      have r2 := isMaxOn_iff.mp hmax _ r1\n      have r4 : (x : \u2102) \u2260 0 := by simp ; linarith\n      have r5 : arg x = 0 := by simp [arg_eq_zero_iff] ; linarith\n      have r3 : \u2016(x : \u2102) ^ (v * I)\u2016 = 1 := by simp [abs_cpow_of_ne_zero r4, r5]\n      simp_rw [norm_mul, r3, mul_one]\n      exact mul_le_mul_of_nonneg_right r2 (norm_nonneg _)\n    \u00b7 have : v \u2209 Function.support \u03c8 := fun a \u21a6 h (subset_tsupport \u03c8 a)\n      simp at this ; simp [this, bound]\n\n  \u00b7 suffices h : Continuous bound by exact h.integrable_of_hasCompactSupport \u03c8.h2.norm.mul_left\n    have := \u03c8.h1.continuous ; fun_prop\n  \u00b7 apply Eventually.of_forall ; intro t\n    apply Tendsto.mul_const\n    apply Tendsto.mul_const\n    refine (hG (1 + t * I) (by simp)).tendsto.comp <| tendsto_nhdsWithin_iff.mpr \u27e8?_, ?_\u27e9\n    \u00b7 exact ((continuous_ofReal.tendsto _).add tendsto_const_nhds).mono_left nhdsWithin_le_nhds\n    \u00b7 exact eventually_nhdsWithin_of_forall (fun x (hx : 1 < x) => by simp [hx.le])\n\n\ntheorem limiting_fourier_lim2_aux (x : \u211d) (C : \u211d) :\n    Integrable (fun t \u21a6 |x| * (C / (1 + (t / (2 * \u03c0)) ^ 2))) (Measure.restrict volume (Ici (-Real.log x)))  := by\n  exact ((integrable_inv_one_add_sq.comp_div (by norm_num [pi_ne_zero])).const_mul _)\n", "allTactics": true, "theorems": true, "env": 0}