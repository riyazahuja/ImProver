[{"idx": 73, "error": "repl output/thms mismatch in length\n\nlen:3\n\n{\"env\": 0}\n\n\n\nPANIC at List.head! Init.Data.List.BasicAux:62:12: empty list\nuncaught exception: unknown metavariable '?[anonymous]'\n"}, {"idx": 73, "error": "repl output/thms mismatch in length\n\nlen:3\n\n{\"env\": 0}\n\n{\"theorems\":\n [{\"tactics\": [0],\n   \"start\": {\"line\": 1, \"column\": 0},\n   \"proofTree\":\n   [{\"tactic\": \"rw [ack]\", \"spawned_children\": [], \"children\": [1]},\n    {\"tactic\": \"rw [rfl]\", \"spawned_children\": [], \"children\": []}],\n   \"messages\": [],\n   \"end\": {\"line\": 2, \"column\": 57},\n   \"decl\": \"@[simp]\\ntheorem ack_zero (n : \u2115) : ack 0 n = n + 1 \"},\n  {\"tactics\": [1],\n   \"start\": {\"line\": 5, \"column\": 0},\n   \"proofTree\":\n   [{\"tactic\": \"rw [ack]\", \"spawned_children\": [], \"children\": [1]},\n    {\"tactic\": \"rw [rfl]\", \"spawned_children\": [], \"children\": []}],\n   \"messages\": [],\n   \"end\": {\"line\": 6, \"column\": 70},\n   \"decl\": \"@[simp]\\ntheorem ack_succ_zero (m : \u2115) : ack (m + 1) 0 = ack m 1 \"},\n  {\"tactics\": [2],\n   \"start\": {\"line\": 9, \"column\": 0},\n   \"proofTree\":\n   [{\"tactic\": \"rw [ack]\", \"spawned_children\": [], \"children\": [1]},\n    {\"tactic\": \"rw [rfl]\", \"spawned_children\": [], \"children\": []}],\n   \"messages\": [],\n   \"end\": {\"line\": 10, \"column\": 92},\n   \"decl\":\n   \"@[simp]\\ntheorem ack_succ_succ (m n : \u2115) : ack (m + 1) (n + 1) = ack m (ack (m + 1) n) \"},\n  {\"tactics\": [3, 4, 5],\n   \"start\": {\"line\": 13, \"column\": 0},\n   \"proofTree\":\n   [{\"tactic\": \"induction' n with n IH\",\n     \"spawned_children\": [],\n     \"children\": [1, 2]},\n    {\"tactic\": \"rfl\", \"spawned_children\": [], \"children\": []},\n    {\"tactic\": \"simp [IH]\", \"spawned_children\": [], \"children\": []}],\n   \"messages\": [],\n   \"end\": {\"line\": 17, \"column\": 13},\n   \"decl\": \"@[simp]\\ntheorem ack_one (n : \u2115) : ack 1 n = n + 2 \"},\n  {\"tactics\": [6, 7, 8],\n   \"start\": {\"line\": 20, \"column\": 0},\n   \"proofTree\":\n   [{\"tactic\": \"induction' n with n IH\",\n     \"spawned_children\": [],\n     \"children\": [1, 2]},\n    {\"tactic\": \"rfl\", \"spawned_children\": [], \"children\": []},\n    {\"tactic\": \"simpa [mul_succ]\", \"spawned_children\": [], \"children\": []}],\n   \"messages\": [],\n   \"end\": {\"line\": 24, \"column\": 20},\n   \"decl\": \"@[simp]\\ntheorem ack_two (n : \u2115) : ack 2 n = 2 * n + 3 \"},\n  {\"tactics\": [9, 10, 11, 12, 13, 14, 15, 16],\n   \"start\": {\"line\": 28, \"column\": 0},\n   \"proofTree\":\n   [{\"tactic\": \"induction' n with n IH\",\n     \"spawned_children\": [],\n     \"children\": [1, 2]},\n    {\"tactic\": \"rfl\", \"spawned_children\": [], \"children\": []},\n    {\"tactic\": \"rw [ack_succ_succ]\", \"spawned_children\": [], \"children\": [3]},\n    {\"tactic\": \"rw [IH]\", \"spawned_children\": [], \"children\": [4]},\n    {\"tactic\": \"rw [ack_two]\", \"spawned_children\": [], \"children\": [5]},\n    {\"tactic\": \"rw [Nat.succ_add]\", \"spawned_children\": [], \"children\": [6]},\n    {\"tactic\": \"rw [Nat.pow_succ 2 (n + 3)]\",\n     \"spawned_children\": [],\n     \"children\": [7]},\n    {\"tactic\": \"rw [mul_comm _ 2]\", \"spawned_children\": [], \"children\": [8]},\n    {\"tactic\": \"rw [Nat.mul_sub_left_distrib]\",\n     \"spawned_children\": [],\n     \"children\": [9]},\n    {\"tactic\": \"rw [\u2190 Nat.sub_add_comm]\",\n     \"spawned_children\": [],\n     \"children\": [10, 13]},\n    {\"tactic\": \"rw [two_mul 3]\", \"spawned_children\": [], \"children\": [11]},\n    {\"tactic\": \"rw [Nat.add_sub_add_right]\",\n     \"spawned_children\": [],\n     \"children\": [12]},\n    {\"tactic\": \"rw [rfl]\", \"spawned_children\": [], \"children\": []},\n    {\"tactic\": \"have H : 2 * 3 \u2264 2 * 2 ^ 3 := by norm_num\",\n     \"spawned_children\": [14],\n     \"children\": [14, 15]},\n    {\"tactic\": \"norm_num\", \"spawned_children\": [], \"children\": []},\n    {\"tactic\": \"apply H.trans\", \"spawned_children\": [], \"children\": [16]},\n    {\"tactic\": \"rw [_root_.mul_le_mul_left two_pos]\",\n     \"spawned_children\": [],\n     \"children\": [17]},\n    {\"tactic\": \"exact pow_le_pow_right one_le_two (Nat.le_add_left 3 n)\",\n     \"spawned_children\": [],\n     \"children\": []}],\n   \"messages\": [],\n   \"end\": {\"line\": 37, \"column\": 59},\n   \"decl\": \"@[simp]\\ntheorem ack_three (n : \u2115) : ack 3 n = 2 ^ (n + 3) - 3 \"},\n  {\"tactics\": [17, 18, 19, 20, 21],\n   \"start\": {\"line\": 40, \"column\": 0},\n   \"proofTree\":\n   [{\"tactic\": \"simp\", \"spawned_children\": [], \"children\": []},\n    {\"tactic\": \"rw [ack_succ_zero]\", \"spawned_children\": [], \"children\": [2]},\n    {\"tactic\": \"apply ack_pos\", \"spawned_children\": [], \"children\": []},\n    {\"tactic\": \"rw [ack_succ_succ]\", \"spawned_children\": [], \"children\": [4]},\n    {\"tactic\": \"apply ack_pos\", \"spawned_children\": [], \"children\": []}],\n   \"messages\": [],\n   \"end\": {\"line\": 47, \"column\": 17},\n   \"decl\":\n   \"theorem ack_pos : \u2200 m n, 0 < ack m n\\n  | 0, n => by simp\\n  | m + 1, 0 => by\\n    rw [ack_succ_zero]\\n    apply ack_pos\\n  | m + 1, n + 1 => by\\n    rw [ack_succ_succ]\\n    apply  ack_pos \"},\n  {\"tactics\": [22, 23, 24, 25, 26],\n   \"start\": {\"line\": 50, \"column\": 0},\n   \"proofTree\":\n   [{\"tactic\": \"simp\", \"spawned_children\": [], \"children\": []},\n    {\"tactic\": \"rw [ack_succ_zero]\", \"spawned_children\": [], \"children\": [2]},\n    {\"tactic\": \"apply one_lt_ack_succ_left\",\n     \"spawned_children\": [],\n     \"children\": []},\n    {\"tactic\": \"rw [ack_succ_succ]\", \"spawned_children\": [], \"children\": [4]},\n    {\"tactic\": \"apply one_lt_ack_succ_left\",\n     \"spawned_children\": [],\n     \"children\": []}],\n   \"messages\": [],\n   \"end\": {\"line\": 57, \"column\": 30},\n   \"decl\":\n   \"theorem one_lt_ack_succ_left : \u2200 m n, 1 < ack (m + 1) n\\n  | 0, n => by simp\\n  | m + 1, 0 => by\\n    rw [ack_succ_zero]\\n    apply one_lt_ack_succ_left\\n  | m + 1, n + 1 => by\\n    rw [ack_succ_succ]\\n    apply  one_lt_ack_succ_left \"},\n  {\"tactics\": [27, 28, 29, 30, 31],\n   \"start\": {\"line\": 60, \"column\": 0},\n   \"proofTree\":\n   [{\"tactic\": \"simp\", \"spawned_children\": [], \"children\": []},\n    {\"tactic\": \"rw [ack_succ_succ]\", \"spawned_children\": [], \"children\": [2]},\n    {\"tactic\":\n     \"cases' exists_eq_succ_of_ne_zero (ack_pos (m + 1) n).ne' with h h\",\n     \"spawned_children\": [],\n     \"children\": [3]},\n    {\"tactic\": \"rw [h]\", \"spawned_children\": [], \"children\": [4]},\n    {\"tactic\": \"apply one_lt_ack_succ_right\",\n     \"spawned_children\": [],\n     \"children\": []}],\n   \"messages\": [],\n   \"end\": {\"line\": 66, \"column\": 31},\n   \"decl\":\n   \"theorem one_lt_ack_succ_right : \u2200 m n, 1 < ack m (n + 1)\\n  | 0, n => by simp\\n  | m + 1, n => by\\n    rw [ack_succ_succ]\\n    cases' exists_eq_succ_of_ne_zero (ack_pos (m + 1) n).ne' with h h\\n    rw [h]\\n    apply  one_lt_ack_succ_right \"},\n  {\"tactics\": [32, 33, 34, 35, 36, 37],\n   \"start\": {\"line\": 69, \"column\": 0},\n   \"proofTree\":\n   [{\"tactic\": \"simpa using h\", \"spawned_children\": [], \"children\": []},\n    {\"tactic\": \"rw [ack_succ_zero]\", \"spawned_children\": [], \"children\": [2]},\n    {\"tactic\": \"rw [ack_succ_succ]\", \"spawned_children\": [], \"children\": [3]},\n    {\"tactic\": \"exact ack_strictMono_right _ (one_lt_ack_succ_left m n)\",\n     \"spawned_children\": [],\n     \"children\": []},\n    {\"tactic\": \"rw [ack_succ_succ]\", \"spawned_children\": [], \"children\": [5]},\n    {\"tactic\": \"rw [ack_succ_succ]\", \"spawned_children\": [], \"children\": [6]},\n    {\"tactic\": \"apply ack_strictMono_right _ (ack_strictMono_right _ _)\",\n     \"spawned_children\": [],\n     \"children\": [7]},\n    {\"tactic\": \"add_lt_add_iff_right\", \"spawned_children\": [], \"children\": []}],\n   \"messages\": [],\n   \"end\": {\"line\": 77, \"column\": 35},\n   \"decl\":\n   \"theorem ack_strictMono_right : \u2200 m, StrictMono (ack m)\\n  | 0, n\u2081, n\u2082, h => by simpa using h\\n  | m + 1, 0, n + 1, _h => by\\n    rw [ack_succ_zero, ack_succ_succ]\\n    exact ack_strictMono_right _ (one_lt_ack_succ_left m n)\\n  | m + 1, n\u2081 + 1, n\u2082 + 1, h => by\\n    rw [ack_succ_succ, ack_succ_succ]\\n    apply ack_strictMono_right _ (ack_strictMono_right _ _)\\n    rwa [add_lt_add_iff_right] at  h \"},\n  {\"tactics\": [38, 39, 40, 41, 42],\n   \"start\": {\"line\": 107, \"column\": 0},\n   \"proofTree\":\n   [{\"tactic\": \"simp\", \"spawned_children\": [], \"children\": []},\n    {\"tactic\": \"simpa using add_lt_ack m 1\",\n     \"spawned_children\": [],\n     \"children\": []},\n    {\"tactic\": \"omega\", \"spawned_children\": [], \"children\": []},\n    {\"tactic\": \"rw [succ_eq_add_one]\", \"spawned_children\": [], \"children\": [4]},\n    {\"tactic\": \"ring_nf\", \"spawned_children\": [], \"children\": []}],\n   \"messages\": [],\n   \"end\": {\"line\": 117, \"column\": 57},\n   \"decl\":\n   \"theorem add_lt_ack : \u2200 m n, m + n < ack m n\\n  | 0, n => by simp\\n  | m + 1, 0 => by simpa using add_lt_ack m 1\\n  | m + 1, n + 1 =>\\n    calc\\n      m + 1 + n + 1 \u2264 m + (m + n + 2) \"},\n  {\"tactics\": [43, 44, 45, 46, 47, 48, 49],\n   \"start\": {\"line\": 133, \"column\": 0},\n   \"proofTree\":\n   [{\"tactic\": \"simpa using one_lt_ack_succ_right m 0\",\n     \"spawned_children\": [],\n     \"children\": []},\n    {\"tactic\": \"rw [ack_zero]\", \"spawned_children\": [], \"children\": [2]},\n    {\"tactic\": \"rw [ack_succ_succ]\", \"spawned_children\": [], \"children\": [3]},\n    {\"tactic\":\n     \"apply lt_of_le_of_lt (le_trans _ <| add_le_add_left (add_add_one_le_ack _ _) m) (add_lt_ack _ _)\",\n     \"spawned_children\": [],\n     \"children\": [4]},\n    {\"tactic\": \"omega\", \"spawned_children\": [], \"children\": []},\n    {\"tactic\":\n     \"simpa using ack_strict_mono_left' 1 ((add_lt_add_iff_right 1).1 h)\",\n     \"spawned_children\": [],\n     \"children\": []},\n    {\"tactic\": \"rw [ack_succ_succ]\", \"spawned_children\": [], \"children\": [7]},\n    {\"tactic\": \"rw [ack_succ_succ]\", \"spawned_children\": [], \"children\": [8]},\n    {\"tactic\": \"exact\", \"spawned_children\": [], \"children\": []}],\n   \"messages\": [],\n   \"end\": {\"line\": 146, \"column\": 61},\n   \"decl\":\n   \"private theorem ack_strict_mono_left' : \u2200 {m\u2081 m\u2082} (n), m\u2081 < m\u2082 \u2192 ack m\u2081 n < ack m\u2082 n\\n  | m, 0, n => fun h => (not_lt_zero m h).elim\\n  | 0, m + 1, 0 => fun _h => by simpa using one_lt_ack_succ_right m 0\\n  | 0, m + 1, n + 1 => fun h => by\\n    rw [ack_zero, ack_succ_succ]\\n    apply lt_of_le_of_lt (le_trans _ <| add_le_add_left (add_add_one_le_ack _ _) m) (add_lt_ack _ _)\\n    omega\\n  | m\u2081 + 1, m\u2082 + 1, 0 => fun h => by\\n    simpa using ack_strict_mono_left' 1 ((add_lt_add_iff_right 1).1 h)\\n  | m\u2081 + 1, m\u2082 + 1, n + 1 => fun h => by\\n    rw [ack_succ_succ, ack_succ_succ]\\n    exact\\n      (ack_strict_mono_left' _ <| (add_lt_add_iff_right 1).1 h).trans\\n        (ack_strictMono_right _ <| ack_strict_mono_left' n h ) \"},\n  {\"tactics\": [50, 51, 52, 53, 54],\n   \"start\": {\"line\": 183, \"column\": 0},\n   \"proofTree\":\n   [{\"tactic\": \"cases' n with n n\", \"spawned_children\": [], \"children\": [1, 2]},\n    {\"tactic\": \"simp\", \"spawned_children\": [], \"children\": []},\n    {\"tactic\": \"rw [ack_succ_succ]\", \"spawned_children\": [], \"children\": [3]},\n    {\"tactic\": \"apply ack_mono_right m (le_trans _ <| add_add_one_le_ack _ n)\",\n     \"spawned_children\": [],\n     \"children\": [4]},\n    {\"tactic\": \"omega\", \"spawned_children\": [], \"children\": []}],\n   \"messages\": [],\n   \"end\": {\"line\": 188, \"column\": 9},\n   \"decl\":\n   \"theorem ack_succ_right_le_ack_succ_left (m n : \u2115) : ack m (n + 1) \u2264 ack (m + 1) n \"},\n  {\"tactics\": [55, 56, 57],\n   \"start\": {\"line\": 193, \"column\": 0},\n   \"proofTree\":\n   [{\"tactic\": \"induction n with k\", \"spawned_children\": [], \"children\": []}],\n   \"messages\": [0, 1],\n   \"end\": {\"line\": 194, \"column\": 20},\n   \"decl\":\n   \"private theorem sq_le_two_pow_add_one_minus_three (n : \u2115) : n ^ 2 \u2264 2 ^ (n + 1) - 3  \"}],\n \"tactics\":\n [{\"tactic\": \"rw [ack]\",\n   \"proofState\": 0,\n   \"pos\": {\"line\": 2, \"column\": 49},\n   \"goals\": \"n : \u2115 \u22a2 ack 0 n = n + 1\",\n   \"endPos\": {\"line\": 2, \"column\": 57}},\n  {\"tactic\": \"rw [ack]\",\n   \"proofState\": 1,\n   \"pos\": {\"line\": 6, \"column\": 62},\n   \"goals\": \"m : \u2115 \u22a2 ack (m + 1) 0 = ack m 1\",\n   \"endPos\": {\"line\": 6, \"column\": 70}},\n  {\"tactic\": \"rw [ack]\",\n   \"proofState\": 2,\n   \"pos\": {\"line\": 10, \"column\": 84},\n   \"goals\": \"m n : \u2115 \u22a2 ack (m + 1) (n + 1) = ack m (ack (m + 1) n)\",\n   \"endPos\": {\"line\": 10, \"column\": 92}},\n  {\"tactic\": \"induction' n with n IH\",\n   \"proofState\": 3,\n   \"pos\": {\"line\": 15, \"column\": 2},\n   \"goals\": \"n : \u2115 \u22a2 ack 1 n = n + 2\",\n   \"endPos\": {\"line\": 15, \"column\": 24}},\n  {\"tactic\": \"rfl\",\n   \"proofState\": 4,\n   \"pos\": {\"line\": 16, \"column\": 4},\n   \"goals\": \"case zero \u22a2 ack 1 0 = 0 + 2\",\n   \"endPos\": {\"line\": 16, \"column\": 7}},\n  {\"tactic\": \"simp [IH]\",\n   \"proofState\": 5,\n   \"pos\": {\"line\": 17, \"column\": 4},\n   \"goals\": \"case succ n : \u2115 IH : ack 1 n = n + 2 \u22a2 ack 1 (n + 1) = n + 1 + 2\",\n   \"endPos\": {\"line\": 17, \"column\": 13}},\n  {\"tactic\": \"induction' n with n IH\",\n   \"proofState\": 6,\n   \"pos\": {\"line\": 22, \"column\": 2},\n   \"goals\": \"n : \u2115 \u22a2 ack 2 n = 2 * n + 3\",\n   \"endPos\": {\"line\": 22, \"column\": 24}},\n  {\"tactic\": \"rfl\",\n   \"proofState\": 7,\n   \"pos\": {\"line\": 23, \"column\": 4},\n   \"goals\": \"case zero \u22a2 ack 2 0 = 2 * 0 + 3\",\n   \"endPos\": {\"line\": 23, \"column\": 7}},\n  {\"tactic\": \"simpa [mul_succ]\",\n   \"proofState\": 8,\n   \"pos\": {\"line\": 24, \"column\": 4},\n   \"goals\":\n   \"case succ n : \u2115 IH : ack 2 n = 2 * n + 3 \u22a2 ack 2 (n + 1) = 2 * (n + 1) + 3\",\n   \"endPos\": {\"line\": 24, \"column\": 20}},\n  {\"tactic\": \"induction' n with n IH\",\n   \"proofState\": 9,\n   \"pos\": {\"line\": 30, \"column\": 2},\n   \"goals\": \"n : \u2115 \u22a2 ack 3 n = 2 ^ (n + 3) - 3\",\n   \"endPos\": {\"line\": 30, \"column\": 24}},\n  {\"tactic\": \"rfl\",\n   \"proofState\": 10,\n   \"pos\": {\"line\": 31, \"column\": 4},\n   \"goals\": \"case zero \u22a2 ack 3 0 = 2 ^ (0 + 3) - 3\",\n   \"endPos\": {\"line\": 31, \"column\": 7}},\n  {\"tactic\":\n   \"rw [ack_succ_succ, IH, ack_two, Nat.succ_add, Nat.pow_succ 2 (n + 3), mul_comm _ 2, Nat.mul_sub_left_distrib, \u2190\\n  Nat.sub_add_comm, two_mul 3, Nat.add_sub_add_right]\",\n   \"proofState\": 11,\n   \"pos\": {\"line\": 32, \"column\": 4},\n   \"goals\":\n   \"case succ n : \u2115 IH : ack 3 n = 2 ^ (n + 3) - 3 \u22a2 ack 3 (n + 1) = 2 ^ (n + 1 + 3) - 3\",\n   \"endPos\": {\"line\": 33, \"column\": 87}},\n  {\"tactic\": \"have H : 2 * 3 \u2264 2 * 2 ^ 3 := by norm_num\",\n   \"proofState\": 12,\n   \"pos\": {\"line\": 34, \"column\": 4},\n   \"goals\":\n   \"case succ n : \u2115 IH : ack 3 n = 2 ^ (n + 3) - 3 \u22a2 2 * 3 \u2264 2 * 2 ^ (n + 3)\",\n   \"endPos\": {\"line\": 34, \"column\": 45}},\n  {\"tactic\": \"norm_num\",\n   \"proofState\": 13,\n   \"pos\": {\"line\": 34, \"column\": 37},\n   \"goals\": \"n : \u2115 IH : ack 3 n = 2 ^ (n + 3) - 3 \u22a2 2 * 3 \u2264 2 * 2 ^ 3\",\n   \"endPos\": {\"line\": 34, \"column\": 45}},\n  {\"tactic\": \"apply H.trans\",\n   \"proofState\": 14,\n   \"pos\": {\"line\": 35, \"column\": 4},\n   \"goals\":\n   \"case succ n : \u2115 IH : ack 3 n = 2 ^ (n + 3) - 3 H : 2 * 3 \u2264 2 * 2 ^ 3 \u22a2 2 * 3 \u2264 2 * 2 ^ (n + 3)\",\n   \"endPos\": {\"line\": 35, \"column\": 17}},\n  {\"tactic\": \"rw [_root_.mul_le_mul_left two_pos]\",\n   \"proofState\": 15,\n   \"pos\": {\"line\": 36, \"column\": 4},\n   \"goals\":\n   \"case succ n : \u2115 IH : ack 3 n = 2 ^ (n + 3) - 3 H : 2 * 3 \u2264 2 * 2 ^ 3 \u22a2 2 * 2 ^ 3 \u2264 2 * 2 ^ (n + 3)\",\n   \"endPos\": {\"line\": 36, \"column\": 39}},\n  {\"tactic\": \"exact pow_le_pow_right one_le_two (Nat.le_add_left 3 n)\",\n   \"proofState\": 16,\n   \"pos\": {\"line\": 37, \"column\": 4},\n   \"goals\":\n   \"case succ n : \u2115 IH : ack 3 n = 2 ^ (n + 3) - 3 H : 2 * 3 \u2264 2 * 2 ^ 3 \u22a2 2 ^ 3 \u2264 2 ^ (n + 3)\",\n   \"endPos\": {\"line\": 37, \"column\": 59}},\n  {\"tactic\": \"simp\",\n   \"proofState\": 17,\n   \"pos\": {\"line\": 41, \"column\": 15},\n   \"goals\": \"n : \u2115 \u22a2 0 < ack 0 n\",\n   \"endPos\": {\"line\": 41, \"column\": 19}},\n  {\"tactic\": \"rw [ack_succ_zero]\",\n   \"proofState\": 18,\n   \"pos\": {\"line\": 43, \"column\": 4},\n   \"goals\": \"m : \u2115 \u22a2 0 < ack (m + 1) 0\",\n   \"endPos\": {\"line\": 43, \"column\": 22}},\n  {\"tactic\": \"apply ack_pos\",\n   \"proofState\": 19,\n   \"pos\": {\"line\": 44, \"column\": 4},\n   \"goals\": \"m : \u2115 \u22a2 0 < ack m 1\",\n   \"endPos\": {\"line\": 44, \"column\": 17}},\n  {\"tactic\": \"rw [ack_succ_succ]\",\n   \"proofState\": 20,\n   \"pos\": {\"line\": 46, \"column\": 4},\n   \"goals\": \"m n : \u2115 \u22a2 0 < ack (m + 1) (n + 1)\",\n   \"endPos\": {\"line\": 46, \"column\": 22}},\n  {\"tactic\": \"apply ack_pos\",\n   \"proofState\": 21,\n   \"pos\": {\"line\": 47, \"column\": 4},\n   \"goals\": \"m n : \u2115 \u22a2 0 < ack m (ack (m + 1) n)\",\n   \"endPos\": {\"line\": 47, \"column\": 17}},\n  {\"tactic\": \"simp\",\n   \"proofState\": 22,\n   \"pos\": {\"line\": 51, \"column\": 15},\n   \"goals\": \"n : \u2115 \u22a2 1 < ack (0 + 1) n\",\n   \"endPos\": {\"line\": 51, \"column\": 19}},\n  {\"tactic\": \"rw [ack_succ_zero]\",\n   \"proofState\": 23,\n   \"pos\": {\"line\": 53, \"column\": 4},\n   \"goals\": \"m : \u2115 \u22a2 1 < ack (m + 1 + 1) 0\",\n   \"endPos\": {\"line\": 53, \"column\": 22}},\n  {\"tactic\": \"apply one_lt_ack_succ_left\",\n   \"proofState\": 24,\n   \"pos\": {\"line\": 54, \"column\": 4},\n   \"goals\": \"m : \u2115 \u22a2 1 < ack (m + 1) 1\",\n   \"endPos\": {\"line\": 54, \"column\": 30}},\n  {\"tactic\": \"rw [ack_succ_succ]\",\n   \"proofState\": 25,\n   \"pos\": {\"line\": 56, \"column\": 4},\n   \"goals\": \"m n : \u2115 \u22a2 1 < ack (m + 1 + 1) (n + 1)\",\n   \"endPos\": {\"line\": 56, \"column\": 22}},\n  {\"tactic\": \"apply one_lt_ack_succ_left\",\n   \"proofState\": 26,\n   \"pos\": {\"line\": 57, \"column\": 4},\n   \"goals\": \"m n : \u2115 \u22a2 1 < ack (m + 1) (ack (m + 1 + 1) n)\",\n   \"endPos\": {\"line\": 57, \"column\": 30}},\n  {\"tactic\": \"simp\",\n   \"proofState\": 27,\n   \"pos\": {\"line\": 61, \"column\": 15},\n   \"goals\": \"n : \u2115 \u22a2 1 < ack 0 (n + 1)\",\n   \"endPos\": {\"line\": 61, \"column\": 19}},\n  {\"tactic\": \"rw [ack_succ_succ]\",\n   \"proofState\": 28,\n   \"pos\": {\"line\": 63, \"column\": 4},\n   \"goals\": \"m n : \u2115 \u22a2 1 < ack (m + 1) (n + 1)\",\n   \"endPos\": {\"line\": 63, \"column\": 22}},\n  {\"tactic\":\n   \"cases' exists_eq_succ_of_ne_zero (ack_pos (m + 1) n).ne' with h h\",\n   \"proofState\": 29,\n   \"pos\": {\"line\": 64, \"column\": 4},\n   \"goals\": \"m n : \u2115 \u22a2 1 < ack m (ack (m + 1) n)\",\n   \"endPos\": {\"line\": 64, \"column\": 69}},\n  {\"tactic\": \"rw [h]\",\n   \"proofState\": 30,\n   \"pos\": {\"line\": 65, \"column\": 4},\n   \"goals\":\n   \"case intro m n h\u271d : \u2115 h : ack (m + 1) n = h\u271d.succ \u22a2 1 < ack m (ack (m + 1) n)\",\n   \"endPos\": {\"line\": 65, \"column\": 10}},\n  {\"tactic\": \"apply one_lt_ack_succ_right\",\n   \"proofState\": 31,\n   \"pos\": {\"line\": 66, \"column\": 4},\n   \"goals\":\n   \"case intro m n h\u271d : \u2115 h : ack (m + 1) n = h\u271d.succ \u22a2 1 < ack m h\u271d.succ\",\n   \"endPos\": {\"line\": 66, \"column\": 31}},\n  {\"tactic\": \"simpa using h\",\n   \"proofState\": 32,\n   \"pos\": {\"line\": 70, \"column\": 23},\n   \"goals\": \"n\u2081 n\u2082 : \u2115 h : n\u2081 < n\u2082 \u22a2 ack 0 n\u2081 < ack 0 n\u2082\",\n   \"endPos\": {\"line\": 70, \"column\": 36}},\n  {\"tactic\": \"rw [ack_succ_zero, ack_succ_succ]\",\n   \"proofState\": 33,\n   \"pos\": {\"line\": 72, \"column\": 4},\n   \"goals\": \"m n : \u2115 _h : 0 < n + 1 \u22a2 ack (m + 1) 0 < ack (m + 1) (n + 1)\",\n   \"endPos\": {\"line\": 72, \"column\": 37}},\n  {\"tactic\": \"exact ack_strictMono_right _ (one_lt_ack_succ_left m n)\",\n   \"proofState\": 34,\n   \"pos\": {\"line\": 73, \"column\": 4},\n   \"goals\": \"m n : \u2115 _h : 0 < n + 1 \u22a2 ack m 1 < ack m (ack (m + 1) n)\",\n   \"endPos\": {\"line\": 73, \"column\": 59}},\n  {\"tactic\": \"rw [ack_succ_succ, ack_succ_succ]\",\n   \"proofState\": 35,\n   \"pos\": {\"line\": 75, \"column\": 4},\n   \"goals\":\n   \"m n\u2081 n\u2082 : \u2115 h : n\u2081 + 1 < n\u2082 + 1 \u22a2 ack (m + 1) (n\u2081 + 1) < ack (m + 1) (n\u2082 + 1)\",\n   \"endPos\": {\"line\": 75, \"column\": 37}},\n  {\"tactic\": \"apply ack_strictMono_right _ (ack_strictMono_right _ _)\",\n   \"proofState\": 36,\n   \"pos\": {\"line\": 76, \"column\": 4},\n   \"goals\":\n   \"m n\u2081 n\u2082 : \u2115 h : n\u2081 + 1 < n\u2082 + 1 \u22a2 ack m (ack (m + 1) n\u2081) < ack m (ack (m + 1) n\u2082)\",\n   \"endPos\": {\"line\": 76, \"column\": 59}},\n  {\"tactic\": \"rwa [add_lt_add_iff_right] at h\",\n   \"proofState\": 37,\n   \"pos\": {\"line\": 77, \"column\": 4},\n   \"goals\": \"m n\u2081 n\u2082 : \u2115 h : n\u2081 + 1 < n\u2082 + 1 \u22a2 n\u2081 < n\u2082\",\n   \"endPos\": {\"line\": 77, \"column\": 35}},\n  {\"tactic\": \"simp\",\n   \"proofState\": 38,\n   \"pos\": {\"line\": 108, \"column\": 15},\n   \"goals\": \"n : \u2115 \u22a2 0 + n < ack 0 n\",\n   \"endPos\": {\"line\": 108, \"column\": 19}},\n  {\"tactic\": \"simpa using add_lt_ack m 1\",\n   \"proofState\": 39,\n   \"pos\": {\"line\": 109, \"column\": 19},\n   \"goals\": \"m : \u2115 \u22a2 m + 1 + 0 < ack (m + 1) 0\",\n   \"endPos\": {\"line\": 109, \"column\": 45}},\n  {\"tactic\": \"omega\",\n   \"proofState\": 40,\n   \"pos\": {\"line\": 112, \"column\": 44},\n   \"goals\": \"m n : \u2115 \u22a2 m + 1 + n + 1 \u2264 m + (m + n + 2)\",\n   \"endPos\": {\"line\": 112, \"column\": 49}},\n  {\"tactic\": \"rw [succ_eq_add_one]\",\n   \"proofState\": 41,\n   \"pos\": {\"line\": 115, \"column\": 47},\n   \"goals\": \"m n : \u2115 \u22a2 m + n + 2 = (m + 1 + n).succ\",\n   \"endPos\": {\"line\": 115, \"column\": 67}},\n  {\"tactic\": \"ring_nf\",\n   \"proofState\": 42,\n   \"pos\": {\"line\": 115, \"column\": 69},\n   \"goals\": \"m n : \u2115 \u22a2 m + n + 2 = m + 1 + n + 1\",\n   \"endPos\": {\"line\": 115, \"column\": 76}},\n  {\"tactic\": \"simpa using one_lt_ack_succ_right m 0\",\n   \"proofState\": 43,\n   \"pos\": {\"line\": 135, \"column\": 32},\n   \"goals\": \"m : \u2115 _h : 0 < m + 1 \u22a2 ack 0 0 < ack (m + 1) 0\",\n   \"endPos\": {\"line\": 135, \"column\": 69}},\n  {\"tactic\": \"rw [ack_zero, ack_succ_succ]\",\n   \"proofState\": 44,\n   \"pos\": {\"line\": 137, \"column\": 4},\n   \"goals\": \"m n : \u2115 h : 0 < m + 1 \u22a2 ack 0 (n + 1) < ack (m + 1) (n + 1)\",\n   \"endPos\": {\"line\": 137, \"column\": 32}},\n  {\"tactic\":\n   \"apply lt_of_le_of_lt (le_trans _ <| add_le_add_left (add_add_one_le_ack _ _) m) (add_lt_ack _ _)\",\n   \"proofState\": 45,\n   \"pos\": {\"line\": 138, \"column\": 4},\n   \"goals\": \"m n : \u2115 h : 0 < m + 1 \u22a2 n + 1 + 1 < ack m (ack (m + 1) n)\",\n   \"endPos\": {\"line\": 138, \"column\": 100}},\n  {\"tactic\": \"omega\",\n   \"proofState\": 46,\n   \"pos\": {\"line\": 139, \"column\": 4},\n   \"goals\": \"m n : \u2115 h : 0 < m + 1 \u22a2 n + 1 + 1 \u2264 m + (m + 1 + n + 1)\",\n   \"endPos\": {\"line\": 139, \"column\": 9}},\n  {\"tactic\":\n   \"simpa using ack_strict_mono_left' 1 ((add_lt_add_iff_right 1).1 h)\",\n   \"proofState\": 47,\n   \"pos\": {\"line\": 141, \"column\": 4},\n   \"goals\": \"m\u2081 m\u2082 : \u2115 h : m\u2081 + 1 < m\u2082 + 1 \u22a2 ack (m\u2081 + 1) 0 < ack (m\u2082 + 1) 0\",\n   \"endPos\": {\"line\": 141, \"column\": 70}},\n  {\"tactic\": \"rw [ack_succ_succ, ack_succ_succ]\",\n   \"proofState\": 48,\n   \"pos\": {\"line\": 143, \"column\": 4},\n   \"goals\":\n   \"m\u2081 m\u2082 n : \u2115 h : m\u2081 + 1 < m\u2082 + 1 \u22a2 ack (m\u2081 + 1) (n + 1) < ack (m\u2082 + 1) (n + 1)\",\n   \"endPos\": {\"line\": 143, \"column\": 37}},\n  {\"tactic\":\n   \"exact\\n  (ack_strict_mono_left' _ <| (add_lt_add_iff_right 1).1 h).trans (ack_strictMono_right _ <| ack_strict_mono_left' n h)\",\n   \"proofState\": 49,\n   \"pos\": {\"line\": 144, \"column\": 4},\n   \"goals\":\n   \"m\u2081 m\u2082 n : \u2115 h : m\u2081 + 1 < m\u2082 + 1 \u22a2 ack m\u2081 (ack (m\u2081 + 1) n) < ack m\u2082 (ack (m\u2082 + 1) n)\",\n   \"endPos\": {\"line\": 146, \"column\": 61}},\n  {\"tactic\": \"cases' n with n n\",\n   \"proofState\": 50,\n   \"pos\": {\"line\": 184, \"column\": 2},\n   \"goals\": \"m n : \u2115 \u22a2 ack m (n + 1) \u2264 ack (m + 1) n\",\n   \"endPos\": {\"line\": 184, \"column\": 19}},\n  {\"tactic\": \"simp\",\n   \"proofState\": 51,\n   \"pos\": {\"line\": 185, \"column\": 4},\n   \"goals\": \"case zero m : \u2115 \u22a2 ack m (0 + 1) \u2264 ack (m + 1) 0\",\n   \"endPos\": {\"line\": 185, \"column\": 8}},\n  {\"tactic\": \"rw [ack_succ_succ]\",\n   \"proofState\": 52,\n   \"pos\": {\"line\": 186, \"column\": 4},\n   \"goals\": \"case succ m n : \u2115 \u22a2 ack m (n + 1 + 1) \u2264 ack (m + 1) (n + 1)\",\n   \"endPos\": {\"line\": 186, \"column\": 22}},\n  {\"tactic\": \"apply ack_mono_right m (le_trans _ <| add_add_one_le_ack _ n)\",\n   \"proofState\": 53,\n   \"pos\": {\"line\": 187, \"column\": 4},\n   \"goals\": \"case succ m n : \u2115 \u22a2 ack m (n + 1 + 1) \u2264 ack m (ack (m + 1) n)\",\n   \"endPos\": {\"line\": 187, \"column\": 65}},\n  {\"tactic\": \"omega\",\n   \"proofState\": 54,\n   \"pos\": {\"line\": 188, \"column\": 4},\n   \"goals\": \"m n : \u2115 \u22a2 n + 1 + 1 \u2264 m + 1 + n + 1\",\n   \"endPos\": {\"line\": 188, \"column\": 9}},\n  {\"tactic\": \"<failed to pretty print>\",\n   \"proofState\": 55,\n   \"pos\": {\"line\": 194, \"column\": 2},\n   \"goals\": \"n : \u2115 \u22a2 n ^ 2 \u2264 2 ^ (n + 1) - 3\",\n   \"endPos\": {\"line\": 194, \"column\": 20}},\n  {\"tactic\": \"<failed to pretty print>\",\n   \"proofState\": 56,\n   \"pos\": {\"line\": 194, \"column\": 19},\n   \"goals\": \"case zero \u22a2 0 ^ 2 \u2264 2 ^ (0 + 1) - 3\",\n   \"endPos\": {\"line\": 194, \"column\": 20}},\n  {\"tactic\": \"<failed to pretty print>\",\n   \"proofState\": 57,\n   \"pos\": {\"line\": 194, \"column\": 19},\n   \"goals\":\n   \"case succ n\u271d : \u2115 a\u271d : n\u271d ^ 2 \u2264 2 ^ (n\u271d + 1) - 3 \u22a2 (n\u271d + 1) ^ 2 \u2264 2 ^ (n\u271d + 1 + 1) - 3\",\n   \"endPos\": {\"line\": 194, \"column\": 20}}],\n \"messages\":\n [{\"severity\": \"error\",\n   \"pos\": {\"line\": 194, \"column\": 20},\n   \"endPos\": null,\n   \"data\": \"unknown tactic\"},\n  {\"severity\": \"error\",\n   \"pos\": {\"line\": 193, \"column\": 88},\n   \"endPos\": {\"line\": 194, \"column\": 20},\n   \"data\":\n   \"unsolved goals\\ncase zero\\n\u22a2 0 ^ 2 \u2264 2 ^ (0 + 1) - 3\\n\\ncase succ\\nn\u271d : \u2115\\na\u271d : n\u271d ^ 2 \u2264 2 ^ (n\u271d + 1) - 3\\n\u22a2 (n\u271d + 1) ^ 2 \u2264 2 ^ (n\u271d + 1 + 1) - 3\"}],\n \"env\": 1}\n\n{\"theorems\":\n [{\"tactics\": [0],\n   \"start\": {\"line\": 1, \"column\": 0},\n   \"proofTree\":\n   [{\"tactic\": \"rw [ack]\", \"spawned_children\": [], \"children\": [1]},\n    {\"tactic\": \"rw [rfl]\", \"spawned_children\": [], \"children\": []}],\n   \"messages\": [],\n   \"end\": {\"line\": 2, \"column\": 57},\n   \"decl\": \"@[simp]\\ntheorem ack_zero (n : \u2115) : ack 0 n = n + 1 \"},\n  {\"tactics\": [1],\n   \"start\": {\"line\": 5, \"column\": 0},\n   \"proofTree\":\n   [{\"tactic\": \"rw [ack]\", \"spawned_children\": [], \"children\": [1]},\n    {\"tactic\": \"rw [rfl]\", \"spawned_children\": [], \"children\": []}],\n   \"messages\": [],\n   \"end\": {\"line\": 6, \"column\": 70},\n   \"decl\": \"@[simp]\\ntheorem ack_succ_zero (m : \u2115) : ack (m + 1) 0 = ack m 1 \"},\n  {\"tactics\": [2],\n   \"start\": {\"line\": 9, \"column\": 0},\n   \"proofTree\":\n   [{\"tactic\": \"rw [ack]\", \"spawned_children\": [], \"children\": [1]},\n    {\"tactic\": \"rw [rfl]\", \"spawned_children\": [], \"children\": []}],\n   \"messages\": [],\n   \"end\": {\"line\": 10, \"column\": 92},\n   \"decl\":\n   \"@[simp]\\ntheorem ack_succ_succ (m n : \u2115) : ack (m + 1) (n + 1) = ack m (ack (m + 1) n) \"},\n  {\"tactics\": [3, 4, 5],\n   \"start\": {\"line\": 13, \"column\": 0},\n   \"proofTree\":\n   [{\"tactic\": \"induction' n with n IH\",\n     \"spawned_children\": [],\n     \"children\": [1, 2]},\n    {\"tactic\": \"rfl\", \"spawned_children\": [], \"children\": []},\n    {\"tactic\": \"simp [IH]\", \"spawned_children\": [], \"children\": []}],\n   \"messages\": [],\n   \"end\": {\"line\": 17, \"column\": 13},\n   \"decl\": \"@[simp]\\ntheorem ack_one (n : \u2115) : ack 1 n = n + 2 \"},\n  {\"tactics\": [6, 7, 8],\n   \"start\": {\"line\": 20, \"column\": 0},\n   \"proofTree\":\n   [{\"tactic\": \"induction' n with n IH\",\n     \"spawned_children\": [],\n     \"children\": [1, 2]},\n    {\"tactic\": \"rfl\", \"spawned_children\": [], \"children\": []},\n    {\"tactic\": \"simpa [mul_succ]\", \"spawned_children\": [], \"children\": []}],\n   \"messages\": [],\n   \"end\": {\"line\": 24, \"column\": 20},\n   \"decl\": \"@[simp]\\ntheorem ack_two (n : \u2115) : ack 2 n = 2 * n + 3 \"},\n  {\"tactics\": [9, 10, 11, 12, 13, 14, 15, 16],\n   \"start\": {\"line\": 28, \"column\": 0},\n   \"proofTree\":\n   [{\"tactic\": \"induction' n with n IH\",\n     \"spawned_children\": [],\n     \"children\": [1, 2]},\n    {\"tactic\": \"rfl\", \"spawned_children\": [], \"children\": []},\n    {\"tactic\": \"rw [ack_succ_succ]\", \"spawned_children\": [], \"children\": [3]},\n    {\"tactic\": \"rw [IH]\", \"spawned_children\": [], \"children\": [4]},\n    {\"tactic\": \"rw [ack_two]\", \"spawned_children\": [], \"children\": [5]},\n    {\"tactic\": \"rw [Nat.succ_add]\", \"spawned_children\": [], \"children\": [6]},\n    {\"tactic\": \"rw [Nat.pow_succ 2 (n + 3)]\",\n     \"spawned_children\": [],\n     \"children\": [7]},\n    {\"tactic\": \"rw [mul_comm _ 2]\", \"spawned_children\": [], \"children\": [8]},\n    {\"tactic\": \"rw [Nat.mul_sub_left_distrib]\",\n     \"spawned_children\": [],\n     \"children\": [9]},\n    {\"tactic\": \"rw [\u2190 Nat.sub_add_comm]\",\n     \"spawned_children\": [],\n     \"children\": [10, 13]},\n    {\"tactic\": \"rw [two_mul 3]\", \"spawned_children\": [], \"children\": [11]},\n    {\"tactic\": \"rw [Nat.add_sub_add_right]\",\n     \"spawned_children\": [],\n     \"children\": [12]},\n    {\"tactic\": \"rw [rfl]\", \"spawned_children\": [], \"children\": []},\n    {\"tactic\": \"have H : 2 * 3 \u2264 2 * 2 ^ 3 := by norm_num\",\n     \"spawned_children\": [14],\n     \"children\": [14, 15]},\n    {\"tactic\": \"norm_num\", \"spawned_children\": [], \"children\": []},\n    {\"tactic\": \"apply H.trans\", \"spawned_children\": [], \"children\": [16]},\n    {\"tactic\": \"rw [_root_.mul_le_mul_left two_pos]\",\n     \"spawned_children\": [],\n     \"children\": [17]},\n    {\"tactic\": \"exact pow_le_pow_right one_le_two (Nat.le_add_left 3 n)\",\n     \"spawned_children\": [],\n     \"children\": []}],\n   \"messages\": [],\n   \"end\": {\"line\": 37, \"column\": 59},\n   \"decl\": \"@[simp]\\ntheorem ack_three (n : \u2115) : ack 3 n = 2 ^ (n + 3) - 3 \"},\n  {\"tactics\": [17, 18, 19, 20, 21],\n   \"start\": {\"line\": 40, \"column\": 0},\n   \"proofTree\":\n   [{\"tactic\": \"simp\", \"spawned_children\": [], \"children\": []},\n    {\"tactic\": \"rw [ack_succ_zero]\", \"spawned_children\": [], \"children\": [2]},\n    {\"tactic\": \"apply ack_pos\", \"spawned_children\": [], \"children\": []},\n    {\"tactic\": \"rw [ack_succ_succ]\", \"spawned_children\": [], \"children\": [4]},\n    {\"tactic\": \"apply ack_pos\", \"spawned_children\": [], \"children\": []}],\n   \"messages\": [],\n   \"end\": {\"line\": 47, \"column\": 17},\n   \"decl\":\n   \"theorem ack_pos : \u2200 m n, 0 < ack m n\\n  | 0, n => by simp\\n  | m + 1, 0 => by\\n    rw [ack_succ_zero]\\n    apply ack_pos\\n  | m + 1, n + 1 => by\\n    rw [ack_succ_succ]\\n    apply  ack_pos \"},\n  {\"tactics\": [22, 23, 24, 25, 26],\n   \"start\": {\"line\": 50, \"column\": 0},\n   \"proofTree\":\n   [{\"tactic\": \"simp\", \"spawned_children\": [], \"children\": []},\n    {\"tactic\": \"rw [ack_succ_zero]\", \"spawned_children\": [], \"children\": [2]},\n    {\"tactic\": \"apply one_lt_ack_succ_left\",\n     \"spawned_children\": [],\n     \"children\": []},\n    {\"tactic\": \"rw [ack_succ_succ]\", \"spawned_children\": [], \"children\": [4]},\n    {\"tactic\": \"apply one_lt_ack_succ_left\",\n     \"spawned_children\": [],\n     \"children\": []}],\n   \"messages\": [],\n   \"end\": {\"line\": 57, \"column\": 30},\n   \"decl\":\n   \"theorem one_lt_ack_succ_left : \u2200 m n, 1 < ack (m + 1) n\\n  | 0, n => by simp\\n  | m + 1, 0 => by\\n    rw [ack_succ_zero]\\n    apply one_lt_ack_succ_left\\n  | m + 1, n + 1 => by\\n    rw [ack_succ_succ]\\n    apply  one_lt_ack_succ_left \"},\n  {\"tactics\": [27, 28, 29, 30, 31],\n   \"start\": {\"line\": 60, \"column\": 0},\n   \"proofTree\":\n   [{\"tactic\": \"simp\", \"spawned_children\": [], \"children\": []},\n    {\"tactic\": \"rw [ack_succ_succ]\", \"spawned_children\": [], \"children\": [2]},\n    {\"tactic\":\n     \"cases' exists_eq_succ_of_ne_zero (ack_pos (m + 1) n).ne' with h h\",\n     \"spawned_children\": [],\n     \"children\": [3]},\n    {\"tactic\": \"rw [h]\", \"spawned_children\": [], \"children\": [4]},\n    {\"tactic\": \"apply one_lt_ack_succ_right\",\n     \"spawned_children\": [],\n     \"children\": []}],\n   \"messages\": [],\n   \"end\": {\"line\": 66, \"column\": 31},\n   \"decl\":\n   \"theorem one_lt_ack_succ_right : \u2200 m n, 1 < ack m (n + 1)\\n  | 0, n => by simp\\n  | m + 1, n => by\\n    rw [ack_succ_succ]\\n    cases' exists_eq_succ_of_ne_zero (ack_pos (m + 1) n).ne' with h h\\n    rw [h]\\n    apply  one_lt_ack_succ_right \"},\n  {\"tactics\": [32, 33, 34, 35, 36, 37],\n   \"start\": {\"line\": 69, \"column\": 0},\n   \"proofTree\":\n   [{\"tactic\": \"simpa using h\", \"spawned_children\": [], \"children\": []},\n    {\"tactic\": \"rw [ack_succ_zero]\", \"spawned_children\": [], \"children\": [2]},\n    {\"tactic\": \"rw [ack_succ_succ]\", \"spawned_children\": [], \"children\": [3]},\n    {\"tactic\": \"exact ack_strictMono_right _ (one_lt_ack_succ_left m n)\",\n     \"spawned_children\": [],\n     \"children\": []},\n    {\"tactic\": \"rw [ack_succ_succ]\", \"spawned_children\": [], \"children\": [5]},\n    {\"tactic\": \"rw [ack_succ_succ]\", \"spawned_children\": [], \"children\": [6]},\n    {\"tactic\": \"apply ack_strictMono_right _ (ack_strictMono_right _ _)\",\n     \"spawned_children\": [],\n     \"children\": [7]},\n    {\"tactic\": \"add_lt_add_iff_right\", \"spawned_children\": [], \"children\": []}],\n   \"messages\": [],\n   \"end\": {\"line\": 77, \"column\": 35},\n   \"decl\":\n   \"theorem ack_strictMono_right : \u2200 m, StrictMono (ack m)\\n  | 0, n\u2081, n\u2082, h => by simpa using h\\n  | m + 1, 0, n + 1, _h => by\\n    rw [ack_succ_zero, ack_succ_succ]\\n    exact ack_strictMono_right _ (one_lt_ack_succ_left m n)\\n  | m + 1, n\u2081 + 1, n\u2082 + 1, h => by\\n    rw [ack_succ_succ, ack_succ_succ]\\n    apply ack_strictMono_right _ (ack_strictMono_right _ _)\\n    rwa [add_lt_add_iff_right] at  h \"},\n  {\"tactics\": [38, 39, 40, 41, 42],\n   \"start\": {\"line\": 107, \"column\": 0},\n   \"proofTree\":\n   [{\"tactic\": \"simp\", \"spawned_children\": [], \"children\": []},\n    {\"tactic\": \"simpa using add_lt_ack m 1\",\n     \"spawned_children\": [],\n     \"children\": []},\n    {\"tactic\": \"omega\", \"spawned_children\": [], \"children\": []},\n    {\"tactic\": \"rw [succ_eq_add_one]\", \"spawned_children\": [], \"children\": [4]},\n    {\"tactic\": \"ring_nf\", \"spawned_children\": [], \"children\": []}],\n   \"messages\": [],\n   \"end\": {\"line\": 117, \"column\": 57},\n   \"decl\":\n   \"theorem add_lt_ack : \u2200 m n, m + n < ack m n\\n  | 0, n => by simp\\n  | m + 1, 0 => by simpa using add_lt_ack m 1\\n  | m + 1, n + 1 =>\\n    calc\\n      m + 1 + n + 1 \u2264 m + (m + n + 2) \"},\n  {\"tactics\": [43, 44, 45, 46, 47, 48, 49],\n   \"start\": {\"line\": 133, \"column\": 0},\n   \"proofTree\":\n   [{\"tactic\": \"simpa using one_lt_ack_succ_right m 0\",\n     \"spawned_children\": [],\n     \"children\": []},\n    {\"tactic\": \"rw [ack_zero]\", \"spawned_children\": [], \"children\": [2]},\n    {\"tactic\": \"rw [ack_succ_succ]\", \"spawned_children\": [], \"children\": [3]},\n    {\"tactic\":\n     \"apply lt_of_le_of_lt (le_trans _ <| add_le_add_left (add_add_one_le_ack _ _) m) (add_lt_ack _ _)\",\n     \"spawned_children\": [],\n     \"children\": [4]},\n    {\"tactic\": \"omega\", \"spawned_children\": [], \"children\": []},\n    {\"tactic\":\n     \"simpa using ack_strict_mono_left' 1 ((add_lt_add_iff_right 1).1 h)\",\n     \"spawned_children\": [],\n     \"children\": []},\n    {\"tactic\": \"rw [ack_succ_succ]\", \"spawned_children\": [], \"children\": [7]},\n    {\"tactic\": \"rw [ack_succ_succ]\", \"spawned_children\": [], \"children\": [8]},\n    {\"tactic\": \"exact\", \"spawned_children\": [], \"children\": []}],\n   \"messages\": [],\n   \"end\": {\"line\": 146, \"column\": 61},\n   \"decl\":\n   \"private theorem ack_strict_mono_left' : \u2200 {m\u2081 m\u2082} (n), m\u2081 < m\u2082 \u2192 ack m\u2081 n < ack m\u2082 n\\n  | m, 0, n => fun h => (not_lt_zero m h).elim\\n  | 0, m + 1, 0 => fun _h => by simpa using one_lt_ack_succ_right m 0\\n  | 0, m + 1, n + 1 => fun h => by\\n    rw [ack_zero, ack_succ_succ]\\n    apply lt_of_le_of_lt (le_trans _ <| add_le_add_left (add_add_one_le_ack _ _) m) (add_lt_ack _ _)\\n    omega\\n  | m\u2081 + 1, m\u2082 + 1, 0 => fun h => by\\n    simpa using ack_strict_mono_left' 1 ((add_lt_add_iff_right 1).1 h)\\n  | m\u2081 + 1, m\u2082 + 1, n + 1 => fun h => by\\n    rw [ack_succ_succ, ack_succ_succ]\\n    exact\\n      (ack_strict_mono_left' _ <| (add_lt_add_iff_right 1).1 h).trans\\n        (ack_strictMono_right _ <| ack_strict_mono_left' n h ) \"},\n  {\"tactics\": [50, 51, 52, 53, 54],\n   \"start\": {\"line\": 183, \"column\": 0},\n   \"proofTree\":\n   [{\"tactic\": \"cases' n with n n\", \"spawned_children\": [], \"children\": [1, 2]},\n    {\"tactic\": \"simp\", \"spawned_children\": [], \"children\": []},\n    {\"tactic\": \"rw [ack_succ_succ]\", \"spawned_children\": [], \"children\": [3]},\n    {\"tactic\": \"apply ack_mono_right m (le_trans _ <| add_add_one_le_ack _ n)\",\n     \"spawned_children\": [],\n     \"children\": [4]},\n    {\"tactic\": \"omega\", \"spawned_children\": [], \"children\": []}],\n   \"messages\": [],\n   \"end\": {\"line\": 188, \"column\": 9},\n   \"decl\":\n   \"theorem ack_succ_right_le_ack_succ_left (m n : \u2115) : ack m (n + 1) \u2264 ack (m + 1) n \"},\n  {\"tactics\": [55, 56, 57, 58, 59, 60],\n   \"start\": {\"line\": 193, \"column\": 0},\n   \"proofTree\":\n   [{\"tactic\": \"induction' n with k hk\",\n     \"spawned_children\": [],\n     \"children\": [1, 2]},\n    {\"tactic\": \"norm_num\", \"spawned_children\": [], \"children\": []},\n    {\"tactic\": \"cases k\", \"spawned_children\": [], \"children\": [3, 4]},\n    {\"tactic\": \"norm_num\", \"spawned_children\": [], \"children\": []},\n    {\"tactic\": \"rw [add_sq]\", \"spawned_children\": [], \"children\": [5]},\n    {\"tactic\": \"rw [Nat.pow_succ]\", \"spawned_children\": [], \"children\": [6]},\n    {\"tactic\": \"rw [two_mul]\", \"spawned_children\": [], \"children\": [7]},\n    {\"tactic\": \"rw [add_assoc]\", \"spawned_children\": [], \"children\": []}],\n   \"messages\": [0],\n   \"end\": {\"line\": 202, \"column\": 41},\n   \"decl\":\n   \"private theorem sq_le_two_pow_add_one_minus_three (n : \u2115) : n ^ 2 \u2264 2 ^ (n + 1) - 3  \"}],\n \"tactics\":\n [{\"tactic\": \"rw [ack]\",\n   \"proofState\": 58,\n   \"pos\": {\"line\": 2, \"column\": 49},\n   \"goals\": \"n : \u2115 \u22a2 ack 0 n = n + 1\",\n   \"endPos\": {\"line\": 2, \"column\": 57}},\n  {\"tactic\": \"rw [ack]\",\n   \"proofState\": 59,\n   \"pos\": {\"line\": 6, \"column\": 62},\n   \"goals\": \"m : \u2115 \u22a2 ack (m + 1) 0 = ack m 1\",\n   \"endPos\": {\"line\": 6, \"column\": 70}},\n  {\"tactic\": \"rw [ack]\",\n   \"proofState\": 60,\n   \"pos\": {\"line\": 10, \"column\": 84},\n   \"goals\": \"m n : \u2115 \u22a2 ack (m + 1) (n + 1) = ack m (ack (m + 1) n)\",\n   \"endPos\": {\"line\": 10, \"column\": 92}},\n  {\"tactic\": \"induction' n with n IH\",\n   \"proofState\": 61,\n   \"pos\": {\"line\": 15, \"column\": 2},\n   \"goals\": \"n : \u2115 \u22a2 ack 1 n = n + 2\",\n   \"endPos\": {\"line\": 15, \"column\": 24}},\n  {\"tactic\": \"rfl\",\n   \"proofState\": 62,\n   \"pos\": {\"line\": 16, \"column\": 4},\n   \"goals\": \"case zero \u22a2 ack 1 0 = 0 + 2\",\n   \"endPos\": {\"line\": 16, \"column\": 7}},\n  {\"tactic\": \"simp [IH]\",\n   \"proofState\": 63,\n   \"pos\": {\"line\": 17, \"column\": 4},\n   \"goals\": \"case succ n : \u2115 IH : ack 1 n = n + 2 \u22a2 ack 1 (n + 1) = n + 1 + 2\",\n   \"endPos\": {\"line\": 17, \"column\": 13}},\n  {\"tactic\": \"induction' n with n IH\",\n   \"proofState\": 64,\n   \"pos\": {\"line\": 22, \"column\": 2},\n   \"goals\": \"n : \u2115 \u22a2 ack 2 n = 2 * n + 3\",\n   \"endPos\": {\"line\": 22, \"column\": 24}},\n  {\"tactic\": \"rfl\",\n   \"proofState\": 65,\n   \"pos\": {\"line\": 23, \"column\": 4},\n   \"goals\": \"case zero \u22a2 ack 2 0 = 2 * 0 + 3\",\n   \"endPos\": {\"line\": 23, \"column\": 7}},\n  {\"tactic\": \"simpa [mul_succ]\",\n   \"proofState\": 66,\n   \"pos\": {\"line\": 24, \"column\": 4},\n   \"goals\":\n   \"case succ n : \u2115 IH : ack 2 n = 2 * n + 3 \u22a2 ack 2 (n + 1) = 2 * (n + 1) + 3\",\n   \"endPos\": {\"line\": 24, \"column\": 20}},\n  {\"tactic\": \"induction' n with n IH\",\n   \"proofState\": 67,\n   \"pos\": {\"line\": 30, \"column\": 2},\n   \"goals\": \"n : \u2115 \u22a2 ack 3 n = 2 ^ (n + 3) - 3\",\n   \"endPos\": {\"line\": 30, \"column\": 24}},\n  {\"tactic\": \"rfl\",\n   \"proofState\": 68,\n   \"pos\": {\"line\": 31, \"column\": 4},\n   \"goals\": \"case zero \u22a2 ack 3 0 = 2 ^ (0 + 3) - 3\",\n   \"endPos\": {\"line\": 31, \"column\": 7}},\n  {\"tactic\":\n   \"rw [ack_succ_succ, IH, ack_two, Nat.succ_add, Nat.pow_succ 2 (n + 3), mul_comm _ 2, Nat.mul_sub_left_distrib, \u2190\\n  Nat.sub_add_comm, two_mul 3, Nat.add_sub_add_right]\",\n   \"proofState\": 69,\n   \"pos\": {\"line\": 32, \"column\": 4},\n   \"goals\":\n   \"case succ n : \u2115 IH : ack 3 n = 2 ^ (n + 3) - 3 \u22a2 ack 3 (n + 1) = 2 ^ (n + 1 + 3) - 3\",\n   \"endPos\": {\"line\": 33, \"column\": 87}},\n  {\"tactic\": \"have H : 2 * 3 \u2264 2 * 2 ^ 3 := by norm_num\",\n   \"proofState\": 70,\n   \"pos\": {\"line\": 34, \"column\": 4},\n   \"goals\":\n   \"case succ n : \u2115 IH : ack 3 n = 2 ^ (n + 3) - 3 \u22a2 2 * 3 \u2264 2 * 2 ^ (n + 3)\",\n   \"endPos\": {\"line\": 34, \"column\": 45}},\n  {\"tactic\": \"norm_num\",\n   \"proofState\": 71,\n   \"pos\": {\"line\": 34, \"column\": 37},\n   \"goals\": \"n : \u2115 IH : ack 3 n = 2 ^ (n + 3) - 3 \u22a2 2 * 3 \u2264 2 * 2 ^ 3\",\n   \"endPos\": {\"line\": 34, \"column\": 45}},\n  {\"tactic\": \"apply H.trans\",\n   \"proofState\": 72,\n   \"pos\": {\"line\": 35, \"column\": 4},\n   \"goals\":\n   \"case succ n : \u2115 IH : ack 3 n = 2 ^ (n + 3) - 3 H : 2 * 3 \u2264 2 * 2 ^ 3 \u22a2 2 * 3 \u2264 2 * 2 ^ (n + 3)\",\n   \"endPos\": {\"line\": 35, \"column\": 17}},\n  {\"tactic\": \"rw [_root_.mul_le_mul_left two_pos]\",\n   \"proofState\": 73,\n   \"pos\": {\"line\": 36, \"column\": 4},\n   \"goals\":\n   \"case succ n : \u2115 IH : ack 3 n = 2 ^ (n + 3) - 3 H : 2 * 3 \u2264 2 * 2 ^ 3 \u22a2 2 * 2 ^ 3 \u2264 2 * 2 ^ (n + 3)\",\n   \"endPos\": {\"line\": 36, \"column\": 39}},\n  {\"tactic\": \"exact pow_le_pow_right one_le_two (Nat.le_add_left 3 n)\",\n   \"proofState\": 74,\n   \"pos\": {\"line\": 37, \"column\": 4},\n   \"goals\":\n   \"case succ n : \u2115 IH : ack 3 n = 2 ^ (n + 3) - 3 H : 2 * 3 \u2264 2 * 2 ^ 3 \u22a2 2 ^ 3 \u2264 2 ^ (n + 3)\",\n   \"endPos\": {\"line\": 37, \"column\": 59}},\n  {\"tactic\": \"simp\",\n   \"proofState\": 75,\n   \"pos\": {\"line\": 41, \"column\": 15},\n   \"goals\": \"n : \u2115 \u22a2 0 < ack 0 n\",\n   \"endPos\": {\"line\": 41, \"column\": 19}},\n  {\"tactic\": \"rw [ack_succ_zero]\",\n   \"proofState\": 76,\n   \"pos\": {\"line\": 43, \"column\": 4},\n   \"goals\": \"m : \u2115 \u22a2 0 < ack (m + 1) 0\",\n   \"endPos\": {\"line\": 43, \"column\": 22}},\n  {\"tactic\": \"apply ack_pos\",\n   \"proofState\": 77,\n   \"pos\": {\"line\": 44, \"column\": 4},\n   \"goals\": \"m : \u2115 \u22a2 0 < ack m 1\",\n   \"endPos\": {\"line\": 44, \"column\": 17}},\n  {\"tactic\": \"rw [ack_succ_succ]\",\n   \"proofState\": 78,\n   \"pos\": {\"line\": 46, \"column\": 4},\n   \"goals\": \"m n : \u2115 \u22a2 0 < ack (m + 1) (n + 1)\",\n   \"endPos\": {\"line\": 46, \"column\": 22}},\n  {\"tactic\": \"apply ack_pos\",\n   \"proofState\": 79,\n   \"pos\": {\"line\": 47, \"column\": 4},\n   \"goals\": \"m n : \u2115 \u22a2 0 < ack m (ack (m + 1) n)\",\n   \"endPos\": {\"line\": 47, \"column\": 17}},\n  {\"tactic\": \"simp\",\n   \"proofState\": 80,\n   \"pos\": {\"line\": 51, \"column\": 15},\n   \"goals\": \"n : \u2115 \u22a2 1 < ack (0 + 1) n\",\n   \"endPos\": {\"line\": 51, \"column\": 19}},\n  {\"tactic\": \"rw [ack_succ_zero]\",\n   \"proofState\": 81,\n   \"pos\": {\"line\": 53, \"column\": 4},\n   \"goals\": \"m : \u2115 \u22a2 1 < ack (m + 1 + 1) 0\",\n   \"endPos\": {\"line\": 53, \"column\": 22}},\n  {\"tactic\": \"apply one_lt_ack_succ_left\",\n   \"proofState\": 82,\n   \"pos\": {\"line\": 54, \"column\": 4},\n   \"goals\": \"m : \u2115 \u22a2 1 < ack (m + 1) 1\",\n   \"endPos\": {\"line\": 54, \"column\": 30}},\n  {\"tactic\": \"rw [ack_succ_succ]\",\n   \"proofState\": 83,\n   \"pos\": {\"line\": 56, \"column\": 4},\n   \"goals\": \"m n : \u2115 \u22a2 1 < ack (m + 1 + 1) (n + 1)\",\n   \"endPos\": {\"line\": 56, \"column\": 22}},\n  {\"tactic\": \"apply one_lt_ack_succ_left\",\n   \"proofState\": 84,\n   \"pos\": {\"line\": 57, \"column\": 4},\n   \"goals\": \"m n : \u2115 \u22a2 1 < ack (m + 1) (ack (m + 1 + 1) n)\",\n   \"endPos\": {\"line\": 57, \"column\": 30}},\n  {\"tactic\": \"simp\",\n   \"proofState\": 85,\n   \"pos\": {\"line\": 61, \"column\": 15},\n   \"goals\": \"n : \u2115 \u22a2 1 < ack 0 (n + 1)\",\n   \"endPos\": {\"line\": 61, \"column\": 19}},\n  {\"tactic\": \"rw [ack_succ_succ]\",\n   \"proofState\": 86,\n   \"pos\": {\"line\": 63, \"column\": 4},\n   \"goals\": \"m n : \u2115 \u22a2 1 < ack (m + 1) (n + 1)\",\n   \"endPos\": {\"line\": 63, \"column\": 22}},\n  {\"tactic\":\n   \"cases' exists_eq_succ_of_ne_zero (ack_pos (m + 1) n).ne' with h h\",\n   \"proofState\": 87,\n   \"pos\": {\"line\": 64, \"column\": 4},\n   \"goals\": \"m n : \u2115 \u22a2 1 < ack m (ack (m + 1) n)\",\n   \"endPos\": {\"line\": 64, \"column\": 69}},\n  {\"tactic\": \"rw [h]\",\n   \"proofState\": 88,\n   \"pos\": {\"line\": 65, \"column\": 4},\n   \"goals\":\n   \"case intro m n h\u271d : \u2115 h : ack (m + 1) n = h\u271d.succ \u22a2 1 < ack m (ack (m + 1) n)\",\n   \"endPos\": {\"line\": 65, \"column\": 10}},\n  {\"tactic\": \"apply one_lt_ack_succ_right\",\n   \"proofState\": 89,\n   \"pos\": {\"line\": 66, \"column\": 4},\n   \"goals\":\n   \"case intro m n h\u271d : \u2115 h : ack (m + 1) n = h\u271d.succ \u22a2 1 < ack m h\u271d.succ\",\n   \"endPos\": {\"line\": 66, \"column\": 31}},\n  {\"tactic\": \"simpa using h\",\n   \"proofState\": 90,\n   \"pos\": {\"line\": 70, \"column\": 23},\n   \"goals\": \"n\u2081 n\u2082 : \u2115 h : n\u2081 < n\u2082 \u22a2 ack 0 n\u2081 < ack 0 n\u2082\",\n   \"endPos\": {\"line\": 70, \"column\": 36}},\n  {\"tactic\": \"rw [ack_succ_zero, ack_succ_succ]\",\n   \"proofState\": 91,\n   \"pos\": {\"line\": 72, \"column\": 4},\n   \"goals\": \"m n : \u2115 _h : 0 < n + 1 \u22a2 ack (m + 1) 0 < ack (m + 1) (n + 1)\",\n   \"endPos\": {\"line\": 72, \"column\": 37}},\n  {\"tactic\": \"exact ack_strictMono_right _ (one_lt_ack_succ_left m n)\",\n   \"proofState\": 92,\n   \"pos\": {\"line\": 73, \"column\": 4},\n   \"goals\": \"m n : \u2115 _h : 0 < n + 1 \u22a2 ack m 1 < ack m (ack (m + 1) n)\",\n   \"endPos\": {\"line\": 73, \"column\": 59}},\n  {\"tactic\": \"rw [ack_succ_succ, ack_succ_succ]\",\n   \"proofState\": 93,\n   \"pos\": {\"line\": 75, \"column\": 4},\n   \"goals\":\n   \"m n\u2081 n\u2082 : \u2115 h : n\u2081 + 1 < n\u2082 + 1 \u22a2 ack (m + 1) (n\u2081 + 1) < ack (m + 1) (n\u2082 + 1)\",\n   \"endPos\": {\"line\": 75, \"column\": 37}},\n  {\"tactic\": \"apply ack_strictMono_right _ (ack_strictMono_right _ _)\",\n   \"proofState\": 94,\n   \"pos\": {\"line\": 76, \"column\": 4},\n   \"goals\":\n   \"m n\u2081 n\u2082 : \u2115 h : n\u2081 + 1 < n\u2082 + 1 \u22a2 ack m (ack (m + 1) n\u2081) < ack m (ack (m + 1) n\u2082)\",\n   \"endPos\": {\"line\": 76, \"column\": 59}},\n  {\"tactic\": \"rwa [add_lt_add_iff_right] at h\",\n   \"proofState\": 95,\n   \"pos\": {\"line\": 77, \"column\": 4},\n   \"goals\": \"m n\u2081 n\u2082 : \u2115 h : n\u2081 + 1 < n\u2082 + 1 \u22a2 n\u2081 < n\u2082\",\n   \"endPos\": {\"line\": 77, \"column\": 35}},\n  {\"tactic\": \"simp\",\n   \"proofState\": 96,\n   \"pos\": {\"line\": 108, \"column\": 15},\n   \"goals\": \"n : \u2115 \u22a2 0 + n < ack 0 n\",\n   \"endPos\": {\"line\": 108, \"column\": 19}},\n  {\"tactic\": \"simpa using add_lt_ack m 1\",\n   \"proofState\": 97,\n   \"pos\": {\"line\": 109, \"column\": 19},\n   \"goals\": \"m : \u2115 \u22a2 m + 1 + 0 < ack (m + 1) 0\",\n   \"endPos\": {\"line\": 109, \"column\": 45}},\n  {\"tactic\": \"omega\",\n   \"proofState\": 98,\n   \"pos\": {\"line\": 112, \"column\": 44},\n   \"goals\": \"m n : \u2115 \u22a2 m + 1 + n + 1 \u2264 m + (m + n + 2)\",\n   \"endPos\": {\"line\": 112, \"column\": 49}},\n  {\"tactic\": \"rw [succ_eq_add_one]\",\n   \"proofState\": 99,\n   \"pos\": {\"line\": 115, \"column\": 47},\n   \"goals\": \"m n : \u2115 \u22a2 m + n + 2 = (m + 1 + n).succ\",\n   \"endPos\": {\"line\": 115, \"column\": 67}},\n  {\"tactic\": \"ring_nf\",\n   \"proofState\": 100,\n   \"pos\": {\"line\": 115, \"column\": 69},\n   \"goals\": \"m n : \u2115 \u22a2 m + n + 2 = m + 1 + n + 1\",\n   \"endPos\": {\"line\": 115, \"column\": 76}},\n  {\"tactic\": \"simpa using one_lt_ack_succ_right m 0\",\n   \"proofState\": 101,\n   \"pos\": {\"line\": 135, \"column\": 32},\n   \"goals\": \"m : \u2115 _h : 0 < m + 1 \u22a2 ack 0 0 < ack (m + 1) 0\",\n   \"endPos\": {\"line\": 135, \"column\": 69}},\n  {\"tactic\": \"rw [ack_zero, ack_succ_succ]\",\n   \"proofState\": 102,\n   \"pos\": {\"line\": 137, \"column\": 4},\n   \"goals\": \"m n : \u2115 h : 0 < m + 1 \u22a2 ack 0 (n + 1) < ack (m + 1) (n + 1)\",\n   \"endPos\": {\"line\": 137, \"column\": 32}},\n  {\"tactic\":\n   \"apply lt_of_le_of_lt (le_trans _ <| add_le_add_left (add_add_one_le_ack _ _) m) (add_lt_ack _ _)\",\n   \"proofState\": 103,\n   \"pos\": {\"line\": 138, \"column\": 4},\n   \"goals\": \"m n : \u2115 h : 0 < m + 1 \u22a2 n + 1 + 1 < ack m (ack (m + 1) n)\",\n   \"endPos\": {\"line\": 138, \"column\": 100}},\n  {\"tactic\": \"omega\",\n   \"proofState\": 104,\n   \"pos\": {\"line\": 139, \"column\": 4},\n   \"goals\": \"m n : \u2115 h : 0 < m + 1 \u22a2 n + 1 + 1 \u2264 m + (m + 1 + n + 1)\",\n   \"endPos\": {\"line\": 139, \"column\": 9}},\n  {\"tactic\":\n   \"simpa using ack_strict_mono_left' 1 ((add_lt_add_iff_right 1).1 h)\",\n   \"proofState\": 105,\n   \"pos\": {\"line\": 141, \"column\": 4},\n   \"goals\": \"m\u2081 m\u2082 : \u2115 h : m\u2081 + 1 < m\u2082 + 1 \u22a2 ack (m\u2081 + 1) 0 < ack (m\u2082 + 1) 0\",\n   \"endPos\": {\"line\": 141, \"column\": 70}},\n  {\"tactic\": \"rw [ack_succ_succ, ack_succ_succ]\",\n   \"proofState\": 106,\n   \"pos\": {\"line\": 143, \"column\": 4},\n   \"goals\":\n   \"m\u2081 m\u2082 n : \u2115 h : m\u2081 + 1 < m\u2082 + 1 \u22a2 ack (m\u2081 + 1) (n + 1) < ack (m\u2082 + 1) (n + 1)\",\n   \"endPos\": {\"line\": 143, \"column\": 37}},\n  {\"tactic\":\n   \"exact\\n  (ack_strict_mono_left' _ <| (add_lt_add_iff_right 1).1 h).trans (ack_strictMono_right _ <| ack_strict_mono_left' n h)\",\n   \"proofState\": 107,\n   \"pos\": {\"line\": 144, \"column\": 4},\n   \"goals\":\n   \"m\u2081 m\u2082 n : \u2115 h : m\u2081 + 1 < m\u2082 + 1 \u22a2 ack m\u2081 (ack (m\u2081 + 1) n) < ack m\u2082 (ack (m\u2082 + 1) n)\",\n   \"endPos\": {\"line\": 146, \"column\": 61}},\n  {\"tactic\": \"cases' n with n n\",\n   \"proofState\": 108,\n   \"pos\": {\"line\": 184, \"column\": 2},\n   \"goals\": \"m n : \u2115 \u22a2 ack m (n + 1) \u2264 ack (m + 1) n\",\n   \"endPos\": {\"line\": 184, \"column\": 19}},\n  {\"tactic\": \"simp\",\n   \"proofState\": 109,\n   \"pos\": {\"line\": 185, \"column\": 4},\n   \"goals\": \"case zero m : \u2115 \u22a2 ack m (0 + 1) \u2264 ack (m + 1) 0\",\n   \"endPos\": {\"line\": 185, \"column\": 8}},\n  {\"tactic\": \"rw [ack_succ_succ]\",\n   \"proofState\": 110,\n   \"pos\": {\"line\": 186, \"column\": 4},\n   \"goals\": \"case succ m n : \u2115 \u22a2 ack m (n + 1 + 1) \u2264 ack (m + 1) (n + 1)\",\n   \"endPos\": {\"line\": 186, \"column\": 22}},\n  {\"tactic\": \"apply ack_mono_right m (le_trans _ <| add_add_one_le_ack _ n)\",\n   \"proofState\": 111,\n   \"pos\": {\"line\": 187, \"column\": 4},\n   \"goals\": \"case succ m n : \u2115 \u22a2 ack m (n + 1 + 1) \u2264 ack m (ack (m + 1) n)\",\n   \"endPos\": {\"line\": 187, \"column\": 65}},\n  {\"tactic\": \"omega\",\n   \"proofState\": 112,\n   \"pos\": {\"line\": 188, \"column\": 4},\n   \"goals\": \"m n : \u2115 \u22a2 n + 1 + 1 \u2264 m + 1 + n + 1\",\n   \"endPos\": {\"line\": 188, \"column\": 9}},\n  {\"tactic\": \"induction' n with k hk\",\n   \"proofState\": 113,\n   \"pos\": {\"line\": 194, \"column\": 2},\n   \"goals\": \"n : \u2115 \u22a2 n ^ 2 \u2264 2 ^ (n + 1) - 3\",\n   \"endPos\": {\"line\": 194, \"column\": 24}},\n  {\"tactic\": \"norm_num\",\n   \"proofState\": 114,\n   \"pos\": {\"line\": 195, \"column\": 4},\n   \"goals\": \"case zero \u22a2 0 ^ 2 \u2264 2 ^ (0 + 1) - 3\",\n   \"endPos\": {\"line\": 195, \"column\": 12}},\n  {\"tactic\": \"cases k\",\n   \"proofState\": 115,\n   \"pos\": {\"line\": 196, \"column\": 4},\n   \"goals\":\n   \"case succ k : \u2115 hk : k ^ 2 \u2264 2 ^ (k + 1) - 3 \u22a2 (k + 1) ^ 2 \u2264 2 ^ (k + 1 + 1) - 3\",\n   \"endPos\": {\"line\": 196, \"column\": 11}},\n  {\"tactic\": \"norm_num\",\n   \"proofState\": 116,\n   \"pos\": {\"line\": 196, \"column\": 13},\n   \"goals\":\n   \"case succ.zero\\nhk : 0 ^ 2 \u2264 2 ^ (0 + 1) - 3\\n\u22a2 (0 + 1) ^ 2 \u2264 2 ^ (0 + 1 + 1) - 3\\ncase succ.succ n\u271d : \u2115 hk : (n\u271d + 1) ^ 2 \u2264 2 ^ (n\u271d + 1 + 1) - 3 \u22a2 (n\u271d + 1 + 1) ^ 2 \u2264 2 ^ (n\u271d + 1 + 1 + 1) - 3\",\n   \"endPos\": {\"line\": 196, \"column\": 21}},\n  {\"tactic\": \"rw [add_sq, Nat.pow_succ, two_mul, add_assoc]\",\n   \"proofState\": 117,\n   \"pos\": {\"line\": 197, \"column\": 4},\n   \"goals\":\n   \"case succ.succ n\u271d : \u2115 hk : (n\u271d + 1) ^ 2 \u2264 2 ^ (n\u271d + 1 + 1) - 3 \u22a2 (n\u271d + 1 + 1) ^ 2 \u2264 2 ^ (n\u271d + 1 + 1 + 1) - 3\",\n   \"endPos\": {\"line\": 197, \"column\": 49}},\n  {\"tactic\": \"apply Nat.add_le_add hk\",\n   \"proofState\": 118,\n   \"pos\": {\"line\": 198, \"column\": 4},\n   \"goals\":\n   \"case succ.succ\\nn\u271d : \u2115\\nhk : (n\u271d + 1) ^ 2 \u2264 2 ^ (n\u271d + 1 + 1) - 3\\n\u22a2 (n\u271d + 1) ^ 1 * (n\u271d + 1) + ((n\u271d + 1 + (n\u271d + 1)) * 1 + 1 ^ 2) \u2264 2 ^ (n\u271d + 1 + 1 + 1) - 3\",\n   \"endPos\": {\"line\": 198, \"column\": 27}}],\n \"messages\":\n [{\"severity\": \"error\",\n   \"pos\": {\"line\": 198, \"column\": 4},\n   \"endPos\": {\"line\": 198, \"column\": 27},\n   \"data\":\n   \"tactic 'apply' failed, failed to unify\\n  (n\u271d + 1) ^ 2 + ?m.111626 \u2264 2 ^ (n\u271d + 1 + 1) - 3 + ?m.111627\\nwith\\n  (n\u271d + 1) ^ 1 * (n\u271d + 1) + ((n\u271d + 1 + (n\u271d + 1)) * 1 + 1 ^ 2) \u2264 2 ^ (n\u271d + 1 + 1 + 1) - 3\\ncase succ.succ\\nn\u271d : \u2115\\nhk : (n\u271d + 1) ^ 2 \u2264 2 ^ (n\u271d + 1 + 1) - 3\\n\u22a2 (n\u271d + 1) ^ 1 * (n\u271d + 1) + ((n\u271d + 1 + (n\u271d + 1)) * 1 + 1 ^ 2) \u2264 2 ^ (n\u271d + 1 + 1 + 1) - 3\"}],\n \"env\": 2}\n\n\n\nPANIC at List.head! Init.Data.List.BasicAux:62:12: empty list\nuncaught exception: unknown metavariable '?[anonymous]'\n"}, {"idx": 73, "error": "repl output/thms mismatch in length\n\nlen:3\n\n{\"env\": 0}\n\n\n\nPANIC at List.head! Init.Data.List.BasicAux:62:12: empty list\nuncaught exception: unknown metavariable '?[anonymous]'\n"}, {"idx": 73, "error": "repl output/thms mismatch in length\n\nlen:3\n\n{\"env\": 0}\n\n{\"theorems\":\n [{\"tactics\": [0, 1, 2, 3, 4, 5, 6, 7, 8],\n   \"start\": {\"line\": 1, \"column\": 0},\n   \"proofTree\":\n   [{\"tactic\": \"induction hyp with\",\n     \"spawned_children\": [1, 3],\n     \"children\": [1, 3]},\n    {\"tactic\": \"use [], s\", \"spawned_children\": [], \"children\": [2]},\n    {\"tactic\": \"simp\", \"spawned_children\": [], \"children\": []},\n    {\"tactic\": \"rcases ih with \u27e8p', q', rfl, rfl\u27e9\",\n     \"spawned_children\": [],\n     \"children\": [4]},\n    {\"tactic\": \"use x :: p', q'\", \"spawned_children\": [], \"children\": [5]},\n    {\"tactic\": \"simp\", \"spawned_children\": [], \"children\": []}],\n   \"messages\": [],\n   \"end\": {\"line\": 12, \"column\": 8},\n   \"decl\":\n   \"lemma Rewrites.exists_parts {r : ContextFreeRule T N} {u v : List (Symbol T N)}\\n    (hyp : r.Rewrites u v) :\\n    \u2203 p q : List (Symbol T N),\\n      u = p ++ [Symbol.nonterminal r.input] ++ q \u2227 v = p ++ r.output ++ q \"},\n  {\"tactics\": [0, 1, 2, 3, 4, 5, 6, 7, 8],\n   \"start\": {\"line\": 1, \"column\": 0},\n   \"proofTree\":\n   [{\"tactic\": \"induction hyp with\",\n     \"spawned_children\": [1, 3],\n     \"children\": [1, 3]},\n    {\"tactic\": \"use [], s\", \"spawned_children\": [], \"children\": [2]},\n    {\"tactic\": \"simp\", \"spawned_children\": [], \"children\": []},\n    {\"tactic\": \"rcases ih with \u27e8p', q', rfl, rfl\u27e9\",\n     \"spawned_children\": [],\n     \"children\": [4]},\n    {\"tactic\": \"use x :: p', q'\", \"spawned_children\": [], \"children\": [5]},\n    {\"tactic\": \"simp\", \"spawned_children\": [], \"children\": []}],\n   \"messages\": [],\n   \"end\": {\"line\": 12, \"column\": 8},\n   \"decl\":\n   \" theorem Rewrites.exists_parts {r : ContextFreeRule T N} {u v : List (Symbol T N)}\\n    (hyp : r.Rewrites u v) :\\n    \u2203 p q : List (Symbol T N),\\n      u = p ++ [Symbol.nonterminal r.input] ++ q \u2227 v = p ++ r.output ++ q \"},\n  {\"tactics\": [0, 1, 2, 3, 4, 5, 6, 7, 8],\n   \"start\": {\"line\": 1, \"column\": 0},\n   \"proofTree\":\n   [{\"tactic\": \"induction hyp with\",\n     \"spawned_children\": [1, 3],\n     \"children\": [1, 3]},\n    {\"tactic\": \"use [], s\", \"spawned_children\": [], \"children\": [2]},\n    {\"tactic\": \"simp\", \"spawned_children\": [], \"children\": []},\n    {\"tactic\": \"rcases ih with \u27e8p', q', rfl, rfl\u27e9\",\n     \"spawned_children\": [],\n     \"children\": [4]},\n    {\"tactic\": \"use x :: p', q'\", \"spawned_children\": [], \"children\": [5]},\n    {\"tactic\": \"simp\", \"spawned_children\": [], \"children\": []}],\n   \"messages\": [],\n   \"end\": {\"line\": 12, \"column\": 8},\n   \"decl\":\n   \" theorem exists_parts {r : ContextFreeRule T N} {u v : List (Symbol T N)}\\n    (hyp : r.Rewrites u v) :\\n    \u2203 p q : List (Symbol T N),\\n      u = p ++ [Symbol.nonterminal r.input] ++ q \u2227 v = p ++ r.output ++ q \"},\n  {\"tactics\": [9, 10, 11, 12, 13, 14],\n   \"start\": {\"line\": 14, \"column\": 0},\n   \"proofTree\":\n   [{\"tactic\": \"induction p with\",\n     \"spawned_children\": [1, 2],\n     \"children\": [1, 2]},\n    {\"tactic\": \"exact Rewrites.head q\", \"spawned_children\": [], \"children\": []},\n    {\"tactic\": \"exact Rewrites.cons d ih\",\n     \"spawned_children\": [],\n     \"children\": []}],\n   \"messages\": [],\n   \"end\": {\"line\": 18, \"column\": 43},\n   \"decl\":\n   \"lemma rewrites_of_exists_parts (r : ContextFreeRule T N) (p q : List (Symbol T N)) :\\n    r.Rewrites (p ++ [Symbol.nonterminal r.input] ++ q) (p ++ r.output ++ q) \"},\n  {\"tactics\": [9, 10, 11, 12, 13, 14],\n   \"start\": {\"line\": 14, \"column\": 0},\n   \"proofTree\":\n   [{\"tactic\": \"induction p with\",\n     \"spawned_children\": [1, 2],\n     \"children\": [1, 2]},\n    {\"tactic\": \"exact Rewrites.head q\", \"spawned_children\": [], \"children\": []},\n    {\"tactic\": \"exact Rewrites.cons d ih\",\n     \"spawned_children\": [],\n     \"children\": []}],\n   \"messages\": [],\n   \"end\": {\"line\": 18, \"column\": 43},\n   \"decl\":\n   \" theorem rewrites_of_exists_parts (r : ContextFreeRule T N) (p q : List (Symbol T N)) :\\n    r.Rewrites (p ++ [Symbol.nonterminal r.input] ++ q) (p ++ r.output ++ q) \"},\n  {\"tactics\": [15, 16],\n   \"start\": {\"line\": 20, \"column\": 0},\n   \"proofTree\":\n   [{\"tactic\": \"rintro \u27e8p, q, rfl, rfl\u27e9\",\n     \"spawned_children\": [],\n     \"children\": [1]},\n    {\"tactic\": \"apply rewrites_of_exists_parts\",\n     \"spawned_children\": [],\n     \"children\": []}],\n   \"messages\": [],\n   \"end\": {\"line\": 26, \"column\": 85},\n   \"decl\":\n   \"/-- Rule `r` rewrites string `u` is to string `v` iff they share both a prefix `p` and postfix `q`\\nsuch that the remaining middle part of `u` is the input of `r` and the remaining middle part\\nof `u` is the output of `r`. -/\\ntheorem rewrites_iff {r : ContextFreeRule T N} (u v : List (Symbol T N)) :\\n    r.Rewrites u v \u2194 \u2203 p q : List (Symbol T N),\\n      u = p ++ [Symbol.nonterminal r.input] ++ q \u2227 v = p ++ r.output ++ q \"},\n  {\"tactics\": [17, 18, 19, 20],\n   \"start\": {\"line\": 28, \"column\": 0},\n   \"proofTree\":\n   [{\"tactic\": \"rw [rewrites_iff]\", \"spawned_children\": [], \"children\": [1]},\n    {\"tactic\": \"rcases hvw with \u27e8x, y, hxy\u27e9\",\n     \"spawned_children\": [],\n     \"children\": [2]},\n    {\"tactic\": \"use p ++ x, y\", \"spawned_children\": [], \"children\": [3]},\n    {\"tactic\": \"simp_all\", \"spawned_children\": [], \"children\": []}],\n   \"messages\": [],\n   \"end\": {\"line\": 34, \"column\": 10},\n   \"decl\":\n   \"/-- Add extra prefix to context-free rewriting. -/\\nlemma Rewrites.append_left {r : ContextFreeRule T N} {v w : List (Symbol T N)}\\n    (hvw : r.Rewrites v w) (p : List (Symbol T N)) : r.Rewrites (p ++ v) (p ++ w) \"},\n  {\"tactics\": [17, 18, 19, 20],\n   \"start\": {\"line\": 28, \"column\": 0},\n   \"proofTree\":\n   [{\"tactic\": \"rw [rewrites_iff]\", \"spawned_children\": [], \"children\": [1]},\n    {\"tactic\": \"rcases hvw with \u27e8x, y, hxy\u27e9\",\n     \"spawned_children\": [],\n     \"children\": [2]},\n    {\"tactic\": \"use p ++ x, y\", \"spawned_children\": [], \"children\": [3]},\n    {\"tactic\": \"simp_all\", \"spawned_children\": [], \"children\": []}],\n   \"messages\": [],\n   \"end\": {\"line\": 34, \"column\": 10},\n   \"decl\":\n   \"/-- Add extra prefix to context-free rewriting. -/\\n theorem Rewrites.append_left {r : ContextFreeRule T N} {v w : List (Symbol T N)}\\n    (hvw : r.Rewrites v w) (p : List (Symbol T N)) : r.Rewrites (p ++ v) (p ++ w) \"},\n  {\"tactics\": [17, 18, 19, 20],\n   \"start\": {\"line\": 28, \"column\": 0},\n   \"proofTree\":\n   [{\"tactic\": \"rw [rewrites_iff]\", \"spawned_children\": [], \"children\": [1]},\n    {\"tactic\": \"rcases hvw with \u27e8x, y, hxy\u27e9\",\n     \"spawned_children\": [],\n     \"children\": [2]},\n    {\"tactic\": \"use p ++ x, y\", \"spawned_children\": [], \"children\": [3]},\n    {\"tactic\": \"simp_all\", \"spawned_children\": [], \"children\": []}],\n   \"messages\": [],\n   \"end\": {\"line\": 34, \"column\": 10},\n   \"decl\":\n   \"/-- Add extra prefix to context-free rewriting. -/\\n theorem append_left {r : ContextFreeRule T N} {v w : List (Symbol T N)}\\n    (hvw : r.Rewrites v w) (p : List (Symbol T N)) : r.Rewrites (p ++ v) (p ++ w) \"},\n  {\"tactics\": [21, 22, 23, 24],\n   \"start\": {\"line\": 36, \"column\": 0},\n   \"proofTree\":\n   [{\"tactic\": \"rw [rewrites_iff]\", \"spawned_children\": [], \"children\": [1]},\n    {\"tactic\": \"rcases hvw with \u27e8x, y, hxy\u27e9\",\n     \"spawned_children\": [],\n     \"children\": [2]},\n    {\"tactic\": \"use x, y ++ p\", \"spawned_children\": [], \"children\": [3]},\n    {\"tactic\": \"simp_all\", \"spawned_children\": [], \"children\": []}],\n   \"messages\": [],\n   \"end\": {\"line\": 42, \"column\": 10},\n   \"decl\":\n   \"/-- Add extra postfix to context-free rewriting. -/\\nlemma Rewrites.append_right {r : ContextFreeRule T N} {v w : List (Symbol T N)}\\n    (hvw : r.Rewrites v w) (p : List (Symbol T N)) : r.Rewrites (v ++ p) (w ++ p) \"},\n  {\"tactics\": [21, 22, 23, 24],\n   \"start\": {\"line\": 36, \"column\": 0},\n   \"proofTree\":\n   [{\"tactic\": \"rw [rewrites_iff]\", \"spawned_children\": [], \"children\": [1]},\n    {\"tactic\": \"rcases hvw with \u27e8x, y, hxy\u27e9\",\n     \"spawned_children\": [],\n     \"children\": [2]},\n    {\"tactic\": \"use x, y ++ p\", \"spawned_children\": [], \"children\": [3]},\n    {\"tactic\": \"simp_all\", \"spawned_children\": [], \"children\": []}],\n   \"messages\": [],\n   \"end\": {\"line\": 42, \"column\": 10},\n   \"decl\":\n   \"/-- Add extra postfix to context-free rewriting. -/\\n theorem Rewrites.append_right {r : ContextFreeRule T N} {v w : List (Symbol T N)}\\n    (hvw : r.Rewrites v w) (p : List (Symbol T N)) : r.Rewrites (v ++ p) (w ++ p) \"},\n  {\"tactics\": [21, 22, 23, 24],\n   \"start\": {\"line\": 36, \"column\": 0},\n   \"proofTree\":\n   [{\"tactic\": \"rw [rewrites_iff]\", \"spawned_children\": [], \"children\": [1]},\n    {\"tactic\": \"rcases hvw with \u27e8x, y, hxy\u27e9\",\n     \"spawned_children\": [],\n     \"children\": [2]},\n    {\"tactic\": \"use x, y ++ p\", \"spawned_children\": [], \"children\": [3]},\n    {\"tactic\": \"simp_all\", \"spawned_children\": [], \"children\": []}],\n   \"messages\": [],\n   \"end\": {\"line\": 42, \"column\": 10},\n   \"decl\":\n   \"/-- Add extra postfix to context-free rewriting. -/\\n theorem append_right {r : ContextFreeRule T N} {v w : List (Symbol T N)}\\n    (hvw : r.Rewrites v w) (p : List (Symbol T N)) : r.Rewrites (v ++ p) (w ++ p) \"},\n  {\"tactics\": [25],\n   \"start\": {\"line\": 70, \"column\": 0},\n   \"proofTree\": [{\"tactic\": \"rfl\", \"spawned_children\": [], \"children\": []}],\n   \"messages\": [],\n   \"end\": {\"line\": 76, \"column\": 5},\n   \"decl\":\n   \"/-- A given word `w` belongs to the language generated by a given context-free grammar `g` iff\\n`g` can derive the word `w` (wrapped as a string) from the initial nonterminal of `g` in some\\nnumber of steps. -/\\n@[simp]\\nlemma mem_language_iff (g : ContextFreeGrammar.{uN} T) (w : List T) :\\n    w \u2208 g.language \u2194 g.Derives [Symbol.nonterminal g.initial] (List.map Symbol.terminal w) \"},\n  {\"tactics\": [25],\n   \"start\": {\"line\": 70, \"column\": 0},\n   \"proofTree\": [{\"tactic\": \"rfl\", \"spawned_children\": [], \"children\": []}],\n   \"messages\": [],\n   \"end\": {\"line\": 76, \"column\": 5},\n   \"decl\":\n   \"/-- A given word `w` belongs to the language generated by a given context-free grammar `g` iff\\n`g` can derive the word `w` (wrapped as a string) from the initial nonterminal of `g` in some\\nnumber of steps. -/\\n@[simp]\\n theorem mem_language_iff (g : ContextFreeGrammar.{uN} T) (w : List T) :\\n    w \u2208 g.language \u2194 g.Derives [Symbol.nonterminal g.initial] (List.map Symbol.terminal w) \"},\n  {\"tactics\": [26, 27, 28, 29, 30, 31],\n   \"start\": {\"line\": 122, \"column\": 0},\n   \"proofTree\":\n   [{\"tactic\": \"induction hvw with\",\n     \"spawned_children\": [1, 2],\n     \"children\": [1, 2]},\n    {\"tactic\": \"rfl\", \"spawned_children\": [], \"children\": []},\n    {\"tactic\": \"exact ih.trans_produces <| last.append_left p\",\n     \"spawned_children\": [],\n     \"children\": []}],\n   \"messages\": [],\n   \"end\": {\"line\": 128, \"column\": 67},\n   \"decl\":\n   \"/-- Add extra prefix to context-free deriving. -/\\nlemma Derives.append_left {v w : List (Symbol T g.NT)}\\n    (hvw : g.Derives v w) (p : List (Symbol T g.NT)) :\\n    g.Derives (p ++ v) (p ++ w) \"},\n  {\"tactics\": [26, 27, 28, 29, 30, 31],\n   \"start\": {\"line\": 122, \"column\": 0},\n   \"proofTree\":\n   [{\"tactic\": \"induction hvw with\",\n     \"spawned_children\": [1, 2],\n     \"children\": [1, 2]},\n    {\"tactic\": \"rfl\", \"spawned_children\": [], \"children\": []},\n    {\"tactic\": \"exact ih.trans_produces <| last.append_left p\",\n     \"spawned_children\": [],\n     \"children\": []}],\n   \"messages\": [],\n   \"end\": {\"line\": 128, \"column\": 67},\n   \"decl\":\n   \"/-- Add extra prefix to context-free deriving. -/\\n theorem Derives.append_left {v w : List (Symbol T g.NT)}\\n    (hvw : g.Derives v w) (p : List (Symbol T g.NT)) :\\n    g.Derives (p ++ v) (p ++ w) \"},\n  {\"tactics\": [26, 27, 28, 29, 30, 31],\n   \"start\": {\"line\": 122, \"column\": 0},\n   \"proofTree\":\n   [{\"tactic\": \"induction hvw with\",\n     \"spawned_children\": [1, 2],\n     \"children\": [1, 2]},\n    {\"tactic\": \"rfl\", \"spawned_children\": [], \"children\": []},\n    {\"tactic\": \"exact ih.trans_produces <| last.append_left p\",\n     \"spawned_children\": [],\n     \"children\": []}],\n   \"messages\": [],\n   \"end\": {\"line\": 128, \"column\": 67},\n   \"decl\":\n   \"/-- Add extra prefix to context-free deriving. -/\\n theorem append_left {v w : List (Symbol T g.NT)}\\n    (hvw : g.Derives v w) (p : List (Symbol T g.NT)) :\\n    g.Derives (p ++ v) (p ++ w) \"},\n  {\"tactics\": [32, 33, 34, 35, 36, 37],\n   \"start\": {\"line\": 130, \"column\": 0},\n   \"proofTree\":\n   [{\"tactic\": \"induction hvw with\",\n     \"spawned_children\": [1, 2],\n     \"children\": [1, 2]},\n    {\"tactic\": \"rfl\", \"spawned_children\": [], \"children\": []},\n    {\"tactic\": \"exact ih.trans_produces <| last.append_right p\",\n     \"spawned_children\": [],\n     \"children\": []}],\n   \"messages\": [],\n   \"end\": {\"line\": 136, \"column\": 68},\n   \"decl\":\n   \"/-- Add extra prefix to context-free deriving. -/\\nlemma Derives.append_right {v w : List (Symbol T g.NT)}\\n    (hvw : g.Derives v w) (p : List (Symbol T g.NT)) :\\n    g.Derives (v ++ p) (w ++ p) \"},\n  {\"tactics\": [32, 33, 34, 35, 36, 37],\n   \"start\": {\"line\": 130, \"column\": 0},\n   \"proofTree\":\n   [{\"tactic\": \"induction hvw with\",\n     \"spawned_children\": [1, 2],\n     \"children\": [1, 2]},\n    {\"tactic\": \"rfl\", \"spawned_children\": [], \"children\": []},\n    {\"tactic\": \"exact ih.trans_produces <| last.append_right p\",\n     \"spawned_children\": [],\n     \"children\": []}],\n   \"messages\": [],\n   \"end\": {\"line\": 136, \"column\": 68},\n   \"decl\":\n   \"/-- Add extra prefix to context-free deriving. -/\\n theorem Derives.append_right {v w : List (Symbol T g.NT)}\\n    (hvw : g.Derives v w) (p : List (Symbol T g.NT)) :\\n    g.Derives (v ++ p) (w ++ p) \"},\n  {\"tactics\": [32, 33, 34, 35, 36, 37],\n   \"start\": {\"line\": 130, \"column\": 0},\n   \"proofTree\":\n   [{\"tactic\": \"induction hvw with\",\n     \"spawned_children\": [1, 2],\n     \"children\": [1, 2]},\n    {\"tactic\": \"rfl\", \"spawned_children\": [], \"children\": []},\n    {\"tactic\": \"exact ih.trans_produces <| last.append_right p\",\n     \"spawned_children\": [],\n     \"children\": []}],\n   \"messages\": [],\n   \"end\": {\"line\": 136, \"column\": 68},\n   \"decl\":\n   \"/-- Add extra prefix to context-free deriving. -/\\n theorem append_right {v w : List (Symbol T g.NT)}\\n    (hvw : g.Derives v w) (p : List (Symbol T g.NT)) :\\n    g.Derives (v ++ p) (w ++ p) \"},\n  {\"tactics\": [38, 39],\n   \"start\": {\"line\": 154, \"column\": 0},\n   \"proofTree\":\n   [{\"tactic\": \"intro x\", \"spawned_children\": [], \"children\": [1]},\n    {\"tactic\": \"simp [ContextFreeRule.reverse]\",\n     \"spawned_children\": [],\n     \"children\": []}],\n   \"messages\": [],\n   \"end\": {\"line\": 157, \"column\": 32},\n   \"decl\":\n   \"lemma ContextFreeRule.reverse_involutive {N : Type uN} :\\n    Function.Involutive (@ContextFreeRule.reverse T N) \"},\n  {\"tactics\": [38, 39],\n   \"start\": {\"line\": 154, \"column\": 0},\n   \"proofTree\":\n   [{\"tactic\": \"intro x\", \"spawned_children\": [], \"children\": [1]},\n    {\"tactic\": \"simp [ContextFreeRule.reverse]\",\n     \"spawned_children\": [],\n     \"children\": []}],\n   \"messages\": [],\n   \"end\": {\"line\": 157, \"column\": 32},\n   \"decl\":\n   \" theorem ContextFreeRule.reverse_involutive {N : Type uN} :\\n    Function.Involutive (@ContextFreeRule.reverse T N) \"},\n  {\"tactics\": [38, 39],\n   \"start\": {\"line\": 154, \"column\": 0},\n   \"proofTree\":\n   [{\"tactic\": \"intro x\", \"spawned_children\": [], \"children\": [1]},\n    {\"tactic\": \"simp [ContextFreeRule.reverse]\",\n     \"spawned_children\": [],\n     \"children\": []}],\n   \"messages\": [],\n   \"end\": {\"line\": 157, \"column\": 32},\n   \"decl\":\n   \" theorem reverse_involutive {N : Type uN} :\\n    Function.Involutive (@ContextFreeRule.reverse T N) \"},\n  {\"tactics\": [40, 41],\n   \"start\": {\"line\": 159, \"column\": 0},\n   \"proofTree\":\n   [{\"tactic\": \"intro x\", \"spawned_children\": [], \"children\": [1]},\n    {\"tactic\":\n     \"simp [ContextFreeGrammar.reverse, ContextFreeRule.reverse_involutive]\",\n     \"spawned_children\": [],\n     \"children\": []}],\n   \"messages\": [],\n   \"end\": {\"line\": 162, \"column\": 71},\n   \"decl\":\n   \"lemma ContextFreeGrammar.reverse_involutive :\\n    Function.Involutive (@ContextFreeGrammar.reverse T) \"},\n  {\"tactics\": [40, 41],\n   \"start\": {\"line\": 159, \"column\": 0},\n   \"proofTree\":\n   [{\"tactic\": \"intro x\", \"spawned_children\": [], \"children\": [1]},\n    {\"tactic\":\n     \"simp [ContextFreeGrammar.reverse, ContextFreeRule.reverse_involutive]\",\n     \"spawned_children\": [],\n     \"children\": []}],\n   \"messages\": [],\n   \"end\": {\"line\": 162, \"column\": 71},\n   \"decl\":\n   \" theorem ContextFreeGrammar.reverse_involutive :\\n    Function.Involutive (@ContextFreeGrammar.reverse T) \"},\n  {\"tactics\": [40, 41],\n   \"start\": {\"line\": 159, \"column\": 0},\n   \"proofTree\":\n   [{\"tactic\": \"intro x\", \"spawned_children\": [], \"children\": [1]},\n    {\"tactic\":\n     \"simp [ContextFreeGrammar.reverse, ContextFreeRule.reverse_involutive]\",\n     \"spawned_children\": [],\n     \"children\": []}],\n   \"messages\": [],\n   \"end\": {\"line\": 162, \"column\": 71},\n   \"decl\":\n   \" theorem reverse_involutive :\\n    Function.Involutive (@ContextFreeGrammar.reverse T) \"},\n  {\"tactics\": [42, 43, 44, 45, 46, 47],\n   \"start\": {\"line\": 165, \"column\": 1},\n   \"proofTree\":\n   [{\"tactic\": \"induction hgs with\",\n     \"spawned_children\": [1, 2],\n     \"children\": [1, 2]},\n    {\"tactic\": \"simp\", \"spawned_children\": [], \"children\": []},\n    {\"tactic\": \"rcases orig with \u27e8r, \u27e8r\u2080, rin\u2080, rfl\u27e9, rewr\u27e9\",\n     \"spawned_children\": [],\n     \"children\": []}],\n   \"messages\": [0, 1],\n   \"end\": {\"line\": 172, \"column\": 115},\n   \"decl\":\n   \"theorem reverse_derives (g : ContextFreeGrammar T) {s : List (Symbol T g.NT)}\\n    (hgs : g.reverse.Derives [Symbol.nonterminal g.reverse.initial] s) :\\n    g.Derives [Symbol.nonterminal g.initial] s.reverse  \"}],\n \"tactics\":\n [{\"tactic\":\n   \"induction hyp with\\n| head s =>\\n  use[], s\\n  simp\\n| cons x _ ih =>\\n  rcases ih with \u27e8p', q', rfl, rfl\u27e9\\n  use x :: p', q'\\n  simp\",\n   \"proofState\": 0,\n   \"pos\": {\"line\": 5, \"column\": 2},\n   \"goals\":\n   \"T : Type uT\\nN : Type uN\\nr : ContextFreeRule T N\\nu v : List (Symbol T N)\\nhyp : r.Rewrites u v\\n\u22a2 \u2203 p q, u = p ++ [Symbol.nonterminal r.input] ++ q \u2227 v = p ++ r.output ++ q\",\n   \"endPos\": {\"line\": 12, \"column\": 8}},\n  {\"tactic\":\n   \"induction hyp with\\n| head s =>\\n  use[], s\\n  simp\\n| cons x _ ih =>\\n  rcases ih with \u27e8p', q', rfl, rfl\u27e9\\n  use x :: p', q'\\n  simp\",\n   \"proofState\": 1,\n   \"pos\": {\"line\": 5, \"column\": 2},\n   \"goals\":\n   \"T : Type uT\\nN : Type uN\\nr : ContextFreeRule T N\\nu v : List (Symbol T N)\\nhyp : r.Rewrites u v\\n\u22a2 \u2203 p q, u = p ++ [Symbol.nonterminal r.input] ++ q \u2227 v = p ++ r.output ++ q\",\n   \"endPos\": {\"line\": 12, \"column\": 8}},\n  {\"tactic\": \"\\n| head s =>\\n  use[], s\\n  simp\",\n   \"proofState\": 2,\n   \"pos\": {\"line\": 6, \"column\": 2},\n   \"goals\":\n   \"case head\\nT : Type uT\\nN : Type uN\\nr : ContextFreeRule T N\\nu v s : List (Symbol T N)\\n\u22a2 \u2203 p q, Symbol.nonterminal r.input :: s = p ++ [Symbol.nonterminal r.input] ++ q \u2227 r.output ++ s = p ++ r.output ++ q\",\n   \"endPos\": {\"line\": 8, \"column\": 8}},\n  {\"tactic\": \"use[], s\",\n   \"proofState\": 3,\n   \"pos\": {\"line\": 7, \"column\": 4},\n   \"goals\":\n   \"case head\\nT : Type uT\\nN : Type uN\\nr : ContextFreeRule T N\\nu v s : List (Symbol T N)\\n\u22a2 \u2203 p q, Symbol.nonterminal r.input :: s = p ++ [Symbol.nonterminal r.input] ++ q \u2227 r.output ++ s = p ++ r.output ++ q\",\n   \"endPos\": {\"line\": 7, \"column\": 13}},\n  {\"tactic\": \"simp\",\n   \"proofState\": 4,\n   \"pos\": {\"line\": 8, \"column\": 4},\n   \"goals\":\n   \"case h\\nT : Type uT\\nN : Type uN\\nr : ContextFreeRule T N\\nu v s : List (Symbol T N)\\n\u22a2 Symbol.nonterminal r.input :: s = [] ++ [Symbol.nonterminal r.input] ++ s \u2227 r.output ++ s = [] ++ r.output ++ s\",\n   \"endPos\": {\"line\": 8, \"column\": 8}},\n  {\"tactic\":\n   \"\\n| cons x _ ih =>\\n  rcases ih with \u27e8p', q', rfl, rfl\u27e9\\n  use x :: p', q'\\n  simp\",\n   \"proofState\": 5,\n   \"pos\": {\"line\": 9, \"column\": 2},\n   \"goals\":\n   \"case cons\\nT : Type uT\\nN : Type uN\\nr : ContextFreeRule T N\\nu v : List (Symbol T N)\\nx : Symbol T N\\ns\u2081\u271d s\u2082\u271d : List (Symbol T N)\\nhrs\u271d : r.Rewrites s\u2081\u271d s\u2082\u271d\\nih : \u2203 p q, s\u2081\u271d = p ++ [Symbol.nonterminal r.input] ++ q \u2227 s\u2082\u271d = p ++ r.output ++ q\\n\u22a2 \u2203 p q, x :: s\u2081\u271d = p ++ [Symbol.nonterminal r.input] ++ q \u2227 x :: s\u2082\u271d = p ++ r.output ++ q\",\n   \"endPos\": {\"line\": 12, \"column\": 8}},\n  {\"tactic\": \"rcases ih with \u27e8p', q', rfl, rfl\u27e9\",\n   \"proofState\": 6,\n   \"pos\": {\"line\": 10, \"column\": 4},\n   \"goals\":\n   \"case cons\\nT : Type uT\\nN : Type uN\\nr : ContextFreeRule T N\\nu v : List (Symbol T N)\\nx : Symbol T N\\ns\u2081\u271d s\u2082\u271d : List (Symbol T N)\\nhrs\u271d : r.Rewrites s\u2081\u271d s\u2082\u271d\\nih : \u2203 p q, s\u2081\u271d = p ++ [Symbol.nonterminal r.input] ++ q \u2227 s\u2082\u271d = p ++ r.output ++ q\\n\u22a2 \u2203 p q, x :: s\u2081\u271d = p ++ [Symbol.nonterminal r.input] ++ q \u2227 x :: s\u2082\u271d = p ++ r.output ++ q\",\n   \"endPos\": {\"line\": 10, \"column\": 37}},\n  {\"tactic\": \"use x :: p', q'\",\n   \"proofState\": 7,\n   \"pos\": {\"line\": 11, \"column\": 4},\n   \"goals\":\n   \"case cons.intro.intro.intro\\nT : Type uT\\nN : Type uN\\nr : ContextFreeRule T N\\nu v : List (Symbol T N)\\nx : Symbol T N\\np' q' : List (Symbol T N)\\nhrs\u271d : r.Rewrites (p' ++ [Symbol.nonterminal r.input] ++ q') (p' ++ r.output ++ q')\\n\u22a2 \u2203 p q,\\n    x :: (p' ++ [Symbol.nonterminal r.input] ++ q') = p ++ [Symbol.nonterminal r.input] ++ q \u2227\\n      x :: (p' ++ r.output ++ q') = p ++ r.output ++ q\",\n   \"endPos\": {\"line\": 11, \"column\": 19}},\n  {\"tactic\": \"simp\",\n   \"proofState\": 8,\n   \"pos\": {\"line\": 12, \"column\": 4},\n   \"goals\":\n   \"case h\\nT : Type uT\\nN : Type uN\\nr : ContextFreeRule T N\\nu v : List (Symbol T N)\\nx : Symbol T N\\np' q' : List (Symbol T N)\\nhrs\u271d : r.Rewrites (p' ++ [Symbol.nonterminal r.input] ++ q') (p' ++ r.output ++ q')\\n\u22a2 x :: (p' ++ [Symbol.nonterminal r.input] ++ q') = x :: p' ++ [Symbol.nonterminal r.input] ++ q' \u2227\\n    x :: (p' ++ r.output ++ q') = x :: p' ++ r.output ++ q'\",\n   \"endPos\": {\"line\": 12, \"column\": 8}},\n  {\"tactic\":\n   \"induction p with\\n| nil => exact Rewrites.head q\\n| cons d l ih => exact Rewrites.cons d ih\",\n   \"proofState\": 9,\n   \"pos\": {\"line\": 16, \"column\": 2},\n   \"goals\":\n   \"T : Type uT\\nN : Type uN\\nr : ContextFreeRule T N\\np q : List (Symbol T N)\\n\u22a2 r.Rewrites (p ++ [Symbol.nonterminal r.input] ++ q) (p ++ r.output ++ q)\",\n   \"endPos\": {\"line\": 18, \"column\": 43}},\n  {\"tactic\":\n   \"induction p with\\n| nil => exact Rewrites.head q\\n| cons d l ih => exact Rewrites.cons d ih\",\n   \"proofState\": 10,\n   \"pos\": {\"line\": 16, \"column\": 2},\n   \"goals\":\n   \"T : Type uT\\nN : Type uN\\nr : ContextFreeRule T N\\np q : List (Symbol T N)\\n\u22a2 r.Rewrites (p ++ [Symbol.nonterminal r.input] ++ q) (p ++ r.output ++ q)\",\n   \"endPos\": {\"line\": 18, \"column\": 43}},\n  {\"tactic\": \"\\n| nil => exact Rewrites.head q\",\n   \"proofState\": 11,\n   \"pos\": {\"line\": 17, \"column\": 2},\n   \"goals\":\n   \"case nil\\nT : Type uT\\nN : Type uN\\nr : ContextFreeRule T N\\nq : List (Symbol T N)\\n\u22a2 r.Rewrites ([] ++ [Symbol.nonterminal r.input] ++ q) ([] ++ r.output ++ q)\",\n   \"endPos\": {\"line\": 17, \"column\": 40}},\n  {\"tactic\": \"exact Rewrites.head q\",\n   \"proofState\": 12,\n   \"pos\": {\"line\": 17, \"column\": 19},\n   \"goals\":\n   \"case nil\\nT : Type uT\\nN : Type uN\\nr : ContextFreeRule T N\\nq : List (Symbol T N)\\n\u22a2 r.Rewrites ([] ++ [Symbol.nonterminal r.input] ++ q) ([] ++ r.output ++ q)\",\n   \"endPos\": {\"line\": 17, \"column\": 40}},\n  {\"tactic\": \"\\n| cons d l ih => exact Rewrites.cons d ih\",\n   \"proofState\": 13,\n   \"pos\": {\"line\": 18, \"column\": 2},\n   \"goals\":\n   \"case cons\\nT : Type uT\\nN : Type uN\\nr : ContextFreeRule T N\\nq : List (Symbol T N)\\nd : Symbol T N\\nl : List (Symbol T N)\\nih : r.Rewrites (l ++ [Symbol.nonterminal r.input] ++ q) (l ++ r.output ++ q)\\n\u22a2 r.Rewrites (d :: l ++ [Symbol.nonterminal r.input] ++ q) (d :: l ++ r.output ++ q)\",\n   \"endPos\": {\"line\": 18, \"column\": 43}},\n  {\"tactic\": \"exact Rewrites.cons d ih\",\n   \"proofState\": 14,\n   \"pos\": {\"line\": 18, \"column\": 19},\n   \"goals\":\n   \"case cons\\nT : Type uT\\nN : Type uN\\nr : ContextFreeRule T N\\nq : List (Symbol T N)\\nd : Symbol T N\\nl : List (Symbol T N)\\nih : r.Rewrites (l ++ [Symbol.nonterminal r.input] ++ q) (l ++ r.output ++ q)\\n\u22a2 r.Rewrites (d :: l ++ [Symbol.nonterminal r.input] ++ q) (d :: l ++ r.output ++ q)\",\n   \"endPos\": {\"line\": 18, \"column\": 43}},\n  {\"tactic\": \"rintro \u27e8p, q, rfl, rfl\u27e9\",\n   \"proofState\": 15,\n   \"pos\": {\"line\": 26, \"column\": 29},\n   \"goals\":\n   \"T : Type uT\\nN : Type uN\\nr : ContextFreeRule T N\\nu v : List (Symbol T N)\\n\u22a2 (\u2203 p q, u = p ++ [Symbol.nonterminal r.input] ++ q \u2227 v = p ++ r.output ++ q) \u2192 r.Rewrites u v\",\n   \"endPos\": {\"line\": 26, \"column\": 52}},\n  {\"tactic\": \"apply rewrites_of_exists_parts\",\n   \"proofState\": 16,\n   \"pos\": {\"line\": 26, \"column\": 54},\n   \"goals\":\n   \"case intro.intro.intro\\nT : Type uT\\nN : Type uN\\nr : ContextFreeRule T N\\np q : List (Symbol T N)\\n\u22a2 r.Rewrites (p ++ [Symbol.nonterminal r.input] ++ q) (p ++ r.output ++ q)\",\n   \"endPos\": {\"line\": 26, \"column\": 84}},\n  {\"tactic\": \"rw [rewrites_iff] at *\",\n   \"proofState\": 17,\n   \"pos\": {\"line\": 31, \"column\": 2},\n   \"goals\":\n   \"T : Type uT\\nN : Type uN\\nr : ContextFreeRule T N\\nv w : List (Symbol T N)\\nhvw : r.Rewrites v w\\np : List (Symbol T N)\\n\u22a2 r.Rewrites (p ++ v) (p ++ w)\",\n   \"endPos\": {\"line\": 31, \"column\": 24}},\n  {\"tactic\": \"rcases hvw with \u27e8x, y, hxy\u27e9\",\n   \"proofState\": 18,\n   \"pos\": {\"line\": 32, \"column\": 2},\n   \"goals\":\n   \"T : Type uT\\nN : Type uN\\nr : ContextFreeRule T N\\nv w : List (Symbol T N)\\nhvw : \u2203 p q, v = p ++ [Symbol.nonterminal r.input] ++ q \u2227 w = p ++ r.output ++ q\\np : List (Symbol T N)\\n\u22a2 \u2203 p_1 q, p ++ v = p_1 ++ [Symbol.nonterminal r.input] ++ q \u2227 p ++ w = p_1 ++ r.output ++ q\",\n   \"endPos\": {\"line\": 32, \"column\": 29}},\n  {\"tactic\": \"use p ++ x, y\",\n   \"proofState\": 19,\n   \"pos\": {\"line\": 33, \"column\": 2},\n   \"goals\":\n   \"case intro.intro\\nT : Type uT\\nN : Type uN\\nr : ContextFreeRule T N\\nv w p x y : List (Symbol T N)\\nhxy : v = x ++ [Symbol.nonterminal r.input] ++ y \u2227 w = x ++ r.output ++ y\\n\u22a2 \u2203 p_1 q, p ++ v = p_1 ++ [Symbol.nonterminal r.input] ++ q \u2227 p ++ w = p_1 ++ r.output ++ q\",\n   \"endPos\": {\"line\": 33, \"column\": 15}},\n  {\"tactic\": \"simp_all\",\n   \"proofState\": 20,\n   \"pos\": {\"line\": 34, \"column\": 2},\n   \"goals\":\n   \"case h\\nT : Type uT\\nN : Type uN\\nr : ContextFreeRule T N\\nv w p x y : List (Symbol T N)\\nhxy : v = x ++ [Symbol.nonterminal r.input] ++ y \u2227 w = x ++ r.output ++ y\\n\u22a2 p ++ v = p ++ x ++ [Symbol.nonterminal r.input] ++ y \u2227 p ++ w = p ++ x ++ r.output ++ y\",\n   \"endPos\": {\"line\": 34, \"column\": 10}},\n  {\"tactic\": \"rw [rewrites_iff] at *\",\n   \"proofState\": 21,\n   \"pos\": {\"line\": 39, \"column\": 2},\n   \"goals\":\n   \"T : Type uT\\nN : Type uN\\nr : ContextFreeRule T N\\nv w : List (Symbol T N)\\nhvw : r.Rewrites v w\\np : List (Symbol T N)\\n\u22a2 r.Rewrites (v ++ p) (w ++ p)\",\n   \"endPos\": {\"line\": 39, \"column\": 24}},\n  {\"tactic\": \"rcases hvw with \u27e8x, y, hxy\u27e9\",\n   \"proofState\": 22,\n   \"pos\": {\"line\": 40, \"column\": 2},\n   \"goals\":\n   \"T : Type uT\\nN : Type uN\\nr : ContextFreeRule T N\\nv w : List (Symbol T N)\\nhvw : \u2203 p q, v = p ++ [Symbol.nonterminal r.input] ++ q \u2227 w = p ++ r.output ++ q\\np : List (Symbol T N)\\n\u22a2 \u2203 p_1 q, v ++ p = p_1 ++ [Symbol.nonterminal r.input] ++ q \u2227 w ++ p = p_1 ++ r.output ++ q\",\n   \"endPos\": {\"line\": 40, \"column\": 29}},\n  {\"tactic\": \"use x, y ++ p\",\n   \"proofState\": 23,\n   \"pos\": {\"line\": 41, \"column\": 2},\n   \"goals\":\n   \"case intro.intro\\nT : Type uT\\nN : Type uN\\nr : ContextFreeRule T N\\nv w p x y : List (Symbol T N)\\nhxy : v = x ++ [Symbol.nonterminal r.input] ++ y \u2227 w = x ++ r.output ++ y\\n\u22a2 \u2203 p_1 q, v ++ p = p_1 ++ [Symbol.nonterminal r.input] ++ q \u2227 w ++ p = p_1 ++ r.output ++ q\",\n   \"endPos\": {\"line\": 41, \"column\": 15}},\n  {\"tactic\": \"simp_all\",\n   \"proofState\": 24,\n   \"pos\": {\"line\": 42, \"column\": 2},\n   \"goals\":\n   \"case h\\nT : Type uT\\nN : Type uN\\nr : ContextFreeRule T N\\nv w p x y : List (Symbol T N)\\nhxy : v = x ++ [Symbol.nonterminal r.input] ++ y \u2227 w = x ++ r.output ++ y\\n\u22a2 v ++ p = x ++ [Symbol.nonterminal r.input] ++ (y ++ p) \u2227 w ++ p = x ++ r.output ++ (y ++ p)\",\n   \"endPos\": {\"line\": 42, \"column\": 10}},\n  {\"tactic\": \"rfl\",\n   \"proofState\": 25,\n   \"pos\": {\"line\": 76, \"column\": 2},\n   \"goals\":\n   \"T : Type uT\\ng : ContextFreeGrammar T\\nw : List T\\n\u22a2 w \u2208 g.language \u2194 g.Derives [Symbol.nonterminal g.initial] (List.map Symbol.terminal w)\",\n   \"endPos\": {\"line\": 76, \"column\": 5}},\n  {\"tactic\":\n   \"induction hvw with\\n| refl => rfl\\n| tail _ last ih => exact ih.trans_produces <| last.append_left p\",\n   \"proofState\": 26,\n   \"pos\": {\"line\": 126, \"column\": 2},\n   \"goals\":\n   \"T : Type uT\\ng : ContextFreeGrammar T\\nv w : List (Symbol T g.NT)\\nhvw : g.Derives v w\\np : List (Symbol T g.NT)\\n\u22a2 g.Derives (p ++ v) (p ++ w)\",\n   \"endPos\": {\"line\": 128, \"column\": 67}},\n  {\"tactic\":\n   \"induction hvw with\\n| refl => rfl\\n| tail _ last ih => exact ih.trans_produces <| last.append_left p\",\n   \"proofState\": 27,\n   \"pos\": {\"line\": 126, \"column\": 2},\n   \"goals\":\n   \"T : Type uT\\ng : ContextFreeGrammar T\\nv w : List (Symbol T g.NT)\\nhvw : g.Derives v w\\np : List (Symbol T g.NT)\\n\u22a2 g.Derives (p ++ v) (p ++ w)\",\n   \"endPos\": {\"line\": 128, \"column\": 67}},\n  {\"tactic\": \"\\n| refl => rfl\",\n   \"proofState\": 28,\n   \"pos\": {\"line\": 127, \"column\": 2},\n   \"goals\":\n   \"case refl T : Type uT g : ContextFreeGrammar T v w p : List (Symbol T g.NT) \u22a2 g.Derives (p ++ v) (p ++ v)\",\n   \"endPos\": {\"line\": 127, \"column\": 15}},\n  {\"tactic\": \"rfl\",\n   \"proofState\": 29,\n   \"pos\": {\"line\": 127, \"column\": 12},\n   \"goals\":\n   \"case refl T : Type uT g : ContextFreeGrammar T v w p : List (Symbol T g.NT) \u22a2 g.Derives (p ++ v) (p ++ v)\",\n   \"endPos\": {\"line\": 127, \"column\": 15}},\n  {\"tactic\":\n   \"\\n| tail _ last ih => exact ih.trans_produces <| last.append_left p\",\n   \"proofState\": 30,\n   \"pos\": {\"line\": 128, \"column\": 2},\n   \"goals\":\n   \"case tail\\nT : Type uT\\ng : ContextFreeGrammar T\\nv w p b\u271d c\u271d : List (Symbol T g.NT)\\na\u271d : Relation.ReflTransGen g.Produces v b\u271d\\nlast : g.Produces b\u271d c\u271d\\nih : g.Derives (p ++ v) (p ++ b\u271d)\\n\u22a2 g.Derives (p ++ v) (p ++ c\u271d)\",\n   \"endPos\": {\"line\": 128, \"column\": 67}},\n  {\"tactic\": \"exact ih.trans_produces <| last.append_left p\",\n   \"proofState\": 31,\n   \"pos\": {\"line\": 128, \"column\": 22},\n   \"goals\":\n   \"case tail\\nT : Type uT\\ng : ContextFreeGrammar T\\nv w p b\u271d c\u271d : List (Symbol T g.NT)\\na\u271d : Relation.ReflTransGen g.Produces v b\u271d\\nlast : g.Produces b\u271d c\u271d\\nih : g.Derives (p ++ v) (p ++ b\u271d)\\n\u22a2 g.Derives (p ++ v) (p ++ c\u271d)\",\n   \"endPos\": {\"line\": 128, \"column\": 67}},\n  {\"tactic\":\n   \"induction hvw with\\n| refl => rfl\\n| tail _ last ih => exact ih.trans_produces <| last.append_right p\",\n   \"proofState\": 32,\n   \"pos\": {\"line\": 134, \"column\": 2},\n   \"goals\":\n   \"T : Type uT\\ng : ContextFreeGrammar T\\nv w : List (Symbol T g.NT)\\nhvw : g.Derives v w\\np : List (Symbol T g.NT)\\n\u22a2 g.Derives (v ++ p) (w ++ p)\",\n   \"endPos\": {\"line\": 136, \"column\": 68}},\n  {\"tactic\":\n   \"induction hvw with\\n| refl => rfl\\n| tail _ last ih => exact ih.trans_produces <| last.append_right p\",\n   \"proofState\": 33,\n   \"pos\": {\"line\": 134, \"column\": 2},\n   \"goals\":\n   \"T : Type uT\\ng : ContextFreeGrammar T\\nv w : List (Symbol T g.NT)\\nhvw : g.Derives v w\\np : List (Symbol T g.NT)\\n\u22a2 g.Derives (v ++ p) (w ++ p)\",\n   \"endPos\": {\"line\": 136, \"column\": 68}},\n  {\"tactic\": \"\\n| refl => rfl\",\n   \"proofState\": 34,\n   \"pos\": {\"line\": 135, \"column\": 2},\n   \"goals\":\n   \"case refl T : Type uT g : ContextFreeGrammar T v w p : List (Symbol T g.NT) \u22a2 g.Derives (v ++ p) (v ++ p)\",\n   \"endPos\": {\"line\": 135, \"column\": 15}},\n  {\"tactic\": \"rfl\",\n   \"proofState\": 35,\n   \"pos\": {\"line\": 135, \"column\": 12},\n   \"goals\":\n   \"case refl T : Type uT g : ContextFreeGrammar T v w p : List (Symbol T g.NT) \u22a2 g.Derives (v ++ p) (v ++ p)\",\n   \"endPos\": {\"line\": 135, \"column\": 15}},\n  {\"tactic\":\n   \"\\n| tail _ last ih => exact ih.trans_produces <| last.append_right p\",\n   \"proofState\": 36,\n   \"pos\": {\"line\": 136, \"column\": 2},\n   \"goals\":\n   \"case tail\\nT : Type uT\\ng : ContextFreeGrammar T\\nv w p b\u271d c\u271d : List (Symbol T g.NT)\\na\u271d : Relation.ReflTransGen g.Produces v b\u271d\\nlast : g.Produces b\u271d c\u271d\\nih : g.Derives (v ++ p) (b\u271d ++ p)\\n\u22a2 g.Derives (v ++ p) (c\u271d ++ p)\",\n   \"endPos\": {\"line\": 136, \"column\": 68}},\n  {\"tactic\": \"exact ih.trans_produces <| last.append_right p\",\n   \"proofState\": 37,\n   \"pos\": {\"line\": 136, \"column\": 22},\n   \"goals\":\n   \"case tail\\nT : Type uT\\ng : ContextFreeGrammar T\\nv w p b\u271d c\u271d : List (Symbol T g.NT)\\na\u271d : Relation.ReflTransGen g.Produces v b\u271d\\nlast : g.Produces b\u271d c\u271d\\nih : g.Derives (v ++ p) (b\u271d ++ p)\\n\u22a2 g.Derives (v ++ p) (c\u271d ++ p)\",\n   \"endPos\": {\"line\": 136, \"column\": 68}},\n  {\"tactic\": \"intro x\",\n   \"proofState\": 38,\n   \"pos\": {\"line\": 156, \"column\": 2},\n   \"goals\": \"T : Type uT N : Type uN \u22a2 Function.Involutive reverse\",\n   \"endPos\": {\"line\": 156, \"column\": 9}},\n  {\"tactic\": \"simp [ContextFreeRule.reverse]\",\n   \"proofState\": 39,\n   \"pos\": {\"line\": 157, \"column\": 2},\n   \"goals\":\n   \"T : Type uT N : Type uN x : ContextFreeRule T N \u22a2 x.reverse.reverse = x\",\n   \"endPos\": {\"line\": 157, \"column\": 32}},\n  {\"tactic\": \"intro x\",\n   \"proofState\": 40,\n   \"pos\": {\"line\": 161, \"column\": 2},\n   \"goals\": \"T : Type uT \u22a2 Function.Involutive reverse\",\n   \"endPos\": {\"line\": 161, \"column\": 9}},\n  {\"tactic\":\n   \"simp [ContextFreeGrammar.reverse, ContextFreeRule.reverse_involutive]\",\n   \"proofState\": 41,\n   \"pos\": {\"line\": 162, \"column\": 2},\n   \"goals\": \"T : Type uT x : ContextFreeGrammar T \u22a2 x.reverse.reverse = x\",\n   \"endPos\": {\"line\": 162, \"column\": 71}},\n  {\"tactic\":\n   \"induction hgs with\\n| refl => simp\\n| tail _ orig ih =>\\n  rcases orig with \u27e8r, \u27e8r\u2080, rin\u2080, rfl\u27e9, rewr\u27e9\\n  exact ih.trans_produces \u27e8r\u2080, rin\u2080, by simpa [ContextFreeRule.reverse, ContextFreeRule.rewrites_iff] using rewr\u27e9\",\n   \"proofState\": 42,\n   \"pos\": {\"line\": 168, \"column\": 2},\n   \"goals\":\n   \"T : Type uT\\ng : ContextFreeGrammar T\\ns : List (Symbol T g.NT)\\nhgs : g.reverse.Derives [Symbol.nonterminal g.reverse.initial] s\\n\u22a2 g.Derives [Symbol.nonterminal g.initial] s.reverse\",\n   \"endPos\": {\"line\": 172, \"column\": 115}},\n  {\"tactic\":\n   \"induction hgs with\\n| refl => simp\\n| tail _ orig ih =>\\n  rcases orig with \u27e8r, \u27e8r\u2080, rin\u2080, rfl\u27e9, rewr\u27e9\\n  exact ih.trans_produces \u27e8r\u2080, rin\u2080, by simpa [ContextFreeRule.reverse, ContextFreeRule.rewrites_iff] using rewr\u27e9\",\n   \"proofState\": 43,\n   \"pos\": {\"line\": 168, \"column\": 2},\n   \"goals\":\n   \"T : Type uT\\ng : ContextFreeGrammar T\\ns : List (Symbol T g.NT)\\nhgs : g.reverse.Derives [Symbol.nonterminal g.reverse.initial] s\\n\u22a2 g.Derives [Symbol.nonterminal g.initial] s.reverse\",\n   \"endPos\": {\"line\": 172, \"column\": 115}},\n  {\"tactic\": \"\\n| refl => simp\",\n   \"proofState\": 44,\n   \"pos\": {\"line\": 169, \"column\": 2},\n   \"goals\":\n   \"case refl\\nT : Type uT\\ng : ContextFreeGrammar T\\ns : List (Symbol T g.NT)\\n\u22a2 g.Derives [Symbol.nonterminal g.initial] [Symbol.nonterminal g.reverse.initial].reverse\",\n   \"endPos\": {\"line\": 169, \"column\": 16}},\n  {\"tactic\": \"simp\",\n   \"proofState\": 45,\n   \"pos\": {\"line\": 169, \"column\": 12},\n   \"goals\":\n   \"case refl\\nT : Type uT\\ng : ContextFreeGrammar T\\ns : List (Symbol T g.NT)\\n\u22a2 g.Derives [Symbol.nonterminal g.initial] [Symbol.nonterminal g.reverse.initial].reverse\",\n   \"endPos\": {\"line\": 169, \"column\": 16}},\n  {\"tactic\":\n   \"\\n| tail _ orig ih =>\\n  rcases orig with \u27e8r, \u27e8r\u2080, rin\u2080, rfl\u27e9, rewr\u27e9\\n  exact ih.trans_produces \u27e8r\u2080, rin\u2080, by simpa [ContextFreeRule.reverse, ContextFreeRule.rewrites_iff] using rewr\u27e9\",\n   \"proofState\": 46,\n   \"pos\": {\"line\": 170, \"column\": 2},\n   \"goals\":\n   \"case tail\\nT : Type uT\\ng : ContextFreeGrammar T\\ns b\u271d c\u271d : List (Symbol T g.NT)\\na\u271d : Relation.ReflTransGen g.reverse.Produces [Symbol.nonterminal g.reverse.initial] b\u271d\\norig : g.reverse.Produces b\u271d c\u271d\\nih : g.Derives [Symbol.nonterminal g.initial] b\u271d.reverse\\n\u22a2 g.Derives [Symbol.nonterminal g.initial] c\u271d.reverse\",\n   \"endPos\": {\"line\": 172, \"column\": 115}},\n  {\"tactic\": \"rcases orig with \u27e8r, \u27e8r\u2080, rin\u2080, rfl\u27e9, rewr\u27e9\",\n   \"proofState\": 47,\n   \"pos\": {\"line\": 171, \"column\": 4},\n   \"goals\":\n   \"case tail\\nT : Type uT\\ng : ContextFreeGrammar T\\ns b\u271d c\u271d : List (Symbol T g.NT)\\na\u271d : Relation.ReflTransGen g.reverse.Produces [Symbol.nonterminal g.reverse.initial] b\u271d\\norig : g.reverse.Produces b\u271d c\u271d\\nih : g.Derives [Symbol.nonterminal g.initial] b\u271d.reverse\\n\u22a2 g.Derives [Symbol.nonterminal g.initial] c\u271d.reverse\",\n   \"endPos\": {\"line\": 171, \"column\": 47}}],\n \"messages\":\n [{\"severity\": \"error\",\n   \"pos\": {\"line\": 169, \"column\": 9},\n   \"endPos\": {\"line\": 169, \"column\": 16},\n   \"data\":\n   \"unsolved goals\\ncase refl\\nT : Type uT\\ng : ContextFreeGrammar T\\ns : List (Symbol T g.NT)\\n\u22a2 g.Derives [Symbol.nonterminal g.initial] [Symbol.nonterminal g.reverse.initial]\"},\n  {\"severity\": \"error\",\n   \"pos\": {\"line\": 171, \"column\": 25},\n   \"endPos\": {\"line\": 171, \"column\": 40},\n   \"data\":\n   \"tactic 'cases' failed, nested error:\\ndependent elimination failed, failed to solve equation\\n  List.map ContextFreeRule.reverse g.rules = r :: as\u271d\\nat case List.Mem.head\"}],\n \"env\": 1}\n\n\n\nPANIC at List.head! Init.Data.List.BasicAux:62:12: empty list\nuncaught exception: unknown metavariable '?[anonymous]'\n"}, {"idx": 73, "error": "repl output/thms mismatch in length\n\nlen:3\n\n{\"env\": 0}\n\n{\"theorems\":\n [{\"tactics\": [0],\n   \"start\": {\"line\": 1, \"column\": 0},\n   \"proofTree\": [{\"tactic\": \"rfl\", \"spawned_children\": [], \"children\": []}],\n   \"messages\": [],\n   \"end\": {\"line\": 2, \"column\": 70},\n   \"decl\":\n   \"@[simp]\\ntheorem mem_one (x : List \u03b1) : x \u2208 (1 : Language \u03b1) \u2194 x = [] \"},\n  {\"tactics\": [1],\n   \"start\": {\"line\": 29, \"column\": 0},\n   \"proofTree\":\n   [{\"tactic\": \"contradiction\", \"spawned_children\": [], \"children\": []}],\n   \"messages\": [],\n   \"end\": {\"line\": 30, \"column\": 39},\n   \"decl\": \"theorem nil_mem_kstar (l : Language \u03b1) : [] \u2208 l\u2217 \"},\n  {\"tactics\": [2, 3, 4, 5, 6],\n   \"start\": {\"line\": 33, \"column\": 0},\n   \"proofTree\":\n   [{\"tactic\": \"simp [mul_def, one_def]\",\n     \"spawned_children\": [],\n     \"children\": []},\n    {\"tactic\": \"simp [mul_def, one_def]\",\n     \"spawned_children\": [],\n     \"children\": []},\n    {\"tactic\": \"cases n\", \"spawned_children\": [], \"children\": [3, 4]},\n    {\"tactic\": \"simp [Nat.cast, add_def, zero_def]\",\n     \"spawned_children\": [],\n     \"children\": []},\n    {\"tactic\": \"simp [Nat.cast, add_def, zero_def]\",\n     \"spawned_children\": [],\n     \"children\": []}],\n   \"messages\": [0, 1, 2],\n   \"end\": {\"line\": 52, \"column\": 19},\n   \"decl\": \"instance instSemiring : Semiring (Language \u03b1) where\\n  add \"},\n  {\"tactics\": [2, 3, 4, 5, 6],\n   \"start\": {\"line\": 33, \"column\": 0},\n   \"proofTree\":\n   [{\"tactic\": \"simp [mul_def, one_def]\",\n     \"spawned_children\": [],\n     \"children\": []},\n    {\"tactic\": \"simp [mul_def, one_def]\",\n     \"spawned_children\": [],\n     \"children\": []},\n    {\"tactic\": \"cases n\", \"spawned_children\": [], \"children\": [3, 4]},\n    {\"tactic\": \"simp [Nat.cast, add_def, zero_def]\",\n     \"spawned_children\": [],\n     \"children\": []},\n    {\"tactic\": \"simp [Nat.cast, add_def, zero_def]\",\n     \"spawned_children\": [],\n     \"children\": []}],\n   \"messages\": [0, 1, 2],\n   \"end\": {\"line\": 52, \"column\": 19},\n   \"decl\": \" instance  1000 \"},\n  {\"tactics\": [2, 3, 4, 5, 6],\n   \"start\": {\"line\": 33, \"column\": 0},\n   \"proofTree\":\n   [{\"tactic\": \"simp [mul_def, one_def]\",\n     \"spawned_children\": [],\n     \"children\": []},\n    {\"tactic\": \"simp [mul_def, one_def]\",\n     \"spawned_children\": [],\n     \"children\": []},\n    {\"tactic\": \"cases n\", \"spawned_children\": [], \"children\": [3, 4]},\n    {\"tactic\": \"simp [Nat.cast, add_def, zero_def]\",\n     \"spawned_children\": [],\n     \"children\": []},\n    {\"tactic\": \"simp [Nat.cast, add_def, zero_def]\",\n     \"spawned_children\": [],\n     \"children\": []}],\n   \"messages\": [0, 1, 2],\n   \"end\": {\"line\": 52, \"column\": 19},\n   \"decl\": \" instance \"},\n  {\"tactics\": [7],\n   \"start\": {\"line\": 68, \"column\": 0},\n   \"proofTree\":\n   [{\"tactic\": \"simp [map]\", \"spawned_children\": [], \"children\": []}],\n   \"messages\": [],\n   \"end\": {\"line\": 69, \"column\": 63},\n   \"decl\": \"@[simp]\\ntheorem map_id (l : Language \u03b1) : map id l = l \"},\n  {\"tactics\": [8],\n   \"start\": {\"line\": 72, \"column\": 0},\n   \"proofTree\":\n   [{\"tactic\": \"simp [map, image_image]\",\n     \"spawned_children\": [],\n     \"children\": []}],\n   \"messages\": [],\n   \"end\": {\"line\": 74, \"column\": 25},\n   \"decl\":\n   \"@[simp]\\ntheorem map_map (g : \u03b2 \u2192 \u03b3) (f : \u03b1 \u2192 \u03b2) (l : Language \u03b1) : map g (map f l) = map (g \u2218 f) l \"},\n  {\"tactics\": [9, 10, 11, 12, 13, 14, 15, 16],\n   \"start\": {\"line\": 77, \"column\": 0},\n   \"proofTree\":\n   [{\"tactic\": \"constructor\", \"spawned_children\": [], \"children\": [1, 9]},\n    {\"tactic\": \"rintro \u27e8S, rfl, h\u27e9\", \"spawned_children\": [], \"children\": [2]},\n    {\"tactic\":\n     \"refine \u27e8S.filter fun l \u21a6 !List.isEmpty l, by simp, fun y hy \u21a6 ?_\u27e9\",\n     \"spawned_children\": [3],\n     \"children\": [3, 4]},\n    {\"tactic\": \"simp\", \"spawned_children\": [], \"children\": []},\n    {\"tactic\": \"rw [mem_filter]\", \"spawned_children\": [], \"children\": [5]},\n    {\"tactic\": \"rw [Bool.not_eq_true']\",\n     \"spawned_children\": [],\n     \"children\": [6]},\n    {\"tactic\": \"rw [\u2190 Bool.bool_iff_false]\",\n     \"spawned_children\": [],\n     \"children\": [7]},\n    {\"tactic\": \"rw [isEmpty_iff_eq_nil]\",\n     \"spawned_children\": [],\n     \"children\": [8]},\n    {\"tactic\": \"exact \u27e8h y hy.1, hy.2\u27e9\",\n     \"spawned_children\": [],\n     \"children\": []},\n    {\"tactic\": \"rintro \u27e8S, hx, h\u27e9\", \"spawned_children\": [], \"children\": [10]},\n    {\"tactic\": \"exact \u27e8S, hx, fun y hy \u21a6 (h y hy).1\u27e9\",\n     \"spawned_children\": [],\n     \"children\": []}],\n   \"messages\": [],\n   \"end\": {\"line\": 87, \"column\": 40},\n   \"decl\":\n   \"lemma mem_kstar_iff_exists_nonempty {x : List \u03b1} :\\n    x \u2208 l\u2217 \u2194 \u2203 S : List (List \u03b1), x = S.join \u2227 \u2200 y \u2208 S, y \u2208 l \u2227 y \u2260 [] \"},\n  {\"tactics\": [9, 10, 11, 12, 13, 14, 15, 16],\n   \"start\": {\"line\": 77, \"column\": 0},\n   \"proofTree\":\n   [{\"tactic\": \"constructor\", \"spawned_children\": [], \"children\": [1, 9]},\n    {\"tactic\": \"rintro \u27e8S, rfl, h\u27e9\", \"spawned_children\": [], \"children\": [2]},\n    {\"tactic\":\n     \"refine \u27e8S.filter fun l \u21a6 !List.isEmpty l, by simp, fun y hy \u21a6 ?_\u27e9\",\n     \"spawned_children\": [3],\n     \"children\": [3, 4]},\n    {\"tactic\": \"simp\", \"spawned_children\": [], \"children\": []},\n    {\"tactic\": \"rw [mem_filter]\", \"spawned_children\": [], \"children\": [5]},\n    {\"tactic\": \"rw [Bool.not_eq_true']\",\n     \"spawned_children\": [],\n     \"children\": [6]},\n    {\"tactic\": \"rw [\u2190 Bool.bool_iff_false]\",\n     \"spawned_children\": [],\n     \"children\": [7]},\n    {\"tactic\": \"rw [isEmpty_iff_eq_nil]\",\n     \"spawned_children\": [],\n     \"children\": [8]},\n    {\"tactic\": \"exact \u27e8h y hy.1, hy.2\u27e9\",\n     \"spawned_children\": [],\n     \"children\": []},\n    {\"tactic\": \"rintro \u27e8S, hx, h\u27e9\", \"spawned_children\": [], \"children\": [10]},\n    {\"tactic\": \"exact \u27e8S, hx, fun y hy \u21a6 (h y hy).1\u27e9\",\n     \"spawned_children\": [],\n     \"children\": []}],\n   \"messages\": [],\n   \"end\": {\"line\": 87, \"column\": 40},\n   \"decl\":\n   \" theorem mem_kstar_iff_exists_nonempty {x : List \u03b1} :\\n    x \u2208 l\u2217 \u2194 \u2203 S : List (List \u03b1), x = S.join \u2227 \u2200 y \u2208 S, y \u2208 l \u2227 y \u2260 [] \"},\n  {\"tactics\": [17, 18],\n   \"start\": {\"line\": 89, \"column\": 0},\n   \"proofTree\":\n   [{\"tactic\": \"ext x\", \"spawned_children\": [], \"children\": [1]},\n    {\"tactic\": \"apply mem_kstar_iff_exists_nonempty\",\n     \"spawned_children\": [],\n     \"children\": []}],\n   \"messages\": [],\n   \"end\": {\"line\": 91, \"column\": 44},\n   \"decl\":\n   \"theorem kstar_def_nonempty (l : Language \u03b1) :\\n    l\u2217 = { x | \u2203 S : List (List \u03b1), x = S.join \u2227 \u2200 y \u2208 S, y \u2208 l \u2227 y \u2260 [] } \"},\n  {\"tactics\": [19, 20, 21],\n   \"start\": {\"line\": 98, \"column\": 0},\n   \"proofTree\":\n   [{\"tactic\": \"intro h\u2081 h\u2082 x hx\", \"spawned_children\": [], \"children\": [1]},\n    {\"tactic\":\n     \"simp only [mul_def, exists_and_left, mem_image2, image_prod] at hx \u22a2\",\n     \"spawned_children\": [],\n     \"children\": [2]},\n    {\"tactic\": \"tauto\", \"spawned_children\": [], \"children\": []}],\n   \"messages\": [],\n   \"end\": {\"line\": 101, \"column\": 7},\n   \"decl\":\n   \"theorem le_mul_congr {l\u2081 l\u2082 m\u2081 m\u2082 : Language \u03b1} : l\u2081 \u2264 m\u2081 \u2192 l\u2082 \u2264 m\u2082 \u2192 l\u2081 * l\u2082 \u2264 m\u2081 * m\u2082 \"},\n  {\"tactics\": [22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37],\n   \"start\": {\"line\": 133, \"column\": 0},\n   \"proofTree\":\n   [{\"tactic\": \"induction n with\",\n     \"spawned_children\": [1, 3],\n     \"children\": [1, 3]},\n    {\"tactic\": \"simp [mem_one, pow_zero, length_eq_zero, eq_comm]\",\n     \"spawned_children\": [],\n     \"children\": [2]},\n    {\"tactic\": \"exact \u27e8[], rfl, rfl, fun _ h \u21a6 by contradiction\u27e9\",\n     \"spawned_children\": [],\n     \"children\": []},\n    {\"tactic\": \"simp [pow_succ', mem_mul, ihn]\",\n     \"spawned_children\": [],\n     \"children\": [4]},\n    {\"tactic\": \"apply Iff.intro\", \"spawned_children\": [], \"children\": [5, 6]},\n    {\"tactic\": \"rintro \u27e8a, ha, b, \u27e8S, rfl, rfl, hS\u27e9, rfl\u27e9\",\n     \"spawned_children\": [],\n     \"children\": []},\n    {\"tactic\": \"rintro \u27e8_ | \u27e8a, S\u27e9, rfl, hn, hS\u27e9\",\n     \"spawned_children\": [],\n     \"children\": [7, 8]},\n    {\"tactic\": \"cases hn\", \"spawned_children\": [], \"children\": []},\n    {\"tactic\": \"cases hn\", \"spawned_children\": [], \"children\": [9]},\n    {\"tactic\": \"rw [forall_mem_cons]\",\n     \"spawned_children\": [],\n     \"children\": [10]},\n    {\"tactic\": \"exact \u27e8a, hS.1, _, \u27e8S, rfl, rfl, hS.2\u27e9, rfl\u27e9\",\n     \"spawned_children\": [],\n     \"children\": []}],\n   \"messages\": [3, 4, 5, 6],\n   \"end\": {\"line\": 146, \"column\": 52},\n   \"decl\":\n   \"theorem mem_pow {l : Language \u03b1} {x : List \u03b1} {n : \u2115} :\\n    x \u2208 l ^ n \u2194 \u2203 S : List (List \u03b1), x = S.join \u2227 S.length = n \u2227 \u2200 y \u2208 S, y \u2208 l  \"}],\n \"tactics\":\n [{\"tactic\": \"rfl\",\n   \"proofState\": 0,\n   \"pos\": {\"line\": 2, \"column\": 67},\n   \"goals\":\n   \"\u03b1 : Type u_1 \u03b2 : Type u_2 \u03b3 : Type u_3 l m : Language \u03b1 a b x\u271d x : List \u03b1 \u22a2 x \u2208 1 \u2194 x = []\",\n   \"endPos\": {\"line\": 2, \"column\": 70}},\n  {\"tactic\": \"contradiction\",\n   \"proofState\": 1,\n   \"pos\": {\"line\": 30, \"column\": 25},\n   \"goals\":\n   \"\u03b1 : Type u_1 \u03b2 : Type u_2 \u03b3 : Type u_3 l\u271d m : Language \u03b1 a b x : List \u03b1 l : Language \u03b1 x\u271d : List \u03b1 h : x\u271d \u2208 [] \u22a2 x\u271d \u2208 l\",\n   \"endPos\": {\"line\": 30, \"column\": 38}},\n  {\"tactic\": \"simp [mul_def, one_def]\",\n   \"proofState\": 2,\n   \"pos\": {\"line\": 45, \"column\": 18},\n   \"goals\":\n   \"\u03b1 : Type u_1 \u03b2 : Type u_2 \u03b3 : Type u_3 l\u271d m : Language \u03b1 a b x : List \u03b1 l : Language \u03b1 \u22a2 1 * l = l\",\n   \"endPos\": {\"line\": 45, \"column\": 41}},\n  {\"tactic\": \"simp [mul_def, one_def]\",\n   \"proofState\": 3,\n   \"pos\": {\"line\": 46, \"column\": 18},\n   \"goals\":\n   \"\u03b1 : Type u_1 \u03b2 : Type u_2 \u03b3 : Type u_3 l\u271d m : Language \u03b1 a b x : List \u03b1 l : Language \u03b1 \u22a2 l * 1 = l\",\n   \"endPos\": {\"line\": 46, \"column\": 41}},\n  {\"tactic\": \"cases n\",\n   \"proofState\": 4,\n   \"pos\": {\"line\": 49, \"column\": 23},\n   \"goals\":\n   \"\u03b1 : Type u_1\\n\u03b2 : Type u_2\\n\u03b3 : Type u_3\\nl m : Language \u03b1\\na b x : List \u03b1\\nn : \u2115\\n\u22a2 NatCast.natCast (n + 1) = NatCast.natCast n + 1\",\n   \"endPos\": {\"line\": 49, \"column\": 30}},\n  {\"tactic\": \"simp [Nat.cast, add_def, zero_def]\",\n   \"proofState\": 5,\n   \"pos\": {\"line\": 49, \"column\": 35},\n   \"goals\":\n   \"case zero\\n\u03b1 : Type u_1\\n\u03b2 : Type u_2\\n\u03b3 : Type u_3\\nl m : Language \u03b1\\na b x : List \u03b1\\n\u22a2 NatCast.natCast (0 + 1) = NatCast.natCast 0 + 1\",\n   \"endPos\": {\"line\": 49, \"column\": 69}},\n  {\"tactic\": \"simp [Nat.cast, add_def, zero_def]\",\n   \"proofState\": 6,\n   \"pos\": {\"line\": 49, \"column\": 35},\n   \"goals\":\n   \"case succ\\n\u03b1 : Type u_1\\n\u03b2 : Type u_2\\n\u03b3 : Type u_3\\nl m : Language \u03b1\\na b x : List \u03b1\\nn\u271d : \u2115\\n\u22a2 NatCast.natCast (n\u271d + 1 + 1) = NatCast.natCast (n\u271d + 1) + 1\",\n   \"endPos\": {\"line\": 49, \"column\": 69}},\n  {\"tactic\": \"simp [map]\",\n   \"proofState\": 7,\n   \"pos\": {\"line\": 69, \"column\": 53},\n   \"goals\":\n   \"\u03b1 : Type u_1 \u03b2 : Type u_2 \u03b3 : Type u_3 l\u271d m : Language \u03b1 a b x : List \u03b1 l : Language \u03b1 \u22a2 (map id) l = l\",\n   \"endPos\": {\"line\": 69, \"column\": 63}},\n  {\"tactic\": \"simp [map, image_image]\",\n   \"proofState\": 8,\n   \"pos\": {\"line\": 74, \"column\": 2},\n   \"goals\":\n   \"\u03b1 : Type u_1\\n\u03b2 : Type u_2\\n\u03b3 : Type u_3\\nl\u271d m : Language \u03b1\\na b x : List \u03b1\\ng : \u03b2 \u2192 \u03b3\\nf : \u03b1 \u2192 \u03b2\\nl : Language \u03b1\\n\u22a2 (map g) ((map f) l) = (map (g \u2218 f)) l\",\n   \"endPos\": {\"line\": 74, \"column\": 25}},\n  {\"tactic\": \"constructor\",\n   \"proofState\": 9,\n   \"pos\": {\"line\": 79, \"column\": 2},\n   \"goals\":\n   \"\u03b1 : Type u_1\\n\u03b2 : Type u_2\\n\u03b3 : Type u_3\\nl m : Language \u03b1\\na b x\u271d x : List \u03b1\\n\u22a2 x \u2208 l\u2217 \u2194 \u2203 S, x = S.join \u2227 \u2200 y \u2208 S, y \u2208 l \u2227 y \u2260 []\",\n   \"endPos\": {\"line\": 79, \"column\": 13}},\n  {\"tactic\": \"rintro \u27e8S, rfl, h\u27e9\",\n   \"proofState\": 10,\n   \"pos\": {\"line\": 80, \"column\": 4},\n   \"goals\":\n   \"case mp\\n\u03b1 : Type u_1\\n\u03b2 : Type u_2\\n\u03b3 : Type u_3\\nl m : Language \u03b1\\na b x\u271d x : List \u03b1\\n\u22a2 x \u2208 l\u2217 \u2192 \u2203 S, x = S.join \u2227 \u2200 y \u2208 S, y \u2208 l \u2227 y \u2260 []\",\n   \"endPos\": {\"line\": 80, \"column\": 22}},\n  {\"tactic\":\n   \"refine\\n  \u27e8S.filter fun l \u21a6 !List.isEmpty l, by simp, fun y hy \u21a6 ?_\u27e9\\n    -- Porting note: The previous code was:\\n        -- rw [mem_filter, empty_iff_eq_nil] at hy\",\n   \"proofState\": 11,\n   \"pos\": {\"line\": 81, \"column\": 4},\n   \"goals\":\n   \"case mp.intro.intro\\n\u03b1 : Type u_1\\n\u03b2 : Type u_2\\n\u03b3 : Type u_3\\nl m : Language \u03b1\\na b x : List \u03b1\\nS : List (List \u03b1)\\nh : \u2200 y \u2208 S, y \u2208 l\\n\u22a2 \u2203 S_1, S.join = S_1.join \u2227 \u2200 y \u2208 S_1, y \u2208 l \u2227 y \u2260 []\",\n   \"endPos\": {\"line\": 81, \"column\": 69}},\n  {\"tactic\": \"simp\",\n   \"proofState\": 12,\n   \"pos\": {\"line\": 81, \"column\": 49},\n   \"goals\":\n   \"\u03b1 : Type u_1\\n\u03b2 : Type u_2\\n\u03b3 : Type u_3\\nl m : Language \u03b1\\na b x : List \u03b1\\nS : List (List \u03b1)\\nh : \u2200 y \u2208 S, y \u2208 l\\n\u22a2 S.join = (filter (fun l => !l.isEmpty) S).join\",\n   \"endPos\": {\"line\": 81, \"column\": 53}},\n  {\"tactic\":\n   \"rw [mem_filter, Bool.not_eq_true', \u2190 Bool.bool_iff_false, isEmpty_iff_eq_nil] at hy\",\n   \"proofState\": 13,\n   \"pos\": {\"line\": 84, \"column\": 4},\n   \"goals\":\n   \"case mp.intro.intro\\n\u03b1 : Type u_1\\n\u03b2 : Type u_2\\n\u03b3 : Type u_3\\nl m : Language \u03b1\\na b x : List \u03b1\\nS : List (List \u03b1)\\nh : \u2200 y \u2208 S, y \u2208 l\\ny : List \u03b1\\nhy : y \u2208 filter (fun l => !l.isEmpty) S\\n\u22a2 y \u2208 l \u2227 y \u2260 []\",\n   \"endPos\": {\"line\": 84, \"column\": 87}},\n  {\"tactic\": \"exact \u27e8h y hy.1, hy.2\u27e9\",\n   \"proofState\": 14,\n   \"pos\": {\"line\": 85, \"column\": 4},\n   \"goals\":\n   \"case mp.intro.intro\\n\u03b1 : Type u_1\\n\u03b2 : Type u_2\\n\u03b3 : Type u_3\\nl m : Language \u03b1\\na b x : List \u03b1\\nS : List (List \u03b1)\\nh : \u2200 y \u2208 S, y \u2208 l\\ny : List \u03b1\\nhy : y \u2208 S \u2227 \u00acy = []\\n\u22a2 y \u2208 l \u2227 y \u2260 []\",\n   \"endPos\": {\"line\": 85, \"column\": 26}},\n  {\"tactic\": \"rintro \u27e8S, hx, h\u27e9\",\n   \"proofState\": 15,\n   \"pos\": {\"line\": 86, \"column\": 4},\n   \"goals\":\n   \"case mpr\\n\u03b1 : Type u_1\\n\u03b2 : Type u_2\\n\u03b3 : Type u_3\\nl m : Language \u03b1\\na b x\u271d x : List \u03b1\\n\u22a2 (\u2203 S, x = S.join \u2227 \u2200 y \u2208 S, y \u2208 l \u2227 y \u2260 []) \u2192 x \u2208 l\u2217\",\n   \"endPos\": {\"line\": 86, \"column\": 21}},\n  {\"tactic\": \"exact \u27e8S, hx, fun y hy \u21a6 (h y hy).1\u27e9\",\n   \"proofState\": 16,\n   \"pos\": {\"line\": 87, \"column\": 4},\n   \"goals\":\n   \"case mpr.intro.intro\\n\u03b1 : Type u_1\\n\u03b2 : Type u_2\\n\u03b3 : Type u_3\\nl m : Language \u03b1\\na b x\u271d x : List \u03b1\\nS : List (List \u03b1)\\nhx : x = S.join\\nh : \u2200 y \u2208 S, y \u2208 l \u2227 y \u2260 []\\n\u22a2 x \u2208 l\u2217\",\n   \"endPos\": {\"line\": 87, \"column\": 40}},\n  {\"tactic\": \"ext x\",\n   \"proofState\": 17,\n   \"pos\": {\"line\": 91, \"column\": 2},\n   \"goals\":\n   \"\u03b1 : Type u_1\\n\u03b2 : Type u_2\\n\u03b3 : Type u_3\\nl\u271d m : Language \u03b1\\na b x : List \u03b1\\nl : Language \u03b1\\n\u22a2 l\u2217 = {x | \u2203 S, x = S.join \u2227 \u2200 y \u2208 S, y \u2208 l \u2227 y \u2260 []}\",\n   \"endPos\": {\"line\": 91, \"column\": 7}},\n  {\"tactic\": \"apply mem_kstar_iff_exists_nonempty\",\n   \"proofState\": 18,\n   \"pos\": {\"line\": 91, \"column\": 9},\n   \"goals\":\n   \"case h\\n\u03b1 : Type u_1\\n\u03b2 : Type u_2\\n\u03b3 : Type u_3\\nl\u271d m : Language \u03b1\\na b x\u271d : List \u03b1\\nl : Language \u03b1\\nx : List \u03b1\\n\u22a2 x \u2208 l\u2217 \u2194 x \u2208 {x | \u2203 S, x = S.join \u2227 \u2200 y \u2208 S, y \u2208 l \u2227 y \u2260 []}\",\n   \"endPos\": {\"line\": 91, \"column\": 44}},\n  {\"tactic\": \"intro h\u2081 h\u2082 x hx\",\n   \"proofState\": 19,\n   \"pos\": {\"line\": 99, \"column\": 2},\n   \"goals\":\n   \"\u03b1 : Type u_1\\n\u03b2 : Type u_2\\n\u03b3 : Type u_3\\nl m : Language \u03b1\\na b x : List \u03b1\\nl\u2081 l\u2082 m\u2081 m\u2082 : Language \u03b1\\n\u22a2 l\u2081 \u2264 m\u2081 \u2192 l\u2082 \u2264 m\u2082 \u2192 l\u2081 * l\u2082 \u2264 m\u2081 * m\u2082\",\n   \"endPos\": {\"line\": 99, \"column\": 18}},\n  {\"tactic\":\n   \"simp only [mul_def, exists_and_left, mem_image2, image_prod] at hx \u22a2\",\n   \"proofState\": 20,\n   \"pos\": {\"line\": 100, \"column\": 2},\n   \"goals\":\n   \"\u03b1 : Type u_1\\n\u03b2 : Type u_2\\n\u03b3 : Type u_3\\nl m : Language \u03b1\\na b x\u271d : List \u03b1\\nl\u2081 l\u2082 m\u2081 m\u2082 : Language \u03b1\\nh\u2081 : l\u2081 \u2264 m\u2081\\nh\u2082 : l\u2082 \u2264 m\u2082\\nx : List \u03b1\\nhx : x \u2208 l\u2081 * l\u2082\\n\u22a2 x \u2208 m\u2081 * m\u2082\",\n   \"endPos\": {\"line\": 100, \"column\": 70}},\n  {\"tactic\": \"tauto\",\n   \"proofState\": 21,\n   \"pos\": {\"line\": 101, \"column\": 2},\n   \"goals\":\n   \"\u03b1 : Type u_1\\n\u03b2 : Type u_2\\n\u03b3 : Type u_3\\nl m : Language \u03b1\\na b x\u271d : List \u03b1\\nl\u2081 l\u2082 m\u2081 m\u2082 : Language \u03b1\\nh\u2081 : l\u2081 \u2264 m\u2081\\nh\u2082 : l\u2082 \u2264 m\u2082\\nx : List \u03b1\\nhx : \u2203 a \u2208 l\u2081, \u2203 b \u2208 l\u2082, a ++ b = x\\n\u22a2 \u2203 a \u2208 m\u2081, \u2203 b \u2208 m\u2082, a ++ b = x\",\n   \"endPos\": {\"line\": 101, \"column\": 7}},\n  {\"tactic\":\n   \"induction n with\\n| zero =>\\n  simp [mem_one, pow_zero, length_eq_zero, eq_comm]\\n  exact \u27e8[], rfl, rfl, fun _ h \u21a6 by contradiction\u27e9\\n| succ n ihn =>\\n  simp [pow_succ', mem_mul, ihn]\\n  apply Iff.intro\\n  { rintro \u27e8a, ha, b, \u27e8S, rfl, rfl, hS\u27e9, rfl\u27e9\\n    exact \u27e8a :: S, rfl, rfl, forall_mem_cons.2 \u27e8ha, hS\u27e9\u27e9\\n  }\\n  { rintro \u27e8_ | \u27e8a, S\u27e9, rfl, hn, hS\u27e9 <;> cases hn\\n    rw [forall_mem_cons] at hS\\n    exact \u27e8a, hS.1, _, \u27e8S, rfl, rfl, hS.2\u27e9, rfl\u27e9\\n  }\",\n   \"proofState\": 22,\n   \"pos\": {\"line\": 135, \"column\": 2},\n   \"goals\":\n   \"\u03b1 : Type u_1\\n\u03b2 : Type u_2\\n\u03b3 : Type u_3\\nl\u271d m : Language \u03b1\\na b x\u271d : List \u03b1\\nl : Language \u03b1\\nx : List \u03b1\\nn : \u2115\\n\u22a2 x \u2208 l ^ n \u2194 \u2203 S, x = S.join \u2227 S.length = n \u2227 \u2200 y \u2208 S, y \u2208 l\",\n   \"endPos\": {\"line\": 146, \"column\": 52}},\n  {\"tactic\":\n   \"induction n with\\n| zero =>\\n  simp [mem_one, pow_zero, length_eq_zero, eq_comm]\\n  exact \u27e8[], rfl, rfl, fun _ h \u21a6 by contradiction\u27e9\\n| succ n ihn =>\\n  simp [pow_succ', mem_mul, ihn]\\n  apply Iff.intro\\n  { rintro \u27e8a, ha, b, \u27e8S, rfl, rfl, hS\u27e9, rfl\u27e9\\n    exact \u27e8a :: S, rfl, rfl, forall_mem_cons.2 \u27e8ha, hS\u27e9\u27e9\\n  }\\n  { rintro \u27e8_ | \u27e8a, S\u27e9, rfl, hn, hS\u27e9 <;> cases hn\\n    rw [forall_mem_cons] at hS\\n    exact \u27e8a, hS.1, _, \u27e8S, rfl, rfl, hS.2\u27e9, rfl\u27e9\\n  }\",\n   \"proofState\": 23,\n   \"pos\": {\"line\": 135, \"column\": 2},\n   \"goals\":\n   \"\u03b1 : Type u_1\\n\u03b2 : Type u_2\\n\u03b3 : Type u_3\\nl\u271d m : Language \u03b1\\na b x\u271d : List \u03b1\\nl : Language \u03b1\\nx : List \u03b1\\nn : \u2115\\n\u22a2 x \u2208 l ^ n \u2194 \u2203 S, x = S.join \u2227 S.length = n \u2227 \u2200 y \u2208 S, y \u2208 l\",\n   \"endPos\": {\"line\": 146, \"column\": 52}},\n  {\"tactic\":\n   \"\\n| zero =>\\n  simp [mem_one, pow_zero, length_eq_zero, eq_comm]\\n  exact \u27e8[], rfl, rfl, fun _ h \u21a6 by contradiction\u27e9\",\n   \"proofState\": 24,\n   \"pos\": {\"line\": 136, \"column\": 2},\n   \"goals\":\n   \"case zero\\n\u03b1 : Type u_1\\n\u03b2 : Type u_2\\n\u03b3 : Type u_3\\nl\u271d m : Language \u03b1\\na b x\u271d : List \u03b1\\nl : Language \u03b1\\nx : List \u03b1\\n\u22a2 x \u2208 l ^ 0 \u2194 \u2203 S, x = S.join \u2227 S.length = 0 \u2227 \u2200 y \u2208 S, y \u2208 l\",\n   \"endPos\": {\"line\": 138, \"column\": 52}},\n  {\"tactic\": \"simp [mem_one, pow_zero, length_eq_zero, eq_comm]\",\n   \"proofState\": 25,\n   \"pos\": {\"line\": 137, \"column\": 4},\n   \"goals\":\n   \"case zero\\n\u03b1 : Type u_1\\n\u03b2 : Type u_2\\n\u03b3 : Type u_3\\nl\u271d m : Language \u03b1\\na b x\u271d : List \u03b1\\nl : Language \u03b1\\nx : List \u03b1\\n\u22a2 x \u2208 l ^ 0 \u2194 \u2203 S, x = S.join \u2227 S.length = 0 \u2227 \u2200 y \u2208 S, y \u2208 l\",\n   \"endPos\": {\"line\": 137, \"column\": 53}},\n  {\"tactic\": \"exact \u27e8[], rfl, rfl, fun _ h \u21a6 by contradiction\u27e9\",\n   \"proofState\": 26,\n   \"pos\": {\"line\": 138, \"column\": 4},\n   \"goals\":\n   \"case zero\\n\u03b1 : Type u_1\\n\u03b2 : Type u_2\\n\u03b3 : Type u_3\\nl\u271d m : Language \u03b1\\na b x\u271d : List \u03b1\\nl : Language \u03b1\\nx : List \u03b1\\n\u22a2 x = [] \u2194 \u2203 S, x = S.join \u2227 S = [] \u2227 \u2200 y \u2208 S, y \u2208 l\",\n   \"endPos\": {\"line\": 138, \"column\": 52}},\n  {\"tactic\":\n   \"\\n| succ n ihn =>\\n  simp [pow_succ', mem_mul, ihn]\\n  apply Iff.intro\\n  { rintro \u27e8a, ha, b, \u27e8S, rfl, rfl, hS\u27e9, rfl\u27e9\\n    exact \u27e8a :: S, rfl, rfl, forall_mem_cons.2 \u27e8ha, hS\u27e9\u27e9\\n  }\\n  { rintro \u27e8_ | \u27e8a, S\u27e9, rfl, hn, hS\u27e9 <;> cases hn\\n    rw [forall_mem_cons] at hS\\n    exact \u27e8a, hS.1, _, \u27e8S, rfl, rfl, hS.2\u27e9, rfl\u27e9\\n  }\",\n   \"proofState\": 27,\n   \"pos\": {\"line\": 139, \"column\": 2},\n   \"goals\":\n   \"case succ\\n\u03b1 : Type u_1\\n\u03b2 : Type u_2\\n\u03b3 : Type u_3\\nl\u271d m : Language \u03b1\\na b x\u271d : List \u03b1\\nl : Language \u03b1\\nx : List \u03b1\\nn : \u2115\\nihn : x \u2208 l ^ n \u2194 \u2203 S, x = S.join \u2227 S.length = n \u2227 \u2200 y \u2208 S, y \u2208 l\\n\u22a2 x \u2208 l ^ (n + 1) \u2194 \u2203 S, x = S.join \u2227 S.length = n + 1 \u2227 \u2200 y \u2208 S, y \u2208 l\",\n   \"endPos\": {\"line\": 146, \"column\": 52}},\n  {\"tactic\": \"simp [pow_succ', mem_mul, ihn]\",\n   \"proofState\": 28,\n   \"pos\": {\"line\": 140, \"column\": 4},\n   \"goals\":\n   \"case succ\\n\u03b1 : Type u_1\\n\u03b2 : Type u_2\\n\u03b3 : Type u_3\\nl\u271d m : Language \u03b1\\na b x\u271d : List \u03b1\\nl : Language \u03b1\\nx : List \u03b1\\nn : \u2115\\nihn : x \u2208 l ^ n \u2194 \u2203 S, x = S.join \u2227 S.length = n \u2227 \u2200 y \u2208 S, y \u2208 l\\n\u22a2 x \u2208 l ^ (n + 1) \u2194 \u2203 S, x = S.join \u2227 S.length = n + 1 \u2227 \u2200 y \u2208 S, y \u2208 l\",\n   \"endPos\": {\"line\": 140, \"column\": 34}},\n  {\"tactic\": \"apply Iff.intro\",\n   \"proofState\": 29,\n   \"pos\": {\"line\": 141, \"column\": 4},\n   \"goals\":\n   \"case succ\\n\u03b1 : Type u_1\\n\u03b2 : Type u_2\\n\u03b3 : Type u_3\\nl\u271d m : Language \u03b1\\na b x\u271d : List \u03b1\\nl : Language \u03b1\\nx : List \u03b1\\nn : \u2115\\nihn : x \u2208 l ^ n \u2194 \u2203 S, x = S.join \u2227 S.length = n \u2227 \u2200 y \u2208 S, y \u2208 l\\n\u22a2 (\u2203 a \u2208 l, \u2203 b \u2208 l ^ n, a ++ b = x) \u2194 \u2203 S, x = S.join \u2227 S.length = n + 1 \u2227 \u2200 y \u2208 S, y \u2208 l\",\n   \"endPos\": {\"line\": 141, \"column\": 19}},\n  {\"tactic\":\n   \"{ rintro \u27e8a, ha, b, \u27e8S, rfl, rfl, hS\u27e9, rfl\u27e9\\n  exact \u27e8a :: S, rfl, rfl, forall_mem_cons.2 \u27e8ha, hS\u27e9\u27e9\\n}\",\n   \"proofState\": 30,\n   \"pos\": {\"line\": 142, \"column\": 4},\n   \"goals\":\n   \"case succ.mp\\n\u03b1 : Type u_1\\n\u03b2 : Type u_2\\n\u03b3 : Type u_3\\nl\u271d m : Language \u03b1\\na b x\u271d : List \u03b1\\nl : Language \u03b1\\nx : List \u03b1\\nn : \u2115\\nihn : x \u2208 l ^ n \u2194 \u2203 S, x = S.join \u2227 S.length = n \u2227 \u2200 y \u2208 S, y \u2208 l\\n\u22a2 (\u2203 a \u2208 l, \u2203 b \u2208 l ^ n, a ++ b = x) \u2192 \u2203 S, x = S.join \u2227 S.length = n + 1 \u2227 \u2200 y \u2208 S, y \u2208 l\\ncase succ.mpr\\n\u03b1 : Type u_1\\n\u03b2 : Type u_2\\n\u03b3 : Type u_3\\nl\u271d m : Language \u03b1\\na b x\u271d : List \u03b1\\nl : Language \u03b1\\nx : List \u03b1\\nn : \u2115\\nihn : x \u2208 l ^ n \u2194 \u2203 S, x = S.join \u2227 S.length = n \u2227 \u2200 y \u2208 S, y \u2208 l\\n\u22a2 (\u2203 S, x = S.join \u2227 S.length = n + 1 \u2227 \u2200 y \u2208 S, y \u2208 l) \u2192 \u2203 a \u2208 l, \u2203 b \u2208 l ^ n, a ++ b = x\",\n   \"endPos\": {\"line\": 143, \"column\": 60}},\n  {\"tactic\": \"rintro \u27e8a, ha, b, \u27e8S, rfl, rfl, hS\u27e9, rfl\u27e9\",\n   \"proofState\": 31,\n   \"pos\": {\"line\": 142, \"column\": 6},\n   \"goals\":\n   \"case succ.mp\\n\u03b1 : Type u_1\\n\u03b2 : Type u_2\\n\u03b3 : Type u_3\\nl\u271d m : Language \u03b1\\na b x\u271d : List \u03b1\\nl : Language \u03b1\\nx : List \u03b1\\nn : \u2115\\nihn : x \u2208 l ^ n \u2194 \u2203 S, x = S.join \u2227 S.length = n \u2227 \u2200 y \u2208 S, y \u2208 l\\n\u22a2 (\u2203 a \u2208 l, \u2203 b \u2208 l ^ n, a ++ b = x) \u2192 \u2203 S, x = S.join \u2227 S.length = n + 1 \u2227 \u2200 y \u2208 S, y \u2208 l\",\n   \"endPos\": {\"line\": 142, \"column\": 47}},\n  {\"tactic\":\n   \"{ rintro \u27e8_ | \u27e8a, S\u27e9, rfl, hn, hS\u27e9 <;> cases hn\\n  rw [forall_mem_cons] at hS\\n  exact \u27e8a, hS.1, _, \u27e8S, rfl, rfl, hS.2\u27e9, rfl\u27e9\\n}\",\n   \"proofState\": 32,\n   \"pos\": {\"line\": 144, \"column\": 4},\n   \"goals\":\n   \"case succ.mpr\\n\u03b1 : Type u_1\\n\u03b2 : Type u_2\\n\u03b3 : Type u_3\\nl\u271d m : Language \u03b1\\na b x\u271d : List \u03b1\\nl : Language \u03b1\\nx : List \u03b1\\nn : \u2115\\nihn : x \u2208 l ^ n \u2194 \u2203 S, x = S.join \u2227 S.length = n \u2227 \u2200 y \u2208 S, y \u2208 l\\n\u22a2 (\u2203 S, x = S.join \u2227 S.length = n + 1 \u2227 \u2200 y \u2208 S, y \u2208 l) \u2192 \u2203 a \u2208 l, \u2203 b \u2208 l ^ n, a ++ b = x\",\n   \"endPos\": {\"line\": 146, \"column\": 52}},\n  {\"tactic\": \"rintro \u27e8_ | \u27e8a, S\u27e9, rfl, hn, hS\u27e9\",\n   \"proofState\": 33,\n   \"pos\": {\"line\": 144, \"column\": 6},\n   \"goals\":\n   \"case succ.mpr\\n\u03b1 : Type u_1\\n\u03b2 : Type u_2\\n\u03b3 : Type u_3\\nl\u271d m : Language \u03b1\\na b x\u271d : List \u03b1\\nl : Language \u03b1\\nx : List \u03b1\\nn : \u2115\\nihn : x \u2208 l ^ n \u2194 \u2203 S, x = S.join \u2227 S.length = n \u2227 \u2200 y \u2208 S, y \u2208 l\\n\u22a2 (\u2203 S, x = S.join \u2227 S.length = n + 1 \u2227 \u2200 y \u2208 S, y \u2208 l) \u2192 \u2203 a \u2208 l, \u2203 b \u2208 l ^ n, a ++ b = x\",\n   \"endPos\": {\"line\": 144, \"column\": 38}},\n  {\"tactic\": \"cases hn\",\n   \"proofState\": 34,\n   \"pos\": {\"line\": 144, \"column\": 43},\n   \"goals\":\n   \"case succ.mpr.intro.nil.intro.intro\\n\u03b1 : Type u_1\\n\u03b2 : Type u_2\\n\u03b3 : Type u_3\\nl\u271d m : Language \u03b1\\na b x : List \u03b1\\nl : Language \u03b1\\nn : \u2115\\nihn : [].join \u2208 l ^ n \u2194 \u2203 S, [].join = S.join \u2227 S.length = n \u2227 \u2200 y \u2208 S, y \u2208 l\\nhn : [].length = n + 1\\nhS : \u2200 y \u2208 [], y \u2208 l\\n\u22a2 \u2203 a \u2208 l, \u2203 b \u2208 l ^ n, a ++ b = [].join\",\n   \"endPos\": {\"line\": 144, \"column\": 51}},\n  {\"tactic\": \"cases hn\",\n   \"proofState\": 35,\n   \"pos\": {\"line\": 144, \"column\": 43},\n   \"goals\":\n   \"case succ.mpr.intro.cons.intro.intro\\n\u03b1 : Type u_1\\n\u03b2 : Type u_2\\n\u03b3 : Type u_3\\nl\u271d m : Language \u03b1\\na\u271d b x : List \u03b1\\nl : Language \u03b1\\nn : \u2115\\na : List \u03b1\\nS : List (List \u03b1)\\nihn : (a :: S).join \u2208 l ^ n \u2194 \u2203 S_1, (a :: S).join = S_1.join \u2227 S_1.length = n \u2227 \u2200 y \u2208 S_1, y \u2208 l\\nhn : (a :: S).length = n + 1\\nhS : \u2200 y \u2208 a :: S, y \u2208 l\\n\u22a2 \u2203 a_1 \u2208 l, \u2203 b \u2208 l ^ n, a_1 ++ b = (a :: S).join\",\n   \"endPos\": {\"line\": 144, \"column\": 51}},\n  {\"tactic\": \"rw [forall_mem_cons] at hS\",\n   \"proofState\": 36,\n   \"pos\": {\"line\": 145, \"column\": 6},\n   \"goals\":\n   \"case succ.mpr.intro.cons.intro.intro.refl\\n\u03b1 : Type u_1\\n\u03b2 : Type u_2\\n\u03b3 : Type u_3\\nl\u271d m : Language \u03b1\\na\u271d b x : List \u03b1\\nl : Language \u03b1\\na : List \u03b1\\nS : List (List \u03b1)\\nhS : \u2200 y \u2208 a :: S, y \u2208 l\\nihn : (a :: S).join \u2208 l ^ S.length \u2194 \u2203 S_1, (a :: S).join = S_1.join \u2227 S_1.length = S.length \u2227 \u2200 y \u2208 S_1, y \u2208 l\\n\u22a2 \u2203 a_1 \u2208 l, \u2203 b \u2208 l ^ S.length, a_1 ++ b = (a :: S).join\",\n   \"endPos\": {\"line\": 145, \"column\": 32}},\n  {\"tactic\": \"exact \u27e8a, hS.1, _, \u27e8S, rfl, rfl, hS.2\u27e9, rfl\u27e9\",\n   \"proofState\": 37,\n   \"pos\": {\"line\": 146, \"column\": 6},\n   \"goals\":\n   \"case succ.mpr.intro.cons.intro.intro.refl\\n\u03b1 : Type u_1\\n\u03b2 : Type u_2\\n\u03b3 : Type u_3\\nl\u271d m : Language \u03b1\\na\u271d b x : List \u03b1\\nl : Language \u03b1\\na : List \u03b1\\nS : List (List \u03b1)\\nhS : a \u2208 l \u2227 \u2200 x \u2208 S, x \u2208 l\\nihn : (a :: S).join \u2208 l ^ S.length \u2194 \u2203 S_1, (a :: S).join = S_1.join \u2227 S_1.length = S.length \u2227 \u2200 y \u2208 S_1, y \u2208 l\\n\u22a2 \u2203 a_1 \u2208 l, \u2203 b \u2208 l ^ S.length, a_1 ++ b = (a :: S).join\",\n   \"endPos\": {\"line\": 146, \"column\": 50}}],\n \"messages\":\n [{\"severity\": \"warning\",\n   \"pos\": {\"line\": 41, \"column\": 24},\n   \"endPos\": {\"line\": 41, \"column\": 25},\n   \"data\":\n   \"unused variable `l`\\nnote: this linter can be disabled with `set_option linter.unusedVariables false`\"},\n  {\"severity\": \"warning\",\n   \"pos\": {\"line\": 41, \"column\": 26},\n   \"endPos\": {\"line\": 41, \"column\": 27},\n   \"data\":\n   \"unused variable `m`\\nnote: this linter can be disabled with `set_option linter.unusedVariables false`\"},\n  {\"severity\": \"warning\",\n   \"pos\": {\"line\": 41, \"column\": 44},\n   \"endPos\": {\"line\": 41, \"column\": 45},\n   \"data\":\n   \"unused variable `a`\\nnote: this linter can be disabled with `set_option linter.unusedVariables false`\"},\n  {\"severity\": \"error\",\n   \"pos\": {\"line\": 138, \"column\": 11},\n   \"endPos\": {\"line\": 138, \"column\": 13},\n   \"data\":\n   \"application type mismatch\\n  Iff.intro []\\nargument\\n  []\\nhas type\\n  List ?m.26112 : Type ?u.26111\\nbut is expected to have type\\n  x = [] \u2192 \u2203 S, x = S.join \u2227 S = [] \u2227 \u2200 y \u2208 S, y \u2208 l : Prop\"},\n  {\"severity\": \"error\",\n   \"pos\": {\"line\": 138, \"column\": 10},\n   \"endPos\": {\"line\": 138, \"column\": 52},\n   \"data\":\n   \"invalid constructor \u27e8...\u27e9, expected type must be an inductive type \\n  (\u2203 S, x = S.join \u2227 S = [] \u2227 \u2200 y \u2208 S, y \u2208 l) \u2192 x = []\"},\n  {\"severity\": \"error\",\n   \"pos\": {\"line\": 142, \"column\": 24},\n   \"endPos\": {\"line\": 142, \"column\": 41},\n   \"data\":\n   \"rcases tactic failed: left\u271d : npowRec n l b is not an inductive datatype\"},\n  {\"severity\": \"error\",\n   \"pos\": {\"line\": 146, \"column\": 25},\n   \"endPos\": {\"line\": 146, \"column\": 44},\n   \"data\":\n   \"invalid constructor \u27e8...\u27e9, expected type must be an inductive type \\n  npowRec S.length l ?m.31319\"}],\n \"env\": 1}\n\n{\"theorems\":\n [{\"tactics\": [0],\n   \"start\": {\"line\": 1, \"column\": 0},\n   \"proofTree\": [{\"tactic\": \"rfl\", \"spawned_children\": [], \"children\": []}],\n   \"messages\": [],\n   \"end\": {\"line\": 2, \"column\": 70},\n   \"decl\":\n   \"@[simp]\\ntheorem mem_one (x : List \u03b1) : x \u2208 (1 : Language \u03b1) \u2194 x = [] \"},\n  {\"tactics\": [1],\n   \"start\": {\"line\": 29, \"column\": 0},\n   \"proofTree\":\n   [{\"tactic\": \"contradiction\", \"spawned_children\": [], \"children\": []}],\n   \"messages\": [],\n   \"end\": {\"line\": 30, \"column\": 39},\n   \"decl\": \"theorem nil_mem_kstar (l : Language \u03b1) : [] \u2208 l\u2217 \"},\n  {\"tactics\": [2, 3, 4, 5, 6],\n   \"start\": {\"line\": 33, \"column\": 0},\n   \"proofTree\":\n   [{\"tactic\": \"simp [mul_def, one_def]\",\n     \"spawned_children\": [],\n     \"children\": []},\n    {\"tactic\": \"simp [mul_def, one_def]\",\n     \"spawned_children\": [],\n     \"children\": []},\n    {\"tactic\": \"cases n\", \"spawned_children\": [], \"children\": [3, 4]},\n    {\"tactic\": \"simp [Nat.cast, add_def, zero_def]\",\n     \"spawned_children\": [],\n     \"children\": []},\n    {\"tactic\": \"simp [Nat.cast, add_def, zero_def]\",\n     \"spawned_children\": [],\n     \"children\": []}],\n   \"messages\": [0, 1, 2],\n   \"end\": {\"line\": 52, \"column\": 19},\n   \"decl\": \"instance instSemiring : Semiring (Language \u03b1) where\\n  add \"},\n  {\"tactics\": [2, 3, 4, 5, 6],\n   \"start\": {\"line\": 33, \"column\": 0},\n   \"proofTree\":\n   [{\"tactic\": \"simp [mul_def, one_def]\",\n     \"spawned_children\": [],\n     \"children\": []},\n    {\"tactic\": \"simp [mul_def, one_def]\",\n     \"spawned_children\": [],\n     \"children\": []},\n    {\"tactic\": \"cases n\", \"spawned_children\": [], \"children\": [3, 4]},\n    {\"tactic\": \"simp [Nat.cast, add_def, zero_def]\",\n     \"spawned_children\": [],\n     \"children\": []},\n    {\"tactic\": \"simp [Nat.cast, add_def, zero_def]\",\n     \"spawned_children\": [],\n     \"children\": []}],\n   \"messages\": [0, 1, 2],\n   \"end\": {\"line\": 52, \"column\": 19},\n   \"decl\": \" instance  1000 \"},\n  {\"tactics\": [2, 3, 4, 5, 6],\n   \"start\": {\"line\": 33, \"column\": 0},\n   \"proofTree\":\n   [{\"tactic\": \"simp [mul_def, one_def]\",\n     \"spawned_children\": [],\n     \"children\": []},\n    {\"tactic\": \"simp [mul_def, one_def]\",\n     \"spawned_children\": [],\n     \"children\": []},\n    {\"tactic\": \"cases n\", \"spawned_children\": [], \"children\": [3, 4]},\n    {\"tactic\": \"simp [Nat.cast, add_def, zero_def]\",\n     \"spawned_children\": [],\n     \"children\": []},\n    {\"tactic\": \"simp [Nat.cast, add_def, zero_def]\",\n     \"spawned_children\": [],\n     \"children\": []}],\n   \"messages\": [0, 1, 2],\n   \"end\": {\"line\": 52, \"column\": 19},\n   \"decl\": \" instance \"},\n  {\"tactics\": [7],\n   \"start\": {\"line\": 68, \"column\": 0},\n   \"proofTree\":\n   [{\"tactic\": \"simp [map]\", \"spawned_children\": [], \"children\": []}],\n   \"messages\": [],\n   \"end\": {\"line\": 69, \"column\": 63},\n   \"decl\": \"@[simp]\\ntheorem map_id (l : Language \u03b1) : map id l = l \"},\n  {\"tactics\": [8],\n   \"start\": {\"line\": 72, \"column\": 0},\n   \"proofTree\":\n   [{\"tactic\": \"simp [map, image_image]\",\n     \"spawned_children\": [],\n     \"children\": []}],\n   \"messages\": [],\n   \"end\": {\"line\": 74, \"column\": 25},\n   \"decl\":\n   \"@[simp]\\ntheorem map_map (g : \u03b2 \u2192 \u03b3) (f : \u03b1 \u2192 \u03b2) (l : Language \u03b1) : map g (map f l) = map (g \u2218 f) l \"},\n  {\"tactics\": [9, 10, 11, 12, 13, 14, 15, 16],\n   \"start\": {\"line\": 77, \"column\": 0},\n   \"proofTree\":\n   [{\"tactic\": \"constructor\", \"spawned_children\": [], \"children\": [1, 9]},\n    {\"tactic\": \"rintro \u27e8S, rfl, h\u27e9\", \"spawned_children\": [], \"children\": [2]},\n    {\"tactic\":\n     \"refine \u27e8S.filter fun l \u21a6 !List.isEmpty l, by simp, fun y hy \u21a6 ?_\u27e9\",\n     \"spawned_children\": [3],\n     \"children\": [3, 4]},\n    {\"tactic\": \"simp\", \"spawned_children\": [], \"children\": []},\n    {\"tactic\": \"rw [mem_filter]\", \"spawned_children\": [], \"children\": [5]},\n    {\"tactic\": \"rw [Bool.not_eq_true']\",\n     \"spawned_children\": [],\n     \"children\": [6]},\n    {\"tactic\": \"rw [\u2190 Bool.bool_iff_false]\",\n     \"spawned_children\": [],\n     \"children\": [7]},\n    {\"tactic\": \"rw [isEmpty_iff_eq_nil]\",\n     \"spawned_children\": [],\n     \"children\": [8]},\n    {\"tactic\": \"exact \u27e8h y hy.1, hy.2\u27e9\",\n     \"spawned_children\": [],\n     \"children\": []},\n    {\"tactic\": \"rintro \u27e8S, hx, h\u27e9\", \"spawned_children\": [], \"children\": [10]},\n    {\"tactic\": \"exact \u27e8S, hx, fun y hy \u21a6 (h y hy).1\u27e9\",\n     \"spawned_children\": [],\n     \"children\": []}],\n   \"messages\": [],\n   \"end\": {\"line\": 87, \"column\": 40},\n   \"decl\":\n   \"lemma mem_kstar_iff_exists_nonempty {x : List \u03b1} :\\n    x \u2208 l\u2217 \u2194 \u2203 S : List (List \u03b1), x = S.join \u2227 \u2200 y \u2208 S, y \u2208 l \u2227 y \u2260 [] \"},\n  {\"tactics\": [9, 10, 11, 12, 13, 14, 15, 16],\n   \"start\": {\"line\": 77, \"column\": 0},\n   \"proofTree\":\n   [{\"tactic\": \"constructor\", \"spawned_children\": [], \"children\": [1, 9]},\n    {\"tactic\": \"rintro \u27e8S, rfl, h\u27e9\", \"spawned_children\": [], \"children\": [2]},\n    {\"tactic\":\n     \"refine \u27e8S.filter fun l \u21a6 !List.isEmpty l, by simp, fun y hy \u21a6 ?_\u27e9\",\n     \"spawned_children\": [3],\n     \"children\": [3, 4]},\n    {\"tactic\": \"simp\", \"spawned_children\": [], \"children\": []},\n    {\"tactic\": \"rw [mem_filter]\", \"spawned_children\": [], \"children\": [5]},\n    {\"tactic\": \"rw [Bool.not_eq_true']\",\n     \"spawned_children\": [],\n     \"children\": [6]},\n    {\"tactic\": \"rw [\u2190 Bool.bool_iff_false]\",\n     \"spawned_children\": [],\n     \"children\": [7]},\n    {\"tactic\": \"rw [isEmpty_iff_eq_nil]\",\n     \"spawned_children\": [],\n     \"children\": [8]},\n    {\"tactic\": \"exact \u27e8h y hy.1, hy.2\u27e9\",\n     \"spawned_children\": [],\n     \"children\": []},\n    {\"tactic\": \"rintro \u27e8S, hx, h\u27e9\", \"spawned_children\": [], \"children\": [10]},\n    {\"tactic\": \"exact \u27e8S, hx, fun y hy \u21a6 (h y hy).1\u27e9\",\n     \"spawned_children\": [],\n     \"children\": []}],\n   \"messages\": [],\n   \"end\": {\"line\": 87, \"column\": 40},\n   \"decl\":\n   \" theorem mem_kstar_iff_exists_nonempty {x : List \u03b1} :\\n    x \u2208 l\u2217 \u2194 \u2203 S : List (List \u03b1), x = S.join \u2227 \u2200 y \u2208 S, y \u2208 l \u2227 y \u2260 [] \"},\n  {\"tactics\": [17, 18],\n   \"start\": {\"line\": 89, \"column\": 0},\n   \"proofTree\":\n   [{\"tactic\": \"ext x\", \"spawned_children\": [], \"children\": [1]},\n    {\"tactic\": \"apply mem_kstar_iff_exists_nonempty\",\n     \"spawned_children\": [],\n     \"children\": []}],\n   \"messages\": [],\n   \"end\": {\"line\": 91, \"column\": 44},\n   \"decl\":\n   \"theorem kstar_def_nonempty (l : Language \u03b1) :\\n    l\u2217 = { x | \u2203 S : List (List \u03b1), x = S.join \u2227 \u2200 y \u2208 S, y \u2208 l \u2227 y \u2260 [] } \"},\n  {\"tactics\": [19, 20, 21],\n   \"start\": {\"line\": 98, \"column\": 0},\n   \"proofTree\":\n   [{\"tactic\": \"intro h\u2081 h\u2082 x hx\", \"spawned_children\": [], \"children\": [1]},\n    {\"tactic\":\n     \"simp only [mul_def, exists_and_left, mem_image2, image_prod] at hx \u22a2\",\n     \"spawned_children\": [],\n     \"children\": [2]},\n    {\"tactic\": \"tauto\", \"spawned_children\": [], \"children\": []}],\n   \"messages\": [],\n   \"end\": {\"line\": 101, \"column\": 7},\n   \"decl\":\n   \"theorem le_mul_congr {l\u2081 l\u2082 m\u2081 m\u2082 : Language \u03b1} : l\u2081 \u2264 m\u2081 \u2192 l\u2082 \u2264 m\u2082 \u2192 l\u2081 * l\u2082 \u2264 m\u2081 * m\u2082 \"},\n  {\"tactics\": [22, 23, 24, 25, 26, 27, 28, 29],\n   \"start\": {\"line\": 133, \"column\": 0},\n   \"proofTree\":\n   [{\"tactic\": \"induction n with\",\n     \"spawned_children\": [1, 3],\n     \"children\": [1, 3]},\n    {\"tactic\": \"simp [mem_one, pow_zero, length_eq_zero]\",\n     \"spawned_children\": [],\n     \"children\": [2]},\n    {\"tactic\":\n     \"exact \u27e8\u27e8[], rfl, rfl, fun _ h => h.elim\u27e9, fun \u27e8_, rfl, _, _\u27e9 => rfl\u27e9\",\n     \"spawned_children\": [],\n     \"children\": []},\n    {\"tactic\": \"simp [pow_succ', mem_mul, ihn]\",\n     \"spawned_children\": [],\n     \"children\": [4]},\n    {\"tactic\":\n     \"exact \u27e8fun \u27e8a, ha, b, \u27e8S, hx, hl, hb\u27e9, h\u27e9 => \u27e8a :: S, by rwa [\u2190h, hx, List.join], by simp [hl], forall_mem_cons.2 \u27e8ha, hb\u27e9\u27e9, fun \u27e8_\",\n     \"spawned_children\": [],\n     \"children\": []}],\n   \"messages\": [],\n   \"end\": {\"line\": 141, \"column\": 135},\n   \"decl\":\n   \"theorem mem_pow {l : Language \u03b1} {x : List \u03b1} {n : \u2115} :\\n    x \u2208 l ^ n \u2194 \u2203 S : List (List \u03b1), x = S.join \u2227 S.length = n \u2227 \u2200 y \u2208 S, y \u2208 l  \"}],\n \"tactics\":\n [{\"tactic\": \"rfl\",\n   \"proofState\": 38,\n   \"pos\": {\"line\": 2, \"column\": 67},\n   \"goals\":\n   \"\u03b1 : Type u_1 \u03b2 : Type u_2 \u03b3 : Type u_3 l m : Language \u03b1 a b x\u271d x : List \u03b1 \u22a2 x \u2208 1 \u2194 x = []\",\n   \"endPos\": {\"line\": 2, \"column\": 70}},\n  {\"tactic\": \"contradiction\",\n   \"proofState\": 39,\n   \"pos\": {\"line\": 30, \"column\": 25},\n   \"goals\":\n   \"\u03b1 : Type u_1 \u03b2 : Type u_2 \u03b3 : Type u_3 l\u271d m : Language \u03b1 a b x : List \u03b1 l : Language \u03b1 x\u271d : List \u03b1 h : x\u271d \u2208 [] \u22a2 x\u271d \u2208 l\",\n   \"endPos\": {\"line\": 30, \"column\": 38}},\n  {\"tactic\": \"simp [mul_def, one_def]\",\n   \"proofState\": 40,\n   \"pos\": {\"line\": 45, \"column\": 18},\n   \"goals\":\n   \"\u03b1 : Type u_1 \u03b2 : Type u_2 \u03b3 : Type u_3 l\u271d m : Language \u03b1 a b x : List \u03b1 l : Language \u03b1 \u22a2 1 * l = l\",\n   \"endPos\": {\"line\": 45, \"column\": 41}},\n  {\"tactic\": \"simp [mul_def, one_def]\",\n   \"proofState\": 41,\n   \"pos\": {\"line\": 46, \"column\": 18},\n   \"goals\":\n   \"\u03b1 : Type u_1 \u03b2 : Type u_2 \u03b3 : Type u_3 l\u271d m : Language \u03b1 a b x : List \u03b1 l : Language \u03b1 \u22a2 l * 1 = l\",\n   \"endPos\": {\"line\": 46, \"column\": 41}},\n  {\"tactic\": \"cases n\",\n   \"proofState\": 42,\n   \"pos\": {\"line\": 49, \"column\": 23},\n   \"goals\":\n   \"\u03b1 : Type u_1\\n\u03b2 : Type u_2\\n\u03b3 : Type u_3\\nl m : Language \u03b1\\na b x : List \u03b1\\nn : \u2115\\n\u22a2 NatCast.natCast (n + 1) = NatCast.natCast n + 1\",\n   \"endPos\": {\"line\": 49, \"column\": 30}},\n  {\"tactic\": \"simp [Nat.cast, add_def, zero_def]\",\n   \"proofState\": 43,\n   \"pos\": {\"line\": 49, \"column\": 35},\n   \"goals\":\n   \"case zero\\n\u03b1 : Type u_1\\n\u03b2 : Type u_2\\n\u03b3 : Type u_3\\nl m : Language \u03b1\\na b x : List \u03b1\\n\u22a2 NatCast.natCast (0 + 1) = NatCast.natCast 0 + 1\",\n   \"endPos\": {\"line\": 49, \"column\": 69}},\n  {\"tactic\": \"simp [Nat.cast, add_def, zero_def]\",\n   \"proofState\": 44,\n   \"pos\": {\"line\": 49, \"column\": 35},\n   \"goals\":\n   \"case succ\\n\u03b1 : Type u_1\\n\u03b2 : Type u_2\\n\u03b3 : Type u_3\\nl m : Language \u03b1\\na b x : List \u03b1\\nn\u271d : \u2115\\n\u22a2 NatCast.natCast (n\u271d + 1 + 1) = NatCast.natCast (n\u271d + 1) + 1\",\n   \"endPos\": {\"line\": 49, \"column\": 69}},\n  {\"tactic\": \"simp [map]\",\n   \"proofState\": 45,\n   \"pos\": {\"line\": 69, \"column\": 53},\n   \"goals\":\n   \"\u03b1 : Type u_1 \u03b2 : Type u_2 \u03b3 : Type u_3 l\u271d m : Language \u03b1 a b x : List \u03b1 l : Language \u03b1 \u22a2 (map id) l = l\",\n   \"endPos\": {\"line\": 69, \"column\": 63}},\n  {\"tactic\": \"simp [map, image_image]\",\n   \"proofState\": 46,\n   \"pos\": {\"line\": 74, \"column\": 2},\n   \"goals\":\n   \"\u03b1 : Type u_1\\n\u03b2 : Type u_2\\n\u03b3 : Type u_3\\nl\u271d m : Language \u03b1\\na b x : List \u03b1\\ng : \u03b2 \u2192 \u03b3\\nf : \u03b1 \u2192 \u03b2\\nl : Language \u03b1\\n\u22a2 (map g) ((map f) l) = (map (g \u2218 f)) l\",\n   \"endPos\": {\"line\": 74, \"column\": 25}},\n  {\"tactic\": \"constructor\",\n   \"proofState\": 47,\n   \"pos\": {\"line\": 79, \"column\": 2},\n   \"goals\":\n   \"\u03b1 : Type u_1\\n\u03b2 : Type u_2\\n\u03b3 : Type u_3\\nl m : Language \u03b1\\na b x\u271d x : List \u03b1\\n\u22a2 x \u2208 l\u2217 \u2194 \u2203 S, x = S.join \u2227 \u2200 y \u2208 S, y \u2208 l \u2227 y \u2260 []\",\n   \"endPos\": {\"line\": 79, \"column\": 13}},\n  {\"tactic\": \"rintro \u27e8S, rfl, h\u27e9\",\n   \"proofState\": 48,\n   \"pos\": {\"line\": 80, \"column\": 4},\n   \"goals\":\n   \"case mp\\n\u03b1 : Type u_1\\n\u03b2 : Type u_2\\n\u03b3 : Type u_3\\nl m : Language \u03b1\\na b x\u271d x : List \u03b1\\n\u22a2 x \u2208 l\u2217 \u2192 \u2203 S, x = S.join \u2227 \u2200 y \u2208 S, y \u2208 l \u2227 y \u2260 []\",\n   \"endPos\": {\"line\": 80, \"column\": 22}},\n  {\"tactic\":\n   \"refine\\n  \u27e8S.filter fun l \u21a6 !List.isEmpty l, by simp, fun y hy \u21a6 ?_\u27e9\\n    -- Porting note: The previous code was:\\n        -- rw [mem_filter, empty_iff_eq_nil] at hy\",\n   \"proofState\": 49,\n   \"pos\": {\"line\": 81, \"column\": 4},\n   \"goals\":\n   \"case mp.intro.intro\\n\u03b1 : Type u_1\\n\u03b2 : Type u_2\\n\u03b3 : Type u_3\\nl m : Language \u03b1\\na b x : List \u03b1\\nS : List (List \u03b1)\\nh : \u2200 y \u2208 S, y \u2208 l\\n\u22a2 \u2203 S_1, S.join = S_1.join \u2227 \u2200 y \u2208 S_1, y \u2208 l \u2227 y \u2260 []\",\n   \"endPos\": {\"line\": 81, \"column\": 69}},\n  {\"tactic\": \"simp\",\n   \"proofState\": 50,\n   \"pos\": {\"line\": 81, \"column\": 49},\n   \"goals\":\n   \"\u03b1 : Type u_1\\n\u03b2 : Type u_2\\n\u03b3 : Type u_3\\nl m : Language \u03b1\\na b x : List \u03b1\\nS : List (List \u03b1)\\nh : \u2200 y \u2208 S, y \u2208 l\\n\u22a2 S.join = (filter (fun l => !l.isEmpty) S).join\",\n   \"endPos\": {\"line\": 81, \"column\": 53}},\n  {\"tactic\":\n   \"rw [mem_filter, Bool.not_eq_true', \u2190 Bool.bool_iff_false, isEmpty_iff_eq_nil] at hy\",\n   \"proofState\": 51,\n   \"pos\": {\"line\": 84, \"column\": 4},\n   \"goals\":\n   \"case mp.intro.intro\\n\u03b1 : Type u_1\\n\u03b2 : Type u_2\\n\u03b3 : Type u_3\\nl m : Language \u03b1\\na b x : List \u03b1\\nS : List (List \u03b1)\\nh : \u2200 y \u2208 S, y \u2208 l\\ny : List \u03b1\\nhy : y \u2208 filter (fun l => !l.isEmpty) S\\n\u22a2 y \u2208 l \u2227 y \u2260 []\",\n   \"endPos\": {\"line\": 84, \"column\": 87}},\n  {\"tactic\": \"exact \u27e8h y hy.1, hy.2\u27e9\",\n   \"proofState\": 52,\n   \"pos\": {\"line\": 85, \"column\": 4},\n   \"goals\":\n   \"case mp.intro.intro\\n\u03b1 : Type u_1\\n\u03b2 : Type u_2\\n\u03b3 : Type u_3\\nl m : Language \u03b1\\na b x : List \u03b1\\nS : List (List \u03b1)\\nh : \u2200 y \u2208 S, y \u2208 l\\ny : List \u03b1\\nhy : y \u2208 S \u2227 \u00acy = []\\n\u22a2 y \u2208 l \u2227 y \u2260 []\",\n   \"endPos\": {\"line\": 85, \"column\": 26}},\n  {\"tactic\": \"rintro \u27e8S, hx, h\u27e9\",\n   \"proofState\": 53,\n   \"pos\": {\"line\": 86, \"column\": 4},\n   \"goals\":\n   \"case mpr\\n\u03b1 : Type u_1\\n\u03b2 : Type u_2\\n\u03b3 : Type u_3\\nl m : Language \u03b1\\na b x\u271d x : List \u03b1\\n\u22a2 (\u2203 S, x = S.join \u2227 \u2200 y \u2208 S, y \u2208 l \u2227 y \u2260 []) \u2192 x \u2208 l\u2217\",\n   \"endPos\": {\"line\": 86, \"column\": 21}},\n  {\"tactic\": \"exact \u27e8S, hx, fun y hy \u21a6 (h y hy).1\u27e9\",\n   \"proofState\": 54,\n   \"pos\": {\"line\": 87, \"column\": 4},\n   \"goals\":\n   \"case mpr.intro.intro\\n\u03b1 : Type u_1\\n\u03b2 : Type u_2\\n\u03b3 : Type u_3\\nl m : Language \u03b1\\na b x\u271d x : List \u03b1\\nS : List (List \u03b1)\\nhx : x = S.join\\nh : \u2200 y \u2208 S, y \u2208 l \u2227 y \u2260 []\\n\u22a2 x \u2208 l\u2217\",\n   \"endPos\": {\"line\": 87, \"column\": 40}},\n  {\"tactic\": \"ext x\",\n   \"proofState\": 55,\n   \"pos\": {\"line\": 91, \"column\": 2},\n   \"goals\":\n   \"\u03b1 : Type u_1\\n\u03b2 : Type u_2\\n\u03b3 : Type u_3\\nl\u271d m : Language \u03b1\\na b x : List \u03b1\\nl : Language \u03b1\\n\u22a2 l\u2217 = {x | \u2203 S, x = S.join \u2227 \u2200 y \u2208 S, y \u2208 l \u2227 y \u2260 []}\",\n   \"endPos\": {\"line\": 91, \"column\": 7}},\n  {\"tactic\": \"apply mem_kstar_iff_exists_nonempty\",\n   \"proofState\": 56,\n   \"pos\": {\"line\": 91, \"column\": 9},\n   \"goals\":\n   \"case h\\n\u03b1 : Type u_1\\n\u03b2 : Type u_2\\n\u03b3 : Type u_3\\nl\u271d m : Language \u03b1\\na b x\u271d : List \u03b1\\nl : Language \u03b1\\nx : List \u03b1\\n\u22a2 x \u2208 l\u2217 \u2194 x \u2208 {x | \u2203 S, x = S.join \u2227 \u2200 y \u2208 S, y \u2208 l \u2227 y \u2260 []}\",\n   \"endPos\": {\"line\": 91, \"column\": 44}},\n  {\"tactic\": \"intro h\u2081 h\u2082 x hx\",\n   \"proofState\": 57,\n   \"pos\": {\"line\": 99, \"column\": 2},\n   \"goals\":\n   \"\u03b1 : Type u_1\\n\u03b2 : Type u_2\\n\u03b3 : Type u_3\\nl m : Language \u03b1\\na b x : List \u03b1\\nl\u2081 l\u2082 m\u2081 m\u2082 : Language \u03b1\\n\u22a2 l\u2081 \u2264 m\u2081 \u2192 l\u2082 \u2264 m\u2082 \u2192 l\u2081 * l\u2082 \u2264 m\u2081 * m\u2082\",\n   \"endPos\": {\"line\": 99, \"column\": 18}},\n  {\"tactic\":\n   \"simp only [mul_def, exists_and_left, mem_image2, image_prod] at hx \u22a2\",\n   \"proofState\": 58,\n   \"pos\": {\"line\": 100, \"column\": 2},\n   \"goals\":\n   \"\u03b1 : Type u_1\\n\u03b2 : Type u_2\\n\u03b3 : Type u_3\\nl m : Language \u03b1\\na b x\u271d : List \u03b1\\nl\u2081 l\u2082 m\u2081 m\u2082 : Language \u03b1\\nh\u2081 : l\u2081 \u2264 m\u2081\\nh\u2082 : l\u2082 \u2264 m\u2082\\nx : List \u03b1\\nhx : x \u2208 l\u2081 * l\u2082\\n\u22a2 x \u2208 m\u2081 * m\u2082\",\n   \"endPos\": {\"line\": 100, \"column\": 70}},\n  {\"tactic\": \"tauto\",\n   \"proofState\": 59,\n   \"pos\": {\"line\": 101, \"column\": 2},\n   \"goals\":\n   \"\u03b1 : Type u_1\\n\u03b2 : Type u_2\\n\u03b3 : Type u_3\\nl m : Language \u03b1\\na b x\u271d : List \u03b1\\nl\u2081 l\u2082 m\u2081 m\u2082 : Language \u03b1\\nh\u2081 : l\u2081 \u2264 m\u2081\\nh\u2082 : l\u2082 \u2264 m\u2082\\nx : List \u03b1\\nhx : \u2203 a \u2208 l\u2081, \u2203 b \u2208 l\u2082, a ++ b = x\\n\u22a2 \u2203 a \u2208 m\u2081, \u2203 b \u2208 m\u2082, a ++ b = x\",\n   \"endPos\": {\"line\": 101, \"column\": 7}},\n  {\"tactic\": \"<failed to pretty print>\",\n   \"proofState\": 60,\n   \"pos\": {\"line\": 135, \"column\": 2},\n   \"goals\":\n   \"\u03b1 : Type u_1\\n\u03b2 : Type u_2\\n\u03b3 : Type u_3\\nl\u271d m : Language \u03b1\\na b x\u271d : List \u03b1\\nl : Language \u03b1\\nx : List \u03b1\\nn : \u2115\\n\u22a2 x \u2208 l ^ n \u2194 \u2203 S, x = S.join \u2227 S.length = n \u2227 \u2200 y \u2208 S, y \u2208 l\",\n   \"endPos\": {\"line\": 141, \"column\": 135}},\n  {\"tactic\": \"<failed to pretty print>\",\n   \"proofState\": 61,\n   \"pos\": {\"line\": 135, \"column\": 2},\n   \"goals\":\n   \"\u03b1 : Type u_1\\n\u03b2 : Type u_2\\n\u03b3 : Type u_3\\nl\u271d m : Language \u03b1\\na b x\u271d : List \u03b1\\nl : Language \u03b1\\nx : List \u03b1\\nn : \u2115\\n\u22a2 x \u2208 l ^ n \u2194 \u2203 S, x = S.join \u2227 S.length = n \u2227 \u2200 y \u2208 S, y \u2208 l\",\n   \"endPos\": {\"line\": 141, \"column\": 135}},\n  {\"tactic\":\n   \"\\n| zero =>\\n  simp [mem_one, pow_zero, length_eq_zero]\\n  exact \u27e8\u27e8[], rfl, rfl, fun _ h => h.elim\u27e9, fun \u27e8_, rfl, _, _\u27e9 => rfl\u27e9\",\n   \"proofState\": 62,\n   \"pos\": {\"line\": 136, \"column\": 2},\n   \"goals\":\n   \"case zero\\n\u03b1 : Type u_1\\n\u03b2 : Type u_2\\n\u03b3 : Type u_3\\nl\u271d m : Language \u03b1\\na b x\u271d : List \u03b1\\nl : Language \u03b1\\nx : List \u03b1\\n\u22a2 x \u2208 l ^ 0 \u2194 \u2203 S, x = S.join \u2227 S.length = 0 \u2227 \u2200 y \u2208 S, y \u2208 l\",\n   \"endPos\": {\"line\": 138, \"column\": 72}},\n  {\"tactic\": \"simp [mem_one, pow_zero, length_eq_zero]\",\n   \"proofState\": 63,\n   \"pos\": {\"line\": 137, \"column\": 4},\n   \"goals\":\n   \"case zero\\n\u03b1 : Type u_1\\n\u03b2 : Type u_2\\n\u03b3 : Type u_3\\nl\u271d m : Language \u03b1\\na b x\u271d : List \u03b1\\nl : Language \u03b1\\nx : List \u03b1\\n\u22a2 x \u2208 l ^ 0 \u2194 \u2203 S, x = S.join \u2227 S.length = 0 \u2227 \u2200 y \u2208 S, y \u2208 l\",\n   \"endPos\": {\"line\": 137, \"column\": 44}},\n  {\"tactic\":\n   \"exact \u27e8\u27e8[], rfl, rfl, fun _ h => h.elim\u27e9, fun \u27e8_, rfl, _, _\u27e9 => rfl\u27e9\",\n   \"proofState\": 64,\n   \"pos\": {\"line\": 138, \"column\": 4},\n   \"goals\":\n   \"case zero\\n\u03b1 : Type u_1\\n\u03b2 : Type u_2\\n\u03b3 : Type u_3\\nl\u271d m : Language \u03b1\\na b x\u271d : List \u03b1\\nl : Language \u03b1\\nx : List \u03b1\\n\u22a2 x = [] \u2194 \u2203 S, x = S.join \u2227 S = [] \u2227 \u2200 y \u2208 S, y \u2208 l\",\n   \"endPos\": {\"line\": 138, \"column\": 72}},\n  {\"tactic\": \"<failed to pretty print>\",\n   \"proofState\": 65,\n   \"pos\": {\"line\": 139, \"column\": 2},\n   \"goals\":\n   \"case succ\\n\u03b1 : Type u_1\\n\u03b2 : Type u_2\\n\u03b3 : Type u_3\\nl\u271d m : Language \u03b1\\na b x\u271d : List \u03b1\\nl : Language \u03b1\\nx : List \u03b1\\nn : \u2115\\nihn : x \u2208 l ^ n \u2194 \u2203 S, x = S.join \u2227 S.length = n \u2227 \u2200 y \u2208 S, y \u2208 l\\n\u22a2 x \u2208 l ^ (n + 1) \u2194 \u2203 S, x = S.join \u2227 S.length = n + 1 \u2227 \u2200 y \u2208 S, y \u2208 l\",\n   \"endPos\": {\"line\": 141, \"column\": 135}},\n  {\"tactic\": \"simp [pow_succ', mem_mul, ihn]\",\n   \"proofState\": 66,\n   \"pos\": {\"line\": 140, \"column\": 4},\n   \"goals\":\n   \"case succ\\n\u03b1 : Type u_1\\n\u03b2 : Type u_2\\n\u03b3 : Type u_3\\nl\u271d m : Language \u03b1\\na b x\u271d : List \u03b1\\nl : Language \u03b1\\nx : List \u03b1\\nn : \u2115\\nihn : x \u2208 l ^ n \u2194 \u2203 S, x = S.join \u2227 S.length = n \u2227 \u2200 y \u2208 S, y \u2208 l\\n\u22a2 x \u2208 l ^ (n + 1) \u2194 \u2203 S, x = S.join \u2227 S.length = n + 1 \u2227 \u2200 y \u2208 S, y \u2208 l\",\n   \"endPos\": {\"line\": 140, \"column\": 34}},\n  {\"tactic\": \"<failed to pretty print>\",\n   \"proofState\": 67,\n   \"pos\": {\"line\": 141, \"column\": 4},\n   \"goals\":\n   \"case succ\\n\u03b1 : Type u_1\\n\u03b2 : Type u_2\\n\u03b3 : Type u_3\\nl\u271d m : Language \u03b1\\na b x\u271d : List \u03b1\\nl : Language \u03b1\\nx : List \u03b1\\nn : \u2115\\nihn : x \u2208 l ^ n \u2194 \u2203 S, x = S.join \u2227 S.length = n \u2227 \u2200 y \u2208 S, y \u2208 l\\n\u22a2 (\u2203 a \u2208 l, \u2203 b \u2208 l ^ n, a ++ b = x) \u2194 \u2203 S, x = S.join \u2227 S.length = n + 1 \u2227 \u2200 y \u2208 S, y \u2208 l\",\n   \"endPos\": {\"line\": 141, \"column\": 135}}],\n \"messages\":\n [{\"severity\": \"warning\",\n   \"pos\": {\"line\": 41, \"column\": 24},\n   \"endPos\": {\"line\": 41, \"column\": 25},\n   \"data\":\n   \"unused variable `l`\\nnote: this linter can be disabled with `set_option linter.unusedVariables false`\"},\n  {\"severity\": \"warning\",\n   \"pos\": {\"line\": 41, \"column\": 26},\n   \"endPos\": {\"line\": 41, \"column\": 27},\n   \"data\":\n   \"unused variable `m`\\nnote: this linter can be disabled with `set_option linter.unusedVariables false`\"},\n  {\"severity\": \"warning\",\n   \"pos\": {\"line\": 41, \"column\": 44},\n   \"endPos\": {\"line\": 41, \"column\": 45},\n   \"data\":\n   \"unused variable `a`\\nnote: this linter can be disabled with `set_option linter.unusedVariables false`\"},\n  {\"severity\": \"error\",\n   \"pos\": {\"line\": 141, \"column\": 135},\n   \"endPos\": {\"line\": 141, \"column\": 137},\n   \"data\": \"unexpected token '|'; expected '\u27e9'\"}],\n \"env\": 2}\n\n\n\nPANIC at List.head! Init.Data.List.BasicAux:62:12: empty list\nuncaught exception: unknown metavariable '?[anonymous]'\n"}, {"idx": 73, "error": "repl output/thms mismatch in length\n\nlen:3\n\n{\"env\": 0}\n\n{\"theorems\":\n [{\"tactics\":\n   [0,\n    1,\n    2,\n    3,\n    4,\n    5,\n    6,\n    7,\n    8,\n    9,\n    10,\n    11,\n    12,\n    13,\n    14,\n    15,\n    16,\n    17,\n    18,\n    19,\n    20,\n    21,\n    22,\n    23,\n    24,\n    25,\n    26,\n    27,\n    28,\n    29],\n   \"start\": {\"line\": 1, \"column\": 0},\n   \"proofTree\":\n   [{\"tactic\": \"obtain \u27e8cf, rfl\u27e9 := Code.exists_code.1 hf\",\n     \"spawned_children\": [],\n     \"children\": [1]},\n    {\"tactic\": \"obtain \u27e8cg, rfl\u27e9 := Code.exists_code.1 hg\",\n     \"spawned_children\": [],\n     \"children\": [2]},\n    {\"tactic\":\n     \"have : Nat.Partrec fun n => Nat.rfindOpt fun k => cf.evaln k n <|> cg.evaln k n :=\",\n     \"spawned_children\": [],\n     \"children\": [3]},\n    {\"tactic\": \"refine \u27e8_, this, fun n => ?_\u27e9\",\n     \"spawned_children\": [],\n     \"children\": [4]},\n    {\"tactic\":\n     \"have : \u2200 x \u2208 rfindOpt fun k \u21a6 HOrElse.hOrElse (Code.evaln k cf n) fun _x \u21a6 Code.evaln k cg n,\",\n     \"spawned_children\": [5],\n     \"children\": [5, 17]},\n    {\"tactic\": \"intro x h\", \"spawned_children\": [], \"children\": [6]},\n    {\"tactic\": \"obtain \u27e8k, e\u27e9 := Nat.rfindOpt_spec h\",\n     \"spawned_children\": [],\n     \"children\": [7]},\n    {\"tactic\": \"revert e\", \"spawned_children\": [], \"children\": [8]},\n    {\"tactic\": \"simp only [Option.mem_def]\",\n     \"spawned_children\": [],\n     \"children\": [9]},\n    {\"tactic\": \"cases' e' : cf.evaln k n with y\",\n     \"spawned_children\": [],\n     \"children\": [10, 11]},\n    {\"tactic\": \"simp\", \"spawned_children\": [], \"children\": [12]},\n    {\"tactic\": \"simp\", \"spawned_children\": [], \"children\": [13]},\n    {\"tactic\": \"intro e\", \"spawned_children\": [], \"children\": [14]},\n    {\"tactic\": \"intro e\", \"spawned_children\": [], \"children\": [15]},\n    {\"tactic\": \"exact Or.inr (Code.evaln_sound e)\",\n     \"spawned_children\": [],\n     \"children\": []},\n    {\"tactic\": \"subst y\", \"spawned_children\": [], \"children\": [16]},\n    {\"tactic\": \"exact Or.inl (Code.evaln_sound e')\",\n     \"spawned_children\": [],\n     \"children\": []},\n    {\"tactic\":\n     \"refine \u27e8this, \u27e8fun h => (this _ \u27e8h, rfl\u27e9).imp Exists.fst Exists.fst, ?_\u27e9\u27e9\",\n     \"spawned_children\": [],\n     \"children\": [18]},\n    {\"tactic\": \"intro h\", \"spawned_children\": [], \"children\": [19]},\n    {\"tactic\": \"rw [Nat.rfindOpt_dom]\",\n     \"spawned_children\": [],\n     \"children\": [20]},\n    {\"tactic\":\n     \"simp only [dom_iff_mem, Code.evaln_complete, Option.mem_def] at h\",\n     \"spawned_children\": [],\n     \"children\": [21]},\n    {\"tactic\": \"obtain \u27e8x, k, e\u27e9 | \u27e8x, k, e\u27e9 := h\",\n     \"spawned_children\": [],\n     \"children\": [22, 24]},\n    {\"tactic\": \"refine \u27e8k, x, ?_\u27e9\", \"spawned_children\": [], \"children\": [23]},\n    {\"tactic\": \"simp only [e, Option.some_orElse, Option.mem_def]\",\n     \"spawned_children\": [],\n     \"children\": []},\n    {\"tactic\": \"refine \u27e8k, ?_\u27e9\", \"spawned_children\": [], \"children\": [25]},\n    {\"tactic\": \"cases' cf.evaln k n with y\",\n     \"spawned_children\": [],\n     \"children\": [26, 28]},\n    {\"tactic\":\n     \"exact \u27e8x, by simp only [e, Option.mem_def, Option.none_orElse]\u27e9\",\n     \"spawned_children\": [27],\n     \"children\": [27]},\n    {\"tactic\": \"simp only [e, Option.mem_def, Option.none_orElse]\",\n     \"spawned_children\": [],\n     \"children\": []},\n    {\"tactic\": \"exact \u27e8y, by simp only [Option.some_orElse, Option.mem_def]\u27e9\",\n     \"spawned_children\": [29],\n     \"children\": [29]},\n    {\"tactic\": \"simp only [Option.some_orElse, Option.mem_def]\",\n     \"spawned_children\": [],\n     \"children\": []}],\n   \"messages\": [],\n   \"end\": {\"line\": 33, \"column\": 66},\n   \"decl\":\n   \"theorem merge' {f g} (hf : Nat.Partrec f) (hg : Nat.Partrec g) :\\n    \u2203 h, Nat.Partrec h \u2227\\n      \u2200 a, (\u2200 x \u2208 h a, x \u2208 f a \u2228 x \u2208 g a) \u2227 ((h a).Dom \u2194 (f a).Dom \u2228 (g a).Dom) \"},\n  {\"tactics\":\n   [30,\n    31,\n    32,\n    33,\n    34,\n    35,\n    36,\n    37,\n    38,\n    39,\n    40,\n    41,\n    42,\n    43,\n    44,\n    45,\n    46,\n    47,\n    48,\n    49,\n    50,\n    51,\n    52,\n    53,\n    54,\n    55],\n   \"start\": {\"line\": 50, \"column\": 0},\n   \"proofTree\":\n   [{\"tactic\":\n     \"let \u27e8k, hk, H\u27e9 := Nat.Partrec.merge' (bind_decode\u2082_iff.1 hf) (bind_decode\u2082_iff.1 hg)\",\n     \"spawned_children\": [],\n     \"children\": [1]},\n    {\"tactic\":\n     \"let k' (a : \u03b1) := (k (encode a)).bind fun n => (decode (\u03b1 := \u03c3) n : Part \u03c3)\",\n     \"spawned_children\": [],\n     \"children\": [2]},\n    {\"tactic\": \"refine\", \"spawned_children\": [], \"children\": [3]},\n    {\"tactic\": \"have : \u2200 x \u2208 k' a, x \u2208 f a \u2228 x \u2208 g a := by\",\n     \"spawned_children\": [4],\n     \"children\": [4, 16]},\n    {\"tactic\": \"intro x h'\", \"spawned_children\": [], \"children\": [5]},\n    {\"tactic\":\n     \"simp only [k', exists_prop, mem_coe, mem_bind_iff, Option.mem_def] at h'\",\n     \"spawned_children\": [],\n     \"children\": [6]},\n    {\"tactic\": \"obtain \u27e8n, hn, hx\u27e9 := h'\",\n     \"spawned_children\": [],\n     \"children\": [7]},\n    {\"tactic\": \"have := (H _).1 _ hn\", \"spawned_children\": [], \"children\": [8]},\n    {\"tactic\": \"simp [mem_decode\u2082, encode_injective.eq_iff] at this\",\n     \"spawned_children\": [],\n     \"children\": [9]},\n    {\"tactic\": \"obtain \u27e8a', ha, rfl\u27e9 | \u27e8a', ha, rfl\u27e9 := this\",\n     \"spawned_children\": [],\n     \"children\": [10, 11]},\n    {\"tactic\": \"simp only [encodek, Option.some_inj] at hx\",\n     \"spawned_children\": [],\n     \"children\": [12]},\n    {\"tactic\": \"simp only [encodek, Option.some_inj] at hx\",\n     \"spawned_children\": [],\n     \"children\": [13]},\n    {\"tactic\": \"rw [hx]\", \"spawned_children\": [], \"children\": [14]},\n    {\"tactic\": \"rw [hx]\", \"spawned_children\": [], \"children\": [15]},\n    {\"tactic\": \"exact Or.inl ha\", \"spawned_children\": [], \"children\": []},\n    {\"tactic\": \"exact Or.inr ha\", \"spawned_children\": [], \"children\": []},\n    {\"tactic\":\n     \"refine \u27e8this, \u27e8fun h => (this _ \u27e8h, rfl\u27e9).imp Exists.fst Exists.fst, ?_\u27e9\u27e9\",\n     \"spawned_children\": [],\n     \"children\": [17]},\n    {\"tactic\": \"intro h\", \"spawned_children\": [], \"children\": [18]},\n    {\"tactic\": \"rw [bind_dom]\", \"spawned_children\": [], \"children\": [19]},\n    {\"tactic\": \"have hk : (k (encode a)).Dom :=\",\n     \"spawned_children\": [20],\n     \"children\": [20, 21]},\n    {\"tactic\": \"simpa only [encodek\u2082, bind_some, coe_some] using h\",\n     \"spawned_children\": [],\n     \"children\": []},\n    {\"tactic\": \"exists hk\", \"spawned_children\": [], \"children\": [22]},\n    {\"tactic\":\n     \"simp only [exists_prop, mem_map_iff, mem_coe, mem_bind_iff, Option.mem_def] at H\",\n     \"spawned_children\": [],\n     \"children\": [23]},\n    {\"tactic\":\n     \"obtain \u27e8a', _, y, _, e\u27e9 | \u27e8a', _, y, _, e\u27e9 := (H _).1 _ \u27e8hk, rfl\u27e9\",\n     \"spawned_children\": [],\n     \"children\": [24, 25]},\n    {\"tactic\": \"simp only [e.symm, encodek, coe_some, some_dom]\",\n     \"spawned_children\": [],\n     \"children\": []},\n    {\"tactic\": \"simp only [e.symm, encodek, coe_some, some_dom]\",\n     \"spawned_children\": [],\n     \"children\": []}],\n   \"messages\": [],\n   \"end\": {\"line\": 76, \"column\": 51},\n   \"decl\":\n   \"theorem merge' {f g : \u03b1 \u2192. \u03c3} (hf : Partrec f) (hg : Partrec g) :\\n    \u2203 k : \u03b1 \u2192. \u03c3,\\n      Partrec k \u2227 \u2200 a, (\u2200 x \u2208 k a, x \u2208 f a \u2228 x \u2208 g a) \u2227 ((k a).Dom \u2194 (f a).Dom \u2228 (g a).Dom) \"},\n  {\"tactics\": [56, 57, 58, 59, 60, 61, 62, 63, 64],\n   \"start\": {\"line\": 79, \"column\": 0},\n   \"proofTree\":\n   [{\"tactic\": \"have : (k a).Dom := (K _).2.2 (h.imp Exists.fst Exists.fst)\",\n     \"spawned_children\": [],\n     \"children\": [1]},\n    {\"tactic\": \"refine \u27e8this, ?_\u27e9\", \"spawned_children\": [], \"children\": [2]},\n    {\"tactic\": \"cases' h with h h\", \"spawned_children\": [], \"children\": [3, 4]},\n    {\"tactic\": \"cases' (K _).1 _ \u27e8this, rfl\u27e9 with h' h'\",\n     \"spawned_children\": [],\n     \"children\": [5, 6]},\n    {\"tactic\": \"cases' (K _).1 _ \u27e8this, rfl\u27e9 with h' h'\",\n     \"spawned_children\": [],\n     \"children\": [7, 8]},\n    {\"tactic\": \"exact mem_unique h' h\", \"spawned_children\": [], \"children\": []},\n    {\"tactic\": \"exact (H _ _ h _ h').symm\",\n     \"spawned_children\": [],\n     \"children\": []},\n    {\"tactic\": \"exact H _ _ h' _ h\", \"spawned_children\": [], \"children\": []},\n    {\"tactic\": \"exact mem_unique h' h\",\n     \"spawned_children\": [],\n     \"children\": []}],\n   \"messages\": [],\n   \"end\": {\"line\": 91, \"column\": 31},\n   \"decl\":\n   \"theorem merge {f g : \u03b1 \u2192. \u03c3} (hf : Partrec f) (hg : Partrec g)\\n    (H : \u2200 (a), \u2200 x \u2208 f a, \u2200 y \u2208 g a, x = y) :\\n    \u2203 k : \u03b1 \u2192. \u03c3, Partrec k \u2227 \u2200 a x, x \u2208 k a \u2194 x \u2208 f a \u2228 x \u2208 g a \"},\n  {\"tactics\": [65, 66, 67],\n   \"start\": {\"line\": 94, \"column\": 0},\n   \"proofTree\":\n   [{\"tactic\": \"cases c a\", \"spawned_children\": [], \"children\": [1, 2]},\n    {\"tactic\": \"simp [ef, eg, encodek]\",\n     \"spawned_children\": [],\n     \"children\": []},\n    {\"tactic\": \"simp [ef, eg, encodek]\",\n     \"spawned_children\": [],\n     \"children\": []}],\n   \"messages\": [],\n   \"end\": {\"line\": 100, \"column\": 52},\n   \"decl\":\n   \"theorem cond {c : \u03b1 \u2192 Bool} {f : \u03b1 \u2192. \u03c3} {g : \u03b1 \u2192. \u03c3} (hc : Computable c) (hf : Partrec f)\\n    (hg : Partrec g) : Partrec fun a => cond (c a) (f a) (g a) \"},\n  {\"tactics\": [68, 69, 70],\n   \"start\": {\"line\": 103, \"column\": 0},\n   \"proofTree\":\n   [{\"tactic\": \"cases f a\", \"spawned_children\": [], \"children\": [1, 2]},\n    {\"tactic\": \"simp only [Bool.cond_true, Bool.cond_false]\",\n     \"spawned_children\": [],\n     \"children\": []},\n    {\"tactic\": \"simp only [Bool.cond_true, Bool.cond_false]\",\n     \"spawned_children\": [],\n     \"children\": []}],\n   \"messages\": [],\n   \"end\": {\"line\": 109, \"column\": 75},\n   \"decl\":\n   \"nonrec theorem sum_casesOn {f : \u03b1 \u2192 Sum \u03b2 \u03b3} {g : \u03b1 \u2192 \u03b2 \u2192. \u03c3} {h : \u03b1 \u2192 \u03b3 \u2192. \u03c3} (hf : Computable f)\\n    (hg : Partrec\u2082 g) (hh : Partrec\u2082 h) : @Partrec _ \u03c3 _ _ fun a => Sum.casesOn (f a) (g a) (h a) \"},\n  {\"tactics\": [71],\n   \"start\": {\"line\": 130, \"column\": 0},\n   \"proofTree\":\n   [{\"tactic\": \"simp [Part.dom_iff_mem]\",\n     \"spawned_children\": [],\n     \"children\": []}],\n   \"messages\": [],\n   \"end\": {\"line\": 132, \"column\": 95},\n   \"decl\":\n   \"theorem Partrec.dom_re {\u03b1 \u03b2} [Primcodable \u03b1] [Primcodable \u03b2] {f : \u03b1 \u2192. \u03b2} (h : Partrec f) :\\n    RePred fun a => (f a).Dom \"},\n  {\"tactics\": [71],\n   \"start\": {\"line\": 130, \"column\": 0},\n   \"proofTree\":\n   [{\"tactic\": \"simp [Part.dom_iff_mem]\",\n     \"spawned_children\": [],\n     \"children\": []}],\n   \"messages\": [],\n   \"end\": {\"line\": 132, \"column\": 95},\n   \"decl\":\n   \"theorem dom_re {\u03b1 \u03b2} [Primcodable \u03b1] [Primcodable \u03b2] {f : \u03b1 \u2192. \u03b2} (h : Partrec f) :\\n    RePred fun a => (f a).Dom \"},\n  {\"tactics\": [72, 73, 74, 75],\n   \"start\": {\"line\": 149, \"column\": 0},\n   \"proofTree\":\n   [{\"tactic\": \"rintro \u27e8f, h, rfl\u27e9\", \"spawned_children\": [], \"children\": [1]},\n    {\"tactic\": \"exact \u27e8by infer_instance, by simpa using h\u27e9\",\n     \"spawned_children\": [2, 3],\n     \"children\": [2, 3]},\n    {\"tactic\": \"infer_instance\", \"spawned_children\": [], \"children\": []},\n    {\"tactic\": \"simpa using h\", \"spawned_children\": [], \"children\": []}],\n   \"messages\": [],\n   \"end\": {\"line\": 152, \"column\": 68},\n   \"decl\":\n   \"theorem computable_iff {p : \u03b1 \u2192 Prop} :\\n    ComputablePred p \u2194 \u2203 f : \u03b1 \u2192 Bool, Computable f \u2227 p = fun a => (f a : Prop) \"},\n  {\"tactics\": [76, 77, 78, 79, 80, 81, 82],\n   \"start\": {\"line\": 155, \"column\": 0},\n   \"proofTree\":\n   [{\"tactic\": \"obtain \u27e8f, hf, rfl\u27e9 := computable_iff.1 hp\",\n     \"spawned_children\": [],\n     \"children\": [1]},\n    {\"tactic\": \"exact\", \"spawned_children\": [2, 3], \"children\": [2, 3]},\n    {\"tactic\": \"infer_instance\", \"spawned_children\": [], \"children\": []},\n    {\"tactic\": \"simp only [Bool.not_eq_true]\",\n     \"spawned_children\": [],\n     \"children\": [4]},\n    {\"tactic\": \"cases f n\", \"spawned_children\": [], \"children\": [5, 6]},\n    {\"tactic\": \"rfl\", \"spawned_children\": [], \"children\": []},\n    {\"tactic\": \"rfl\", \"spawned_children\": [], \"children\": []}],\n   \"messages\": [],\n   \"end\": {\"line\": 161, \"column\": 26},\n   \"decl\":\n   \"protected theorem not {p : \u03b1 \u2192 Prop} (hp : ComputablePred p) : ComputablePred fun a => \u00acp a \"},\n  {\"tactics\": [83, 84, 85, 86, 87, 88, 89, 90],\n   \"start\": {\"line\": 164, \"column\": 0},\n   \"proofTree\":\n   [{\"tactic\": \"obtain \u27e8f, hf, rfl\u27e9 := computable_iff.1 hp\",\n     \"spawned_children\": [],\n     \"children\": [1]},\n    {\"tactic\": \"unfold RePred\", \"spawned_children\": [], \"children\": [2]},\n    {\"tactic\": \"dsimp only []\", \"spawned_children\": [], \"children\": [3]},\n    {\"tactic\": \"refine\", \"spawned_children\": [], \"children\": [4]},\n    {\"tactic\": \"cases a\", \"spawned_children\": [], \"children\": [5]},\n    {\"tactic\": \"cases f n\", \"spawned_children\": [], \"children\": [6, 7]},\n    {\"tactic\": \"simp\", \"spawned_children\": [], \"children\": []},\n    {\"tactic\": \"simp\", \"spawned_children\": [], \"children\": []}],\n   \"messages\": [],\n   \"end\": {\"line\": 171, \"column\": 29},\n   \"decl\": \"theorem to_re {p : \u03b1 \u2192 Prop} (hp : ComputablePred p) : RePred p \"},\n  {\"tactics\": [91, 92, 93, 94, 95, 96, 97, 98, 99, 100],\n   \"start\": {\"line\": 174, \"column\": 0},\n   \"proofTree\":\n   [{\"tactic\": \"cases' h with _ h\", \"spawned_children\": [], \"children\": [1]},\n    {\"tactic\": \"obtain \u27e8c, e\u27e9 :=\", \"spawned_children\": [], \"children\": [2]},\n    {\"tactic\": \"simp only [Bool.cond_decide] at e\",\n     \"spawned_children\": [],\n     \"children\": [3]},\n    {\"tactic\": \"by_cases H : eval c \u2208 C\",\n     \"spawned_children\": [],\n     \"children\": [4, 7]},\n    {\"tactic\": \"simp only [H, if_true] at e\",\n     \"spawned_children\": [],\n     \"children\": [5]},\n    {\"tactic\": \"change (fun b => g b) \u2208 C\",\n     \"spawned_children\": [],\n     \"children\": [6]},\n    {\"tactic\": \"\u2190 e\", \"spawned_children\": [], \"children\": []},\n    {\"tactic\": \"simp only [H, if_false] at e\",\n     \"spawned_children\": [],\n     \"children\": [8]},\n    {\"tactic\": \"rw [e]\", \"spawned_children\": [], \"children\": [9]},\n    {\"tactic\": \"contradiction\", \"spawned_children\": [], \"children\": []}],\n   \"messages\": [],\n   \"end\": {\"line\": 189, \"column\": 17},\n   \"decl\":\n   \"/-- **Rice's Theorem** -/\\ntheorem rice (C : Set (\u2115 \u2192. \u2115)) (h : ComputablePred fun c => eval c \u2208 C) {f g} (hf : Nat.Partrec f)\\n    (hg : Nat.Partrec g) (fC : f \u2208 C) : g \u2208 C \"},\n  {\"tactics\": [101, 102, 103, 104, 105, 106, 107, 108, 109, 110],\n   \"start\": {\"line\": 192, \"column\": 0},\n   \"proofTree\":\n   [{\"tactic\": \"exact\", \"spawned_children\": [1], \"children\": [1]},\n    {\"tactic\": \"obtain rfl | rfl := h\",\n     \"spawned_children\": [],\n     \"children\": [2, 3]},\n    {\"tactic\": \"simp [ComputablePred, Set.mem_empty_iff_false]\",\n     \"spawned_children\": [],\n     \"children\": [4]},\n    {\"tactic\": \"simp [ComputablePred, Set.mem_empty_iff_false]\",\n     \"spawned_children\": [],\n     \"children\": [6]},\n    {\"tactic\": \"exact \u27e8by infer_instance, Computable.const _\u27e9\",\n     \"spawned_children\": [5],\n     \"children\": [5]},\n    {\"tactic\": \"infer_instance\", \"spawned_children\": [], \"children\": []},\n    {\"tactic\": \"exact \u27e8by infer_instance, Computable.const _\u27e9\",\n     \"spawned_children\": [7],\n     \"children\": [7]},\n    {\"tactic\": \"infer_instance\", \"spawned_children\": [], \"children\": []}],\n   \"messages\": [],\n   \"end\": {\"line\": 207, \"column\": 60},\n   \"decl\":\n   \"theorem rice\u2082 (C : Set Code) (H : \u2200 cf cg, eval cf = eval cg \u2192 (cf \u2208 C \u2194 cg \u2208 C)) :\\n    (ComputablePred fun c => c \u2208 C) \u2194 C = \u2205 \u2228 C = Set.univ \"},\n  {\"tactics\": [111, 112, 113, 114, 115, 116, 117, 118],\n   \"start\": {\"line\": 224, \"column\": 0},\n   \"proofTree\":\n   [{\"tactic\": \"obtain \u27e8k, pk, hk\u27e9 :=\",\n     \"spawned_children\": [1],\n     \"children\": [1, 4]},\n    {\"tactic\": \"intro a x hx y hy\", \"spawned_children\": [], \"children\": [2]},\n    {\"tactic\":\n     \"simp only [Part.mem_map_iff, Part.mem_assert_iff, Part.mem_some_iff, exists_prop,\",\n     \"spawned_children\": [],\n     \"children\": [3]},\n    {\"tactic\": \"cases hy.1 hx.1\", \"spawned_children\": [], \"children\": []},\n    {\"tactic\": \"refine Partrec.of_eq pk fun n => Part.eq_some_iff.2 ?_\",\n     \"spawned_children\": [],\n     \"children\": [5]},\n    {\"tactic\": \"rw [hk]\", \"spawned_children\": [], \"children\": [6]},\n    {\"tactic\":\n     \"simp only [Part.mem_map_iff, Part.mem_assert_iff, Part.mem_some_iff, exists_prop, and_true,\",\n     \"spawned_children\": [],\n     \"children\": [7]},\n    {\"tactic\": \"apply Decidable.em\", \"spawned_children\": [], \"children\": []}],\n   \"messages\": [],\n   \"end\": {\"line\": 239, \"column\": 26},\n   \"decl\":\n   \"theorem computable_iff_re_compl_re {p : \u03b1 \u2192 Prop} [DecidablePred p] :\\n    ComputablePred p \u2194 RePred p \u2227 RePred fun a => \u00acp a \"},\n  {\"tactics\": [119, 120],\n   \"start\": {\"line\": 242, \"column\": 0},\n   \"proofTree\":\n   [{\"tactic\": \"exact computable_iff_re_compl_re\",\n     \"spawned_children\": [],\n     \"children\": []}],\n   \"messages\": [],\n   \"end\": {\"line\": 244, \"column\": 44},\n   \"decl\":\n   \"theorem computable_iff_re_compl_re' {p : \u03b1 \u2192 Prop} :\\n    ComputablePred p \u2194 RePred p \u2227 RePred fun a => \u00acp a \"},\n  {\"tactics\": [121, 122, 123, 124, 125, 126, 127, 128, 129, 130],\n   \"start\": {\"line\": 276, \"column\": 0},\n   \"proofTree\":\n   [{\"tactic\": \"induction pf with\",\n     \"spawned_children\": [1, 2, 3],\n     \"children\": [1, 2, 3]},\n    {\"tactic\": \"exact hf.to_prim.to_comp\",\n     \"spawned_children\": [],\n     \"children\": []},\n    {\"tactic\": \"exact (Partrec.vector_mOfFn hg).bind (hf.comp snd)\",\n     \"spawned_children\": [],\n     \"children\": []},\n    {\"tactic\": \"have := hf.comp (vector_cons.comp snd fst)\",\n     \"spawned_children\": [],\n     \"children\": [4]},\n    {\"tactic\": \"have :=\", \"spawned_children\": [], \"children\": [5]},\n    {\"tactic\": \"exact _root_.Partrec.rfind this\",\n     \"spawned_children\": [],\n     \"children\": []}],\n   \"messages\": [],\n   \"end\": {\"line\": 285, \"column\": 35},\n   \"decl\": \"theorem to_part {n f} (pf : @Partrec' n f) : _root_.Partrec f \"},\n  {\"tactics\": [131, 132, 133, 134, 135],\n   \"start\": {\"line\": 300, \"column\": 0},\n   \"proofTree\":\n   [{\"tactic\": \"simp\", \"spawned_children\": [], \"children\": [1]},\n    {\"tactic\": \"rw [\u2190 ofFn_get v.tail]\",\n     \"spawned_children\": [],\n     \"children\": [2]},\n    {\"tactic\": \"congr\", \"spawned_children\": [], \"children\": [3]},\n    {\"tactic\": \"funext i\", \"spawned_children\": [], \"children\": [4]},\n    {\"tactic\": \"simp\", \"spawned_children\": [], \"children\": []}],\n   \"messages\": [],\n   \"end\": {\"line\": 302, \"column\": 55},\n   \"decl\":\n   \"theorem tail {n f} (hf : @Partrec' n f) : @Partrec' n.succ fun v => f v.tail \"},\n  {\"tactics\": [136, 137, 138, 139, 140],\n   \"start\": {\"line\": 305, \"column\": 0},\n   \"proofTree\":\n   [{\"tactic\": \"refine Fin.cases ?_ (fun i => ?_) i\",\n     \"spawned_children\": [],\n     \"children\": [1, 2]},\n    {\"tactic\": \"simp [*]\", \"spawned_children\": [], \"children\": []},\n    {\"tactic\": \"simp [*]\", \"spawned_children\": [], \"children\": [3]},\n    {\"tactic\": \"exact prim (Nat.Primrec'.get _)\",\n     \"spawned_children\": [],\n     \"children\": []},\n    {\"tactic\": \"simp [mOfFn, Part.bind_assoc, pure]\",\n     \"spawned_children\": [],\n     \"children\": []}],\n   \"messages\": [],\n   \"end\": {\"line\": 310, \"column\": 51},\n   \"decl\":\n   \"protected theorem bind {n f g} (hf : @Partrec' n f) (hg : @Partrec' (n + 1) g) :\\n    @Partrec' n fun v => (f v).bind fun a => g (a ::\u1d65 v) \"},\n  {\"tactics\": [141, 142],\n   \"start\": {\"line\": 313, \"column\": 0},\n   \"proofTree\":\n   [{\"tactic\": \"simp [(Part.bind_some_eq_map _ _).symm]\",\n     \"spawned_children\": [],\n     \"children\": [1]},\n    {\"tactic\": \"exact hf.bind hg\", \"spawned_children\": [], \"children\": []}],\n   \"messages\": [],\n   \"end\": {\"line\": 315, \"column\": 59},\n   \"decl\":\n   \"protected theorem map {n f} {g : Vector \u2115 (n + 1) \u2192 \u2115} (hf : @Partrec' n f)\\n    (hg : @Partrec' (n + 1) g) : @Partrec' n fun v => (f v).map fun a => g (a ::\u1d65 v) \"},\n  {\"tactics\": [143, 144],\n   \"start\": {\"line\": 330, \"column\": 0},\n   \"proofTree\":\n   [{\"tactic\": \"simpa using hf\", \"spawned_children\": [], \"children\": []},\n    {\"tactic\": \"simp only [hg i, get_cons_succ]\",\n     \"spawned_children\": [],\n     \"children\": []}],\n   \"messages\": [],\n   \"end\": {\"line\": 332, \"column\": 79},\n   \"decl\":\n   \"protected theorem cons {n m} {f : Vector \u2115 n \u2192 \u2115} {g} (hf : @Partrec' n f) (hg : @Vec n m g) :\\n    Vec fun v => f v ::\u1d65 g v \"},\n  {\"tactics\": [145],\n   \"start\": {\"line\": 339, \"column\": 0},\n   \"proofTree\": [{\"tactic\": \"simp\", \"spawned_children\": [], \"children\": []}],\n   \"messages\": [],\n   \"end\": {\"line\": 340, \"column\": 39},\n   \"decl\":\n   \"theorem comp' {n m f g} (hf : @Partrec' m f) (hg : @Vec n m g) : Partrec' fun v => f (g v) \"},\n  {\"tactics\": [146],\n   \"start\": {\"line\": 343, \"column\": 0},\n   \"proofTree\":\n   [{\"tactic\": \"simpa using hf.comp' (Partrec'.cons hg Partrec'.nil)\",\n     \"spawned_children\": [],\n     \"children\": []}],\n   \"messages\": [],\n   \"end\": {\"line\": 345, \"column\": 54},\n   \"decl\":\n   \"theorem comp\u2081 {n} (f : \u2115 \u2192. \u2115) {g : Vector \u2115 n \u2192 \u2115} (hf : @Partrec' 1 fun v => f v.head)\\n    (hg : @Partrec' n g) : @Partrec' n fun v => f (g v) \"},\n  {\"tactics\": [147, 148],\n   \"start\": {\"line\": 349, \"column\": 0},\n   \"proofTree\":\n   [{\"tactic\":\n     \"simp only [Nat.rfindOpt, exists_prop, tsub_eq_zero_iff_le, PFun.coe_val, Part.mem_bind_iff, Part.mem_some_iff, Option.mem_def, Part.mem_coe]\",\n     \"spawned_children\": [],\n     \"children\": []}],\n   \"messages\": [],\n   \"end\": {\"line\": 352, \"column\": 26},\n   \"decl\":\n   \"theorem rfindOpt {n} {f : Vector \u2115 (n + 1) \u2192 \u2115} (hf : @Partrec' (n + 1) f) :\\n    @Partrec' n fun v => Nat.rfindOpt fun a => ofNat (Option \u2115) (f (a ::\u1d65 v))  \"}],\n \"tactics\":\n [{\"tactic\": \"obtain \u27e8cf, rfl\u27e9 := Code.exists_code.1 hf\",\n   \"proofState\": 0,\n   \"pos\": {\"line\": 4, \"column\": 2},\n   \"goals\":\n   \"f g : \u2115 \u2192. \u2115\\nhf : Partrec f\\nhg : Partrec g\\n\u22a2 \u2203 h, Partrec h \u2227 \u2200 (a : \u2115), (\u2200 x \u2208 h a, x \u2208 f a \u2228 x \u2208 g a) \u2227 ((h a).Dom \u2194 (f a).Dom \u2228 (g a).Dom)\",\n   \"endPos\": {\"line\": 4, \"column\": 43}},\n  {\"tactic\": \"obtain \u27e8cg, rfl\u27e9 := Code.exists_code.1 hg\",\n   \"proofState\": 1,\n   \"pos\": {\"line\": 5, \"column\": 2},\n   \"goals\":\n   \"case intro\\ng : \u2115 \u2192. \u2115\\nhg : Partrec g\\ncf : Code\\nhf : Partrec cf.eval\\n\u22a2 \u2203 h, Partrec h \u2227 \u2200 (a : \u2115), (\u2200 x \u2208 h a, x \u2208 cf.eval a \u2228 x \u2208 g a) \u2227 ((h a).Dom \u2194 (cf.eval a).Dom \u2228 (g a).Dom)\",\n   \"endPos\": {\"line\": 5, \"column\": 43}},\n  {\"tactic\":\n   \"have : Nat.Partrec fun n => Nat.rfindOpt fun k => cf.evaln k n <|> cg.evaln k n :=\\n  Partrec.nat_iff.1\\n    (Partrec.rfindOpt <|\\n      Primrec.option_orElse.to_comp.comp (Code.evaln_prim.to_comp.comp <| (snd.pair (const cf)).pair fst)\\n        (Code.evaln_prim.to_comp.comp <| (snd.pair (const cg)).pair fst))\",\n   \"proofState\": 2,\n   \"pos\": {\"line\": 6, \"column\": 2},\n   \"goals\":\n   \"case intro.intro\\ncf : Code\\nhf : Partrec cf.eval\\ncg : Code\\nhg : Partrec cg.eval\\n\u22a2 \u2203 h,\\n    Partrec h \u2227 \u2200 (a : \u2115), (\u2200 x \u2208 h a, x \u2208 cf.eval a \u2228 x \u2208 cg.eval a) \u2227 ((h a).Dom \u2194 (cf.eval a).Dom \u2228 (cg.eval a).Dom)\",\n   \"endPos\": {\"line\": 11, \"column\": 75}},\n  {\"tactic\": \"refine \u27e8_, this, fun n => ?_\u27e9\",\n   \"proofState\": 3,\n   \"pos\": {\"line\": 12, \"column\": 2},\n   \"goals\":\n   \"case intro.intro\\ncf : Code\\nhf : Partrec cf.eval\\ncg : Code\\nhg : Partrec cg.eval\\nthis : Partrec fun n => rfindOpt fun k => HOrElse.hOrElse (Code.evaln k cf n) fun x => Code.evaln k cg n\\n\u22a2 \u2203 h,\\n    Partrec h \u2227 \u2200 (a : \u2115), (\u2200 x \u2208 h a, x \u2208 cf.eval a \u2228 x \u2208 cg.eval a) \u2227 ((h a).Dom \u2194 (cf.eval a).Dom \u2228 (cg.eval a).Dom)\",\n   \"endPos\": {\"line\": 12, \"column\": 31}},\n  {\"tactic\":\n   \"have :\\n  \u2200 x \u2208 rfindOpt fun k \u21a6 HOrElse.hOrElse (Code.evaln k cf n) fun _x \u21a6 Code.evaln k cg n,\\n    x \u2208 Code.eval cf n \u2228 x \u2208 Code.eval cg n :=\\n  by\\n  intro x h\\n  obtain \u27e8k, e\u27e9 := Nat.rfindOpt_spec h\\n  revert e\\n  simp only [Option.mem_def]\\n  cases' e' : cf.evaln k n with y <;> simp <;> intro e\\n  \u00b7 exact Or.inr (Code.evaln_sound e)\\n  \u00b7 subst y\\n    exact Or.inl (Code.evaln_sound e')\",\n   \"proofState\": 4,\n   \"pos\": {\"line\": 13, \"column\": 2},\n   \"goals\":\n   \"case intro.intro\\ncf : Code\\nhf : Partrec cf.eval\\ncg : Code\\nhg : Partrec cg.eval\\nthis : Partrec fun n => rfindOpt fun k => HOrElse.hOrElse (Code.evaln k cf n) fun x => Code.evaln k cg n\\nn : \u2115\\n\u22a2 (\u2200 x \u2208 rfindOpt fun k => HOrElse.hOrElse (Code.evaln k cf n) fun x => Code.evaln k cg n,\\n      x \u2208 cf.eval n \u2228 x \u2208 cg.eval n) \u2227\\n    ((rfindOpt fun k => HOrElse.hOrElse (Code.evaln k cf n) fun x => Code.evaln k cg n).Dom \u2194\\n      (cf.eval n).Dom \u2228 (cg.eval n).Dom)\",\n   \"endPos\": {\"line\": 22, \"column\": 40}},\n  {\"tactic\": \"intro x h\",\n   \"proofState\": 5,\n   \"pos\": {\"line\": 15, \"column\": 4},\n   \"goals\":\n   \"cf : Code\\nhf : Partrec cf.eval\\ncg : Code\\nhg : Partrec cg.eval\\nthis : Partrec fun n => rfindOpt fun k => HOrElse.hOrElse (Code.evaln k cf n) fun x => Code.evaln k cg n\\nn : \u2115\\n\u22a2 \u2200 x \u2208 rfindOpt fun k => HOrElse.hOrElse (Code.evaln k cf n) fun _x => Code.evaln k cg n, x \u2208 cf.eval n \u2228 x \u2208 cg.eval n\",\n   \"endPos\": {\"line\": 15, \"column\": 13}},\n  {\"tactic\": \"obtain \u27e8k, e\u27e9 := Nat.rfindOpt_spec h\",\n   \"proofState\": 6,\n   \"pos\": {\"line\": 16, \"column\": 4},\n   \"goals\":\n   \"cf : Code\\nhf : Partrec cf.eval\\ncg : Code\\nhg : Partrec cg.eval\\nthis : Partrec fun n => rfindOpt fun k => HOrElse.hOrElse (Code.evaln k cf n) fun x => Code.evaln k cg n\\nn x : \u2115\\nh : x \u2208 rfindOpt fun k => HOrElse.hOrElse (Code.evaln k cf n) fun _x => Code.evaln k cg n\\n\u22a2 x \u2208 cf.eval n \u2228 x \u2208 cg.eval n\",\n   \"endPos\": {\"line\": 16, \"column\": 40}},\n  {\"tactic\": \"revert e\",\n   \"proofState\": 7,\n   \"pos\": {\"line\": 17, \"column\": 4},\n   \"goals\":\n   \"case intro\\ncf : Code\\nhf : Partrec cf.eval\\ncg : Code\\nhg : Partrec cg.eval\\nthis : Partrec fun n => rfindOpt fun k => HOrElse.hOrElse (Code.evaln k cf n) fun x => Code.evaln k cg n\\nn x : \u2115\\nh : x \u2208 rfindOpt fun k => HOrElse.hOrElse (Code.evaln k cf n) fun _x => Code.evaln k cg n\\nk : \u2115\\ne : x \u2208 HOrElse.hOrElse (Code.evaln k cf n) fun _x => Code.evaln k cg n\\n\u22a2 x \u2208 cf.eval n \u2228 x \u2208 cg.eval n\",\n   \"endPos\": {\"line\": 17, \"column\": 12}},\n  {\"tactic\": \"simp only [Option.mem_def]\",\n   \"proofState\": 8,\n   \"pos\": {\"line\": 18, \"column\": 4},\n   \"goals\":\n   \"case intro\\ncf : Code\\nhf : Partrec cf.eval\\ncg : Code\\nhg : Partrec cg.eval\\nthis : Partrec fun n => rfindOpt fun k => HOrElse.hOrElse (Code.evaln k cf n) fun x => Code.evaln k cg n\\nn x : \u2115\\nh : x \u2208 rfindOpt fun k => HOrElse.hOrElse (Code.evaln k cf n) fun _x => Code.evaln k cg n\\nk : \u2115\\n\u22a2 (x \u2208 HOrElse.hOrElse (Code.evaln k cf n) fun _x => Code.evaln k cg n) \u2192 x \u2208 cf.eval n \u2228 x \u2208 cg.eval n\",\n   \"endPos\": {\"line\": 18, \"column\": 30}},\n  {\"tactic\": \"cases' e' : cf.evaln k n with y\",\n   \"proofState\": 9,\n   \"pos\": {\"line\": 19, \"column\": 4},\n   \"goals\":\n   \"case intro\\ncf : Code\\nhf : Partrec cf.eval\\ncg : Code\\nhg : Partrec cg.eval\\nthis : Partrec fun n => rfindOpt fun k => HOrElse.hOrElse (Code.evaln k cf n) fun x => Code.evaln k cg n\\nn x : \u2115\\nh : x \u2208 rfindOpt fun k => HOrElse.hOrElse (Code.evaln k cf n) fun _x => Code.evaln k cg n\\nk : \u2115\\n\u22a2 (HOrElse.hOrElse (Code.evaln k cf n) fun _x => Code.evaln k cg n) = Option.some x \u2192 x \u2208 cf.eval n \u2228 x \u2208 cg.eval n\",\n   \"endPos\": {\"line\": 19, \"column\": 35}},\n  {\"tactic\": \"simp\",\n   \"proofState\": 10,\n   \"pos\": {\"line\": 19, \"column\": 40},\n   \"goals\":\n   \"case intro.none\\ncf : Code\\nhf : Partrec cf.eval\\ncg : Code\\nhg : Partrec cg.eval\\nthis : Partrec fun n => rfindOpt fun k => HOrElse.hOrElse (Code.evaln k cf n) fun x => Code.evaln k cg n\\nn x : \u2115\\nh : x \u2208 rfindOpt fun k => HOrElse.hOrElse (Code.evaln k cf n) fun _x => Code.evaln k cg n\\nk : \u2115\\ne' : Code.evaln k cf n = Option.none\\n\u22a2 (HOrElse.hOrElse Option.none fun _x => Code.evaln k cg n) = Option.some x \u2192 x \u2208 cf.eval n \u2228 x \u2208 cg.eval n\",\n   \"endPos\": {\"line\": 19, \"column\": 44}},\n  {\"tactic\": \"simp\",\n   \"proofState\": 11,\n   \"pos\": {\"line\": 19, \"column\": 40},\n   \"goals\":\n   \"case intro.some\\ncf : Code\\nhf : Partrec cf.eval\\ncg : Code\\nhg : Partrec cg.eval\\nthis : Partrec fun n => rfindOpt fun k => HOrElse.hOrElse (Code.evaln k cf n) fun x => Code.evaln k cg n\\nn x : \u2115\\nh : x \u2208 rfindOpt fun k => HOrElse.hOrElse (Code.evaln k cf n) fun _x => Code.evaln k cg n\\nk y : \u2115\\ne' : Code.evaln k cf n = Option.some y\\n\u22a2 (HOrElse.hOrElse (Option.some y) fun _x => Code.evaln k cg n) = Option.some x \u2192 x \u2208 cf.eval n \u2228 x \u2208 cg.eval n\",\n   \"endPos\": {\"line\": 19, \"column\": 44}},\n  {\"tactic\": \"intro e\",\n   \"proofState\": 12,\n   \"pos\": {\"line\": 19, \"column\": 49},\n   \"goals\":\n   \"case intro.none\\ncf : Code\\nhf : Partrec cf.eval\\ncg : Code\\nhg : Partrec cg.eval\\nthis : Partrec fun n => rfindOpt fun k => HOrElse.hOrElse (Code.evaln k cf n) fun x => Code.evaln k cg n\\nn x : \u2115\\nh : x \u2208 rfindOpt fun k => HOrElse.hOrElse (Code.evaln k cf n) fun _x => Code.evaln k cg n\\nk : \u2115\\ne' : Code.evaln k cf n = Option.none\\n\u22a2 Code.evaln k cg n = Option.some x \u2192 x \u2208 cf.eval n \u2228 x \u2208 cg.eval n\",\n   \"endPos\": {\"line\": 19, \"column\": 56}},\n  {\"tactic\": \"intro e\",\n   \"proofState\": 13,\n   \"pos\": {\"line\": 19, \"column\": 49},\n   \"goals\":\n   \"case intro.some\\ncf : Code\\nhf : Partrec cf.eval\\ncg : Code\\nhg : Partrec cg.eval\\nthis : Partrec fun n => rfindOpt fun k => HOrElse.hOrElse (Code.evaln k cf n) fun x => Code.evaln k cg n\\nn x : \u2115\\nh : x \u2208 rfindOpt fun k => HOrElse.hOrElse (Code.evaln k cf n) fun _x => Code.evaln k cg n\\nk y : \u2115\\ne' : Code.evaln k cf n = Option.some y\\n\u22a2 y = x \u2192 x \u2208 cf.eval n \u2228 x \u2208 cg.eval n\",\n   \"endPos\": {\"line\": 19, \"column\": 56}},\n  {\"tactic\": \"exact Or.inr (Code.evaln_sound e)\",\n   \"proofState\": 14,\n   \"pos\": {\"line\": 20, \"column\": 6},\n   \"goals\":\n   \"case intro.none\\ncf : Code\\nhf : Partrec cf.eval\\ncg : Code\\nhg : Partrec cg.eval\\nthis : Partrec fun n => rfindOpt fun k => HOrElse.hOrElse (Code.evaln k cf n) fun x => Code.evaln k cg n\\nn x : \u2115\\nh : x \u2208 rfindOpt fun k => HOrElse.hOrElse (Code.evaln k cf n) fun _x => Code.evaln k cg n\\nk : \u2115\\ne' : Code.evaln k cf n = Option.none\\ne : Code.evaln k cg n = Option.some x\\n\u22a2 x \u2208 cf.eval n \u2228 x \u2208 cg.eval n\",\n   \"endPos\": {\"line\": 20, \"column\": 39}},\n  {\"tactic\": \"subst y\",\n   \"proofState\": 15,\n   \"pos\": {\"line\": 21, \"column\": 6},\n   \"goals\":\n   \"case intro.some\\ncf : Code\\nhf : Partrec cf.eval\\ncg : Code\\nhg : Partrec cg.eval\\nthis : Partrec fun n => rfindOpt fun k => HOrElse.hOrElse (Code.evaln k cf n) fun x => Code.evaln k cg n\\nn x : \u2115\\nh : x \u2208 rfindOpt fun k => HOrElse.hOrElse (Code.evaln k cf n) fun _x => Code.evaln k cg n\\nk y : \u2115\\ne' : Code.evaln k cf n = Option.some y\\ne : y = x\\n\u22a2 x \u2208 cf.eval n \u2228 x \u2208 cg.eval n\",\n   \"endPos\": {\"line\": 21, \"column\": 13}},\n  {\"tactic\": \"exact Or.inl (Code.evaln_sound e')\",\n   \"proofState\": 16,\n   \"pos\": {\"line\": 22, \"column\": 6},\n   \"goals\":\n   \"case intro.some\\ncf : Code\\nhf : Partrec cf.eval\\ncg : Code\\nhg : Partrec cg.eval\\nthis : Partrec fun n => rfindOpt fun k => HOrElse.hOrElse (Code.evaln k cf n) fun x => Code.evaln k cg n\\nn x : \u2115\\nh : x \u2208 rfindOpt fun k => HOrElse.hOrElse (Code.evaln k cf n) fun _x => Code.evaln k cg n\\nk : \u2115\\ne' : Code.evaln k cf n = Option.some x\\n\u22a2 x \u2208 cf.eval n \u2228 x \u2208 cg.eval n\",\n   \"endPos\": {\"line\": 22, \"column\": 40}},\n  {\"tactic\":\n   \"refine \u27e8this, \u27e8fun h => (this _ \u27e8h, rfl\u27e9).imp Exists.fst Exists.fst, ?_\u27e9\u27e9\",\n   \"proofState\": 17,\n   \"pos\": {\"line\": 23, \"column\": 2},\n   \"goals\":\n   \"case intro.intro\\ncf : Code\\nhf : Partrec cf.eval\\ncg : Code\\nhg : Partrec cg.eval\\nthis\u271d : Partrec fun n => rfindOpt fun k => HOrElse.hOrElse (Code.evaln k cf n) fun x => Code.evaln k cg n\\nn : \u2115\\nthis :\\n  \u2200 x \u2208 rfindOpt fun k => HOrElse.hOrElse (Code.evaln k cf n) fun _x => Code.evaln k cg n, x \u2208 cf.eval n \u2228 x \u2208 cg.eval n\\n\u22a2 (\u2200 x \u2208 rfindOpt fun k => HOrElse.hOrElse (Code.evaln k cf n) fun x => Code.evaln k cg n,\\n      x \u2208 cf.eval n \u2228 x \u2208 cg.eval n) \u2227\\n    ((rfindOpt fun k => HOrElse.hOrElse (Code.evaln k cf n) fun x => Code.evaln k cg n).Dom \u2194\\n      (cf.eval n).Dom \u2228 (cg.eval n).Dom)\",\n   \"endPos\": {\"line\": 23, \"column\": 75}},\n  {\"tactic\": \"intro h\",\n   \"proofState\": 18,\n   \"pos\": {\"line\": 24, \"column\": 2},\n   \"goals\":\n   \"case intro.intro\\ncf : Code\\nhf : Partrec cf.eval\\ncg : Code\\nhg : Partrec cg.eval\\nthis\u271d : Partrec fun n => rfindOpt fun k => HOrElse.hOrElse (Code.evaln k cf n) fun x => Code.evaln k cg n\\nn : \u2115\\nthis :\\n  \u2200 x \u2208 rfindOpt fun k => HOrElse.hOrElse (Code.evaln k cf n) fun _x => Code.evaln k cg n, x \u2208 cf.eval n \u2228 x \u2208 cg.eval n\\n\u22a2 (cf.eval n).Dom \u2228 (cg.eval n).Dom \u2192\\n    (rfindOpt fun k => HOrElse.hOrElse (Code.evaln k cf n) fun x => Code.evaln k cg n).Dom\",\n   \"endPos\": {\"line\": 24, \"column\": 9}},\n  {\"tactic\": \"rw [Nat.rfindOpt_dom]\",\n   \"proofState\": 19,\n   \"pos\": {\"line\": 25, \"column\": 2},\n   \"goals\":\n   \"case intro.intro\\ncf : Code\\nhf : Partrec cf.eval\\ncg : Code\\nhg : Partrec cg.eval\\nthis\u271d : Partrec fun n => rfindOpt fun k => HOrElse.hOrElse (Code.evaln k cf n) fun x => Code.evaln k cg n\\nn : \u2115\\nthis :\\n  \u2200 x \u2208 rfindOpt fun k => HOrElse.hOrElse (Code.evaln k cf n) fun _x => Code.evaln k cg n, x \u2208 cf.eval n \u2228 x \u2208 cg.eval n\\nh : (cf.eval n).Dom \u2228 (cg.eval n).Dom\\n\u22a2 (rfindOpt fun k => HOrElse.hOrElse (Code.evaln k cf n) fun x => Code.evaln k cg n).Dom\",\n   \"endPos\": {\"line\": 25, \"column\": 23}},\n  {\"tactic\":\n   \"simp only [dom_iff_mem, Code.evaln_complete, Option.mem_def] at h\",\n   \"proofState\": 20,\n   \"pos\": {\"line\": 26, \"column\": 2},\n   \"goals\":\n   \"case intro.intro\\ncf : Code\\nhf : Partrec cf.eval\\ncg : Code\\nhg : Partrec cg.eval\\nthis\u271d : Partrec fun n => rfindOpt fun k => HOrElse.hOrElse (Code.evaln k cf n) fun x => Code.evaln k cg n\\nn : \u2115\\nthis :\\n  \u2200 x \u2208 rfindOpt fun k => HOrElse.hOrElse (Code.evaln k cf n) fun _x => Code.evaln k cg n, x \u2208 cf.eval n \u2228 x \u2208 cg.eval n\\nh : (cf.eval n).Dom \u2228 (cg.eval n).Dom\\n\u22a2 \u2203 n_1 a, a \u2208 HOrElse.hOrElse (Code.evaln n_1 cf n) fun x => Code.evaln n_1 cg n\",\n   \"endPos\": {\"line\": 26, \"column\": 67}},\n  {\"tactic\": \"obtain \u27e8x, k, e\u27e9 | \u27e8x, k, e\u27e9 := h\",\n   \"proofState\": 21,\n   \"pos\": {\"line\": 27, \"column\": 2},\n   \"goals\":\n   \"case intro.intro\\ncf : Code\\nhf : Partrec cf.eval\\ncg : Code\\nhg : Partrec cg.eval\\nthis\u271d : Partrec fun n => rfindOpt fun k => HOrElse.hOrElse (Code.evaln k cf n) fun x => Code.evaln k cg n\\nn : \u2115\\nthis :\\n  \u2200 x \u2208 rfindOpt fun k => HOrElse.hOrElse (Code.evaln k cf n) fun _x => Code.evaln k cg n, x \u2208 cf.eval n \u2228 x \u2208 cg.eval n\\nh : (\u2203 y k, Code.evaln k cf n = Option.some y) \u2228 \u2203 y k, Code.evaln k cg n = Option.some y\\n\u22a2 \u2203 n_1 a, a \u2208 HOrElse.hOrElse (Code.evaln n_1 cf n) fun x => Code.evaln n_1 cg n\",\n   \"endPos\": {\"line\": 27, \"column\": 35}},\n  {\"tactic\": \"refine \u27e8k, x, ?_\u27e9\",\n   \"proofState\": 22,\n   \"pos\": {\"line\": 28, \"column\": 4},\n   \"goals\":\n   \"case intro.intro.inl.intro.intro\\ncf : Code\\nhf : Partrec cf.eval\\ncg : Code\\nhg : Partrec cg.eval\\nthis\u271d : Partrec fun n => rfindOpt fun k => HOrElse.hOrElse (Code.evaln k cf n) fun x => Code.evaln k cg n\\nn : \u2115\\nthis :\\n  \u2200 x \u2208 rfindOpt fun k => HOrElse.hOrElse (Code.evaln k cf n) fun _x => Code.evaln k cg n, x \u2208 cf.eval n \u2228 x \u2208 cg.eval n\\nx k : \u2115\\ne : Code.evaln k cf n = Option.some x\\n\u22a2 \u2203 n_1 a, a \u2208 HOrElse.hOrElse (Code.evaln n_1 cf n) fun x => Code.evaln n_1 cg n\",\n   \"endPos\": {\"line\": 28, \"column\": 21}},\n  {\"tactic\": \"simp only [e, Option.some_orElse, Option.mem_def]\",\n   \"proofState\": 23,\n   \"pos\": {\"line\": 29, \"column\": 4},\n   \"goals\":\n   \"case intro.intro.inl.intro.intro\\ncf : Code\\nhf : Partrec cf.eval\\ncg : Code\\nhg : Partrec cg.eval\\nthis\u271d : Partrec fun n => rfindOpt fun k => HOrElse.hOrElse (Code.evaln k cf n) fun x => Code.evaln k cg n\\nn : \u2115\\nthis :\\n  \u2200 x \u2208 rfindOpt fun k => HOrElse.hOrElse (Code.evaln k cf n) fun _x => Code.evaln k cg n, x \u2208 cf.eval n \u2228 x \u2208 cg.eval n\\nx k : \u2115\\ne : Code.evaln k cf n = Option.some x\\n\u22a2 x \u2208 HOrElse.hOrElse (Code.evaln k cf n) fun x => Code.evaln k cg n\",\n   \"endPos\": {\"line\": 29, \"column\": 53}},\n  {\"tactic\": \"refine \u27e8k, ?_\u27e9\",\n   \"proofState\": 24,\n   \"pos\": {\"line\": 30, \"column\": 4},\n   \"goals\":\n   \"case intro.intro.inr.intro.intro\\ncf : Code\\nhf : Partrec cf.eval\\ncg : Code\\nhg : Partrec cg.eval\\nthis\u271d : Partrec fun n => rfindOpt fun k => HOrElse.hOrElse (Code.evaln k cf n) fun x => Code.evaln k cg n\\nn : \u2115\\nthis :\\n  \u2200 x \u2208 rfindOpt fun k => HOrElse.hOrElse (Code.evaln k cf n) fun _x => Code.evaln k cg n, x \u2208 cf.eval n \u2228 x \u2208 cg.eval n\\nx k : \u2115\\ne : Code.evaln k cg n = Option.some x\\n\u22a2 \u2203 n_1 a, a \u2208 HOrElse.hOrElse (Code.evaln n_1 cf n) fun x => Code.evaln n_1 cg n\",\n   \"endPos\": {\"line\": 30, \"column\": 18}},\n  {\"tactic\": \"cases' cf.evaln k n with y\",\n   \"proofState\": 25,\n   \"pos\": {\"line\": 31, \"column\": 4},\n   \"goals\":\n   \"case intro.intro.inr.intro.intro\\ncf : Code\\nhf : Partrec cf.eval\\ncg : Code\\nhg : Partrec cg.eval\\nthis\u271d : Partrec fun n => rfindOpt fun k => HOrElse.hOrElse (Code.evaln k cf n) fun x => Code.evaln k cg n\\nn : \u2115\\nthis :\\n  \u2200 x \u2208 rfindOpt fun k => HOrElse.hOrElse (Code.evaln k cf n) fun _x => Code.evaln k cg n, x \u2208 cf.eval n \u2228 x \u2208 cg.eval n\\nx k : \u2115\\ne : Code.evaln k cg n = Option.some x\\n\u22a2 \u2203 a, a \u2208 HOrElse.hOrElse (Code.evaln k cf n) fun x => Code.evaln k cg n\",\n   \"endPos\": {\"line\": 31, \"column\": 30}},\n  {\"tactic\": \"exact \u27e8x, by simp only [e, Option.mem_def, Option.none_orElse]\u27e9\",\n   \"proofState\": 26,\n   \"pos\": {\"line\": 32, \"column\": 6},\n   \"goals\":\n   \"case intro.intro.inr.intro.intro.none\\ncf : Code\\nhf : Partrec cf.eval\\ncg : Code\\nhg : Partrec cg.eval\\nthis\u271d : Partrec fun n => rfindOpt fun k => HOrElse.hOrElse (Code.evaln k cf n) fun x => Code.evaln k cg n\\nn : \u2115\\nthis :\\n  \u2200 x \u2208 rfindOpt fun k => HOrElse.hOrElse (Code.evaln k cf n) fun _x => Code.evaln k cg n, x \u2208 cf.eval n \u2228 x \u2208 cg.eval n\\nx k : \u2115\\ne : Code.evaln k cg n = Option.some x\\n\u22a2 \u2203 a, a \u2208 HOrElse.hOrElse Option.none fun x => Code.evaln k cg n\",\n   \"endPos\": {\"line\": 32, \"column\": 69}},\n  {\"tactic\": \"simp only [e, Option.mem_def, Option.none_orElse]\",\n   \"proofState\": 27,\n   \"pos\": {\"line\": 32, \"column\": 19},\n   \"goals\":\n   \"cf : Code\\nhf : Partrec cf.eval\\ncg : Code\\nhg : Partrec cg.eval\\nthis\u271d : Partrec fun n => rfindOpt fun k => HOrElse.hOrElse (Code.evaln k cf n) fun x => Code.evaln k cg n\\nn : \u2115\\nthis :\\n  \u2200 x \u2208 rfindOpt fun k => HOrElse.hOrElse (Code.evaln k cf n) fun _x => Code.evaln k cg n, x \u2208 cf.eval n \u2228 x \u2208 cg.eval n\\nx k : \u2115\\ne : Code.evaln k cg n = Option.some x\\n\u22a2 x \u2208 HOrElse.hOrElse Option.none fun x => Code.evaln k cg n\",\n   \"endPos\": {\"line\": 32, \"column\": 68}},\n  {\"tactic\": \"exact \u27e8y, by simp only [Option.some_orElse, Option.mem_def]\u27e9\",\n   \"proofState\": 28,\n   \"pos\": {\"line\": 33, \"column\": 6},\n   \"goals\":\n   \"case intro.intro.inr.intro.intro.some\\ncf : Code\\nhf : Partrec cf.eval\\ncg : Code\\nhg : Partrec cg.eval\\nthis\u271d : Partrec fun n => rfindOpt fun k => HOrElse.hOrElse (Code.evaln k cf n) fun x => Code.evaln k cg n\\nn : \u2115\\nthis :\\n  \u2200 x \u2208 rfindOpt fun k => HOrElse.hOrElse (Code.evaln k cf n) fun _x => Code.evaln k cg n, x \u2208 cf.eval n \u2228 x \u2208 cg.eval n\\nx k : \u2115\\ne : Code.evaln k cg n = Option.some x\\ny : \u2115\\n\u22a2 \u2203 a, a \u2208 HOrElse.hOrElse (Option.some y) fun x => Code.evaln k cg n\",\n   \"endPos\": {\"line\": 33, \"column\": 66}},\n  {\"tactic\": \"simp only [Option.some_orElse, Option.mem_def]\",\n   \"proofState\": 29,\n   \"pos\": {\"line\": 33, \"column\": 19},\n   \"goals\":\n   \"cf : Code\\nhf : Partrec cf.eval\\ncg : Code\\nhg : Partrec cg.eval\\nthis\u271d : Partrec fun n => rfindOpt fun k => HOrElse.hOrElse (Code.evaln k cf n) fun x => Code.evaln k cg n\\nn : \u2115\\nthis :\\n  \u2200 x \u2208 rfindOpt fun k => HOrElse.hOrElse (Code.evaln k cf n) fun _x => Code.evaln k cg n, x \u2208 cf.eval n \u2228 x \u2208 cg.eval n\\nx k : \u2115\\ne : Code.evaln k cg n = Option.some x\\ny : \u2115\\n\u22a2 y \u2208 HOrElse.hOrElse (Option.some y) fun x => Code.evaln k cg n\",\n   \"endPos\": {\"line\": 33, \"column\": 65}},\n  {\"tactic\":\n   \"let \u27e8k, hk, H\u27e9 := Nat.Partrec.merge' (bind_decode\u2082_iff.1 hf) (bind_decode\u2082_iff.1 hg)\",\n   \"proofState\": 30,\n   \"pos\": {\"line\": 53, \"column\": 2},\n   \"goals\":\n   \"\u03b1 : Type u_1\\n\u03b2 : Type u_2\\n\u03b3 : Type u_3\\n\u03c3 : Type u_4\\ninst\u271d\u00b3 : Primcodable \u03b1\\ninst\u271d\u00b2 : Primcodable \u03b2\\ninst\u271d\u00b9 : Primcodable \u03b3\\ninst\u271d : Primcodable \u03c3\\nf g : \u03b1 \u2192. \u03c3\\nhf : Partrec f\\nhg : Partrec g\\n\u22a2 \u2203 k, Partrec k \u2227 \u2200 (a : \u03b1), (\u2200 x \u2208 k a, x \u2208 f a \u2228 x \u2208 g a) \u2227 ((k a).Dom \u2194 (f a).Dom \u2228 (g a).Dom)\",\n   \"endPos\": {\"line\": 53, \"column\": 86}},\n  {\"tactic\":\n   \"let k' (a : \u03b1) := (k (encode a)).bind fun n => (decode (\u03b1 := \u03c3) n : Part \u03c3)\",\n   \"proofState\": 31,\n   \"pos\": {\"line\": 54, \"column\": 2},\n   \"goals\":\n   \"\u03b1 : Type u_1\\n\u03b2 : Type u_2\\n\u03b3 : Type u_3\\n\u03c3 : Type u_4\\ninst\u271d\u00b3 : Primcodable \u03b1\\ninst\u271d\u00b2 : Primcodable \u03b2\\ninst\u271d\u00b9 : Primcodable \u03b3\\ninst\u271d : Primcodable \u03c3\\nf g : \u03b1 \u2192. \u03c3\\nhf : Partrec f\\nhg : Partrec g\\nk : \u2115 \u2192. \u2115\\nhk : Nat.Partrec k\\nH :\\n  \u2200 (a : \u2115),\\n    (\u2200 x \u2208 k a,\\n        (x \u2208 (\u2191(decode\u2082 \u03b1 a)).bind fun a => Part.map encode (f a)) \u2228\\n          x \u2208 (\u2191(decode\u2082 \u03b1 a)).bind fun a => Part.map encode (g a)) \u2227\\n      ((k a).Dom \u2194\\n        ((\u2191(decode\u2082 \u03b1 a)).bind fun a => Part.map encode (f a)).Dom \u2228\\n          ((\u2191(decode\u2082 \u03b1 a)).bind fun a => Part.map encode (g a)).Dom)\\n\u22a2 \u2203 k, Partrec k \u2227 \u2200 (a : \u03b1), (\u2200 x \u2208 k a, x \u2208 f a \u2228 x \u2208 g a) \u2227 ((k a).Dom \u2194 (f a).Dom \u2228 (g a).Dom)\",\n   \"endPos\": {\"line\": 54, \"column\": 77}},\n  {\"tactic\":\n   \"refine \u27e8k', ((nat_iff.2 hk).comp Computable.encode).bind (Computable.decode.ofOption.comp snd).to\u2082, fun a => ?_\u27e9\",\n   \"proofState\": 32,\n   \"pos\": {\"line\": 55, \"column\": 2},\n   \"goals\":\n   \"\u03b1 : Type u_1\\n\u03b2 : Type u_2\\n\u03b3 : Type u_3\\n\u03c3 : Type u_4\\ninst\u271d\u00b3 : Primcodable \u03b1\\ninst\u271d\u00b2 : Primcodable \u03b2\\ninst\u271d\u00b9 : Primcodable \u03b3\\ninst\u271d : Primcodable \u03c3\\nf g : \u03b1 \u2192. \u03c3\\nhf : Partrec f\\nhg : Partrec g\\nk : \u2115 \u2192. \u2115\\nhk : Nat.Partrec k\\nH :\\n  \u2200 (a : \u2115),\\n    (\u2200 x \u2208 k a,\\n        (x \u2208 (\u2191(decode\u2082 \u03b1 a)).bind fun a => Part.map encode (f a)) \u2228\\n          x \u2208 (\u2191(decode\u2082 \u03b1 a)).bind fun a => Part.map encode (g a)) \u2227\\n      ((k a).Dom \u2194\\n        ((\u2191(decode\u2082 \u03b1 a)).bind fun a => Part.map encode (f a)).Dom \u2228\\n          ((\u2191(decode\u2082 \u03b1 a)).bind fun a => Part.map encode (g a)).Dom)\\nk' : \u03b1 \u2192 Part \u03c3 := fun a => (k (encode a)).bind fun n => \u2191(decode n)\\n\u22a2 \u2203 k, Partrec k \u2227 \u2200 (a : \u03b1), (\u2200 x \u2208 k a, x \u2208 f a \u2228 x \u2208 g a) \u2227 ((k a).Dom \u2194 (f a).Dom \u2228 (g a).Dom)\",\n   \"endPos\": {\"line\": 57, \"column\": 18}},\n  {\"tactic\":\n   \"have : \u2200 x \u2208 k' a, x \u2208 f a \u2228 x \u2208 g a := by\\n  intro x h'\\n  simp only [k', exists_prop, mem_coe, mem_bind_iff, Option.mem_def] at h'\\n  obtain \u27e8n, hn, hx\u27e9 := h'\\n  have := (H _).1 _ hn\\n  simp [mem_decode\u2082, encode_injective.eq_iff] at this\\n  obtain \u27e8a', ha, rfl\u27e9 | \u27e8a', ha, rfl\u27e9 := this <;> simp only [encodek, Option.some_inj] at hx <;> rw [hx] at ha\\n  \u00b7 exact Or.inl ha\\n  \u00b7 exact Or.inr ha\",\n   \"proofState\": 33,\n   \"pos\": {\"line\": 58, \"column\": 2},\n   \"goals\":\n   \"\u03b1 : Type u_1\\n\u03b2 : Type u_2\\n\u03b3 : Type u_3\\n\u03c3 : Type u_4\\ninst\u271d\u00b3 : Primcodable \u03b1\\ninst\u271d\u00b2 : Primcodable \u03b2\\ninst\u271d\u00b9 : Primcodable \u03b3\\ninst\u271d : Primcodable \u03c3\\nf g : \u03b1 \u2192. \u03c3\\nhf : Partrec f\\nhg : Partrec g\\nk : \u2115 \u2192. \u2115\\nhk : Nat.Partrec k\\nH :\\n  \u2200 (a : \u2115),\\n    (\u2200 x \u2208 k a,\\n        (x \u2208 (\u2191(decode\u2082 \u03b1 a)).bind fun a => Part.map encode (f a)) \u2228\\n          x \u2208 (\u2191(decode\u2082 \u03b1 a)).bind fun a => Part.map encode (g a)) \u2227\\n      ((k a).Dom \u2194\\n        ((\u2191(decode\u2082 \u03b1 a)).bind fun a => Part.map encode (f a)).Dom \u2228\\n          ((\u2191(decode\u2082 \u03b1 a)).bind fun a => Part.map encode (g a)).Dom)\\nk' : \u03b1 \u2192 Part \u03c3 := fun a => (k (encode a)).bind fun n => \u2191(decode n)\\na : \u03b1\\n\u22a2 (\u2200 x \u2208 k' a, x \u2208 f a \u2228 x \u2208 g a) \u2227 ((k' a).Dom \u2194 (f a).Dom \u2228 (g a).Dom)\",\n   \"endPos\": {\"line\": 67, \"column\": 21}},\n  {\"tactic\": \"intro x h'\",\n   \"proofState\": 34,\n   \"pos\": {\"line\": 59, \"column\": 4},\n   \"goals\":\n   \"\u03b1 : Type u_1\\n\u03b2 : Type u_2\\n\u03b3 : Type u_3\\n\u03c3 : Type u_4\\ninst\u271d\u00b3 : Primcodable \u03b1\\ninst\u271d\u00b2 : Primcodable \u03b2\\ninst\u271d\u00b9 : Primcodable \u03b3\\ninst\u271d : Primcodable \u03c3\\nf g : \u03b1 \u2192. \u03c3\\nhf : Partrec f\\nhg : Partrec g\\nk : \u2115 \u2192. \u2115\\nhk : Nat.Partrec k\\nH :\\n  \u2200 (a : \u2115),\\n    (\u2200 x \u2208 k a,\\n        (x \u2208 (\u2191(decode\u2082 \u03b1 a)).bind fun a => Part.map encode (f a)) \u2228\\n          x \u2208 (\u2191(decode\u2082 \u03b1 a)).bind fun a => Part.map encode (g a)) \u2227\\n      ((k a).Dom \u2194\\n        ((\u2191(decode\u2082 \u03b1 a)).bind fun a => Part.map encode (f a)).Dom \u2228\\n          ((\u2191(decode\u2082 \u03b1 a)).bind fun a => Part.map encode (g a)).Dom)\\nk' : \u03b1 \u2192 Part \u03c3 := fun a => (k (encode a)).bind fun n => \u2191(decode n)\\na : \u03b1\\n\u22a2 \u2200 x \u2208 k' a, x \u2208 f a \u2228 x \u2208 g a\",\n   \"endPos\": {\"line\": 59, \"column\": 14}},\n  {\"tactic\":\n   \"simp only [k', exists_prop, mem_coe, mem_bind_iff, Option.mem_def] at h'\",\n   \"proofState\": 35,\n   \"pos\": {\"line\": 60, \"column\": 4},\n   \"goals\":\n   \"\u03b1 : Type u_1\\n\u03b2 : Type u_2\\n\u03b3 : Type u_3\\n\u03c3 : Type u_4\\ninst\u271d\u00b3 : Primcodable \u03b1\\ninst\u271d\u00b2 : Primcodable \u03b2\\ninst\u271d\u00b9 : Primcodable \u03b3\\ninst\u271d : Primcodable \u03c3\\nf g : \u03b1 \u2192. \u03c3\\nhf : Partrec f\\nhg : Partrec g\\nk : \u2115 \u2192. \u2115\\nhk : Nat.Partrec k\\nH :\\n  \u2200 (a : \u2115),\\n    (\u2200 x \u2208 k a,\\n        (x \u2208 (\u2191(decode\u2082 \u03b1 a)).bind fun a => Part.map encode (f a)) \u2228\\n          x \u2208 (\u2191(decode\u2082 \u03b1 a)).bind fun a => Part.map encode (g a)) \u2227\\n      ((k a).Dom \u2194\\n        ((\u2191(decode\u2082 \u03b1 a)).bind fun a => Part.map encode (f a)).Dom \u2228\\n          ((\u2191(decode\u2082 \u03b1 a)).bind fun a => Part.map encode (g a)).Dom)\\nk' : \u03b1 \u2192 Part \u03c3 := fun a => (k (encode a)).bind fun n => \u2191(decode n)\\na : \u03b1\\nx : \u03c3\\nh' : x \u2208 k' a\\n\u22a2 x \u2208 f a \u2228 x \u2208 g a\",\n   \"endPos\": {\"line\": 60, \"column\": 76}},\n  {\"tactic\": \"obtain \u27e8n, hn, hx\u27e9 := h'\",\n   \"proofState\": 36,\n   \"pos\": {\"line\": 61, \"column\": 4},\n   \"goals\":\n   \"\u03b1 : Type u_1\\n\u03b2 : Type u_2\\n\u03b3 : Type u_3\\n\u03c3 : Type u_4\\ninst\u271d\u00b3 : Primcodable \u03b1\\ninst\u271d\u00b2 : Primcodable \u03b2\\ninst\u271d\u00b9 : Primcodable \u03b3\\ninst\u271d : Primcodable \u03c3\\nf g : \u03b1 \u2192. \u03c3\\nhf : Partrec f\\nhg : Partrec g\\nk : \u2115 \u2192. \u2115\\nhk : Nat.Partrec k\\nH :\\n  \u2200 (a : \u2115),\\n    (\u2200 x \u2208 k a,\\n        (x \u2208 (\u2191(decode\u2082 \u03b1 a)).bind fun a => Part.map encode (f a)) \u2228\\n          x \u2208 (\u2191(decode\u2082 \u03b1 a)).bind fun a => Part.map encode (g a)) \u2227\\n      ((k a).Dom \u2194\\n        ((\u2191(decode\u2082 \u03b1 a)).bind fun a => Part.map encode (f a)).Dom \u2228\\n          ((\u2191(decode\u2082 \u03b1 a)).bind fun a => Part.map encode (g a)).Dom)\\nk' : \u03b1 \u2192 Part \u03c3 := fun a => (k (encode a)).bind fun n => \u2191(decode n)\\na : \u03b1\\nx : \u03c3\\nh' : \u2203 a_1 \u2208 k (encode a), decode a_1 = Option.some x\\n\u22a2 x \u2208 f a \u2228 x \u2208 g a\",\n   \"endPos\": {\"line\": 61, \"column\": 28}},\n  {\"tactic\": \"have := (H _).1 _ hn\",\n   \"proofState\": 37,\n   \"pos\": {\"line\": 62, \"column\": 4},\n   \"goals\":\n   \"case intro.intro\\n\u03b1 : Type u_1\\n\u03b2 : Type u_2\\n\u03b3 : Type u_3\\n\u03c3 : Type u_4\\ninst\u271d\u00b3 : Primcodable \u03b1\\ninst\u271d\u00b2 : Primcodable \u03b2\\ninst\u271d\u00b9 : Primcodable \u03b3\\ninst\u271d : Primcodable \u03c3\\nf g : \u03b1 \u2192. \u03c3\\nhf : Partrec f\\nhg : Partrec g\\nk : \u2115 \u2192. \u2115\\nhk : Nat.Partrec k\\nH :\\n  \u2200 (a : \u2115),\\n    (\u2200 x \u2208 k a,\\n        (x \u2208 (\u2191(decode\u2082 \u03b1 a)).bind fun a => Part.map encode (f a)) \u2228\\n          x \u2208 (\u2191(decode\u2082 \u03b1 a)).bind fun a => Part.map encode (g a)) \u2227\\n      ((k a).Dom \u2194\\n        ((\u2191(decode\u2082 \u03b1 a)).bind fun a => Part.map encode (f a)).Dom \u2228\\n          ((\u2191(decode\u2082 \u03b1 a)).bind fun a => Part.map encode (g a)).Dom)\\nk' : \u03b1 \u2192 Part \u03c3 := fun a => (k (encode a)).bind fun n => \u2191(decode n)\\na : \u03b1\\nx : \u03c3\\nn : \u2115\\nhn : n \u2208 k (encode a)\\nhx : decode n = Option.some x\\n\u22a2 x \u2208 f a \u2228 x \u2208 g a\",\n   \"endPos\": {\"line\": 62, \"column\": 24}},\n  {\"tactic\": \"simp [mem_decode\u2082, encode_injective.eq_iff] at this\",\n   \"proofState\": 38,\n   \"pos\": {\"line\": 63, \"column\": 4},\n   \"goals\":\n   \"case intro.intro\\n\u03b1 : Type u_1\\n\u03b2 : Type u_2\\n\u03b3 : Type u_3\\n\u03c3 : Type u_4\\ninst\u271d\u00b3 : Primcodable \u03b1\\ninst\u271d\u00b2 : Primcodable \u03b2\\ninst\u271d\u00b9 : Primcodable \u03b3\\ninst\u271d : Primcodable \u03c3\\nf g : \u03b1 \u2192. \u03c3\\nhf : Partrec f\\nhg : Partrec g\\nk : \u2115 \u2192. \u2115\\nhk : Nat.Partrec k\\nH :\\n  \u2200 (a : \u2115),\\n    (\u2200 x \u2208 k a,\\n        (x \u2208 (\u2191(decode\u2082 \u03b1 a)).bind fun a => Part.map encode (f a)) \u2228\\n          x \u2208 (\u2191(decode\u2082 \u03b1 a)).bind fun a => Part.map encode (g a)) \u2227\\n      ((k a).Dom \u2194\\n        ((\u2191(decode\u2082 \u03b1 a)).bind fun a => Part.map encode (f a)).Dom \u2228\\n          ((\u2191(decode\u2082 \u03b1 a)).bind fun a => Part.map encode (g a)).Dom)\\nk' : \u03b1 \u2192 Part \u03c3 := fun a => (k (encode a)).bind fun n => \u2191(decode n)\\na : \u03b1\\nx : \u03c3\\nn : \u2115\\nhn : n \u2208 k (encode a)\\nhx : decode n = Option.some x\\nthis :\\n  (n \u2208 (\u2191(decode\u2082 \u03b1 (encode a))).bind fun a => Part.map encode (f a)) \u2228\\n    n \u2208 (\u2191(decode\u2082 \u03b1 (encode a))).bind fun a => Part.map encode (g a)\\n\u22a2 x \u2208 f a \u2228 x \u2208 g a\",\n   \"endPos\": {\"line\": 63, \"column\": 55}},\n  {\"tactic\": \"obtain \u27e8a', ha, rfl\u27e9 | \u27e8a', ha, rfl\u27e9 := this\",\n   \"proofState\": 39,\n   \"pos\": {\"line\": 64, \"column\": 4},\n   \"goals\":\n   \"case intro.intro\\n\u03b1 : Type u_1\\n\u03b2 : Type u_2\\n\u03b3 : Type u_3\\n\u03c3 : Type u_4\\ninst\u271d\u00b3 : Primcodable \u03b1\\ninst\u271d\u00b2 : Primcodable \u03b2\\ninst\u271d\u00b9 : Primcodable \u03b3\\ninst\u271d : Primcodable \u03c3\\nf g : \u03b1 \u2192. \u03c3\\nhf : Partrec f\\nhg : Partrec g\\nk : \u2115 \u2192. \u2115\\nhk : Nat.Partrec k\\nH :\\n  \u2200 (a : \u2115),\\n    (\u2200 x \u2208 k a,\\n        (x \u2208 (\u2191(decode\u2082 \u03b1 a)).bind fun a => Part.map encode (f a)) \u2228\\n          x \u2208 (\u2191(decode\u2082 \u03b1 a)).bind fun a => Part.map encode (g a)) \u2227\\n      ((k a).Dom \u2194\\n        ((\u2191(decode\u2082 \u03b1 a)).bind fun a => Part.map encode (f a)).Dom \u2228\\n          ((\u2191(decode\u2082 \u03b1 a)).bind fun a => Part.map encode (g a)).Dom)\\nk' : \u03b1 \u2192 Part \u03c3 := fun a => (k (encode a)).bind fun n => \u2191(decode n)\\na : \u03b1\\nx : \u03c3\\nn : \u2115\\nhn : n \u2208 k (encode a)\\nhx : decode n = Option.some x\\nthis : (\u2203 a_1 \u2208 f a, encode a_1 = n) \u2228 \u2203 a_1 \u2208 g a, encode a_1 = n\\n\u22a2 x \u2208 f a \u2228 x \u2208 g a\",\n   \"endPos\": {\"line\": 64, \"column\": 48}},\n  {\"tactic\": \"simp only [encodek, Option.some_inj] at hx\",\n   \"proofState\": 40,\n   \"pos\": {\"line\": 64, \"column\": 53},\n   \"goals\":\n   \"case intro.intro.inl.intro.intro\\n\u03b1 : Type u_1\\n\u03b2 : Type u_2\\n\u03b3 : Type u_3\\n\u03c3 : Type u_4\\ninst\u271d\u00b3 : Primcodable \u03b1\\ninst\u271d\u00b2 : Primcodable \u03b2\\ninst\u271d\u00b9 : Primcodable \u03b3\\ninst\u271d : Primcodable \u03c3\\nf g : \u03b1 \u2192. \u03c3\\nhf : Partrec f\\nhg : Partrec g\\nk : \u2115 \u2192. \u2115\\nhk : Nat.Partrec k\\nH :\\n  \u2200 (a : \u2115),\\n    (\u2200 x \u2208 k a,\\n        (x \u2208 (\u2191(decode\u2082 \u03b1 a)).bind fun a => Part.map encode (f a)) \u2228\\n          x \u2208 (\u2191(decode\u2082 \u03b1 a)).bind fun a => Part.map encode (g a)) \u2227\\n      ((k a).Dom \u2194\\n        ((\u2191(decode\u2082 \u03b1 a)).bind fun a => Part.map encode (f a)).Dom \u2228\\n          ((\u2191(decode\u2082 \u03b1 a)).bind fun a => Part.map encode (g a)).Dom)\\nk' : \u03b1 \u2192 Part \u03c3 := fun a => (k (encode a)).bind fun n => \u2191(decode n)\\na : \u03b1\\nx a' : \u03c3\\nha : a' \u2208 f a\\nhn : encode a' \u2208 k (encode a)\\nhx : decode (encode a') = Option.some x\\n\u22a2 x \u2208 f a \u2228 x \u2208 g a\",\n   \"endPos\": {\"line\": 64, \"column\": 95}},\n  {\"tactic\": \"simp only [encodek, Option.some_inj] at hx\",\n   \"proofState\": 41,\n   \"pos\": {\"line\": 64, \"column\": 53},\n   \"goals\":\n   \"case intro.intro.inr.intro.intro\\n\u03b1 : Type u_1\\n\u03b2 : Type u_2\\n\u03b3 : Type u_3\\n\u03c3 : Type u_4\\ninst\u271d\u00b3 : Primcodable \u03b1\\ninst\u271d\u00b2 : Primcodable \u03b2\\ninst\u271d\u00b9 : Primcodable \u03b3\\ninst\u271d : Primcodable \u03c3\\nf g : \u03b1 \u2192. \u03c3\\nhf : Partrec f\\nhg : Partrec g\\nk : \u2115 \u2192. \u2115\\nhk : Nat.Partrec k\\nH :\\n  \u2200 (a : \u2115),\\n    (\u2200 x \u2208 k a,\\n        (x \u2208 (\u2191(decode\u2082 \u03b1 a)).bind fun a => Part.map encode (f a)) \u2228\\n          x \u2208 (\u2191(decode\u2082 \u03b1 a)).bind fun a => Part.map encode (g a)) \u2227\\n      ((k a).Dom \u2194\\n        ((\u2191(decode\u2082 \u03b1 a)).bind fun a => Part.map encode (f a)).Dom \u2228\\n          ((\u2191(decode\u2082 \u03b1 a)).bind fun a => Part.map encode (g a)).Dom)\\nk' : \u03b1 \u2192 Part \u03c3 := fun a => (k (encode a)).bind fun n => \u2191(decode n)\\na : \u03b1\\nx a' : \u03c3\\nha : a' \u2208 g a\\nhn : encode a' \u2208 k (encode a)\\nhx : decode (encode a') = Option.some x\\n\u22a2 x \u2208 f a \u2228 x \u2208 g a\",\n   \"endPos\": {\"line\": 64, \"column\": 95}},\n  {\"tactic\": \"rw [hx] at ha\",\n   \"proofState\": 42,\n   \"pos\": {\"line\": 65, \"column\": 6},\n   \"goals\":\n   \"case intro.intro.inl.intro.intro\\n\u03b1 : Type u_1\\n\u03b2 : Type u_2\\n\u03b3 : Type u_3\\n\u03c3 : Type u_4\\ninst\u271d\u00b3 : Primcodable \u03b1\\ninst\u271d\u00b2 : Primcodable \u03b2\\ninst\u271d\u00b9 : Primcodable \u03b3\\ninst\u271d : Primcodable \u03c3\\nf g : \u03b1 \u2192. \u03c3\\nhf : Partrec f\\nhg : Partrec g\\nk : \u2115 \u2192. \u2115\\nhk : Nat.Partrec k\\nH :\\n  \u2200 (a : \u2115),\\n    (\u2200 x \u2208 k a,\\n        (x \u2208 (\u2191(decode\u2082 \u03b1 a)).bind fun a => Part.map encode (f a)) \u2228\\n          x \u2208 (\u2191(decode\u2082 \u03b1 a)).bind fun a => Part.map encode (g a)) \u2227\\n      ((k a).Dom \u2194\\n        ((\u2191(decode\u2082 \u03b1 a)).bind fun a => Part.map encode (f a)).Dom \u2228\\n          ((\u2191(decode\u2082 \u03b1 a)).bind fun a => Part.map encode (g a)).Dom)\\nk' : \u03b1 \u2192 Part \u03c3 := fun a => (k (encode a)).bind fun n => \u2191(decode n)\\na : \u03b1\\nx a' : \u03c3\\nha : a' \u2208 f a\\nhn : encode a' \u2208 k (encode a)\\nhx : a' = x\\n\u22a2 x \u2208 f a \u2228 x \u2208 g a\",\n   \"endPos\": {\"line\": 65, \"column\": 19}},\n  {\"tactic\": \"rw [hx] at ha\",\n   \"proofState\": 43,\n   \"pos\": {\"line\": 65, \"column\": 6},\n   \"goals\":\n   \"case intro.intro.inr.intro.intro\\n\u03b1 : Type u_1\\n\u03b2 : Type u_2\\n\u03b3 : Type u_3\\n\u03c3 : Type u_4\\ninst\u271d\u00b3 : Primcodable \u03b1\\ninst\u271d\u00b2 : Primcodable \u03b2\\ninst\u271d\u00b9 : Primcodable \u03b3\\ninst\u271d : Primcodable \u03c3\\nf g : \u03b1 \u2192. \u03c3\\nhf : Partrec f\\nhg : Partrec g\\nk : \u2115 \u2192. \u2115\\nhk : Nat.Partrec k\\nH :\\n  \u2200 (a : \u2115),\\n    (\u2200 x \u2208 k a,\\n        (x \u2208 (\u2191(decode\u2082 \u03b1 a)).bind fun a => Part.map encode (f a)) \u2228\\n          x \u2208 (\u2191(decode\u2082 \u03b1 a)).bind fun a => Part.map encode (g a)) \u2227\\n      ((k a).Dom \u2194\\n        ((\u2191(decode\u2082 \u03b1 a)).bind fun a => Part.map encode (f a)).Dom \u2228\\n          ((\u2191(decode\u2082 \u03b1 a)).bind fun a => Part.map encode (g a)).Dom)\\nk' : \u03b1 \u2192 Part \u03c3 := fun a => (k (encode a)).bind fun n => \u2191(decode n)\\na : \u03b1\\nx a' : \u03c3\\nha : a' \u2208 g a\\nhn : encode a' \u2208 k (encode a)\\nhx : a' = x\\n\u22a2 x \u2208 f a \u2228 x \u2208 g a\",\n   \"endPos\": {\"line\": 65, \"column\": 19}},\n  {\"tactic\": \"exact Or.inl ha\",\n   \"proofState\": 44,\n   \"pos\": {\"line\": 66, \"column\": 6},\n   \"goals\":\n   \"case intro.intro.inl.intro.intro\\n\u03b1 : Type u_1\\n\u03b2 : Type u_2\\n\u03b3 : Type u_3\\n\u03c3 : Type u_4\\ninst\u271d\u00b3 : Primcodable \u03b1\\ninst\u271d\u00b2 : Primcodable \u03b2\\ninst\u271d\u00b9 : Primcodable \u03b3\\ninst\u271d : Primcodable \u03c3\\nf g : \u03b1 \u2192. \u03c3\\nhf : Partrec f\\nhg : Partrec g\\nk : \u2115 \u2192. \u2115\\nhk : Nat.Partrec k\\nH :\\n  \u2200 (a : \u2115),\\n    (\u2200 x \u2208 k a,\\n        (x \u2208 (\u2191(decode\u2082 \u03b1 a)).bind fun a => Part.map encode (f a)) \u2228\\n          x \u2208 (\u2191(decode\u2082 \u03b1 a)).bind fun a => Part.map encode (g a)) \u2227\\n      ((k a).Dom \u2194\\n        ((\u2191(decode\u2082 \u03b1 a)).bind fun a => Part.map encode (f a)).Dom \u2228\\n          ((\u2191(decode\u2082 \u03b1 a)).bind fun a => Part.map encode (g a)).Dom)\\nk' : \u03b1 \u2192 Part \u03c3 := fun a => (k (encode a)).bind fun n => \u2191(decode n)\\na : \u03b1\\nx a' : \u03c3\\nha : x \u2208 f a\\nhn : encode a' \u2208 k (encode a)\\nhx : a' = x\\n\u22a2 x \u2208 f a \u2228 x \u2208 g a\",\n   \"endPos\": {\"line\": 66, \"column\": 21}},\n  {\"tactic\": \"exact Or.inr ha\",\n   \"proofState\": 45,\n   \"pos\": {\"line\": 67, \"column\": 6},\n   \"goals\":\n   \"case intro.intro.inr.intro.intro\\n\u03b1 : Type u_1\\n\u03b2 : Type u_2\\n\u03b3 : Type u_3\\n\u03c3 : Type u_4\\ninst\u271d\u00b3 : Primcodable \u03b1\\ninst\u271d\u00b2 : Primcodable \u03b2\\ninst\u271d\u00b9 : Primcodable \u03b3\\ninst\u271d : Primcodable \u03c3\\nf g : \u03b1 \u2192. \u03c3\\nhf : Partrec f\\nhg : Partrec g\\nk : \u2115 \u2192. \u2115\\nhk : Nat.Partrec k\\nH :\\n  \u2200 (a : \u2115),\\n    (\u2200 x \u2208 k a,\\n        (x \u2208 (\u2191(decode\u2082 \u03b1 a)).bind fun a => Part.map encode (f a)) \u2228\\n          x \u2208 (\u2191(decode\u2082 \u03b1 a)).bind fun a => Part.map encode (g a)) \u2227\\n      ((k a).Dom \u2194\\n        ((\u2191(decode\u2082 \u03b1 a)).bind fun a => Part.map encode (f a)).Dom \u2228\\n          ((\u2191(decode\u2082 \u03b1 a)).bind fun a => Part.map encode (g a)).Dom)\\nk' : \u03b1 \u2192 Part \u03c3 := fun a => (k (encode a)).bind fun n => \u2191(decode n)\\na : \u03b1\\nx a' : \u03c3\\nha : x \u2208 g a\\nhn : encode a' \u2208 k (encode a)\\nhx : a' = x\\n\u22a2 x \u2208 f a \u2228 x \u2208 g a\",\n   \"endPos\": {\"line\": 67, \"column\": 21}},\n  {\"tactic\":\n   \"refine \u27e8this, \u27e8fun h => (this _ \u27e8h, rfl\u27e9).imp Exists.fst Exists.fst, ?_\u27e9\u27e9\",\n   \"proofState\": 46,\n   \"pos\": {\"line\": 68, \"column\": 2},\n   \"goals\":\n   \"\u03b1 : Type u_1\\n\u03b2 : Type u_2\\n\u03b3 : Type u_3\\n\u03c3 : Type u_4\\ninst\u271d\u00b3 : Primcodable \u03b1\\ninst\u271d\u00b2 : Primcodable \u03b2\\ninst\u271d\u00b9 : Primcodable \u03b3\\ninst\u271d : Primcodable \u03c3\\nf g : \u03b1 \u2192. \u03c3\\nhf : Partrec f\\nhg : Partrec g\\nk : \u2115 \u2192. \u2115\\nhk : Nat.Partrec k\\nH :\\n  \u2200 (a : \u2115),\\n    (\u2200 x \u2208 k a,\\n        (x \u2208 (\u2191(decode\u2082 \u03b1 a)).bind fun a => Part.map encode (f a)) \u2228\\n          x \u2208 (\u2191(decode\u2082 \u03b1 a)).bind fun a => Part.map encode (g a)) \u2227\\n      ((k a).Dom \u2194\\n        ((\u2191(decode\u2082 \u03b1 a)).bind fun a => Part.map encode (f a)).Dom \u2228\\n          ((\u2191(decode\u2082 \u03b1 a)).bind fun a => Part.map encode (g a)).Dom)\\nk' : \u03b1 \u2192 Part \u03c3 := fun a => (k (encode a)).bind fun n => \u2191(decode n)\\na : \u03b1\\nthis : \u2200 x \u2208 k' a, x \u2208 f a \u2228 x \u2208 g a\\n\u22a2 (\u2200 x \u2208 k' a, x \u2208 f a \u2228 x \u2208 g a) \u2227 ((k' a).Dom \u2194 (f a).Dom \u2228 (g a).Dom)\",\n   \"endPos\": {\"line\": 68, \"column\": 75}},\n  {\"tactic\": \"intro h\",\n   \"proofState\": 47,\n   \"pos\": {\"line\": 69, \"column\": 2},\n   \"goals\":\n   \"\u03b1 : Type u_1\\n\u03b2 : Type u_2\\n\u03b3 : Type u_3\\n\u03c3 : Type u_4\\ninst\u271d\u00b3 : Primcodable \u03b1\\ninst\u271d\u00b2 : Primcodable \u03b2\\ninst\u271d\u00b9 : Primcodable \u03b3\\ninst\u271d : Primcodable \u03c3\\nf g : \u03b1 \u2192. \u03c3\\nhf : Partrec f\\nhg : Partrec g\\nk : \u2115 \u2192. \u2115\\nhk : Nat.Partrec k\\nH :\\n  \u2200 (a : \u2115),\\n    (\u2200 x \u2208 k a,\\n        (x \u2208 (\u2191(decode\u2082 \u03b1 a)).bind fun a => Part.map encode (f a)) \u2228\\n          x \u2208 (\u2191(decode\u2082 \u03b1 a)).bind fun a => Part.map encode (g a)) \u2227\\n      ((k a).Dom \u2194\\n        ((\u2191(decode\u2082 \u03b1 a)).bind fun a => Part.map encode (f a)).Dom \u2228\\n          ((\u2191(decode\u2082 \u03b1 a)).bind fun a => Part.map encode (g a)).Dom)\\nk' : \u03b1 \u2192 Part \u03c3 := fun a => (k (encode a)).bind fun n => \u2191(decode n)\\na : \u03b1\\nthis : \u2200 x \u2208 k' a, x \u2208 f a \u2228 x \u2208 g a\\n\u22a2 (f a).Dom \u2228 (g a).Dom \u2192 (k' a).Dom\",\n   \"endPos\": {\"line\": 69, \"column\": 9}},\n  {\"tactic\": \"rw [bind_dom]\",\n   \"proofState\": 48,\n   \"pos\": {\"line\": 70, \"column\": 2},\n   \"goals\":\n   \"\u03b1 : Type u_1\\n\u03b2 : Type u_2\\n\u03b3 : Type u_3\\n\u03c3 : Type u_4\\ninst\u271d\u00b3 : Primcodable \u03b1\\ninst\u271d\u00b2 : Primcodable \u03b2\\ninst\u271d\u00b9 : Primcodable \u03b3\\ninst\u271d : Primcodable \u03c3\\nf g : \u03b1 \u2192. \u03c3\\nhf : Partrec f\\nhg : Partrec g\\nk : \u2115 \u2192. \u2115\\nhk : Nat.Partrec k\\nH :\\n  \u2200 (a : \u2115),\\n    (\u2200 x \u2208 k a,\\n        (x \u2208 (\u2191(decode\u2082 \u03b1 a)).bind fun a => Part.map encode (f a)) \u2228\\n          x \u2208 (\u2191(decode\u2082 \u03b1 a)).bind fun a => Part.map encode (g a)) \u2227\\n      ((k a).Dom \u2194\\n        ((\u2191(decode\u2082 \u03b1 a)).bind fun a => Part.map encode (f a)).Dom \u2228\\n          ((\u2191(decode\u2082 \u03b1 a)).bind fun a => Part.map encode (g a)).Dom)\\nk' : \u03b1 \u2192 Part \u03c3 := fun a => (k (encode a)).bind fun n => \u2191(decode n)\\na : \u03b1\\nthis : \u2200 x \u2208 k' a, x \u2208 f a \u2228 x \u2208 g a\\nh : (f a).Dom \u2228 (g a).Dom\\n\u22a2 (k' a).Dom\",\n   \"endPos\": {\"line\": 70, \"column\": 15}},\n  {\"tactic\":\n   \"have hk : (k (encode a)).Dom := (H _).2.2 (by simpa only [encodek\u2082, bind_some, coe_some] using h)\",\n   \"proofState\": 49,\n   \"pos\": {\"line\": 71, \"column\": 2},\n   \"goals\":\n   \"\u03b1 : Type u_1\\n\u03b2 : Type u_2\\n\u03b3 : Type u_3\\n\u03c3 : Type u_4\\ninst\u271d\u00b3 : Primcodable \u03b1\\ninst\u271d\u00b2 : Primcodable \u03b2\\ninst\u271d\u00b9 : Primcodable \u03b3\\ninst\u271d : Primcodable \u03c3\\nf g : \u03b1 \u2192. \u03c3\\nhf : Partrec f\\nhg : Partrec g\\nk : \u2115 \u2192. \u2115\\nhk : Nat.Partrec k\\nH :\\n  \u2200 (a : \u2115),\\n    (\u2200 x \u2208 k a,\\n        (x \u2208 (\u2191(decode\u2082 \u03b1 a)).bind fun a => Part.map encode (f a)) \u2228\\n          x \u2208 (\u2191(decode\u2082 \u03b1 a)).bind fun a => Part.map encode (g a)) \u2227\\n      ((k a).Dom \u2194\\n        ((\u2191(decode\u2082 \u03b1 a)).bind fun a => Part.map encode (f a)).Dom \u2228\\n          ((\u2191(decode\u2082 \u03b1 a)).bind fun a => Part.map encode (g a)).Dom)\\nk' : \u03b1 \u2192 Part \u03c3 := fun a => (k (encode a)).bind fun n => \u2191(decode n)\\na : \u03b1\\nthis : \u2200 x \u2208 k' a, x \u2208 f a \u2228 x \u2208 g a\\nh : (f a).Dom \u2228 (g a).Dom\\n\u22a2 \u2203 (h : (k (encode a)).Dom), (\u2191(decode ((k (encode a)).get h))).Dom\",\n   \"endPos\": {\"line\": 72, \"column\": 69}},\n  {\"tactic\": \"simpa only [encodek\u2082, bind_some, coe_some] using h\",\n   \"proofState\": 50,\n   \"pos\": {\"line\": 72, \"column\": 18},\n   \"goals\":\n   \"\u03b1 : Type u_1\\n\u03b2 : Type u_2\\n\u03b3 : Type u_3\\n\u03c3 : Type u_4\\ninst\u271d\u00b3 : Primcodable \u03b1\\ninst\u271d\u00b2 : Primcodable \u03b2\\ninst\u271d\u00b9 : Primcodable \u03b3\\ninst\u271d : Primcodable \u03c3\\nf g : \u03b1 \u2192. \u03c3\\nhf : Partrec f\\nhg : Partrec g\\nk : \u2115 \u2192. \u2115\\nhk : Nat.Partrec k\\nH :\\n  \u2200 (a : \u2115),\\n    (\u2200 x \u2208 k a,\\n        (x \u2208 (\u2191(decode\u2082 \u03b1 a)).bind fun a => Part.map encode (f a)) \u2228\\n          x \u2208 (\u2191(decode\u2082 \u03b1 a)).bind fun a => Part.map encode (g a)) \u2227\\n      ((k a).Dom \u2194\\n        ((\u2191(decode\u2082 \u03b1 a)).bind fun a => Part.map encode (f a)).Dom \u2228\\n          ((\u2191(decode\u2082 \u03b1 a)).bind fun a => Part.map encode (g a)).Dom)\\nk' : \u03b1 \u2192 Part \u03c3 := fun a => (k (encode a)).bind fun n => \u2191(decode n)\\na : \u03b1\\nthis : \u2200 x \u2208 k' a, x \u2208 f a \u2228 x \u2208 g a\\nh : (f a).Dom \u2228 (g a).Dom\\n\u22a2 ((\u2191(decode\u2082 \u03b1 (encode a))).bind fun a => Part.map encode (f a)).Dom \u2228\\n    ((\u2191(decode\u2082 \u03b1 (encode a))).bind fun a => Part.map encode (g a)).Dom\",\n   \"endPos\": {\"line\": 72, \"column\": 68}},\n  {\"tactic\": \"exists hk\",\n   \"proofState\": 51,\n   \"pos\": {\"line\": 73, \"column\": 2},\n   \"goals\":\n   \"\u03b1 : Type u_1\\n\u03b2 : Type u_2\\n\u03b3 : Type u_3\\n\u03c3 : Type u_4\\ninst\u271d\u00b3 : Primcodable \u03b1\\ninst\u271d\u00b2 : Primcodable \u03b2\\ninst\u271d\u00b9 : Primcodable \u03b3\\ninst\u271d : Primcodable \u03c3\\nf g : \u03b1 \u2192. \u03c3\\nhf : Partrec f\\nhg : Partrec g\\nk : \u2115 \u2192. \u2115\\nhk\u271d : Nat.Partrec k\\nH :\\n  \u2200 (a : \u2115),\\n    (\u2200 x \u2208 k a,\\n        (x \u2208 (\u2191(decode\u2082 \u03b1 a)).bind fun a => Part.map encode (f a)) \u2228\\n          x \u2208 (\u2191(decode\u2082 \u03b1 a)).bind fun a => Part.map encode (g a)) \u2227\\n      ((k a).Dom \u2194\\n        ((\u2191(decode\u2082 \u03b1 a)).bind fun a => Part.map encode (f a)).Dom \u2228\\n          ((\u2191(decode\u2082 \u03b1 a)).bind fun a => Part.map encode (g a)).Dom)\\nk' : \u03b1 \u2192 Part \u03c3 := fun a => (k (encode a)).bind fun n => \u2191(decode n)\\na : \u03b1\\nthis : \u2200 x \u2208 k' a, x \u2208 f a \u2228 x \u2208 g a\\nh : (f a).Dom \u2228 (g a).Dom\\nhk : (k (encode a)).Dom\\n\u22a2 \u2203 (h : (k (encode a)).Dom), (\u2191(decode ((k (encode a)).get h))).Dom\",\n   \"endPos\": {\"line\": 73, \"column\": 11}},\n  {\"tactic\":\n   \"simp only [exists_prop, mem_map_iff, mem_coe, mem_bind_iff, Option.mem_def] at H\",\n   \"proofState\": 52,\n   \"pos\": {\"line\": 74, \"column\": 2},\n   \"goals\":\n   \"\u03b1 : Type u_1\\n\u03b2 : Type u_2\\n\u03b3 : Type u_3\\n\u03c3 : Type u_4\\ninst\u271d\u00b3 : Primcodable \u03b1\\ninst\u271d\u00b2 : Primcodable \u03b2\\ninst\u271d\u00b9 : Primcodable \u03b3\\ninst\u271d : Primcodable \u03c3\\nf g : \u03b1 \u2192. \u03c3\\nhf : Partrec f\\nhg : Partrec g\\nk : \u2115 \u2192. \u2115\\nhk\u271d : Nat.Partrec k\\nH :\\n  \u2200 (a : \u2115),\\n    (\u2200 x \u2208 k a,\\n        (x \u2208 (\u2191(decode\u2082 \u03b1 a)).bind fun a => Part.map encode (f a)) \u2228\\n          x \u2208 (\u2191(decode\u2082 \u03b1 a)).bind fun a => Part.map encode (g a)) \u2227\\n      ((k a).Dom \u2194\\n        ((\u2191(decode\u2082 \u03b1 a)).bind fun a => Part.map encode (f a)).Dom \u2228\\n          ((\u2191(decode\u2082 \u03b1 a)).bind fun a => Part.map encode (g a)).Dom)\\nk' : \u03b1 \u2192 Part \u03c3 := fun a => (k (encode a)).bind fun n => \u2191(decode n)\\na : \u03b1\\nthis : \u2200 x \u2208 k' a, x \u2208 f a \u2228 x \u2208 g a\\nh : (f a).Dom \u2228 (g a).Dom\\nhk : (k (encode a)).Dom\\n\u22a2 (\u2191(decode ((k (encode a)).get hk))).Dom\",\n   \"endPos\": {\"line\": 74, \"column\": 82}},\n  {\"tactic\":\n   \"obtain \u27e8a', _, y, _, e\u27e9 | \u27e8a', _, y, _, e\u27e9 := (H _).1 _ \u27e8hk, rfl\u27e9\",\n   \"proofState\": 53,\n   \"pos\": {\"line\": 75, \"column\": 2},\n   \"goals\":\n   \"\u03b1 : Type u_1\\n\u03b2 : Type u_2\\n\u03b3 : Type u_3\\n\u03c3 : Type u_4\\ninst\u271d\u00b3 : Primcodable \u03b1\\ninst\u271d\u00b2 : Primcodable \u03b2\\ninst\u271d\u00b9 : Primcodable \u03b3\\ninst\u271d : Primcodable \u03c3\\nf g : \u03b1 \u2192. \u03c3\\nhf : Partrec f\\nhg : Partrec g\\nk : \u2115 \u2192. \u2115\\nhk\u271d : Nat.Partrec k\\nk' : \u03b1 \u2192 Part \u03c3 := fun a => (k (encode a)).bind fun n => \u2191(decode n)\\na : \u03b1\\nthis : \u2200 x \u2208 k' a, x \u2208 f a \u2228 x \u2208 g a\\nh : (f a).Dom \u2228 (g a).Dom\\nhk : (k (encode a)).Dom\\nH :\\n  \u2200 (a : \u2115),\\n    (\u2200 x \u2208 k a,\\n        (\u2203 a_2, decode\u2082 \u03b1 a = Option.some a_2 \u2227 \u2203 a \u2208 f a_2, encode a = x) \u2228\\n          \u2203 a_2, decode\u2082 \u03b1 a = Option.some a_2 \u2227 \u2203 a \u2208 g a_2, encode a = x) \u2227\\n      ((k a).Dom \u2194\\n        ((\u2191(decode\u2082 \u03b1 a)).bind fun a => Part.map encode (f a)).Dom \u2228\\n          ((\u2191(decode\u2082 \u03b1 a)).bind fun a => Part.map encode (g a)).Dom)\\n\u22a2 (\u2191(decode ((k (encode a)).get hk))).Dom\",\n   \"endPos\": {\"line\": 75, \"column\": 67}},\n  {\"tactic\": \"simp only [e.symm, encodek, coe_some, some_dom]\",\n   \"proofState\": 54,\n   \"pos\": {\"line\": 76, \"column\": 4},\n   \"goals\":\n   \"case inl.intro.intro.intro.intro\\n\u03b1 : Type u_1\\n\u03b2 : Type u_2\\n\u03b3 : Type u_3\\n\u03c3 : Type u_4\\ninst\u271d\u00b3 : Primcodable \u03b1\\ninst\u271d\u00b2 : Primcodable \u03b2\\ninst\u271d\u00b9 : Primcodable \u03b3\\ninst\u271d : Primcodable \u03c3\\nf g : \u03b1 \u2192. \u03c3\\nhf : Partrec f\\nhg : Partrec g\\nk : \u2115 \u2192. \u2115\\nhk\u271d : Nat.Partrec k\\nk' : \u03b1 \u2192 Part \u03c3 := fun a => (k (encode a)).bind fun n => \u2191(decode n)\\na : \u03b1\\nthis : \u2200 x \u2208 k' a, x \u2208 f a \u2228 x \u2208 g a\\nh : (f a).Dom \u2228 (g a).Dom\\nhk : (k (encode a)).Dom\\nH :\\n  \u2200 (a : \u2115),\\n    (\u2200 x \u2208 k a,\\n        (\u2203 a_2, decode\u2082 \u03b1 a = Option.some a_2 \u2227 \u2203 a \u2208 f a_2, encode a = x) \u2228\\n          \u2203 a_2, decode\u2082 \u03b1 a = Option.some a_2 \u2227 \u2203 a \u2208 g a_2, encode a = x) \u2227\\n      ((k a).Dom \u2194\\n        ((\u2191(decode\u2082 \u03b1 a)).bind fun a => Part.map encode (f a)).Dom \u2228\\n          ((\u2191(decode\u2082 \u03b1 a)).bind fun a => Part.map encode (g a)).Dom)\\na' : \u03b1\\nleft\u271d\u00b9 : decode\u2082 \u03b1 (encode a) = Option.some a'\\ny : \u03c3\\nleft\u271d : y \u2208 f a'\\ne : encode y = (k (encode a)).get hk\\n\u22a2 (\u2191(decode ((k (encode a)).get hk))).Dom\",\n   \"endPos\": {\"line\": 76, \"column\": 51}},\n  {\"tactic\": \"simp only [e.symm, encodek, coe_some, some_dom]\",\n   \"proofState\": 55,\n   \"pos\": {\"line\": 76, \"column\": 4},\n   \"goals\":\n   \"case inr.intro.intro.intro.intro\\n\u03b1 : Type u_1\\n\u03b2 : Type u_2\\n\u03b3 : Type u_3\\n\u03c3 : Type u_4\\ninst\u271d\u00b3 : Primcodable \u03b1\\ninst\u271d\u00b2 : Primcodable \u03b2\\ninst\u271d\u00b9 : Primcodable \u03b3\\ninst\u271d : Primcodable \u03c3\\nf g : \u03b1 \u2192. \u03c3\\nhf : Partrec f\\nhg : Partrec g\\nk : \u2115 \u2192. \u2115\\nhk\u271d : Nat.Partrec k\\nk' : \u03b1 \u2192 Part \u03c3 := fun a => (k (encode a)).bind fun n => \u2191(decode n)\\na : \u03b1\\nthis : \u2200 x \u2208 k' a, x \u2208 f a \u2228 x \u2208 g a\\nh : (f a).Dom \u2228 (g a).Dom\\nhk : (k (encode a)).Dom\\nH :\\n  \u2200 (a : \u2115),\\n    (\u2200 x \u2208 k a,\\n        (\u2203 a_2, decode\u2082 \u03b1 a = Option.some a_2 \u2227 \u2203 a \u2208 f a_2, encode a = x) \u2228\\n          \u2203 a_2, decode\u2082 \u03b1 a = Option.some a_2 \u2227 \u2203 a \u2208 g a_2, encode a = x) \u2227\\n      ((k a).Dom \u2194\\n        ((\u2191(decode\u2082 \u03b1 a)).bind fun a => Part.map encode (f a)).Dom \u2228\\n          ((\u2191(decode\u2082 \u03b1 a)).bind fun a => Part.map encode (g a)).Dom)\\na' : \u03b1\\nleft\u271d\u00b9 : decode\u2082 \u03b1 (encode a) = Option.some a'\\ny : \u03c3\\nleft\u271d : y \u2208 g a'\\ne : encode y = (k (encode a)).get hk\\n\u22a2 (\u2191(decode ((k (encode a)).get hk))).Dom\",\n   \"endPos\": {\"line\": 76, \"column\": 51}},\n  {\"tactic\": \"have : (k a).Dom := (K _).2.2 (h.imp Exists.fst Exists.fst)\",\n   \"proofState\": 56,\n   \"pos\": {\"line\": 85, \"column\": 6},\n   \"goals\":\n   \"\u03b1 : Type u_1\\n\u03b2 : Type u_2\\n\u03b3 : Type u_3\\n\u03c3 : Type u_4\\ninst\u271d\u00b3 : Primcodable \u03b1\\ninst\u271d\u00b2 : Primcodable \u03b2\\ninst\u271d\u00b9 : Primcodable \u03b3\\ninst\u271d : Primcodable \u03c3\\nf g : \u03b1 \u2192. \u03c3\\nhf : Partrec f\\nhg : Partrec g\\nH : \u2200 (a : \u03b1), \u2200 x \u2208 f a, \u2200 y \u2208 g a, x = y\\nk : \u03b1 \u2192. \u03c3\\nhk : Partrec k\\nK : \u2200 (a : \u03b1), (\u2200 x \u2208 k a, x \u2208 f a \u2228 x \u2208 g a) \u2227 ((k a).Dom \u2194 (f a).Dom \u2228 (g a).Dom)\\na : \u03b1\\nx : \u03c3\\nh : x \u2208 f a \u2228 x \u2208 g a\\n\u22a2 x \u2208 k a\",\n   \"endPos\": {\"line\": 85, \"column\": 65}},\n  {\"tactic\": \"refine \u27e8this, ?_\u27e9\",\n   \"proofState\": 57,\n   \"pos\": {\"line\": 86, \"column\": 6},\n   \"goals\":\n   \"\u03b1 : Type u_1\\n\u03b2 : Type u_2\\n\u03b3 : Type u_3\\n\u03c3 : Type u_4\\ninst\u271d\u00b3 : Primcodable \u03b1\\ninst\u271d\u00b2 : Primcodable \u03b2\\ninst\u271d\u00b9 : Primcodable \u03b3\\ninst\u271d : Primcodable \u03c3\\nf g : \u03b1 \u2192. \u03c3\\nhf : Partrec f\\nhg : Partrec g\\nH : \u2200 (a : \u03b1), \u2200 x \u2208 f a, \u2200 y \u2208 g a, x = y\\nk : \u03b1 \u2192. \u03c3\\nhk : Partrec k\\nK : \u2200 (a : \u03b1), (\u2200 x \u2208 k a, x \u2208 f a \u2228 x \u2208 g a) \u2227 ((k a).Dom \u2194 (f a).Dom \u2228 (g a).Dom)\\na : \u03b1\\nx : \u03c3\\nh : x \u2208 f a \u2228 x \u2208 g a\\nthis : (k a).Dom\\n\u22a2 x \u2208 k a\",\n   \"endPos\": {\"line\": 86, \"column\": 23}},\n  {\"tactic\": \"cases' h with h h\",\n   \"proofState\": 58,\n   \"pos\": {\"line\": 87, \"column\": 6},\n   \"goals\":\n   \"\u03b1 : Type u_1\\n\u03b2 : Type u_2\\n\u03b3 : Type u_3\\n\u03c3 : Type u_4\\ninst\u271d\u00b3 : Primcodable \u03b1\\ninst\u271d\u00b2 : Primcodable \u03b2\\ninst\u271d\u00b9 : Primcodable \u03b3\\ninst\u271d : Primcodable \u03c3\\nf g : \u03b1 \u2192. \u03c3\\nhf : Partrec f\\nhg : Partrec g\\nH : \u2200 (a : \u03b1), \u2200 x \u2208 f a, \u2200 y \u2208 g a, x = y\\nk : \u03b1 \u2192. \u03c3\\nhk : Partrec k\\nK : \u2200 (a : \u03b1), (\u2200 x \u2208 k a, x \u2208 f a \u2228 x \u2208 g a) \u2227 ((k a).Dom \u2194 (f a).Dom \u2228 (g a).Dom)\\na : \u03b1\\nx : \u03c3\\nh : x \u2208 f a \u2228 x \u2208 g a\\nthis : (k a).Dom\\n\u22a2 (k a).get this = x\",\n   \"endPos\": {\"line\": 87, \"column\": 23}},\n  {\"tactic\": \"cases' (K _).1 _ \u27e8this, rfl\u27e9 with h' h'\",\n   \"proofState\": 59,\n   \"pos\": {\"line\": 87, \"column\": 28},\n   \"goals\":\n   \"case inl\\n\u03b1 : Type u_1\\n\u03b2 : Type u_2\\n\u03b3 : Type u_3\\n\u03c3 : Type u_4\\ninst\u271d\u00b3 : Primcodable \u03b1\\ninst\u271d\u00b2 : Primcodable \u03b2\\ninst\u271d\u00b9 : Primcodable \u03b3\\ninst\u271d : Primcodable \u03c3\\nf g : \u03b1 \u2192. \u03c3\\nhf : Partrec f\\nhg : Partrec g\\nH : \u2200 (a : \u03b1), \u2200 x \u2208 f a, \u2200 y \u2208 g a, x = y\\nk : \u03b1 \u2192. \u03c3\\nhk : Partrec k\\nK : \u2200 (a : \u03b1), (\u2200 x \u2208 k a, x \u2208 f a \u2228 x \u2208 g a) \u2227 ((k a).Dom \u2194 (f a).Dom \u2228 (g a).Dom)\\na : \u03b1\\nx : \u03c3\\nthis : (k a).Dom\\nh : x \u2208 f a\\n\u22a2 (k a).get this = x\",\n   \"endPos\": {\"line\": 87, \"column\": 67}},\n  {\"tactic\": \"cases' (K _).1 _ \u27e8this, rfl\u27e9 with h' h'\",\n   \"proofState\": 60,\n   \"pos\": {\"line\": 87, \"column\": 28},\n   \"goals\":\n   \"case inr\\n\u03b1 : Type u_1\\n\u03b2 : Type u_2\\n\u03b3 : Type u_3\\n\u03c3 : Type u_4\\ninst\u271d\u00b3 : Primcodable \u03b1\\ninst\u271d\u00b2 : Primcodable \u03b2\\ninst\u271d\u00b9 : Primcodable \u03b3\\ninst\u271d : Primcodable \u03c3\\nf g : \u03b1 \u2192. \u03c3\\nhf : Partrec f\\nhg : Partrec g\\nH : \u2200 (a : \u03b1), \u2200 x \u2208 f a, \u2200 y \u2208 g a, x = y\\nk : \u03b1 \u2192. \u03c3\\nhk : Partrec k\\nK : \u2200 (a : \u03b1), (\u2200 x \u2208 k a, x \u2208 f a \u2228 x \u2208 g a) \u2227 ((k a).Dom \u2194 (f a).Dom \u2228 (g a).Dom)\\na : \u03b1\\nx : \u03c3\\nthis : (k a).Dom\\nh : x \u2208 g a\\n\u22a2 (k a).get this = x\",\n   \"endPos\": {\"line\": 87, \"column\": 67}},\n  {\"tactic\": \"exact mem_unique h' h\",\n   \"proofState\": 61,\n   \"pos\": {\"line\": 88, \"column\": 8},\n   \"goals\":\n   \"case inl.inl\\n\u03b1 : Type u_1\\n\u03b2 : Type u_2\\n\u03b3 : Type u_3\\n\u03c3 : Type u_4\\ninst\u271d\u00b3 : Primcodable \u03b1\\ninst\u271d\u00b2 : Primcodable \u03b2\\ninst\u271d\u00b9 : Primcodable \u03b3\\ninst\u271d : Primcodable \u03c3\\nf g : \u03b1 \u2192. \u03c3\\nhf : Partrec f\\nhg : Partrec g\\nH : \u2200 (a : \u03b1), \u2200 x \u2208 f a, \u2200 y \u2208 g a, x = y\\nk : \u03b1 \u2192. \u03c3\\nhk : Partrec k\\nK : \u2200 (a : \u03b1), (\u2200 x \u2208 k a, x \u2208 f a \u2228 x \u2208 g a) \u2227 ((k a).Dom \u2194 (f a).Dom \u2228 (g a).Dom)\\na : \u03b1\\nx : \u03c3\\nthis : (k a).Dom\\nh : x \u2208 f a\\nh' : (k a).get this \u2208 f a\\n\u22a2 (k a).get this = x\",\n   \"endPos\": {\"line\": 88, \"column\": 29}},\n  {\"tactic\": \"exact (H _ _ h _ h').symm\",\n   \"proofState\": 62,\n   \"pos\": {\"line\": 89, \"column\": 8},\n   \"goals\":\n   \"case inl.inr\\n\u03b1 : Type u_1\\n\u03b2 : Type u_2\\n\u03b3 : Type u_3\\n\u03c3 : Type u_4\\ninst\u271d\u00b3 : Primcodable \u03b1\\ninst\u271d\u00b2 : Primcodable \u03b2\\ninst\u271d\u00b9 : Primcodable \u03b3\\ninst\u271d : Primcodable \u03c3\\nf g : \u03b1 \u2192. \u03c3\\nhf : Partrec f\\nhg : Partrec g\\nH : \u2200 (a : \u03b1), \u2200 x \u2208 f a, \u2200 y \u2208 g a, x = y\\nk : \u03b1 \u2192. \u03c3\\nhk : Partrec k\\nK : \u2200 (a : \u03b1), (\u2200 x \u2208 k a, x \u2208 f a \u2228 x \u2208 g a) \u2227 ((k a).Dom \u2194 (f a).Dom \u2228 (g a).Dom)\\na : \u03b1\\nx : \u03c3\\nthis : (k a).Dom\\nh : x \u2208 f a\\nh' : (k a).get this \u2208 g a\\n\u22a2 (k a).get this = x\",\n   \"endPos\": {\"line\": 89, \"column\": 33}},\n  {\"tactic\": \"exact H _ _ h' _ h\",\n   \"proofState\": 63,\n   \"pos\": {\"line\": 90, \"column\": 8},\n   \"goals\":\n   \"case inr.inl\\n\u03b1 : Type u_1\\n\u03b2 : Type u_2\\n\u03b3 : Type u_3\\n\u03c3 : Type u_4\\ninst\u271d\u00b3 : Primcodable \u03b1\\ninst\u271d\u00b2 : Primcodable \u03b2\\ninst\u271d\u00b9 : Primcodable \u03b3\\ninst\u271d : Primcodable \u03c3\\nf g : \u03b1 \u2192. \u03c3\\nhf : Partrec f\\nhg : Partrec g\\nH : \u2200 (a : \u03b1), \u2200 x \u2208 f a, \u2200 y \u2208 g a, x = y\\nk : \u03b1 \u2192. \u03c3\\nhk : Partrec k\\nK : \u2200 (a : \u03b1), (\u2200 x \u2208 k a, x \u2208 f a \u2228 x \u2208 g a) \u2227 ((k a).Dom \u2194 (f a).Dom \u2228 (g a).Dom)\\na : \u03b1\\nx : \u03c3\\nthis : (k a).Dom\\nh : x \u2208 g a\\nh' : (k a).get this \u2208 f a\\n\u22a2 (k a).get this = x\",\n   \"endPos\": {\"line\": 90, \"column\": 26}},\n  {\"tactic\": \"exact mem_unique h' h\",\n   \"proofState\": 64,\n   \"pos\": {\"line\": 91, \"column\": 8},\n   \"goals\":\n   \"case inr.inr\\n\u03b1 : Type u_1\\n\u03b2 : Type u_2\\n\u03b3 : Type u_3\\n\u03c3 : Type u_4\\ninst\u271d\u00b3 : Primcodable \u03b1\\ninst\u271d\u00b2 : Primcodable \u03b2\\ninst\u271d\u00b9 : Primcodable \u03b3\\ninst\u271d : Primcodable \u03c3\\nf g : \u03b1 \u2192. \u03c3\\nhf : Partrec f\\nhg : Partrec g\\nH : \u2200 (a : \u03b1), \u2200 x \u2208 f a, \u2200 y \u2208 g a, x = y\\nk : \u03b1 \u2192. \u03c3\\nhk : Partrec k\\nK : \u2200 (a : \u03b1), (\u2200 x \u2208 k a, x \u2208 f a \u2228 x \u2208 g a) \u2227 ((k a).Dom \u2194 (f a).Dom \u2228 (g a).Dom)\\na : \u03b1\\nx : \u03c3\\nthis : (k a).Dom\\nh : x \u2208 g a\\nh' : (k a).get this \u2208 g a\\n\u22a2 (k a).get this = x\",\n   \"endPos\": {\"line\": 91, \"column\": 29}},\n  {\"tactic\": \"cases c a\",\n   \"proofState\": 65,\n   \"pos\": {\"line\": 100, \"column\": 16},\n   \"goals\":\n   \"\u03b1 : Type u_1\\n\u03b2 : Type u_2\\n\u03b3 : Type u_3\\n\u03c3 : Type u_4\\ninst\u271d\u00b3 : Primcodable \u03b1\\ninst\u271d\u00b2 : Primcodable \u03b2\\ninst\u271d\u00b9 : Primcodable \u03b3\\ninst\u271d : Primcodable \u03c3\\nc : \u03b1 \u2192 Bool\\nf g : \u03b1 \u2192. \u03c3\\nhc : Computable c\\nhf : Partrec f\\nhg : Partrec g\\ncf : Code\\nef : cf.eval = fun n => (\u2191(decode n)).bind fun a => Part.map encode (f a)\\ncg : Code\\neg : cg.eval = fun n => (\u2191(decode n)).bind fun a => Part.map encode (g a)\\na : \u03b1\\n\u22a2 (((bif c a then cf else cg).eval (encode a)).bind fun b => \u2191(decode (a, b).2)) = bif c a then f a else g a\",\n   \"endPos\": {\"line\": 100, \"column\": 25}},\n  {\"tactic\": \"simp [ef, eg, encodek]\",\n   \"proofState\": 66,\n   \"pos\": {\"line\": 100, \"column\": 30},\n   \"goals\":\n   \"case false\\n\u03b1 : Type u_1\\n\u03b2 : Type u_2\\n\u03b3 : Type u_3\\n\u03c3 : Type u_4\\ninst\u271d\u00b3 : Primcodable \u03b1\\ninst\u271d\u00b2 : Primcodable \u03b2\\ninst\u271d\u00b9 : Primcodable \u03b3\\ninst\u271d : Primcodable \u03c3\\nc : \u03b1 \u2192 Bool\\nf g : \u03b1 \u2192. \u03c3\\nhc : Computable c\\nhf : Partrec f\\nhg : Partrec g\\ncf : Code\\nef : cf.eval = fun n => (\u2191(decode n)).bind fun a => Part.map encode (f a)\\ncg : Code\\neg : cg.eval = fun n => (\u2191(decode n)).bind fun a => Part.map encode (g a)\\na : \u03b1\\n\u22a2 (((bif false then cf else cg).eval (encode a)).bind fun b => \u2191(decode (a, b).2)) = bif false then f a else g a\",\n   \"endPos\": {\"line\": 100, \"column\": 52}},\n  {\"tactic\": \"simp [ef, eg, encodek]\",\n   \"proofState\": 67,\n   \"pos\": {\"line\": 100, \"column\": 30},\n   \"goals\":\n   \"case true\\n\u03b1 : Type u_1\\n\u03b2 : Type u_2\\n\u03b3 : Type u_3\\n\u03c3 : Type u_4\\ninst\u271d\u00b3 : Primcodable \u03b1\\ninst\u271d\u00b2 : Primcodable \u03b2\\ninst\u271d\u00b9 : Primcodable \u03b3\\ninst\u271d : Primcodable \u03c3\\nc : \u03b1 \u2192 Bool\\nf g : \u03b1 \u2192. \u03c3\\nhc : Computable c\\nhf : Partrec f\\nhg : Partrec g\\ncf : Code\\nef : cf.eval = fun n => (\u2191(decode n)).bind fun a => Part.map encode (f a)\\ncg : Code\\neg : cg.eval = fun n => (\u2191(decode n)).bind fun a => Part.map encode (g a)\\na : \u03b1\\n\u22a2 (((bif true then cf else cg).eval (encode a)).bind fun b => \u2191(decode (a, b).2)) = bif true then f a else g a\",\n   \"endPos\": {\"line\": 100, \"column\": 52}},\n  {\"tactic\": \"cases f a\",\n   \"proofState\": 68,\n   \"pos\": {\"line\": 109, \"column\": 18},\n   \"goals\":\n   \"\u03b1 : Type u_1\\n\u03b2 : Type u_2\\n\u03b3 : Type u_3\\n\u03c3 : Type u_4\\ninst\u271d\u00b3 : Primcodable \u03b1\\ninst\u271d\u00b2 : Primcodable \u03b2\\ninst\u271d\u00b9 : Primcodable \u03b3\\ninst\u271d : Primcodable \u03c3\\nf : \u03b1 \u2192 \u03b2 \u2295 \u03b3\\ng : \u03b1 \u2192 \u03b2 \u2192. \u03c3\\nh : \u03b1 \u2192 \u03b3 \u2192. \u03c3\\nhf : Computable f\\nhg : Partrec\u2082 g\\nhh : Partrec\u2082 h\\na : \u03b1\\n\u22a2 (bif Sum.casesOn (f a) (fun b => true) fun b => false then\\n      Sum.casesOn (f a) (fun b => Part.map Option.some (g (a, b).1 (a, b).2)) fun c => Part.some Option.none\\n    else Sum.casesOn (f a) (fun b => Part.some Option.none) fun b => Part.map Option.some (h (a, b).1 (a, b).2)) =\\n    Part.map Option.some (Sum.casesOn (f a) (g a) (h a))\",\n   \"endPos\": {\"line\": 109, \"column\": 27}},\n  {\"tactic\": \"simp only [Bool.cond_true, Bool.cond_false]\",\n   \"proofState\": 69,\n   \"pos\": {\"line\": 109, \"column\": 32},\n   \"goals\":\n   \"case inl\\n\u03b1 : Type u_1\\n\u03b2 : Type u_2\\n\u03b3 : Type u_3\\n\u03c3 : Type u_4\\ninst\u271d\u00b3 : Primcodable \u03b1\\ninst\u271d\u00b2 : Primcodable \u03b2\\ninst\u271d\u00b9 : Primcodable \u03b3\\ninst\u271d : Primcodable \u03c3\\nf : \u03b1 \u2192 \u03b2 \u2295 \u03b3\\ng : \u03b1 \u2192 \u03b2 \u2192. \u03c3\\nh : \u03b1 \u2192 \u03b3 \u2192. \u03c3\\nhf : Computable f\\nhg : Partrec\u2082 g\\nhh : Partrec\u2082 h\\na : \u03b1\\nval\u271d : \u03b2\\n\u22a2 (bif Sum.casesOn (Sum.inl val\u271d) (fun b => true) fun b => false then\\n      Sum.casesOn (Sum.inl val\u271d) (fun b => Part.map Option.some (g (a, b).1 (a, b).2)) fun c => Part.some Option.none\\n    else\\n      Sum.casesOn (Sum.inl val\u271d) (fun b => Part.some Option.none) fun b => Part.map Option.some (h (a, b).1 (a, b).2)) =\\n    Part.map Option.some (Sum.casesOn (Sum.inl val\u271d) (g a) (h a))\",\n   \"endPos\": {\"line\": 109, \"column\": 75}},\n  {\"tactic\": \"simp only [Bool.cond_true, Bool.cond_false]\",\n   \"proofState\": 70,\n   \"pos\": {\"line\": 109, \"column\": 32},\n   \"goals\":\n   \"case inr\\n\u03b1 : Type u_1\\n\u03b2 : Type u_2\\n\u03b3 : Type u_3\\n\u03c3 : Type u_4\\ninst\u271d\u00b3 : Primcodable \u03b1\\ninst\u271d\u00b2 : Primcodable \u03b2\\ninst\u271d\u00b9 : Primcodable \u03b3\\ninst\u271d : Primcodable \u03c3\\nf : \u03b1 \u2192 \u03b2 \u2295 \u03b3\\ng : \u03b1 \u2192 \u03b2 \u2192. \u03c3\\nh : \u03b1 \u2192 \u03b3 \u2192. \u03c3\\nhf : Computable f\\nhg : Partrec\u2082 g\\nhh : Partrec\u2082 h\\na : \u03b1\\nval\u271d : \u03b3\\n\u22a2 (bif Sum.casesOn (Sum.inr val\u271d) (fun b => true) fun b => false then\\n      Sum.casesOn (Sum.inr val\u271d) (fun b => Part.map Option.some (g (a, b).1 (a, b).2)) fun c => Part.some Option.none\\n    else\\n      Sum.casesOn (Sum.inr val\u271d) (fun b => Part.some Option.none) fun b => Part.map Option.some (h (a, b).1 (a, b).2)) =\\n    Part.map Option.some (Sum.casesOn (Sum.inr val\u271d) (g a) (h a))\",\n   \"endPos\": {\"line\": 109, \"column\": 75}},\n  {\"tactic\": \"simp [Part.dom_iff_mem]\",\n   \"proofState\": 71,\n   \"pos\": {\"line\": 132, \"column\": 72},\n   \"goals\":\n   \"\u03b1 : Type u_1\\n\u03b2 : Type u_2\\ninst\u271d\u00b9 : Primcodable \u03b1\\ninst\u271d : Primcodable \u03b2\\nf : \u03b1 \u2192. \u03b2\\nh : Partrec f\\nn : \u03b1\\nx\u271d : Unit\\n\u22a2 x\u271d \u2208 Part.map (fun b => ()) (f n) \u2194 x\u271d \u2208 Part.assert ((fun a => (f a).Dom) n) fun x => Part.some ()\",\n   \"endPos\": {\"line\": 132, \"column\": 95}},\n  {\"tactic\": \"rintro \u27e8f, h, rfl\u27e9\",\n   \"proofState\": 72,\n   \"pos\": {\"line\": 152, \"column\": 4},\n   \"goals\":\n   \"\u03b1 : Type u_1\\n\u03c3 : Type u_2\\ninst\u271d\u00b9 : Primcodable \u03b1\\ninst\u271d : Primcodable \u03c3\\np : \u03b1 \u2192 Prop\\n\u22a2 (\u2203 f, Computable f \u2227 p = fun a => f a = true) \u2192 ComputablePred p\",\n   \"endPos\": {\"line\": 152, \"column\": 22}},\n  {\"tactic\": \"exact \u27e8by infer_instance, by simpa using h\u27e9\",\n   \"proofState\": 73,\n   \"pos\": {\"line\": 152, \"column\": 24},\n   \"goals\":\n   \"case intro.intro\\n\u03b1 : Type u_1\\n\u03c3 : Type u_2\\ninst\u271d\u00b9 : Primcodable \u03b1\\ninst\u271d : Primcodable \u03c3\\nf : \u03b1 \u2192 Bool\\nh : Computable f\\n\u22a2 ComputablePred fun a => f a = true\",\n   \"endPos\": {\"line\": 152, \"column\": 67}},\n  {\"tactic\": \"infer_instance\",\n   \"proofState\": 74,\n   \"pos\": {\"line\": 152, \"column\": 34},\n   \"goals\":\n   \"\u03b1 : Type u_1\\n\u03c3 : Type u_2\\ninst\u271d\u00b9 : Primcodable \u03b1\\ninst\u271d : Primcodable \u03c3\\nf : \u03b1 \u2192 Bool\\nh : Computable f\\n\u22a2 DecidablePred fun a => f a = true\",\n   \"endPos\": {\"line\": 152, \"column\": 48}},\n  {\"tactic\": \"simpa using h\",\n   \"proofState\": 75,\n   \"pos\": {\"line\": 152, \"column\": 53},\n   \"goals\":\n   \"\u03b1 : Type u_1\\n\u03c3 : Type u_2\\ninst\u271d\u00b9 : Primcodable \u03b1\\ninst\u271d : Primcodable \u03c3\\nf : \u03b1 \u2192 Bool\\nh : Computable f\\n\u22a2 Computable fun a => decide ((fun a => f a = true) a)\",\n   \"endPos\": {\"line\": 152, \"column\": 66}},\n  {\"tactic\": \"obtain \u27e8f, hf, rfl\u27e9 := computable_iff.1 hp\",\n   \"proofState\": 76,\n   \"pos\": {\"line\": 156, \"column\": 2},\n   \"goals\":\n   \"\u03b1 : Type u_1\\n\u03c3 : Type u_2\\ninst\u271d\u00b9 : Primcodable \u03b1\\ninst\u271d : Primcodable \u03c3\\np : \u03b1 \u2192 Prop\\nhp : ComputablePred p\\n\u22a2 ComputablePred fun a => \u00acp a\",\n   \"endPos\": {\"line\": 156, \"column\": 44}},\n  {\"tactic\":\n   \"exact\\n  \u27e8by infer_instance,\\n    (cond hf (const false) (const true)).of_eq fun n =>\\n      by\\n      simp only [Bool.not_eq_true]\\n      cases f n <;> rfl\u27e9\",\n   \"proofState\": 77,\n   \"pos\": {\"line\": 157, \"column\": 2},\n   \"goals\":\n   \"case intro.intro\\n\u03b1 : Type u_1\\n\u03c3 : Type u_2\\ninst\u271d\u00b9 : Primcodable \u03b1\\ninst\u271d : Primcodable \u03c3\\nf : \u03b1 \u2192 Bool\\nhf : Computable f\\nhp : ComputablePred fun a => f a = true\\n\u22a2 ComputablePred fun a => \u00ac(fun a => f a = true) a\",\n   \"endPos\": {\"line\": 161, \"column\": 26}},\n  {\"tactic\": \"infer_instance\",\n   \"proofState\": 78,\n   \"pos\": {\"line\": 158, \"column\": 8},\n   \"goals\":\n   \"\u03b1 : Type u_1\\n\u03c3 : Type u_2\\ninst\u271d\u00b9 : Primcodable \u03b1\\ninst\u271d : Primcodable \u03c3\\nf : \u03b1 \u2192 Bool\\nhf : Computable f\\nhp : ComputablePred fun a => f a = true\\n\u22a2 DecidablePred fun a => \u00ac(fun a => f a = true) a\",\n   \"endPos\": {\"line\": 158, \"column\": 22}},\n  {\"tactic\": \"simp only [Bool.not_eq_true]\",\n   \"proofState\": 79,\n   \"pos\": {\"line\": 160, \"column\": 8},\n   \"goals\":\n   \"\u03b1 : Type u_1\\n\u03c3 : Type u_2\\ninst\u271d\u00b9 : Primcodable \u03b1\\ninst\u271d : Primcodable \u03c3\\nf : \u03b1 \u2192 Bool\\nhf : Computable f\\nhp : ComputablePred fun a => f a = true\\nn : \u03b1\\n\u22a2 (bif f n then false else true) = decide ((fun a => \u00ac(fun a => f a = true) a) n)\",\n   \"endPos\": {\"line\": 160, \"column\": 36}},\n  {\"tactic\": \"cases f n\",\n   \"proofState\": 80,\n   \"pos\": {\"line\": 161, \"column\": 8},\n   \"goals\":\n   \"\u03b1 : Type u_1\\n\u03c3 : Type u_2\\ninst\u271d\u00b9 : Primcodable \u03b1\\ninst\u271d : Primcodable \u03c3\\nf : \u03b1 \u2192 Bool\\nhf : Computable f\\nhp : ComputablePred fun a => f a = true\\nn : \u03b1\\n\u22a2 (bif f n then false else true) = decide (f n = false)\",\n   \"endPos\": {\"line\": 161, \"column\": 17}},\n  {\"tactic\": \"rfl\",\n   \"proofState\": 81,\n   \"pos\": {\"line\": 161, \"column\": 22},\n   \"goals\":\n   \"case false\\n\u03b1 : Type u_1\\n\u03c3 : Type u_2\\ninst\u271d\u00b9 : Primcodable \u03b1\\ninst\u271d : Primcodable \u03c3\\nf : \u03b1 \u2192 Bool\\nhf : Computable f\\nhp : ComputablePred fun a => f a = true\\nn : \u03b1\\n\u22a2 (bif false then false else true) = decide (false = false)\",\n   \"endPos\": {\"line\": 161, \"column\": 25}},\n  {\"tactic\": \"rfl\",\n   \"proofState\": 82,\n   \"pos\": {\"line\": 161, \"column\": 22},\n   \"goals\":\n   \"case true\\n\u03b1 : Type u_1\\n\u03c3 : Type u_2\\ninst\u271d\u00b9 : Primcodable \u03b1\\ninst\u271d : Primcodable \u03c3\\nf : \u03b1 \u2192 Bool\\nhf : Computable f\\nhp : ComputablePred fun a => f a = true\\nn : \u03b1\\n\u22a2 (bif true then false else true) = decide (true = false)\",\n   \"endPos\": {\"line\": 161, \"column\": 25}},\n  {\"tactic\": \"obtain \u27e8f, hf, rfl\u27e9 := computable_iff.1 hp\",\n   \"proofState\": 83,\n   \"pos\": {\"line\": 165, \"column\": 2},\n   \"goals\":\n   \"\u03b1 : Type u_1 \u03c3 : Type u_2 inst\u271d\u00b9 : Primcodable \u03b1 inst\u271d : Primcodable \u03c3 p : \u03b1 \u2192 Prop hp : ComputablePred p \u22a2 RePred p\",\n   \"endPos\": {\"line\": 165, \"column\": 44}},\n  {\"tactic\": \"unfold RePred\",\n   \"proofState\": 84,\n   \"pos\": {\"line\": 166, \"column\": 2},\n   \"goals\":\n   \"case intro.intro\\n\u03b1 : Type u_1\\n\u03c3 : Type u_2\\ninst\u271d\u00b9 : Primcodable \u03b1\\ninst\u271d : Primcodable \u03c3\\nf : \u03b1 \u2192 Bool\\nhf : Computable f\\nhp : ComputablePred fun a => f a = true\\n\u22a2 RePred fun a => f a = true\",\n   \"endPos\": {\"line\": 166, \"column\": 15}},\n  {\"tactic\": \"dsimp only []\",\n   \"proofState\": 85,\n   \"pos\": {\"line\": 167, \"column\": 2},\n   \"goals\":\n   \"case intro.intro\\n\u03b1 : Type u_1\\n\u03c3 : Type u_2\\ninst\u271d\u00b9 : Primcodable \u03b1\\ninst\u271d : Primcodable \u03c3\\nf : \u03b1 \u2192 Bool\\nhf : Computable f\\nhp : ComputablePred fun a => f a = true\\n\u22a2 Partrec fun a => Part.assert ((fun a => f a = true) a) fun x => Part.some ()\",\n   \"endPos\": {\"line\": 167, \"column\": 15}},\n  {\"tactic\":\n   \"refine (Partrec.cond hf (Decidable.Partrec.const' (Part.some ())) Partrec.none).of_eq fun n => Part.ext fun a => ?_\",\n   \"proofState\": 86,\n   \"pos\": {\"line\": 168, \"column\": 2},\n   \"goals\":\n   \"case intro.intro\\n\u03b1 : Type u_1\\n\u03c3 : Type u_2\\ninst\u271d\u00b9 : Primcodable \u03b1\\ninst\u271d : Primcodable \u03c3\\nf : \u03b1 \u2192 Bool\\nhf : Computable f\\nhp : ComputablePred fun a => f a = true\\n\u22a2 Partrec fun a => Part.assert (f a = true) fun x => Part.some ()\",\n   \"endPos\": {\"line\": 170, \"column\": 26}},\n  {\"tactic\": \"cases a\",\n   \"proofState\": 87,\n   \"pos\": {\"line\": 171, \"column\": 2},\n   \"goals\":\n   \"case intro.intro\\n\u03b1 : Type u_1\\n\u03c3 : Type u_2\\ninst\u271d\u00b9 : Primcodable \u03b1\\ninst\u271d : Primcodable \u03c3\\nf : \u03b1 \u2192 Bool\\nhf : Computable f\\nhp : ComputablePred fun a => f a = true\\nn : \u03b1\\na : Unit\\n\u22a2 (a \u2208 bif f n then Part.some () else Part.none) \u2194 a \u2208 Part.assert (f n = true) fun x => Part.some ()\",\n   \"endPos\": {\"line\": 171, \"column\": 9}},\n  {\"tactic\": \"cases f n\",\n   \"proofState\": 88,\n   \"pos\": {\"line\": 171, \"column\": 11},\n   \"goals\":\n   \"case intro.intro.unit\\n\u03b1 : Type u_1\\n\u03c3 : Type u_2\\ninst\u271d\u00b9 : Primcodable \u03b1\\ninst\u271d : Primcodable \u03c3\\nf : \u03b1 \u2192 Bool\\nhf : Computable f\\nhp : ComputablePred fun a => f a = true\\nn : \u03b1\\n\u22a2 (PUnit.unit \u2208 bif f n then Part.some () else Part.none) \u2194 PUnit.unit \u2208 Part.assert (f n = true) fun x => Part.some ()\",\n   \"endPos\": {\"line\": 171, \"column\": 20}},\n  {\"tactic\": \"simp\",\n   \"proofState\": 89,\n   \"pos\": {\"line\": 171, \"column\": 25},\n   \"goals\":\n   \"case intro.intro.unit.false\\n\u03b1 : Type u_1\\n\u03c3 : Type u_2\\ninst\u271d\u00b9 : Primcodable \u03b1\\ninst\u271d : Primcodable \u03c3\\nf : \u03b1 \u2192 Bool\\nhf : Computable f\\nhp : ComputablePred fun a => f a = true\\nn : \u03b1\\n\u22a2 (PUnit.unit \u2208 bif false then Part.some () else Part.none) \u2194\\n    PUnit.unit \u2208 Part.assert (false = true) fun x => Part.some ()\",\n   \"endPos\": {\"line\": 171, \"column\": 29}},\n  {\"tactic\": \"simp\",\n   \"proofState\": 90,\n   \"pos\": {\"line\": 171, \"column\": 25},\n   \"goals\":\n   \"case intro.intro.unit.true\\n\u03b1 : Type u_1\\n\u03c3 : Type u_2\\ninst\u271d\u00b9 : Primcodable \u03b1\\ninst\u271d : Primcodable \u03c3\\nf : \u03b1 \u2192 Bool\\nhf : Computable f\\nhp : ComputablePred fun a => f a = true\\nn : \u03b1\\n\u22a2 (PUnit.unit \u2208 bif true then Part.some () else Part.none) \u2194\\n    PUnit.unit \u2208 Part.assert (true = true) fun x => Part.some ()\",\n   \"endPos\": {\"line\": 171, \"column\": 29}},\n  {\"tactic\": \"cases' h with _ h\",\n   \"proofState\": 91,\n   \"pos\": {\"line\": 177, \"column\": 2},\n   \"goals\":\n   \"\u03b1 : Type u_1\\n\u03c3 : Type u_2\\ninst\u271d\u00b9 : Primcodable \u03b1\\ninst\u271d : Primcodable \u03c3\\nC : Set (\u2115 \u2192. \u2115)\\nh : ComputablePred fun c => c.eval \u2208 C\\nf g : \u2115 \u2192. \u2115\\nhf : Nat.Partrec f\\nhg : Nat.Partrec g\\nfC : f \u2208 C\\n\u22a2 g \u2208 C\",\n   \"endPos\": {\"line\": 177, \"column\": 19}},\n  {\"tactic\":\n   \"obtain \u27e8c, e\u27e9 :=\\n  fixed_point\u2082\\n    (Partrec.cond (h.comp fst) ((Partrec.nat_iff.2 hg).comp snd).to\u2082 ((Partrec.nat_iff.2 hf).comp snd).to\u2082).to\u2082\",\n   \"proofState\": 92,\n   \"pos\": {\"line\": 178, \"column\": 2},\n   \"goals\":\n   \"case intro\\n\u03b1 : Type u_1\\n\u03c3 : Type u_2\\ninst\u271d\u00b9 : Primcodable \u03b1\\ninst\u271d : Primcodable \u03c3\\nC : Set (\u2115 \u2192. \u2115)\\nf g : \u2115 \u2192. \u2115\\nhf : Nat.Partrec f\\nhg : Nat.Partrec g\\nfC : f \u2208 C\\nw\u271d : DecidablePred fun c => c.eval \u2208 C\\nh : Computable fun a => decide ((fun c => c.eval \u2208 C) a)\\n\u22a2 g \u2208 C\",\n   \"endPos\": {\"line\": 181, \"column\": 52}},\n  {\"tactic\": \"simp only [Bool.cond_decide] at e\",\n   \"proofState\": 93,\n   \"pos\": {\"line\": 182, \"column\": 2},\n   \"goals\":\n   \"case intro.intro\\n\u03b1 : Type u_1\\n\u03c3 : Type u_2\\ninst\u271d\u00b9 : Primcodable \u03b1\\ninst\u271d : Primcodable \u03c3\\nC : Set (\u2115 \u2192. \u2115)\\nf g : \u2115 \u2192. \u2115\\nhf : Nat.Partrec f\\nhg : Nat.Partrec g\\nfC : f \u2208 C\\nw\u271d : DecidablePred fun c => c.eval \u2208 C\\nh : Computable fun a => decide ((fun c => c.eval \u2208 C) a)\\nc : Code\\ne :\\n  c.eval = fun b =>\\n    bif decide ((fun c => c.eval \u2208 C) (c, b).1) then (fun a b => g (a, b).2) (c, b).1 (c, b).2\\n    else (fun a b => f (a, b).2) (c, b).1 (c, b).2\\n\u22a2 g \u2208 C\",\n   \"endPos\": {\"line\": 182, \"column\": 35}},\n  {\"tactic\": \"by_cases H : eval c \u2208 C\",\n   \"proofState\": 94,\n   \"pos\": {\"line\": 183, \"column\": 2},\n   \"goals\":\n   \"case intro.intro\\n\u03b1 : Type u_1\\n\u03c3 : Type u_2\\ninst\u271d\u00b9 : Primcodable \u03b1\\ninst\u271d : Primcodable \u03c3\\nC : Set (\u2115 \u2192. \u2115)\\nf g : \u2115 \u2192. \u2115\\nhf : Nat.Partrec f\\nhg : Nat.Partrec g\\nfC : f \u2208 C\\nw\u271d : DecidablePred fun c => c.eval \u2208 C\\nh : Computable fun a => decide ((fun c => c.eval \u2208 C) a)\\nc : Code\\ne : c.eval = fun b => if c.eval \u2208 C then g b else f b\\n\u22a2 g \u2208 C\",\n   \"endPos\": {\"line\": 183, \"column\": 25}},\n  {\"tactic\": \"simp only [H, if_true] at e\",\n   \"proofState\": 95,\n   \"pos\": {\"line\": 184, \"column\": 4},\n   \"goals\":\n   \"case pos\\n\u03b1 : Type u_1\\n\u03c3 : Type u_2\\ninst\u271d\u00b9 : Primcodable \u03b1\\ninst\u271d : Primcodable \u03c3\\nC : Set (\u2115 \u2192. \u2115)\\nf g : \u2115 \u2192. \u2115\\nhf : Nat.Partrec f\\nhg : Nat.Partrec g\\nfC : f \u2208 C\\nw\u271d : DecidablePred fun c => c.eval \u2208 C\\nh : Computable fun a => decide ((fun c => c.eval \u2208 C) a)\\nc : Code\\ne : c.eval = fun b => if c.eval \u2208 C then g b else f b\\nH : c.eval \u2208 C\\n\u22a2 g \u2208 C\",\n   \"endPos\": {\"line\": 184, \"column\": 31}},\n  {\"tactic\": \"change (fun b => g b) \u2208 C\",\n   \"proofState\": 96,\n   \"pos\": {\"line\": 185, \"column\": 4},\n   \"goals\":\n   \"case pos\\n\u03b1 : Type u_1\\n\u03c3 : Type u_2\\ninst\u271d\u00b9 : Primcodable \u03b1\\ninst\u271d : Primcodable \u03c3\\nC : Set (\u2115 \u2192. \u2115)\\nf g : \u2115 \u2192. \u2115\\nhf : Nat.Partrec f\\nhg : Nat.Partrec g\\nfC : f \u2208 C\\nw\u271d : DecidablePred fun c => c.eval \u2208 C\\nh : Computable fun a => decide ((fun c => c.eval \u2208 C) a)\\nc : Code\\nH : c.eval \u2208 C\\ne : c.eval = fun b => g b\\n\u22a2 g \u2208 C\",\n   \"endPos\": {\"line\": 185, \"column\": 29}},\n  {\"tactic\": \"rwa [\u2190 e]\",\n   \"proofState\": 97,\n   \"pos\": {\"line\": 186, \"column\": 4},\n   \"goals\":\n   \"case pos\\n\u03b1 : Type u_1\\n\u03c3 : Type u_2\\ninst\u271d\u00b9 : Primcodable \u03b1\\ninst\u271d : Primcodable \u03c3\\nC : Set (\u2115 \u2192. \u2115)\\nf g : \u2115 \u2192. \u2115\\nhf : Nat.Partrec f\\nhg : Nat.Partrec g\\nfC : f \u2208 C\\nw\u271d : DecidablePred fun c => c.eval \u2208 C\\nh : Computable fun a => decide ((fun c => c.eval \u2208 C) a)\\nc : Code\\nH : c.eval \u2208 C\\ne : c.eval = fun b => g b\\n\u22a2 (fun b => g b) \u2208 C\",\n   \"endPos\": {\"line\": 186, \"column\": 13}},\n  {\"tactic\": \"simp only [H, if_false] at e\",\n   \"proofState\": 98,\n   \"pos\": {\"line\": 187, \"column\": 4},\n   \"goals\":\n   \"case neg\\n\u03b1 : Type u_1\\n\u03c3 : Type u_2\\ninst\u271d\u00b9 : Primcodable \u03b1\\ninst\u271d : Primcodable \u03c3\\nC : Set (\u2115 \u2192. \u2115)\\nf g : \u2115 \u2192. \u2115\\nhf : Nat.Partrec f\\nhg : Nat.Partrec g\\nfC : f \u2208 C\\nw\u271d : DecidablePred fun c => c.eval \u2208 C\\nh : Computable fun a => decide ((fun c => c.eval \u2208 C) a)\\nc : Code\\ne : c.eval = fun b => if c.eval \u2208 C then g b else f b\\nH : c.eval \u2209 C\\n\u22a2 g \u2208 C\",\n   \"endPos\": {\"line\": 187, \"column\": 32}},\n  {\"tactic\": \"rw [e] at H\",\n   \"proofState\": 99,\n   \"pos\": {\"line\": 188, \"column\": 4},\n   \"goals\":\n   \"case neg\\n\u03b1 : Type u_1\\n\u03c3 : Type u_2\\ninst\u271d\u00b9 : Primcodable \u03b1\\ninst\u271d : Primcodable \u03c3\\nC : Set (\u2115 \u2192. \u2115)\\nf g : \u2115 \u2192. \u2115\\nhf : Nat.Partrec f\\nhg : Nat.Partrec g\\nfC : f \u2208 C\\nw\u271d : DecidablePred fun c => c.eval \u2208 C\\nh : Computable fun a => decide ((fun c => c.eval \u2208 C) a)\\nc : Code\\nH : c.eval \u2209 C\\ne : c.eval = fun b => f b\\n\u22a2 g \u2208 C\",\n   \"endPos\": {\"line\": 188, \"column\": 15}},\n  {\"tactic\": \"contradiction\",\n   \"proofState\": 100,\n   \"pos\": {\"line\": 189, \"column\": 4},\n   \"goals\":\n   \"case neg\\n\u03b1 : Type u_1\\n\u03c3 : Type u_2\\ninst\u271d\u00b9 : Primcodable \u03b1\\ninst\u271d : Primcodable \u03c3\\nC : Set (\u2115 \u2192. \u2115)\\nf g : \u2115 \u2192. \u2115\\nhf : Nat.Partrec f\\nhg : Nat.Partrec g\\nfC : f \u2208 C\\nw\u271d : DecidablePred fun c => c.eval \u2208 C\\nh : Computable fun a => decide ((fun c => c.eval \u2208 C) a)\\nc : Code\\nH : (fun b => f b) \u2209 C\\ne : c.eval = fun b => f b\\n\u22a2 g \u2208 C\",\n   \"endPos\": {\"line\": 189, \"column\": 17}},\n  {\"tactic\":\n   \"classical exact\\n  have hC : \u2200 f, f \u2208 C \u2194 eval f \u2208 eval '' C := fun f => \u27e8Set.mem_image_of_mem _, fun \u27e8g, hg, e\u27e9 => (H _ _ e).1 hg\u27e9\\n  \u27e8fun h =>\\n    or_iff_not_imp_left.2 fun C0 =>\\n      Set.eq_univ_of_forall fun cg =>\\n        let \u27e8cf, fC\u27e9 := Set.nonempty_iff_ne_empty.2 C0\\n        (hC _).2 <|\\n          rice (eval '' C) (h.of_eq hC) (Partrec.nat_iff.1 <| eval_part.comp (const cf) Computable.id)\\n            (Partrec.nat_iff.1 <| eval_part.comp (const cg) Computable.id) ((hC _).1 fC),\\n    fun h => by\\n    {obtain rfl | rfl := h <;> simp [ComputablePred, Set.mem_empty_iff_false] <;>\\n      exact \u27e8by infer_instance, Computable.const _\u27e9\\n  }\u27e9\",\n   \"proofState\": 101,\n   \"pos\": {\"line\": 194, \"column\": 2},\n   \"goals\":\n   \"\u03b1 : Type u_1\\n\u03c3 : Type u_2\\ninst\u271d\u00b9 : Primcodable \u03b1\\ninst\u271d : Primcodable \u03c3\\nC : Set Code\\nH : \u2200 (cf cg : Code), cf.eval = cg.eval \u2192 (cf \u2208 C \u2194 cg \u2208 C)\\n\u22a2 (ComputablePred fun c => c \u2208 C) \u2194 C = \u2205 \u2228 C = Set.univ\",\n   \"endPos\": {\"line\": 207, \"column\": 60}},\n  {\"tactic\":\n   \"exact\\n  have hC : \u2200 f, f \u2208 C \u2194 eval f \u2208 eval '' C := fun f => \u27e8Set.mem_image_of_mem _, fun \u27e8g, hg, e\u27e9 => (H _ _ e).1 hg\u27e9\\n  \u27e8fun h =>\\n    or_iff_not_imp_left.2 fun C0 =>\\n      Set.eq_univ_of_forall fun cg =>\\n        let \u27e8cf, fC\u27e9 := Set.nonempty_iff_ne_empty.2 C0\\n        (hC _).2 <|\\n          rice (eval '' C) (h.of_eq hC) (Partrec.nat_iff.1 <| eval_part.comp (const cf) Computable.id)\\n            (Partrec.nat_iff.1 <| eval_part.comp (const cg) Computable.id) ((hC _).1 fC),\\n    fun h => by\\n    {obtain rfl | rfl := h <;> simp [ComputablePred, Set.mem_empty_iff_false] <;>\\n      exact \u27e8by infer_instance, Computable.const _\u27e9\\n  }\u27e9\",\n   \"proofState\": 102,\n   \"pos\": {\"line\": 194, \"column\": 12},\n   \"goals\":\n   \"\u03b1 : Type u_1\\n\u03c3 : Type u_2\\ninst\u271d\u00b9 : Primcodable \u03b1\\ninst\u271d : Primcodable \u03c3\\nC : Set Code\\nH : \u2200 (cf cg : Code), cf.eval = cg.eval \u2192 (cf \u2208 C \u2194 cg \u2208 C)\\n\u22a2 (ComputablePred fun c => c \u2208 C) \u2194 C = \u2205 \u2228 C = Set.univ\",\n   \"endPos\": {\"line\": 207, \"column\": 60}},\n  {\"tactic\":\n   \"{obtain rfl | rfl := h <;> simp [ComputablePred, Set.mem_empty_iff_false] <;>\\n    exact \u27e8by infer_instance, Computable.const _\u27e9\\n}\",\n   \"proofState\": 103,\n   \"pos\": {\"line\": 205, \"column\": 20},\n   \"goals\":\n   \"\u03b1 : Type u_1\\n\u03c3 : Type u_2\\ninst\u271d\u00b9 : Primcodable \u03b1\\ninst\u271d : Primcodable \u03c3\\nC : Set Code\\nH : \u2200 (cf cg : Code), cf.eval = cg.eval \u2192 (cf \u2208 C \u2194 cg \u2208 C)\\nhC : \u2200 (f : Code), f \u2208 C \u2194 f.eval \u2208 eval '' C\\nh : C = \u2205 \u2228 C = Set.univ\\n\u22a2 ComputablePred fun c => c \u2208 C\",\n   \"endPos\": {\"line\": 207, \"column\": 59}},\n  {\"tactic\": \"obtain rfl | rfl := h\",\n   \"proofState\": 104,\n   \"pos\": {\"line\": 206, \"column\": 10},\n   \"goals\":\n   \"\u03b1 : Type u_1\\n\u03c3 : Type u_2\\ninst\u271d\u00b9 : Primcodable \u03b1\\ninst\u271d : Primcodable \u03c3\\nC : Set Code\\nH : \u2200 (cf cg : Code), cf.eval = cg.eval \u2192 (cf \u2208 C \u2194 cg \u2208 C)\\nhC : \u2200 (f : Code), f \u2208 C \u2194 f.eval \u2208 eval '' C\\nh : C = \u2205 \u2228 C = Set.univ\\n\u22a2 ComputablePred fun c => c \u2208 C\",\n   \"endPos\": {\"line\": 206, \"column\": 31}},\n  {\"tactic\": \"simp [ComputablePred, Set.mem_empty_iff_false]\",\n   \"proofState\": 105,\n   \"pos\": {\"line\": 206, \"column\": 36},\n   \"goals\":\n   \"case inl\\n\u03b1 : Type u_1\\n\u03c3 : Type u_2\\ninst\u271d\u00b9 : Primcodable \u03b1\\ninst\u271d : Primcodable \u03c3\\nH : \u2200 (cf cg : Code), cf.eval = cg.eval \u2192 (cf \u2208 \u2205 \u2194 cg \u2208 \u2205)\\nhC : \u2200 (f : Code), f \u2208 \u2205 \u2194 f.eval \u2208 eval '' \u2205\\n\u22a2 ComputablePred fun c => c \u2208 \u2205\",\n   \"endPos\": {\"line\": 206, \"column\": 82}},\n  {\"tactic\": \"simp [ComputablePred, Set.mem_empty_iff_false]\",\n   \"proofState\": 106,\n   \"pos\": {\"line\": 206, \"column\": 36},\n   \"goals\":\n   \"case inr\\n\u03b1 : Type u_1\\n\u03c3 : Type u_2\\ninst\u271d\u00b9 : Primcodable \u03b1\\ninst\u271d : Primcodable \u03c3\\nH : \u2200 (cf cg : Code), cf.eval = cg.eval \u2192 (cf \u2208 Set.univ \u2194 cg \u2208 Set.univ)\\nhC : \u2200 (f : Code), f \u2208 Set.univ \u2194 f.eval \u2208 eval '' Set.univ\\n\u22a2 ComputablePred fun c => c \u2208 Set.univ\",\n   \"endPos\": {\"line\": 206, \"column\": 82}},\n  {\"tactic\": \"exact \u27e8by infer_instance, Computable.const _\u27e9\",\n   \"proofState\": 107,\n   \"pos\": {\"line\": 207, \"column\": 12},\n   \"goals\":\n   \"case inl\\n\u03b1 : Type u_1\\n\u03c3 : Type u_2\\ninst\u271d\u00b9 : Primcodable \u03b1\\ninst\u271d : Primcodable \u03c3\\nH : \u2200 (cf cg : Code), cf.eval = cg.eval \u2192 (cf \u2208 \u2205 \u2194 cg \u2208 \u2205)\\nhC : \u2200 (f : Code), f \u2208 \u2205 \u2194 f.eval \u2208 eval '' \u2205\\n\u22a2 \u2203 x, Computable fun a => false\",\n   \"endPos\": {\"line\": 207, \"column\": 57}},\n  {\"tactic\": \"infer_instance\",\n   \"proofState\": 108,\n   \"pos\": {\"line\": 207, \"column\": 22},\n   \"goals\":\n   \"\u03b1 : Type u_1\\n\u03c3 : Type u_2\\ninst\u271d\u00b9 : Primcodable \u03b1\\ninst\u271d : Primcodable \u03c3\\nH : \u2200 (cf cg : Code), cf.eval = cg.eval \u2192 (cf \u2208 \u2205 \u2194 cg \u2208 \u2205)\\nhC : \u2200 (f : Code), f \u2208 \u2205 \u2194 f.eval \u2208 eval '' \u2205\\n\u22a2 DecidablePred fun c => c \u2208 \u2205\",\n   \"endPos\": {\"line\": 207, \"column\": 36}},\n  {\"tactic\": \"exact \u27e8by infer_instance, Computable.const _\u27e9\",\n   \"proofState\": 109,\n   \"pos\": {\"line\": 207, \"column\": 12},\n   \"goals\":\n   \"case inr\\n\u03b1 : Type u_1\\n\u03c3 : Type u_2\\ninst\u271d\u00b9 : Primcodable \u03b1\\ninst\u271d : Primcodable \u03c3\\nH : \u2200 (cf cg : Code), cf.eval = cg.eval \u2192 (cf \u2208 Set.univ \u2194 cg \u2208 Set.univ)\\nhC : \u2200 (f : Code), f \u2208 Set.univ \u2194 f.eval \u2208 eval '' Set.univ\\n\u22a2 \u2203 x, Computable fun a => true\",\n   \"endPos\": {\"line\": 207, \"column\": 57}},\n  {\"tactic\": \"infer_instance\",\n   \"proofState\": 110,\n   \"pos\": {\"line\": 207, \"column\": 22},\n   \"goals\":\n   \"\u03b1 : Type u_1\\n\u03c3 : Type u_2\\ninst\u271d\u00b9 : Primcodable \u03b1\\ninst\u271d : Primcodable \u03c3\\nH : \u2200 (cf cg : Code), cf.eval = cg.eval \u2192 (cf \u2208 Set.univ \u2194 cg \u2208 Set.univ)\\nhC : \u2200 (f : Code), f \u2208 Set.univ \u2194 f.eval \u2208 eval '' Set.univ\\n\u22a2 DecidablePred fun c => c \u2208 Set.univ\",\n   \"endPos\": {\"line\": 207, \"column\": 36}},\n  {\"tactic\":\n   \"obtain \u27e8k, pk, hk\u27e9 :=\\n  Partrec.merge (h\u2081.map (Computable.const true).to\u2082) (h\u2082.map (Computable.const false).to\u2082)\\n    (by\\n      intro a x hx y hy\\n      simp only [Part.mem_map_iff, Part.mem_assert_iff, Part.mem_some_iff, exists_prop, and_true, exists_const] at hx hy\\n      cases hy.1 hx.1)\",\n   \"proofState\": 111,\n   \"pos\": {\"line\": 228, \"column\": 6},\n   \"goals\":\n   \"\u03b1 : Type u_1\\n\u03c3 : Type u_2\\ninst\u271d\u00b2 : Primcodable \u03b1\\ninst\u271d\u00b9 : Primcodable \u03c3\\np : \u03b1 \u2192 Prop\\ninst\u271d : DecidablePred p\\nx\u271d : RePred p \u2227 RePred fun a => \u00acp a\\nh\u2081 : RePred p\\nh\u2082 : RePred fun a => \u00acp a\\n\u22a2 Computable fun a => decide (p a)\",\n   \"endPos\": {\"line\": 234, \"column\": 26}},\n  {\"tactic\": \"intro a x hx y hy\",\n   \"proofState\": 112,\n   \"pos\": {\"line\": 231, \"column\": 10},\n   \"goals\":\n   \"\u03b1 : Type u_1\\n\u03c3 : Type u_2\\ninst\u271d\u00b2 : Primcodable \u03b1\\ninst\u271d\u00b9 : Primcodable \u03c3\\np : \u03b1 \u2192 Prop\\ninst\u271d : DecidablePred p\\nx\u271d : RePred p \u2227 RePred fun a => \u00acp a\\nh\u2081 : RePred p\\nh\u2082 : RePred fun a => \u00acp a\\n\u22a2 \u2200 (a : \u03b1),\\n    \u2200 x \u2208 Part.map (fun b => true) (Part.assert (p a) fun x => Part.some ()),\\n      \u2200 y \u2208 Part.map (fun b => false) (Part.assert ((fun a => \u00acp a) a) fun x => Part.some ()), x = y\",\n   \"endPos\": {\"line\": 231, \"column\": 27}},\n  {\"tactic\":\n   \"simp only [Part.mem_map_iff, Part.mem_assert_iff, Part.mem_some_iff, exists_prop, and_true, exists_const] at hx hy\",\n   \"proofState\": 113,\n   \"pos\": {\"line\": 232, \"column\": 10},\n   \"goals\":\n   \"\u03b1 : Type u_1\\n\u03c3 : Type u_2\\ninst\u271d\u00b2 : Primcodable \u03b1\\ninst\u271d\u00b9 : Primcodable \u03c3\\np : \u03b1 \u2192 Prop\\ninst\u271d : DecidablePred p\\nx\u271d : RePred p \u2227 RePred fun a => \u00acp a\\nh\u2081 : RePred p\\nh\u2082 : RePred fun a => \u00acp a\\na : \u03b1\\nx : Bool\\nhx : x \u2208 Part.map (fun b => true) (Part.assert (p a) fun x => Part.some ())\\ny : Bool\\nhy : y \u2208 Part.map (fun b => false) (Part.assert ((fun a => \u00acp a) a) fun x => Part.some ())\\n\u22a2 x = y\",\n   \"endPos\": {\"line\": 233, \"column\": 44}},\n  {\"tactic\": \"cases hy.1 hx.1\",\n   \"proofState\": 114,\n   \"pos\": {\"line\": 234, \"column\": 10},\n   \"goals\":\n   \"\u03b1 : Type u_1\\n\u03c3 : Type u_2\\ninst\u271d\u00b2 : Primcodable \u03b1\\ninst\u271d\u00b9 : Primcodable \u03c3\\np : \u03b1 \u2192 Prop\\ninst\u271d : DecidablePred p\\nx\u271d : RePred p \u2227 RePred fun a => \u00acp a\\nh\u2081 : RePred p\\nh\u2082 : RePred fun a => \u00acp a\\na : \u03b1\\nx y : Bool\\nhx : p a \u2227 true = x\\nhy : \u00acp a \u2227 false = y\\n\u22a2 x = y\",\n   \"endPos\": {\"line\": 234, \"column\": 25}},\n  {\"tactic\": \"refine Partrec.of_eq pk fun n => Part.eq_some_iff.2 ?_\",\n   \"proofState\": 115,\n   \"pos\": {\"line\": 235, \"column\": 6},\n   \"goals\":\n   \"case intro.intro\\n\u03b1 : Type u_1\\n\u03c3 : Type u_2\\ninst\u271d\u00b2 : Primcodable \u03b1\\ninst\u271d\u00b9 : Primcodable \u03c3\\np : \u03b1 \u2192 Prop\\ninst\u271d : DecidablePred p\\nx\u271d : RePred p \u2227 RePred fun a => \u00acp a\\nh\u2081 : RePred p\\nh\u2082 : RePred fun a => \u00acp a\\nk : \u03b1 \u2192. Bool\\npk : Partrec k\\nhk :\\n  \u2200 (a : \u03b1) (x : Bool),\\n    x \u2208 k a \u2194\\n      x \u2208 Part.map (fun b => true) (Part.assert (p a) fun x => Part.some ()) \u2228\\n        x \u2208 Part.map (fun b => false) (Part.assert ((fun a => \u00acp a) a) fun x => Part.some ())\\n\u22a2 Computable fun a => decide (p a)\",\n   \"endPos\": {\"line\": 235, \"column\": 60}},\n  {\"tactic\": \"rw [hk]\",\n   \"proofState\": 116,\n   \"pos\": {\"line\": 236, \"column\": 6},\n   \"goals\":\n   \"case intro.intro\\n\u03b1 : Type u_1\\n\u03c3 : Type u_2\\ninst\u271d\u00b2 : Primcodable \u03b1\\ninst\u271d\u00b9 : Primcodable \u03c3\\np : \u03b1 \u2192 Prop\\ninst\u271d : DecidablePred p\\nx\u271d : RePred p \u2227 RePred fun a => \u00acp a\\nh\u2081 : RePred p\\nh\u2082 : RePred fun a => \u00acp a\\nk : \u03b1 \u2192. Bool\\npk : Partrec k\\nhk :\\n  \u2200 (a : \u03b1) (x : Bool),\\n    x \u2208 k a \u2194\\n      x \u2208 Part.map (fun b => true) (Part.assert (p a) fun x => Part.some ()) \u2228\\n        x \u2208 Part.map (fun b => false) (Part.assert ((fun a => \u00acp a) a) fun x => Part.some ())\\nn : \u03b1\\n\u22a2 (fun a => decide (p a)) n \u2208 k n\",\n   \"endPos\": {\"line\": 236, \"column\": 13}},\n  {\"tactic\":\n   \"simp only [Part.mem_map_iff, Part.mem_assert_iff, Part.mem_some_iff, exists_prop, and_true, true_eq_decide_iff,\\n  and_self, exists_const, false_eq_decide_iff]\",\n   \"proofState\": 117,\n   \"pos\": {\"line\": 237, \"column\": 6},\n   \"goals\":\n   \"case intro.intro\\n\u03b1 : Type u_1\\n\u03c3 : Type u_2\\ninst\u271d\u00b2 : Primcodable \u03b1\\ninst\u271d\u00b9 : Primcodable \u03c3\\np : \u03b1 \u2192 Prop\\ninst\u271d : DecidablePred p\\nx\u271d : RePred p \u2227 RePred fun a => \u00acp a\\nh\u2081 : RePred p\\nh\u2082 : RePred fun a => \u00acp a\\nk : \u03b1 \u2192. Bool\\npk : Partrec k\\nhk :\\n  \u2200 (a : \u03b1) (x : Bool),\\n    x \u2208 k a \u2194\\n      x \u2208 Part.map (fun b => true) (Part.assert (p a) fun x => Part.some ()) \u2228\\n        x \u2208 Part.map (fun b => false) (Part.assert ((fun a => \u00acp a) a) fun x => Part.some ())\\nn : \u03b1\\n\u22a2 (fun a => decide (p a)) n \u2208 Part.map (fun b => true) (Part.assert (p n) fun x => Part.some ()) \u2228\\n    (fun a => decide (p a)) n \u2208 Part.map (fun b => false) (Part.assert ((fun a => \u00acp a) n) fun x => Part.some ())\",\n   \"endPos\": {\"line\": 238, \"column\": 72}},\n  {\"tactic\": \"apply Decidable.em\",\n   \"proofState\": 118,\n   \"pos\": {\"line\": 239, \"column\": 6},\n   \"goals\":\n   \"case intro.intro\\n\u03b1 : Type u_1\\n\u03c3 : Type u_2\\ninst\u271d\u00b2 : Primcodable \u03b1\\ninst\u271d\u00b9 : Primcodable \u03c3\\np : \u03b1 \u2192 Prop\\ninst\u271d : DecidablePred p\\nx\u271d : RePred p \u2227 RePred fun a => \u00acp a\\nh\u2081 : RePred p\\nh\u2082 : RePred fun a => \u00acp a\\nk : \u03b1 \u2192. Bool\\npk : Partrec k\\nhk :\\n  \u2200 (a : \u03b1) (x : Bool),\\n    x \u2208 k a \u2194\\n      x \u2208 Part.map (fun b => true) (Part.assert (p a) fun x => Part.some ()) \u2228\\n        x \u2208 Part.map (fun b => false) (Part.assert ((fun a => \u00acp a) a) fun x => Part.some ())\\nn : \u03b1\\n\u22a2 p n \u2228 \u00acp n\",\n   \"endPos\": {\"line\": 239, \"column\": 24}},\n  {\"tactic\": \"classical exact computable_iff_re_compl_re\",\n   \"proofState\": 119,\n   \"pos\": {\"line\": 244, \"column\": 2},\n   \"goals\":\n   \"\u03b1 : Type u_1\\n\u03c3 : Type u_2\\ninst\u271d\u00b9 : Primcodable \u03b1\\ninst\u271d : Primcodable \u03c3\\np : \u03b1 \u2192 Prop\\n\u22a2 ComputablePred p \u2194 RePred p \u2227 RePred fun a => \u00acp a\",\n   \"endPos\": {\"line\": 244, \"column\": 44}},\n  {\"tactic\": \"exact computable_iff_re_compl_re\",\n   \"proofState\": 120,\n   \"pos\": {\"line\": 244, \"column\": 12},\n   \"goals\":\n   \"\u03b1 : Type u_1\\n\u03c3 : Type u_2\\ninst\u271d\u00b9 : Primcodable \u03b1\\ninst\u271d : Primcodable \u03c3\\np : \u03b1 \u2192 Prop\\n\u22a2 ComputablePred p \u2194 RePred p \u2227 RePred fun a => \u00acp a\",\n   \"endPos\": {\"line\": 244, \"column\": 44}},\n  {\"tactic\":\n   \"induction pf with\\n| prim hf => exact hf.to_prim.to_comp\\n| comp _ _ _ hf hg => exact (Partrec.vector_mOfFn hg).bind (hf.comp snd)\\n| rfind _ hf =>\\n  have := hf.comp (vector_cons.comp snd fst)\\n  have := ((Primrec.eq.comp _root_.Primrec.id (_root_.Primrec.const 0)).to_comp.comp this).to\u2082.partrec\u2082\\n  exact _root_.Partrec.rfind this\",\n   \"proofState\": 121,\n   \"pos\": {\"line\": 277, \"column\": 2},\n   \"goals\": \"n : \u2115 f : Vector \u2115 n \u2192. \u2115 pf : Partrec' f \u22a2 _root_.Partrec f\",\n   \"endPos\": {\"line\": 285, \"column\": 35}},\n  {\"tactic\":\n   \"induction pf with\\n| prim hf => exact hf.to_prim.to_comp\\n| comp _ _ _ hf hg => exact (Partrec.vector_mOfFn hg).bind (hf.comp snd)\\n| rfind _ hf =>\\n  have := hf.comp (vector_cons.comp snd fst)\\n  have := ((Primrec.eq.comp _root_.Primrec.id (_root_.Primrec.const 0)).to_comp.comp this).to\u2082.partrec\u2082\\n  exact _root_.Partrec.rfind this\",\n   \"proofState\": 122,\n   \"pos\": {\"line\": 277, \"column\": 2},\n   \"goals\": \"n : \u2115 f : Vector \u2115 n \u2192. \u2115 pf : Partrec' f \u22a2 _root_.Partrec f\",\n   \"endPos\": {\"line\": 285, \"column\": 35}},\n  {\"tactic\": \"\\n| prim hf => exact hf.to_prim.to_comp\",\n   \"proofState\": 123,\n   \"pos\": {\"line\": 278, \"column\": 2},\n   \"goals\":\n   \"case prim n : \u2115 f : Vector \u2115 n \u2192. \u2115 n\u271d : \u2115 f\u271d : Vector \u2115 n\u271d \u2192 \u2115 hf : Primrec' f\u271d \u22a2 _root_.Partrec \u2191f\u271d\",\n   \"endPos\": {\"line\": 278, \"column\": 39}},\n  {\"tactic\": \"exact hf.to_prim.to_comp\",\n   \"proofState\": 124,\n   \"pos\": {\"line\": 278, \"column\": 15},\n   \"goals\":\n   \"case prim n : \u2115 f : Vector \u2115 n \u2192. \u2115 n\u271d : \u2115 f\u271d : Vector \u2115 n\u271d \u2192 \u2115 hf : Primrec' f\u271d \u22a2 _root_.Partrec \u2191f\u271d\",\n   \"endPos\": {\"line\": 278, \"column\": 39}},\n  {\"tactic\":\n   \"\\n| comp _ _ _ hf hg => exact (Partrec.vector_mOfFn hg).bind (hf.comp snd)\",\n   \"proofState\": 125,\n   \"pos\": {\"line\": 279, \"column\": 2},\n   \"goals\":\n   \"case comp\\nn : \u2115\\nf : Vector \u2115 n \u2192. \u2115\\nm\u271d n\u271d : \u2115\\nf\u271d : Vector \u2115 n\u271d \u2192. \u2115\\ng\u271d : Fin n\u271d \u2192 Vector \u2115 m\u271d \u2192. \u2115\\na\u271d\u00b9 : Partrec' f\u271d\\na\u271d : \u2200 (i : Fin n\u271d), Partrec' (g\u271d i)\\nhf : _root_.Partrec f\u271d\\nhg : \u2200 (i : Fin n\u271d), _root_.Partrec (g\u271d i)\\n\u22a2 _root_.Partrec fun v => (mOfFn fun i => g\u271d i v) >>= f\u271d\",\n   \"endPos\": {\"line\": 279, \"column\": 74}},\n  {\"tactic\": \"exact (Partrec.vector_mOfFn hg).bind (hf.comp snd)\",\n   \"proofState\": 126,\n   \"pos\": {\"line\": 279, \"column\": 24},\n   \"goals\":\n   \"case comp\\nn : \u2115\\nf : Vector \u2115 n \u2192. \u2115\\nm\u271d n\u271d : \u2115\\nf\u271d : Vector \u2115 n\u271d \u2192. \u2115\\ng\u271d : Fin n\u271d \u2192 Vector \u2115 m\u271d \u2192. \u2115\\na\u271d\u00b9 : Partrec' f\u271d\\na\u271d : \u2200 (i : Fin n\u271d), Partrec' (g\u271d i)\\nhf : _root_.Partrec f\u271d\\nhg : \u2200 (i : Fin n\u271d), _root_.Partrec (g\u271d i)\\n\u22a2 _root_.Partrec fun v => (mOfFn fun i => g\u271d i v) >>= f\u271d\",\n   \"endPos\": {\"line\": 279, \"column\": 74}},\n  {\"tactic\":\n   \"\\n| rfind _ hf =>\\n  have := hf.comp (vector_cons.comp snd fst)\\n  have := ((Primrec.eq.comp _root_.Primrec.id (_root_.Primrec.const 0)).to_comp.comp this).to\u2082.partrec\u2082\\n  exact _root_.Partrec.rfind this\",\n   \"proofState\": 127,\n   \"pos\": {\"line\": 280, \"column\": 2},\n   \"goals\":\n   \"case rfind\\nn : \u2115\\nf : Vector \u2115 n \u2192. \u2115\\nn\u271d : \u2115\\nf\u271d : Vector \u2115 (n\u271d + 1) \u2192 \u2115\\na\u271d : Partrec' \u2191f\u271d\\nhf : _root_.Partrec \u2191f\u271d\\n\u22a2 _root_.Partrec fun v => Nat.rfind fun n => Part.some (decide (f\u271d (n ::\u1d65 v) = 0))\",\n   \"endPos\": {\"line\": 285, \"column\": 35}},\n  {\"tactic\": \"have := hf.comp (vector_cons.comp snd fst)\",\n   \"proofState\": 128,\n   \"pos\": {\"line\": 281, \"column\": 4},\n   \"goals\":\n   \"case rfind\\nn : \u2115\\nf : Vector \u2115 n \u2192. \u2115\\nn\u271d : \u2115\\nf\u271d : Vector \u2115 (n\u271d + 1) \u2192 \u2115\\na\u271d : Partrec' \u2191f\u271d\\nhf : _root_.Partrec \u2191f\u271d\\n\u22a2 _root_.Partrec fun v => Nat.rfind fun n => Part.some (decide (f\u271d (n ::\u1d65 v) = 0))\",\n   \"endPos\": {\"line\": 281, \"column\": 46}},\n  {\"tactic\":\n   \"have := ((Primrec.eq.comp _root_.Primrec.id (_root_.Primrec.const 0)).to_comp.comp this).to\u2082.partrec\u2082\",\n   \"proofState\": 129,\n   \"pos\": {\"line\": 282, \"column\": 4},\n   \"goals\":\n   \"case rfind\\nn : \u2115\\nf : Vector \u2115 n \u2192. \u2115\\nn\u271d : \u2115\\nf\u271d : Vector \u2115 (n\u271d + 1) \u2192 \u2115\\na\u271d : Partrec' \u2191f\u271d\\nhf : _root_.Partrec \u2191f\u271d\\nthis : _root_.Partrec fun a => \u2191f\u271d (a.2 ::\u1d65 a.1)\\n\u22a2 _root_.Partrec fun v => Nat.rfind fun n => Part.some (decide (f\u271d (n ::\u1d65 v) = 0))\",\n   \"endPos\": {\"line\": 284, \"column\": 26}},\n  {\"tactic\": \"exact _root_.Partrec.rfind this\",\n   \"proofState\": 130,\n   \"pos\": {\"line\": 285, \"column\": 4},\n   \"goals\":\n   \"case rfind\\nn : \u2115\\nf : Vector \u2115 n \u2192. \u2115\\nn\u271d : \u2115\\nf\u271d : Vector \u2115 (n\u271d + 1) \u2192 \u2115\\na\u271d : Partrec' \u2191f\u271d\\nhf : _root_.Partrec \u2191f\u271d\\nthis\u271d : _root_.Partrec fun a => \u2191f\u271d (a.2 ::\u1d65 a.1)\\nthis : Partrec\u2082 fun a => \u2191fun b => decide ((fun a => id a = 0) (f\u271d ((a, b).2 ::\u1d65 (a, b).1)))\\n\u22a2 _root_.Partrec fun v => Nat.rfind fun n => Part.some (decide (f\u271d (n ::\u1d65 v) = 0))\",\n   \"endPos\": {\"line\": 285, \"column\": 35}},\n  {\"tactic\": \"simp\",\n   \"proofState\": 131,\n   \"pos\": {\"line\": 302, \"column\": 4},\n   \"goals\":\n   \"n : \u2115\\nf : Vector \u2115 n \u2192. \u2115\\nhf : Partrec' f\\nv : Vector \u2115 n.succ\\n\u22a2 (mOfFn fun i => (\u2191fun v => v.get i.succ) v) >>= f = f v.tail\",\n   \"endPos\": {\"line\": 302, \"column\": 8}},\n  {\"tactic\": \"rw [\u2190 ofFn_get v.tail]\",\n   \"proofState\": 132,\n   \"pos\": {\"line\": 302, \"column\": 10},\n   \"goals\":\n   \"n : \u2115 f : Vector \u2115 n \u2192. \u2115 hf : Partrec' f v : Vector \u2115 n.succ \u22a2 f (ofFn fun i => v.get i.succ) = f v.tail\",\n   \"endPos\": {\"line\": 302, \"column\": 32}},\n  {\"tactic\": \"congr\",\n   \"proofState\": 133,\n   \"pos\": {\"line\": 302, \"column\": 34},\n   \"goals\":\n   \"n : \u2115 f : Vector \u2115 n \u2192. \u2115 hf : Partrec' f v : Vector \u2115 n.succ \u22a2 f (ofFn fun i => v.get i.succ) = f (ofFn v.tail.get)\",\n   \"endPos\": {\"line\": 302, \"column\": 39}},\n  {\"tactic\": \"funext i\",\n   \"proofState\": 134,\n   \"pos\": {\"line\": 302, \"column\": 41},\n   \"goals\":\n   \"case e_a.e_a n : \u2115 f : Vector \u2115 n \u2192. \u2115 hf : Partrec' f v : Vector \u2115 n.succ \u22a2 (fun i => v.get i.succ) = v.tail.get\",\n   \"endPos\": {\"line\": 302, \"column\": 49}},\n  {\"tactic\": \"simp\",\n   \"proofState\": 135,\n   \"pos\": {\"line\": 302, \"column\": 51},\n   \"goals\":\n   \"case e_a.e_a.h n : \u2115 f : Vector \u2115 n \u2192. \u2115 hf : Partrec' f v : Vector \u2115 n.succ i : Fin n \u22a2 v.get i.succ = v.tail.get i\",\n   \"endPos\": {\"line\": 302, \"column\": 55}},\n  {\"tactic\": \"refine Fin.cases ?_ (fun i => ?_) i\",\n   \"proofState\": 136,\n   \"pos\": {\"line\": 308, \"column\": 8},\n   \"goals\":\n   \"n : \u2115\\nf : Vector \u2115 n \u2192. \u2115\\ng : Vector \u2115 (n + 1) \u2192. \u2115\\nhf : Partrec' f\\nhg : Partrec' g\\ni : Fin (n + 1)\\n\u22a2 Partrec' ((fun i => Fin.cases f (fun i v => \u2191(some (v.get i))) i) i)\",\n   \"endPos\": {\"line\": 308, \"column\": 43}},\n  {\"tactic\": \"simp [*]\",\n   \"proofState\": 137,\n   \"pos\": {\"line\": 308, \"column\": 48},\n   \"goals\":\n   \"case refine_1\\nn : \u2115\\nf : Vector \u2115 n \u2192. \u2115\\ng : Vector \u2115 (n + 1) \u2192. \u2115\\nhf : Partrec' f\\nhg : Partrec' g\\ni : Fin (n + 1)\\n\u22a2 Partrec' ((fun i => Fin.cases f (fun i v => \u2191(some (v.get i))) i) 0)\",\n   \"endPos\": {\"line\": 308, \"column\": 56}},\n  {\"tactic\": \"simp [*]\",\n   \"proofState\": 138,\n   \"pos\": {\"line\": 308, \"column\": 48},\n   \"goals\":\n   \"case refine_2\\nn : \u2115\\nf : Vector \u2115 n \u2192. \u2115\\ng : Vector \u2115 (n + 1) \u2192. \u2115\\nhf : Partrec' f\\nhg : Partrec' g\\ni\u271d : Fin (n + 1)\\ni : Fin n\\n\u22a2 Partrec' ((fun i => Fin.cases f (fun i v => \u2191(some (v.get i))) i) i.succ)\",\n   \"endPos\": {\"line\": 308, \"column\": 56}},\n  {\"tactic\": \"exact prim (Nat.Primrec'.get _)\",\n   \"proofState\": 139,\n   \"pos\": {\"line\": 309, \"column\": 8},\n   \"goals\":\n   \"case refine_2\\nn : \u2115\\nf : Vector \u2115 n \u2192. \u2115\\ng : Vector \u2115 (n + 1) \u2192. \u2115\\nhf : Partrec' f\\nhg : Partrec' g\\ni\u271d : Fin (n + 1)\\ni : Fin n\\n\u22a2 Partrec' fun v => Part.some (v.get i)\",\n   \"endPos\": {\"line\": 309, \"column\": 39}},\n  {\"tactic\": \"simp [mOfFn, Part.bind_assoc, pure]\",\n   \"proofState\": 140,\n   \"pos\": {\"line\": 310, \"column\": 16},\n   \"goals\":\n   \"n : \u2115\\nf : Vector \u2115 n \u2192. \u2115\\ng : Vector \u2115 (n + 1) \u2192. \u2115\\nhf : Partrec' f\\nhg : Partrec' g\\nv : Vector \u2115 n\\n\u22a2 (mOfFn fun i => Fin.cases f (fun i v => \u2191(some (v.get i))) i v) >>= g = (f v).bind fun a => g (a ::\u1d65 v)\",\n   \"endPos\": {\"line\": 310, \"column\": 51}},\n  {\"tactic\": \"simp [(Part.bind_some_eq_map _ _).symm]\",\n   \"proofState\": 141,\n   \"pos\": {\"line\": 315, \"column\": 2},\n   \"goals\":\n   \"n : \u2115\\nf : Vector \u2115 n \u2192. \u2115\\ng : Vector \u2115 (n + 1) \u2192 \u2115\\nhf : Partrec' f\\nhg : Partrec' \u2191g\\n\u22a2 Partrec' fun v => Part.map (fun a => g (a ::\u1d65 v)) (f v)\",\n   \"endPos\": {\"line\": 315, \"column\": 41}},\n  {\"tactic\": \"exact hf.bind hg\",\n   \"proofState\": 142,\n   \"pos\": {\"line\": 315, \"column\": 43},\n   \"goals\":\n   \"n : \u2115\\nf : Vector \u2115 n \u2192. \u2115\\ng : Vector \u2115 (n + 1) \u2192 \u2115\\nhf : Partrec' f\\nhg : Partrec' \u2191g\\n\u22a2 Partrec' fun v => (f v).bind (Part.some \u2218 fun a => g (a ::\u1d65 v))\",\n   \"endPos\": {\"line\": 315, \"column\": 59}},\n  {\"tactic\": \"simpa using hf\",\n   \"proofState\": 143,\n   \"pos\": {\"line\": 332, \"column\": 16},\n   \"goals\":\n   \"n m : \u2115\\nf : Vector \u2115 n \u2192 \u2115\\ng : Vector \u2115 n \u2192 Vector \u2115 m\\nhf : Partrec' \u2191f\\nhg : Vec g\\ni : Fin m.succ\\n\u22a2 Partrec' fun v => \u2191(some (((fun v => f v ::\u1d65 g v) v).get 0))\",\n   \"endPos\": {\"line\": 332, \"column\": 30}},\n  {\"tactic\": \"simp only [hg i, get_cons_succ]\",\n   \"proofState\": 144,\n   \"pos\": {\"line\": 332, \"column\": 45},\n   \"goals\":\n   \"n m : \u2115\\nf : Vector \u2115 n \u2192 \u2115\\ng : Vector \u2115 n \u2192 Vector \u2115 m\\nhf : Partrec' \u2191f\\nhg : Vec g\\ni\u271d : Fin m.succ\\ni : Fin m\\n\u22a2 Partrec' fun v => \u2191(some (((fun v => f v ::\u1d65 g v) v).get i.succ))\",\n   \"endPos\": {\"line\": 332, \"column\": 76}},\n  {\"tactic\": \"simp\",\n   \"proofState\": 145,\n   \"pos\": {\"line\": 340, \"column\": 35},\n   \"goals\":\n   \"n m : \u2115\\nf : Vector \u2115 m \u2192. \u2115\\ng : Vector \u2115 n \u2192 Vector \u2115 m\\nhf : Partrec' f\\nhg : Vec g\\nv : Vector \u2115 n\\n\u22a2 (mOfFn fun i => \u2191(some ((g v).get i))) >>= f = f (g v)\",\n   \"endPos\": {\"line\": 340, \"column\": 39}},\n  {\"tactic\": \"simpa using hf.comp' (Partrec'.cons hg Partrec'.nil)\",\n   \"proofState\": 146,\n   \"pos\": {\"line\": 345, \"column\": 2},\n   \"goals\":\n   \"n : \u2115 f : \u2115 \u2192. \u2115 g : Vector \u2115 n \u2192 \u2115 hf : Partrec' fun v => f v.head hg : Partrec' \u2191g \u22a2 Partrec' fun v => f (g v)\",\n   \"endPos\": {\"line\": 345, \"column\": 54}},\n  {\"tactic\":\n   \"simp only [Nat.rfindOpt, exists_prop, tsub_eq_zero_iff_le, PFun.coe_val, Part.mem_bind_iff, Part.mem_some_iff,\\n  Option.mem_def, Part.mem_coe]\",\n   \"proofState\": 147,\n   \"pos\": {\"line\": 351, \"column\": 2},\n   \"goals\":\n   \"n : \u2115 f : Vector \u2115 (n + 1) \u2192 \u2115 hf : Partrec' \u2191f \u22a2 Partrec' fun v => Nat.rfindOpt fun a => ofNat (Option \u2115) (f (a ::\u1d65 v))\",\n   \"endPos\": {\"line\": 351, \"column\": 142}},\n  {\"tactic\": \"<failed to pretty print>\",\n   \"proofState\": 148,\n   \"pos\": {\"line\": 352, \"column\": 2},\n   \"goals\":\n   \"n : \u2115\\nf : Vector \u2115 (n + 1) \u2192 \u2115\\nhf : Partrec' \u2191f\\n\u22a2 Partrec' fun v =>\\n    (Nat.rfind fun n_1 => \u2191(some (ofNat (Option \u2115) (f (n_1 ::\u1d65 v))).isSome)).bind fun n_1 =>\\n      \u2191(ofNat (Option \u2115) (f (n_1 ::\u1d65 v)))\",\n   \"endPos\": {\"line\": 352, \"column\": 26}}],\n \"messages\":\n [{\"severity\": \"error\",\n   \"pos\": {\"line\": 352, \"column\": 26},\n   \"endPos\": {\"line\": 352, \"column\": 27},\n   \"data\": \"unexpected token ','; expected '\u21a6', '=>'\"}],\n \"env\": 1}\n\n\n\nPANIC at List.head! Init.Data.List.BasicAux:62:12: empty list\nuncaught exception: unknown metavariable '?[anonymous]'\n"}, {"idx": 73, "error": "repl output/thms mismatch in length\n\nlen:3\n\n{\"env\": 0}\n\n{\"theorems\":\n [{\"tactics\": [0],\n   \"start\": {\"line\": 1, \"column\": 0},\n   \"proofTree\":\n   [{\"tactic\":\n     \"simp only [evalFrom, List.foldl_append, List.foldl_cons, List.foldl_nil]\",\n     \"spawned_children\": [],\n     \"children\": []}],\n   \"messages\": [],\n   \"end\": {\"line\": 4, \"column\": 74},\n   \"decl\":\n   \"@[simp]\\ntheorem evalFrom_append_singleton (s : \u03c3) (x : List \u03b1) (a : \u03b1) :\\n    M.evalFrom s (x ++ [a]) = M.step (M.evalFrom s x) a \"},\n  {\"tactics\": [1],\n   \"start\": {\"line\": 36, \"column\": 0},\n   \"proofTree\": [{\"tactic\": \"rfl\", \"spawned_children\": [], \"children\": []}],\n   \"messages\": [],\n   \"end\": {\"line\": 36, \"column\": 92},\n   \"decl\":\n   \"theorem mem_accepts (x : List \u03b1) : x \u2208 M.accepts \u2194 M.evalFrom M.start x \u2208 M.accept \"},\n  {\"tactics\": [2, 3, 4, 5, 6, 7],\n   \"start\": {\"line\": 40, \"column\": 0},\n   \"proofTree\":\n   [{\"tactic\": \"obtain \u27e8n, m, hneq, heq\u27e9 :=\",\n     \"spawned_children\": [1],\n     \"children\": [1, 2]},\n    {\"tactic\": \"norm_num\", \"spawned_children\": [], \"children\": []},\n    {\"tactic\": \"wlog hle : (n : \u2115) \u2264 m\",\n     \"spawned_children\": [],\n     \"children\": [3, 4]},\n    {\"tactic\": \"exact this _ hlen hx _ _ hneq.symm heq.symm (le_of_not_le hle)\",\n     \"spawned_children\": [],\n     \"children\": []},\n    {\"tactic\": \"have hm : (m : \u2115) \u2264 Fintype.card \u03c3 := Fin.is_le m\",\n     \"spawned_children\": [],\n     \"children\": []}],\n   \"messages\": [0, 1, 2, 3, 4, 5, 6, 7, 8],\n   \"end\": {\"line\": 54, \"column\": 58},\n   \"decl\":\n   \"theorem evalFrom_split [Fintype \u03c3] {x : List \u03b1} {s t : \u03c3} (hlen : Fintype.card \u03c3 \u2264 x.length)\\n    (hx : M.evalFrom s x = t) :\\n    \u2203 q a b c,\\n      x = a ++ b ++ c \u2227\\n        a.length + b.length \u2264 Fintype.card \u03c3 \u2227\\n          b \u2260 [] \u2227 M.evalFrom s a = q \u2227 M.evalFrom q b = q \u2227 M.evalFrom q c = t  \"}],\n \"tactics\":\n [{\"tactic\":\n   \"simp only [evalFrom, List.foldl_append, List.foldl_cons, List.foldl_nil]\",\n   \"proofState\": 0,\n   \"pos\": {\"line\": 4, \"column\": 2},\n   \"goals\":\n   \"\u03b1 : Type u \u03c3 : Type v M : DFA \u03b1 \u03c3 s : \u03c3 x : List \u03b1 a : \u03b1 \u22a2 M.evalFrom s (x ++ [a]) = M.step (M.evalFrom s x) a\",\n   \"endPos\": {\"line\": 4, \"column\": 74}},\n  {\"tactic\": \"rfl\",\n   \"proofState\": 1,\n   \"pos\": {\"line\": 36, \"column\": 89},\n   \"goals\":\n   \"\u03b1 : Type u \u03c3 : Type v M : DFA \u03b1 \u03c3 x : List \u03b1 \u22a2 x \u2208 M.accepts \u2194 M.evalFrom M.start x \u2208 M.accept\",\n   \"endPos\": {\"line\": 36, \"column\": 92}},\n  {\"tactic\":\n   \"obtain \u27e8n, m, hneq, heq\u27e9 :=\\n  Fintype.exists_ne_map_eq_of_card_lt (fun n : Fin (Fintype.card \u03c3 + 1) => M.evalFrom s (x.take n)) (by norm_num)\",\n   \"proofState\": 2,\n   \"pos\": {\"line\": 46, \"column\": 2},\n   \"goals\":\n   \"\u03b1 : Type u\\n\u03c3 : Type v\\nM : DFA \u03b1 \u03c3\\ninst\u271d : Fintype \u03c3\\nx : List \u03b1\\ns t : \u03c3\\nhlen : Fintype.card \u03c3 \u2264 x.length\\nhx : M.evalFrom s x = t\\n\u22a2 \u2203 q a b c,\\n    x = a ++ b ++ c \u2227\\n      a.length + b.length \u2264 Fintype.card \u03c3 \u2227 b \u2260 [] \u2227 M.evalFrom s a = q \u2227 M.evalFrom q b = q \u2227 M.evalFrom q c = t\",\n   \"endPos\": {\"line\": 48, \"column\": 81}},\n  {\"tactic\": \"norm_num\",\n   \"proofState\": 3,\n   \"pos\": {\"line\": 48, \"column\": 72},\n   \"goals\":\n   \"\u03b1 : Type u\\n\u03c3 : Type v\\nM : DFA \u03b1 \u03c3\\ninst\u271d : Fintype \u03c3\\nx : List \u03b1\\ns t : \u03c3\\nhlen : Fintype.card \u03c3 \u2264 x.length\\nhx : M.evalFrom s x = t\\n\u22a2 Fintype.card \u03c3 < Fintype.card (Fin (Fintype.card \u03c3 + 1))\",\n   \"endPos\": {\"line\": 48, \"column\": 80}},\n  {\"tactic\": \"wlog hle : (n : \u2115) \u2264 m\",\n   \"proofState\": 4,\n   \"pos\": {\"line\": 49, \"column\": 2},\n   \"goals\":\n   \"case intro.intro.intro\\n\u03b1 : Type u\\n\u03c3 : Type v\\nM : DFA \u03b1 \u03c3\\ninst\u271d : Fintype \u03c3\\nx : List \u03b1\\ns t : \u03c3\\nhlen : Fintype.card \u03c3 \u2264 x.length\\nhx : M.evalFrom s x = t\\nn m : Fin (Fintype.card \u03c3 + 1)\\nhneq : n \u2260 m\\nheq : M.evalFrom s (List.take (\u2191n) x) = M.evalFrom s (List.take (\u2191m) x)\\n\u22a2 \u2203 q a b c,\\n    x = a ++ b ++ c \u2227\\n      a.length + b.length \u2264 Fintype.card \u03c3 \u2227 b \u2260 [] \u2227 M.evalFrom s a = q \u2227 M.evalFrom q b = q \u2227 M.evalFrom q c = t\",\n   \"endPos\": {\"line\": 49, \"column\": 24}},\n  {\"tactic\": \"exact this _ hlen hx _ _ hneq.symm heq.symm (le_of_not_le hle)\",\n   \"proofState\": 5,\n   \"pos\": {\"line\": 50, \"column\": 4},\n   \"goals\":\n   \"case intro.intro.intro.inr\\n\u03b1 : Type u\\n\u03c3 : Type v\\nM : DFA \u03b1 \u03c3\\ninst\u271d : Fintype \u03c3\\nx : List \u03b1\\ns t : \u03c3\\nhlen : Fintype.card \u03c3 \u2264 x.length\\nhx : M.evalFrom s x = t\\nn m : Fin (Fintype.card \u03c3 + 1)\\nhneq : n \u2260 m\\nheq : M.evalFrom s (List.take (\u2191n) x) = M.evalFrom s (List.take (\u2191m) x)\\nthis :\\n  \u2200 {\u03b1 : Type u} {\u03c3 : Type v} (M : DFA \u03b1 \u03c3) [inst : Fintype \u03c3] {x : List \u03b1} {s t : \u03c3},\\n    Fintype.card \u03c3 \u2264 x.length \u2192\\n      M.evalFrom s x = t \u2192\\n        \u2200 (n m : Fin (Fintype.card \u03c3 + 1)),\\n          n \u2260 m \u2192\\n            M.evalFrom s (List.take (\u2191n) x) = M.evalFrom s (List.take (\u2191m) x) \u2192\\n              \u2191n \u2264 \u2191m \u2192\\n                \u2203 q a b c,\\n                  x = a ++ b ++ c \u2227\\n                    a.length + b.length \u2264 Fintype.card \u03c3 \u2227\\n                      b \u2260 [] \u2227 M.evalFrom s a = q \u2227 M.evalFrom q b = q \u2227 M.evalFrom q c = t\\nhle : \u00ac\u2191n \u2264 \u2191m\\n\u22a2 \u2203 q a b c,\\n    x = a ++ b ++ c \u2227\\n      a.length + b.length \u2264 Fintype.card \u03c3 \u2227 b \u2260 [] \u2227 M.evalFrom s a = q \u2227 M.evalFrom q b = q \u2227 M.evalFrom q c = t\",\n   \"endPos\": {\"line\": 50, \"column\": 66}},\n  {\"tactic\": \"have hm : (m : \u2115) \u2264 Fintype.card \u03c3 := Fin.is_le m\",\n   \"proofState\": 6,\n   \"pos\": {\"line\": 51, \"column\": 2},\n   \"goals\":\n   \"\u03b1\u271d : Type u\\n\u03c3\u271d : Type v\\nM\u271d : DFA \u03b1\u271d \u03c3\u271d\\n\u03b1 : Type u\\n\u03c3 : Type v\\nM : DFA \u03b1 \u03c3\\ninst\u271d : Fintype \u03c3\\nx : List \u03b1\\ns t : \u03c3\\nhlen : Fintype.card \u03c3 \u2264 x.length\\nhx : M.evalFrom s x = t\\nn m : Fin (Fintype.card \u03c3 + 1)\\nhneq : n \u2260 m\\nheq : M.evalFrom s (List.take (\u2191n) x) = M.evalFrom s (List.take (\u2191m) x)\\nhle : \u2191n \u2264 \u2191m\\n\u22a2 \u2203 q a b c,\\n    x = a ++ b ++ c \u2227\\n      a.length + b.length \u2264 Fintype.card \u03c3 \u2227 b \u2260 [] \u2227 M.evalFrom s a = q \u2227 M.evalFrom q b = q \u2227 M.evalFrom q c = t\",\n   \"endPos\": {\"line\": 51, \"column\": 51}},\n  {\"tactic\": \"refine \u27e8_, _, _, _, List.take_append_drop _ _, _, _, rfl, _\u27e9\",\n   \"proofState\": 7,\n   \"pos\": {\"line\": 52, \"column\": 2},\n   \"goals\":\n   \"\u03b1\u271d : Type u\\n\u03c3\u271d : Type v\\nM\u271d : DFA \u03b1\u271d \u03c3\u271d\\n\u03b1 : Type u\\n\u03c3 : Type v\\nM : DFA \u03b1 \u03c3\\ninst\u271d : Fintype \u03c3\\nx : List \u03b1\\ns t : \u03c3\\nhlen : Fintype.card \u03c3 \u2264 x.length\\nhx : M.evalFrom s x = t\\nn m : Fin (Fintype.card \u03c3 + 1)\\nhneq : n \u2260 m\\nheq : M.evalFrom s (List.take (\u2191n) x) = M.evalFrom s (List.take (\u2191m) x)\\nhle : \u2191n \u2264 \u2191m\\nhm : \u2191m \u2264 Fintype.card \u03c3\\n\u22a2 \u2203 q a b c,\\n    x = a ++ b ++ c \u2227\\n      a.length + b.length \u2264 Fintype.card \u03c3 \u2227 b \u2260 [] \u2227 M.evalFrom s a = q \u2227 M.evalFrom q b = q \u2227 M.evalFrom q c = t\",\n   \"endPos\": {\"line\": 52, \"column\": 62}}],\n \"messages\":\n [{\"severity\": \"error\",\n   \"pos\": {\"line\": 54, \"column\": 51},\n   \"endPos\": null,\n   \"data\": \"unknown tactic\"},\n  {\"severity\": \"error\",\n   \"pos\": {\"line\": 52, \"column\": 60},\n   \"endPos\": {\"line\": 52, \"column\": 61},\n   \"data\":\n   \"don't know how to synthesize placeholder for argument 'right'\\ncontext:\\n\u03b1\u271d : Type u\\n\u03c3\u271d : Type v\\nM\u271d : DFA \u03b1\u271d \u03c3\u271d\\n\u03b1 : Type u\\n\u03c3 : Type v\\nM : DFA \u03b1 \u03c3\\ninst\u271d : Fintype \u03c3\\nx : List \u03b1\\ns t : \u03c3\\nhlen : Fintype.card \u03c3 \u2264 x.length\\nhx : M.evalFrom s x = t\\nn m : Fin (Fintype.card \u03c3 + 1)\\nhneq : n \u2260 m\\nheq : M.evalFrom s (List.take (\u2191n) x) = M.evalFrom s (List.take (\u2191m) x)\\nhle : \u2191n \u2264 \u2191m\\nhm : \u2191m \u2264 Fintype.card \u03c3\\n\u22a2 M.evalFrom (M.evalFrom s ?m.5860) ?m.5870 = M.evalFrom s ?m.5860 \u2227 M.evalFrom (M.evalFrom s ?m.5860) ?m.5880 = t\"},\n  {\"severity\": \"error\",\n   \"pos\": {\"line\": 52, \"column\": 16},\n   \"endPos\": {\"line\": 52, \"column\": 17},\n   \"data\":\n   \"don't know how to synthesize placeholder for argument 'w'\\ncontext:\\n\u03b1\u271d : Type u\\n\u03c3\u271d : Type v\\nM\u271d : DFA \u03b1\u271d \u03c3\u271d\\n\u03b1 : Type u\\n\u03c3 : Type v\\nM : DFA \u03b1 \u03c3\\ninst\u271d : Fintype \u03c3\\nx : List \u03b1\\ns t : \u03c3\\nhlen : Fintype.card \u03c3 \u2264 x.length\\nhx : M.evalFrom s x = t\\nn m : Fin (Fintype.card \u03c3 + 1)\\nhneq : n \u2260 m\\nheq : M.evalFrom s (List.take (\u2191n) x) = M.evalFrom s (List.take (\u2191m) x)\\nhle : \u2191n \u2264 \u2191m\\nhm : \u2191m \u2264 Fintype.card \u03c3\\n\u22a2 List \u03b1\"},\n  {\"severity\": \"error\",\n   \"pos\": {\"line\": 52, \"column\": 10},\n   \"endPos\": {\"line\": 52, \"column\": 11},\n   \"data\":\n   \"don't know how to synthesize placeholder for argument 'w'\\ncontext:\\n\u03b1\u271d : Type u\\n\u03c3\u271d : Type v\\nM\u271d : DFA \u03b1\u271d \u03c3\u271d\\n\u03b1 : Type u\\n\u03c3 : Type v\\nM : DFA \u03b1 \u03c3\\ninst\u271d : Fintype \u03c3\\nx : List \u03b1\\ns t : \u03c3\\nhlen : Fintype.card \u03c3 \u2264 x.length\\nhx : M.evalFrom s x = t\\nn m : Fin (Fintype.card \u03c3 + 1)\\nhneq : n \u2260 m\\nheq : M.evalFrom s (List.take (\u2191n) x) = M.evalFrom s (List.take (\u2191m) x)\\nhle : \u2191n \u2264 \u2191m\\nhm : \u2191m \u2264 Fintype.card \u03c3\\n\u22a2 \u03c3\"},\n  {\"severity\": \"error\",\n   \"pos\": {\"line\": 52, \"column\": 52},\n   \"endPos\": {\"line\": 52, \"column\": 53},\n   \"data\":\n   \"don't know how to synthesize placeholder for argument 'left'\\ncontext:\\n\u03b1\u271d : Type u\\n\u03c3\u271d : Type v\\nM\u271d : DFA \u03b1\u271d \u03c3\u271d\\n\u03b1 : Type u\\n\u03c3 : Type v\\nM : DFA \u03b1 \u03c3\\ninst\u271d : Fintype \u03c3\\nx : List \u03b1\\ns t : \u03c3\\nhlen : Fintype.card \u03c3 \u2264 x.length\\nhx : M.evalFrom s x = t\\nn m : Fin (Fintype.card \u03c3 + 1)\\nhneq : n \u2260 m\\nheq : M.evalFrom s (List.take (\u2191n) x) = M.evalFrom s (List.take (\u2191m) x)\\nhle : \u2191n \u2264 \u2191m\\nhm : \u2191m \u2264 Fintype.card \u03c3\\n\u22a2 ?m.5870 \u2260 []\"},\n  {\"severity\": \"error\",\n   \"pos\": {\"line\": 52, \"column\": 49},\n   \"endPos\": {\"line\": 52, \"column\": 50},\n   \"data\":\n   \"don't know how to synthesize placeholder for argument 'left'\\ncontext:\\n\u03b1\u271d : Type u\\n\u03c3\u271d : Type v\\nM\u271d : DFA \u03b1\u271d \u03c3\u271d\\n\u03b1 : Type u\\n\u03c3 : Type v\\nM : DFA \u03b1 \u03c3\\ninst\u271d : Fintype \u03c3\\nx : List \u03b1\\ns t : \u03c3\\nhlen : Fintype.card \u03c3 \u2264 x.length\\nhx : M.evalFrom s x = t\\nn m : Fin (Fintype.card \u03c3 + 1)\\nhneq : n \u2260 m\\nheq : M.evalFrom s (List.take (\u2191n) x) = M.evalFrom s (List.take (\u2191m) x)\\nhle : \u2191n \u2264 \u2191m\\nhm : \u2191m \u2264 Fintype.card \u03c3\\n\u22a2 ?m.5860.length + ?m.5870.length \u2264 Fintype.card \u03c3\"},\n  {\"severity\": \"error\",\n   \"pos\": {\"line\": 52, \"column\": 19},\n   \"endPos\": {\"line\": 52, \"column\": 20},\n   \"data\":\n   \"don't know how to synthesize placeholder for argument 'w'\\ncontext:\\n\u03b1\u271d : Type u\\n\u03c3\u271d : Type v\\nM\u271d : DFA \u03b1\u271d \u03c3\u271d\\n\u03b1 : Type u\\n\u03c3 : Type v\\nM : DFA \u03b1 \u03c3\\ninst\u271d : Fintype \u03c3\\nx : List \u03b1\\ns t : \u03c3\\nhlen : Fintype.card \u03c3 \u2264 x.length\\nhx : M.evalFrom s x = t\\nn m : Fin (Fintype.card \u03c3 + 1)\\nhneq : n \u2260 m\\nheq : M.evalFrom s (List.take (\u2191n) x) = M.evalFrom s (List.take (\u2191m) x)\\nhle : \u2191n \u2264 \u2191m\\nhm : \u2191m \u2264 Fintype.card \u03c3\\n\u22a2 List \u03b1\"},\n  {\"severity\": \"error\",\n   \"pos\": {\"line\": 52, \"column\": 13},\n   \"endPos\": {\"line\": 52, \"column\": 14},\n   \"data\":\n   \"don't know how to synthesize placeholder for argument 'w'\\ncontext:\\n\u03b1\u271d : Type u\\n\u03c3\u271d : Type v\\nM\u271d : DFA \u03b1\u271d \u03c3\u271d\\n\u03b1 : Type u\\n\u03c3 : Type v\\nM : DFA \u03b1 \u03c3\\ninst\u271d : Fintype \u03c3\\nx : List \u03b1\\ns t : \u03c3\\nhlen : Fintype.card \u03c3 \u2264 x.length\\nhx : M.evalFrom s x = t\\nn m : Fin (Fintype.card \u03c3 + 1)\\nhneq : n \u2260 m\\nheq : M.evalFrom s (List.take (\u2191n) x) = M.evalFrom s (List.take (\u2191m) x)\\nhle : \u2191n \u2264 \u2191m\\nhm : \u2191m \u2264 Fintype.card \u03c3\\n\u22a2 List \u03b1\"},\n  {\"severity\": \"error\",\n   \"pos\": {\"line\": 45, \"column\": 84},\n   \"endPos\": {\"line\": 54, \"column\": 58},\n   \"data\":\n   \"unsolved goals\\n\u03b1\u271d : Type u\\n\u03c3\u271d : Type v\\nM\u271d : DFA \u03b1\u271d \u03c3\u271d\\n\u03b1 : Type u\\n\u03c3 : Type v\\nM : DFA \u03b1 \u03c3\\ninst\u271d : Fintype \u03c3\\nx : List \u03b1\\ns t : \u03c3\\nhlen : Fintype.card \u03c3 \u2264 x.length\\nhx : M.evalFrom s x = t\\nn m : Fin (Fintype.card \u03c3 + 1)\\nhneq : n \u2260 m\\nheq : M.evalFrom s (List.take (\u2191n) x) = M.evalFrom s (List.take (\u2191m) x)\\nhle : \u2191n \u2264 \u2191m\\nhm : \u2191m \u2264 Fintype.card \u03c3\\n\u22a2 \u2203 q a b c,\\n    x = a ++ b ++ c \u2227\\n      a.length + b.length \u2264 Fintype.card \u03c3 \u2227 b \u2260 [] \u2227 M.evalFrom s a = q \u2227 M.evalFrom q b = q \u2227 M.evalFrom q c = t\"}],\n \"env\": 1}\n\n{\"theorems\":\n [{\"tactics\": [0],\n   \"start\": {\"line\": 1, \"column\": 0},\n   \"proofTree\":\n   [{\"tactic\":\n     \"simp only [evalFrom, List.foldl_append, List.foldl_cons, List.foldl_nil]\",\n     \"spawned_children\": [],\n     \"children\": []}],\n   \"messages\": [],\n   \"end\": {\"line\": 4, \"column\": 74},\n   \"decl\":\n   \"@[simp]\\ntheorem evalFrom_append_singleton (s : \u03c3) (x : List \u03b1) (a : \u03b1) :\\n    M.evalFrom s (x ++ [a]) = M.step (M.evalFrom s x) a \"},\n  {\"tactics\": [1],\n   \"start\": {\"line\": 36, \"column\": 0},\n   \"proofTree\": [{\"tactic\": \"rfl\", \"spawned_children\": [], \"children\": []}],\n   \"messages\": [],\n   \"end\": {\"line\": 36, \"column\": 92},\n   \"decl\":\n   \"theorem mem_accepts (x : List \u03b1) : x \u2208 M.accepts \u2194 M.evalFrom M.start x \u2208 M.accept \"},\n  {\"tactics\":\n   [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21],\n   \"start\": {\"line\": 40, \"column\": 0},\n   \"proofTree\":\n   [{\"tactic\": \"obtain \u27e8n, m, hneq, heq\u27e9 :=\",\n     \"spawned_children\": [1],\n     \"children\": [1, 2]},\n    {\"tactic\": \"norm_num\", \"spawned_children\": [], \"children\": []},\n    {\"tactic\": \"wlog hle : (n : \u2115) \u2264 m\",\n     \"spawned_children\": [],\n     \"children\": [3]},\n    {\"tactic\": \"have hm : (m : \u2115) \u2264 Fintype.card \u03c3 := Fin.is_le m\",\n     \"spawned_children\": [],\n     \"children\": [4]},\n    {\"tactic\":\n     \"refine \u27e8M.evalFrom s ((x.take m).take n), (x.take m).take n, (x.take m).drop n, x.drop m, ?_, ?_, ?_, by rfl, ?_\u27e9\",\n     \"spawned_children\": [5],\n     \"children\": [5, 6, 9, 14, 23]},\n    {\"tactic\": \"rfl\", \"spawned_children\": [], \"children\": []},\n    {\"tactic\": \"rw [List.take_append_drop]\",\n     \"spawned_children\": [],\n     \"children\": [7]},\n    {\"tactic\": \"rw [List.take_append_drop]\",\n     \"spawned_children\": [],\n     \"children\": [8]},\n    {\"tactic\": \"rw [rfl]\", \"spawned_children\": [], \"children\": []},\n    {\"tactic\": \"simp only [List.length_drop, List.length_take]\",\n     \"spawned_children\": [],\n     \"children\": [10]},\n    {\"tactic\": \"rw [min_eq_left (hm.trans hlen)]\",\n     \"spawned_children\": [],\n     \"children\": [11]},\n    {\"tactic\": \"rw [min_eq_left hle]\",\n     \"spawned_children\": [],\n     \"children\": [12]},\n    {\"tactic\": \"rw [add_tsub_cancel_of_le hle]\",\n     \"spawned_children\": [],\n     \"children\": [13]},\n    {\"tactic\": \"exact hm\", \"spawned_children\": [], \"children\": []},\n    {\"tactic\": \"intro h\", \"spawned_children\": [], \"children\": [15]},\n    {\"tactic\": \"have hlen' := congr_arg List.length h\",\n     \"spawned_children\": [],\n     \"children\": [16]},\n    {\"tactic\":\n     \"simp only [List.length_drop, List.length, List.length_take] at hlen'\",\n     \"spawned_children\": [],\n     \"children\": [17]},\n    {\"tactic\": \"rw [min_eq_left]\",\n     \"spawned_children\": [],\n     \"children\": [18, 22]},\n    {\"tactic\": \"rw [tsub_eq_zero_iff_le]\",\n     \"spawned_children\": [],\n     \"children\": [19]},\n    {\"tactic\": \"apply hneq\", \"spawned_children\": [], \"children\": [20]},\n    {\"tactic\": \"apply le_antisymm\", \"spawned_children\": [], \"children\": [21]},\n    {\"tactic\": \"assumption'\", \"spawned_children\": [], \"children\": []},\n    {\"tactic\": \"\u00b7 exact le_trans hlen (List.length_take_le _ _)\",\n     \"spawned_children\": [],\n     \"children\": []},\n    {\"tactic\":\n     \"have hq : M.evalFrom (M.evalFrom s ((x.take m).take n)) ((x.take m).drop n) = M.evalFrom s ((x.take m).take n)\",\n     \"spawned_children\": [],\n     \"children\": []}],\n   \"messages\": [1, 2],\n   \"end\": {\"line\": 66, \"column\": 68},\n   \"decl\":\n   \"theorem evalFrom_split [Fintype \u03c3] {x : List \u03b1} {s t : \u03c3} (hlen : Fintype.card \u03c3 \u2264 x.length)\\n    (hx : M.evalFrom s x = t) :\\n    \u2203 q a b c,\\n      x = a ++ b ++ c \u2227\\n        a.length + b.length \u2264 Fintype.card \u03c3 \u2227\\n          b \u2260 [] \u2227 M.evalFrom s a = q \u2227 M.evalFrom q b = q \u2227 M.evalFrom q c = t  \"}],\n \"tactics\":\n [{\"tactic\":\n   \"simp only [evalFrom, List.foldl_append, List.foldl_cons, List.foldl_nil]\",\n   \"proofState\": 8,\n   \"pos\": {\"line\": 4, \"column\": 2},\n   \"goals\":\n   \"\u03b1 : Type u \u03c3 : Type v M : DFA \u03b1 \u03c3 s : \u03c3 x : List \u03b1 a : \u03b1 \u22a2 M.evalFrom s (x ++ [a]) = M.step (M.evalFrom s x) a\",\n   \"endPos\": {\"line\": 4, \"column\": 74}},\n  {\"tactic\": \"rfl\",\n   \"proofState\": 9,\n   \"pos\": {\"line\": 36, \"column\": 89},\n   \"goals\":\n   \"\u03b1 : Type u \u03c3 : Type v M : DFA \u03b1 \u03c3 x : List \u03b1 \u22a2 x \u2208 M.accepts \u2194 M.evalFrom M.start x \u2208 M.accept\",\n   \"endPos\": {\"line\": 36, \"column\": 92}},\n  {\"tactic\":\n   \"obtain \u27e8n, m, hneq, heq\u27e9 :=\\n  Fintype.exists_ne_map_eq_of_card_lt (fun n : Fin (Fintype.card \u03c3 + 1) => M.evalFrom s (x.take n)) (by norm_num)\",\n   \"proofState\": 10,\n   \"pos\": {\"line\": 46, \"column\": 2},\n   \"goals\":\n   \"\u03b1 : Type u\\n\u03c3 : Type v\\nM : DFA \u03b1 \u03c3\\ninst\u271d : Fintype \u03c3\\nx : List \u03b1\\ns t : \u03c3\\nhlen : Fintype.card \u03c3 \u2264 x.length\\nhx : M.evalFrom s x = t\\n\u22a2 \u2203 q a b c,\\n    x = a ++ b ++ c \u2227\\n      a.length + b.length \u2264 Fintype.card \u03c3 \u2227 b \u2260 [] \u2227 M.evalFrom s a = q \u2227 M.evalFrom q b = q \u2227 M.evalFrom q c = t\",\n   \"endPos\": {\"line\": 48, \"column\": 81}},\n  {\"tactic\": \"norm_num\",\n   \"proofState\": 11,\n   \"pos\": {\"line\": 48, \"column\": 72},\n   \"goals\":\n   \"\u03b1 : Type u\\n\u03c3 : Type v\\nM : DFA \u03b1 \u03c3\\ninst\u271d : Fintype \u03c3\\nx : List \u03b1\\ns t : \u03c3\\nhlen : Fintype.card \u03c3 \u2264 x.length\\nhx : M.evalFrom s x = t\\n\u22a2 Fintype.card \u03c3 < Fintype.card (Fin (Fintype.card \u03c3 + 1))\",\n   \"endPos\": {\"line\": 48, \"column\": 80}},\n  {\"tactic\": \"wlog hle : (n : \u2115) \u2264 m\",\n   \"proofState\": 12,\n   \"pos\": {\"line\": 49, \"column\": 2},\n   \"goals\":\n   \"case intro.intro.intro\\n\u03b1 : Type u\\n\u03c3 : Type v\\nM : DFA \u03b1 \u03c3\\ninst\u271d : Fintype \u03c3\\nx : List \u03b1\\ns t : \u03c3\\nhlen : Fintype.card \u03c3 \u2264 x.length\\nhx : M.evalFrom s x = t\\nn m : Fin (Fintype.card \u03c3 + 1)\\nhneq : n \u2260 m\\nheq : M.evalFrom s (List.take (\u2191n) x) = M.evalFrom s (List.take (\u2191m) x)\\n\u22a2 \u2203 q a b c,\\n    x = a ++ b ++ c \u2227\\n      a.length + b.length \u2264 Fintype.card \u03c3 \u2227 b \u2260 [] \u2227 M.evalFrom s a = q \u2227 M.evalFrom q b = q \u2227 M.evalFrom q c = t\",\n   \"endPos\": {\"line\": 49, \"column\": 24}},\n  {\"tactic\": \"have hm : (m : \u2115) \u2264 Fintype.card \u03c3 := Fin.is_le m\",\n   \"proofState\": 13,\n   \"pos\": {\"line\": 50, \"column\": 2},\n   \"goals\":\n   \"case intro.intro.intro.inr\\n\u03b1 : Type u\\n\u03c3 : Type v\\nM : DFA \u03b1 \u03c3\\ninst\u271d : Fintype \u03c3\\nx : List \u03b1\\ns t : \u03c3\\nhlen : Fintype.card \u03c3 \u2264 x.length\\nhx : M.evalFrom s x = t\\nn m : Fin (Fintype.card \u03c3 + 1)\\nhneq : n \u2260 m\\nheq : M.evalFrom s (List.take (\u2191n) x) = M.evalFrom s (List.take (\u2191m) x)\\nthis :\\n  \u2200 {\u03b1 : Type u} {\u03c3 : Type v} (M : DFA \u03b1 \u03c3) [inst : Fintype \u03c3] {x : List \u03b1} {s t : \u03c3},\\n    Fintype.card \u03c3 \u2264 x.length \u2192\\n      M.evalFrom s x = t \u2192\\n        \u2200 (n m : Fin (Fintype.card \u03c3 + 1)),\\n          n \u2260 m \u2192\\n            M.evalFrom s (List.take (\u2191n) x) = M.evalFrom s (List.take (\u2191m) x) \u2192\\n              \u2191n \u2264 \u2191m \u2192\\n                \u2203 q a b c,\\n                  x = a ++ b ++ c \u2227\\n                    a.length + b.length \u2264 Fintype.card \u03c3 \u2227\\n                      b \u2260 [] \u2227 M.evalFrom s a = q \u2227 M.evalFrom q b = q \u2227 M.evalFrom q c = t\\nhle : \u00ac\u2191n \u2264 \u2191m\\n\u22a2 \u2203 q a b c,\\n    x = a ++ b ++ c \u2227\\n      a.length + b.length \u2264 Fintype.card \u03c3 \u2227 b \u2260 [] \u2227 M.evalFrom s a = q \u2227 M.evalFrom q b = q \u2227 M.evalFrom q c = t\\n\u03b1\u271d : Type u\\n\u03c3\u271d : Type v\\nM\u271d : DFA \u03b1\u271d \u03c3\u271d\\n\u03b1 : Type u\\n\u03c3 : Type v\\nM : DFA \u03b1 \u03c3\\ninst\u271d : Fintype \u03c3\\nx : List \u03b1\\ns t : \u03c3\\nhlen : Fintype.card \u03c3 \u2264 x.length\\nhx : M.evalFrom s x = t\\nn m : Fin (Fintype.card \u03c3 + 1)\\nhneq : n \u2260 m\\nheq : M.evalFrom s (List.take (\u2191n) x) = M.evalFrom s (List.take (\u2191m) x)\\nhle : \u2191n \u2264 \u2191m\\n\u22a2 \u2203 q a b c,\\n    x = a ++ b ++ c \u2227\\n      a.length + b.length \u2264 Fintype.card \u03c3 \u2227 b \u2260 [] \u2227 M.evalFrom s a = q \u2227 M.evalFrom q b = q \u2227 M.evalFrom q c = t\",\n   \"endPos\": {\"line\": 50, \"column\": 51}},\n  {\"tactic\":\n   \"refine \u27e8M.evalFrom s ((x.take m).take n), (x.take m).take n, (x.take m).drop n, x.drop m, ?_, ?_, ?_, by rfl, ?_\u27e9\",\n   \"proofState\": 14,\n   \"pos\": {\"line\": 51, \"column\": 2},\n   \"goals\":\n   \"case intro.intro.intro.inr\\n\u03b1 : Type u\\n\u03c3 : Type v\\nM : DFA \u03b1 \u03c3\\ninst\u271d : Fintype \u03c3\\nx : List \u03b1\\ns t : \u03c3\\nhlen : Fintype.card \u03c3 \u2264 x.length\\nhx : M.evalFrom s x = t\\nn m : Fin (Fintype.card \u03c3 + 1)\\nhneq : n \u2260 m\\nheq : M.evalFrom s (List.take (\u2191n) x) = M.evalFrom s (List.take (\u2191m) x)\\nthis :\\n  \u2200 {\u03b1 : Type u} {\u03c3 : Type v} (M : DFA \u03b1 \u03c3) [inst : Fintype \u03c3] {x : List \u03b1} {s t : \u03c3},\\n    Fintype.card \u03c3 \u2264 x.length \u2192\\n      M.evalFrom s x = t \u2192\\n        \u2200 (n m : Fin (Fintype.card \u03c3 + 1)),\\n          n \u2260 m \u2192\\n            M.evalFrom s (List.take (\u2191n) x) = M.evalFrom s (List.take (\u2191m) x) \u2192\\n              \u2191n \u2264 \u2191m \u2192\\n                \u2203 q a b c,\\n                  x = a ++ b ++ c \u2227\\n                    a.length + b.length \u2264 Fintype.card \u03c3 \u2227\\n                      b \u2260 [] \u2227 M.evalFrom s a = q \u2227 M.evalFrom q b = q \u2227 M.evalFrom q c = t\\nhle : \u00ac\u2191n \u2264 \u2191m\\nhm : \u2191m \u2264 Fintype.card \u03c3\\n\u22a2 \u2203 q a b c,\\n    x = a ++ b ++ c \u2227\\n      a.length + b.length \u2264 Fintype.card \u03c3 \u2227 b \u2260 [] \u2227 M.evalFrom s a = q \u2227 M.evalFrom q b = q \u2227 M.evalFrom q c = t\\n\u03b1\u271d : Type u\\n\u03c3\u271d : Type v\\nM\u271d : DFA \u03b1\u271d \u03c3\u271d\\n\u03b1 : Type u\\n\u03c3 : Type v\\nM : DFA \u03b1 \u03c3\\ninst\u271d : Fintype \u03c3\\nx : List \u03b1\\ns t : \u03c3\\nhlen : Fintype.card \u03c3 \u2264 x.length\\nhx : M.evalFrom s x = t\\nn m : Fin (Fintype.card \u03c3 + 1)\\nhneq : n \u2260 m\\nheq : M.evalFrom s (List.take (\u2191n) x) = M.evalFrom s (List.take (\u2191m) x)\\nhle : \u2191n \u2264 \u2191m\\n\u22a2 \u2203 q a b c,\\n    x = a ++ b ++ c \u2227\\n      a.length + b.length \u2264 Fintype.card \u03c3 \u2227 b \u2260 [] \u2227 M.evalFrom s a = q \u2227 M.evalFrom q b = q \u2227 M.evalFrom q c = t\",\n   \"endPos\": {\"line\": 51, \"column\": 115}},\n  {\"tactic\": \"rfl\",\n   \"proofState\": 15,\n   \"pos\": {\"line\": 51, \"column\": 107},\n   \"goals\":\n   \"\u03b1 : Type u\\n\u03c3 : Type v\\nM : DFA \u03b1 \u03c3\\ninst\u271d : Fintype \u03c3\\nx : List \u03b1\\ns t : \u03c3\\nhlen : Fintype.card \u03c3 \u2264 x.length\\nhx : M.evalFrom s x = t\\nn m : Fin (Fintype.card \u03c3 + 1)\\nhneq : n \u2260 m\\nheq : M.evalFrom s (List.take (\u2191n) x) = M.evalFrom s (List.take (\u2191m) x)\\nthis :\\n  \u2200 {\u03b1 : Type u} {\u03c3 : Type v} (M : DFA \u03b1 \u03c3) [inst : Fintype \u03c3] {x : List \u03b1} {s t : \u03c3},\\n    Fintype.card \u03c3 \u2264 x.length \u2192\\n      M.evalFrom s x = t \u2192\\n        \u2200 (n m : Fin (Fintype.card \u03c3 + 1)),\\n          n \u2260 m \u2192\\n            M.evalFrom s (List.take (\u2191n) x) = M.evalFrom s (List.take (\u2191m) x) \u2192\\n              \u2191n \u2264 \u2191m \u2192\\n                \u2203 q a b c,\\n                  x = a ++ b ++ c \u2227\\n                    a.length + b.length \u2264 Fintype.card \u03c3 \u2227\\n                      b \u2260 [] \u2227 M.evalFrom s a = q \u2227 M.evalFrom q b = q \u2227 M.evalFrom q c = t\\nhle : \u00ac\u2191n \u2264 \u2191m\\nhm : \u2191m \u2264 Fintype.card \u03c3\\n\u22a2 M.evalFrom s (List.take (\u2191n) (List.take (\u2191m) x)) = M.evalFrom s (List.take (\u2191n) (List.take (\u2191m) x))\",\n   \"endPos\": {\"line\": 51, \"column\": 110}},\n  {\"tactic\": \"rw [List.take_append_drop, List.take_append_drop]\",\n   \"proofState\": 16,\n   \"pos\": {\"line\": 52, \"column\": 4},\n   \"goals\":\n   \"case intro.intro.intro.inr.refine_1\\n\u03b1 : Type u\\n\u03c3 : Type v\\nM : DFA \u03b1 \u03c3\\ninst\u271d : Fintype \u03c3\\nx : List \u03b1\\ns t : \u03c3\\nhlen : Fintype.card \u03c3 \u2264 x.length\\nhx : M.evalFrom s x = t\\nn m : Fin (Fintype.card \u03c3 + 1)\\nhneq : n \u2260 m\\nheq : M.evalFrom s (List.take (\u2191n) x) = M.evalFrom s (List.take (\u2191m) x)\\nthis :\\n  \u2200 {\u03b1 : Type u} {\u03c3 : Type v} (M : DFA \u03b1 \u03c3) [inst : Fintype \u03c3] {x : List \u03b1} {s t : \u03c3},\\n    Fintype.card \u03c3 \u2264 x.length \u2192\\n      M.evalFrom s x = t \u2192\\n        \u2200 (n m : Fin (Fintype.card \u03c3 + 1)),\\n          n \u2260 m \u2192\\n            M.evalFrom s (List.take (\u2191n) x) = M.evalFrom s (List.take (\u2191m) x) \u2192\\n              \u2191n \u2264 \u2191m \u2192\\n                \u2203 q a b c,\\n                  x = a ++ b ++ c \u2227\\n                    a.length + b.length \u2264 Fintype.card \u03c3 \u2227\\n                      b \u2260 [] \u2227 M.evalFrom s a = q \u2227 M.evalFrom q b = q \u2227 M.evalFrom q c = t\\nhle : \u00ac\u2191n \u2264 \u2191m\\nhm : \u2191m \u2264 Fintype.card \u03c3\\n\u22a2 x = List.take (\u2191n) (List.take (\u2191m) x) ++ List.drop (\u2191n) (List.take (\u2191m) x) ++ List.drop (\u2191m) x\",\n   \"endPos\": {\"line\": 52, \"column\": 53}},\n  {\"tactic\": \"simp only [List.length_drop, List.length_take]\",\n   \"proofState\": 17,\n   \"pos\": {\"line\": 53, \"column\": 4},\n   \"goals\":\n   \"case intro.intro.intro.inr.refine_2\\n\u03b1 : Type u\\n\u03c3 : Type v\\nM : DFA \u03b1 \u03c3\\ninst\u271d : Fintype \u03c3\\nx : List \u03b1\\ns t : \u03c3\\nhlen : Fintype.card \u03c3 \u2264 x.length\\nhx : M.evalFrom s x = t\\nn m : Fin (Fintype.card \u03c3 + 1)\\nhneq : n \u2260 m\\nheq : M.evalFrom s (List.take (\u2191n) x) = M.evalFrom s (List.take (\u2191m) x)\\nthis :\\n  \u2200 {\u03b1 : Type u} {\u03c3 : Type v} (M : DFA \u03b1 \u03c3) [inst : Fintype \u03c3] {x : List \u03b1} {s t : \u03c3},\\n    Fintype.card \u03c3 \u2264 x.length \u2192\\n      M.evalFrom s x = t \u2192\\n        \u2200 (n m : Fin (Fintype.card \u03c3 + 1)),\\n          n \u2260 m \u2192\\n            M.evalFrom s (List.take (\u2191n) x) = M.evalFrom s (List.take (\u2191m) x) \u2192\\n              \u2191n \u2264 \u2191m \u2192\\n                \u2203 q a b c,\\n                  x = a ++ b ++ c \u2227\\n                    a.length + b.length \u2264 Fintype.card \u03c3 \u2227\\n                      b \u2260 [] \u2227 M.evalFrom s a = q \u2227 M.evalFrom q b = q \u2227 M.evalFrom q c = t\\nhle : \u00ac\u2191n \u2264 \u2191m\\nhm : \u2191m \u2264 Fintype.card \u03c3\\n\u22a2 (List.take (\u2191n) (List.take (\u2191m) x)).length + (List.drop (\u2191n) (List.take (\u2191m) x)).length \u2264 Fintype.card \u03c3\",\n   \"endPos\": {\"line\": 53, \"column\": 50}},\n  {\"tactic\":\n   \"rw [min_eq_left (hm.trans hlen), min_eq_left hle, add_tsub_cancel_of_le hle]\",\n   \"proofState\": 18,\n   \"pos\": {\"line\": 54, \"column\": 4},\n   \"goals\":\n   \"case intro.intro.intro.inr.refine_2\\n\u03b1 : Type u\\n\u03c3 : Type v\\nM : DFA \u03b1 \u03c3\\ninst\u271d : Fintype \u03c3\\nx : List \u03b1\\ns t : \u03c3\\nhlen : Fintype.card \u03c3 \u2264 x.length\\nhx : M.evalFrom s x = t\\nn m : Fin (Fintype.card \u03c3 + 1)\\nhneq : n \u2260 m\\nheq : M.evalFrom s (List.take (\u2191n) x) = M.evalFrom s (List.take (\u2191m) x)\\nthis :\\n  \u2200 {\u03b1 : Type u} {\u03c3 : Type v} (M : DFA \u03b1 \u03c3) [inst : Fintype \u03c3] {x : List \u03b1} {s t : \u03c3},\\n    Fintype.card \u03c3 \u2264 x.length \u2192\\n      M.evalFrom s x = t \u2192\\n        \u2200 (n m : Fin (Fintype.card \u03c3 + 1)),\\n          n \u2260 m \u2192\\n            M.evalFrom s (List.take (\u2191n) x) = M.evalFrom s (List.take (\u2191m) x) \u2192\\n              \u2191n \u2264 \u2191m \u2192\\n                \u2203 q a b c,\\n                  x = a ++ b ++ c \u2227\\n                    a.length + b.length \u2264 Fintype.card \u03c3 \u2227\\n                      b \u2260 [] \u2227 M.evalFrom s a = q \u2227 M.evalFrom q b = q \u2227 M.evalFrom q c = t\\nhle : \u00ac\u2191n \u2264 \u2191m\\nhm : \u2191m \u2264 Fintype.card \u03c3\\n\u22a2 min (\u2191n) (min (\u2191m) x.length) + (min (\u2191m) x.length - \u2191n) \u2264 Fintype.card \u03c3\",\n   \"endPos\": {\"line\": 54, \"column\": 80}},\n  {\"tactic\": \"exact hm\",\n   \"proofState\": 19,\n   \"pos\": {\"line\": 55, \"column\": 4},\n   \"goals\":\n   \"case intro.intro.intro.inr.refine_2\\n\u03b1 : Type u\\n\u03c3 : Type v\\nM : DFA \u03b1 \u03c3\\ninst\u271d : Fintype \u03c3\\nx : List \u03b1\\ns t : \u03c3\\nhlen : Fintype.card \u03c3 \u2264 x.length\\nhx : M.evalFrom s x = t\\nn m : Fin (Fintype.card \u03c3 + 1)\\nhneq : n \u2260 m\\nheq : M.evalFrom s (List.take (\u2191n) x) = M.evalFrom s (List.take (\u2191m) x)\\nthis :\\n  \u2200 {\u03b1 : Type u} {\u03c3 : Type v} (M : DFA \u03b1 \u03c3) [inst : Fintype \u03c3] {x : List \u03b1} {s t : \u03c3},\\n    Fintype.card \u03c3 \u2264 x.length \u2192\\n      M.evalFrom s x = t \u2192\\n        \u2200 (n m : Fin (Fintype.card \u03c3 + 1)),\\n          n \u2260 m \u2192\\n            M.evalFrom s (List.take (\u2191n) x) = M.evalFrom s (List.take (\u2191m) x) \u2192\\n              \u2191n \u2264 \u2191m \u2192\\n                \u2203 q a b c,\\n                  x = a ++ b ++ c \u2227\\n                    a.length + b.length \u2264 Fintype.card \u03c3 \u2227\\n                      b \u2260 [] \u2227 M.evalFrom s a = q \u2227 M.evalFrom q b = q \u2227 M.evalFrom q c = t\\nhle : \u00ac\u2191n \u2264 \u2191m\\nhm : \u2191m \u2264 Fintype.card \u03c3\\n\u22a2 \u2191m \u2264 Fintype.card \u03c3\",\n   \"endPos\": {\"line\": 55, \"column\": 12}},\n  {\"tactic\": \"intro h\",\n   \"proofState\": 20,\n   \"pos\": {\"line\": 56, \"column\": 4},\n   \"goals\":\n   \"case intro.intro.intro.inr.refine_3\\n\u03b1 : Type u\\n\u03c3 : Type v\\nM : DFA \u03b1 \u03c3\\ninst\u271d : Fintype \u03c3\\nx : List \u03b1\\ns t : \u03c3\\nhlen : Fintype.card \u03c3 \u2264 x.length\\nhx : M.evalFrom s x = t\\nn m : Fin (Fintype.card \u03c3 + 1)\\nhneq : n \u2260 m\\nheq : M.evalFrom s (List.take (\u2191n) x) = M.evalFrom s (List.take (\u2191m) x)\\nthis :\\n  \u2200 {\u03b1 : Type u} {\u03c3 : Type v} (M : DFA \u03b1 \u03c3) [inst : Fintype \u03c3] {x : List \u03b1} {s t : \u03c3},\\n    Fintype.card \u03c3 \u2264 x.length \u2192\\n      M.evalFrom s x = t \u2192\\n        \u2200 (n m : Fin (Fintype.card \u03c3 + 1)),\\n          n \u2260 m \u2192\\n            M.evalFrom s (List.take (\u2191n) x) = M.evalFrom s (List.take (\u2191m) x) \u2192\\n              \u2191n \u2264 \u2191m \u2192\\n                \u2203 q a b c,\\n                  x = a ++ b ++ c \u2227\\n                    a.length + b.length \u2264 Fintype.card \u03c3 \u2227\\n                      b \u2260 [] \u2227 M.evalFrom s a = q \u2227 M.evalFrom q b = q \u2227 M.evalFrom q c = t\\nhle : \u00ac\u2191n \u2264 \u2191m\\nhm : \u2191m \u2264 Fintype.card \u03c3\\n\u22a2 List.drop (\u2191n) (List.take (\u2191m) x) \u2260 []\",\n   \"endPos\": {\"line\": 56, \"column\": 11}},\n  {\"tactic\": \"have hlen' := congr_arg List.length h\",\n   \"proofState\": 21,\n   \"pos\": {\"line\": 57, \"column\": 4},\n   \"goals\":\n   \"case intro.intro.intro.inr.refine_3\\n\u03b1 : Type u\\n\u03c3 : Type v\\nM : DFA \u03b1 \u03c3\\ninst\u271d : Fintype \u03c3\\nx : List \u03b1\\ns t : \u03c3\\nhlen : Fintype.card \u03c3 \u2264 x.length\\nhx : M.evalFrom s x = t\\nn m : Fin (Fintype.card \u03c3 + 1)\\nhneq : n \u2260 m\\nheq : M.evalFrom s (List.take (\u2191n) x) = M.evalFrom s (List.take (\u2191m) x)\\nthis :\\n  \u2200 {\u03b1 : Type u} {\u03c3 : Type v} (M : DFA \u03b1 \u03c3) [inst : Fintype \u03c3] {x : List \u03b1} {s t : \u03c3},\\n    Fintype.card \u03c3 \u2264 x.length \u2192\\n      M.evalFrom s x = t \u2192\\n        \u2200 (n m : Fin (Fintype.card \u03c3 + 1)),\\n          n \u2260 m \u2192\\n            M.evalFrom s (List.take (\u2191n) x) = M.evalFrom s (List.take (\u2191m) x) \u2192\\n              \u2191n \u2264 \u2191m \u2192\\n                \u2203 q a b c,\\n                  x = a ++ b ++ c \u2227\\n                    a.length + b.length \u2264 Fintype.card \u03c3 \u2227\\n                      b \u2260 [] \u2227 M.evalFrom s a = q \u2227 M.evalFrom q b = q \u2227 M.evalFrom q c = t\\nhle : \u00ac\u2191n \u2264 \u2191m\\nhm : \u2191m \u2264 Fintype.card \u03c3\\nh : List.drop (\u2191n) (List.take (\u2191m) x) = []\\n\u22a2 False\",\n   \"endPos\": {\"line\": 57, \"column\": 41}},\n  {\"tactic\":\n   \"simp only [List.length_drop, List.length, List.length_take] at hlen'\",\n   \"proofState\": 22,\n   \"pos\": {\"line\": 58, \"column\": 4},\n   \"goals\":\n   \"case intro.intro.intro.inr.refine_3\\n\u03b1 : Type u\\n\u03c3 : Type v\\nM : DFA \u03b1 \u03c3\\ninst\u271d : Fintype \u03c3\\nx : List \u03b1\\ns t : \u03c3\\nhlen : Fintype.card \u03c3 \u2264 x.length\\nhx : M.evalFrom s x = t\\nn m : Fin (Fintype.card \u03c3 + 1)\\nhneq : n \u2260 m\\nheq : M.evalFrom s (List.take (\u2191n) x) = M.evalFrom s (List.take (\u2191m) x)\\nthis :\\n  \u2200 {\u03b1 : Type u} {\u03c3 : Type v} (M : DFA \u03b1 \u03c3) [inst : Fintype \u03c3] {x : List \u03b1} {s t : \u03c3},\\n    Fintype.card \u03c3 \u2264 x.length \u2192\\n      M.evalFrom s x = t \u2192\\n        \u2200 (n m : Fin (Fintype.card \u03c3 + 1)),\\n          n \u2260 m \u2192\\n            M.evalFrom s (List.take (\u2191n) x) = M.evalFrom s (List.take (\u2191m) x) \u2192\\n              \u2191n \u2264 \u2191m \u2192\\n                \u2203 q a b c,\\n                  x = a ++ b ++ c \u2227\\n                    a.length + b.length \u2264 Fintype.card \u03c3 \u2227\\n                      b \u2260 [] \u2227 M.evalFrom s a = q \u2227 M.evalFrom q b = q \u2227 M.evalFrom q c = t\\nhle : \u00ac\u2191n \u2264 \u2191m\\nhm : \u2191m \u2264 Fintype.card \u03c3\\nh : List.drop (\u2191n) (List.take (\u2191m) x) = []\\nhlen' : (List.drop (\u2191n) (List.take (\u2191m) x)).length = [].length\\n\u22a2 False\",\n   \"endPos\": {\"line\": 58, \"column\": 72}},\n  {\"tactic\": \"rw [min_eq_left, tsub_eq_zero_iff_le] at hlen'\",\n   \"proofState\": 23,\n   \"pos\": {\"line\": 59, \"column\": 4},\n   \"goals\":\n   \"case intro.intro.intro.inr.refine_3\\n\u03b1 : Type u\\n\u03c3 : Type v\\nM : DFA \u03b1 \u03c3\\ninst\u271d : Fintype \u03c3\\nx : List \u03b1\\ns t : \u03c3\\nhlen : Fintype.card \u03c3 \u2264 x.length\\nhx : M.evalFrom s x = t\\nn m : Fin (Fintype.card \u03c3 + 1)\\nhneq : n \u2260 m\\nheq : M.evalFrom s (List.take (\u2191n) x) = M.evalFrom s (List.take (\u2191m) x)\\nthis :\\n  \u2200 {\u03b1 : Type u} {\u03c3 : Type v} (M : DFA \u03b1 \u03c3) [inst : Fintype \u03c3] {x : List \u03b1} {s t : \u03c3},\\n    Fintype.card \u03c3 \u2264 x.length \u2192\\n      M.evalFrom s x = t \u2192\\n        \u2200 (n m : Fin (Fintype.card \u03c3 + 1)),\\n          n \u2260 m \u2192\\n            M.evalFrom s (List.take (\u2191n) x) = M.evalFrom s (List.take (\u2191m) x) \u2192\\n              \u2191n \u2264 \u2191m \u2192\\n                \u2203 q a b c,\\n                  x = a ++ b ++ c \u2227\\n                    a.length + b.length \u2264 Fintype.card \u03c3 \u2227\\n                      b \u2260 [] \u2227 M.evalFrom s a = q \u2227 M.evalFrom q b = q \u2227 M.evalFrom q c = t\\nhle : \u00ac\u2191n \u2264 \u2191m\\nhm : \u2191m \u2264 Fintype.card \u03c3\\nh : List.drop (\u2191n) (List.take (\u2191m) x) = []\\nhlen' : min (\u2191m) x.length - \u2191n = 0\\n\u22a2 False\",\n   \"endPos\": {\"line\": 59, \"column\": 50}},\n  {\"tactic\": \"apply hneq\",\n   \"proofState\": 24,\n   \"pos\": {\"line\": 60, \"column\": 6},\n   \"goals\":\n   \"case intro.intro.intro.inr.refine_3\\n\u03b1 : Type u\\n\u03c3 : Type v\\nM : DFA \u03b1 \u03c3\\ninst\u271d : Fintype \u03c3\\nx : List \u03b1\\ns t : \u03c3\\nhlen : Fintype.card \u03c3 \u2264 x.length\\nhx : M.evalFrom s x = t\\nn m : Fin (Fintype.card \u03c3 + 1)\\nhneq : n \u2260 m\\nheq : M.evalFrom s (List.take (\u2191n) x) = M.evalFrom s (List.take (\u2191m) x)\\nthis :\\n  \u2200 {\u03b1 : Type u} {\u03c3 : Type v} (M : DFA \u03b1 \u03c3) [inst : Fintype \u03c3] {x : List \u03b1} {s t : \u03c3},\\n    Fintype.card \u03c3 \u2264 x.length \u2192\\n      M.evalFrom s x = t \u2192\\n        \u2200 (n m : Fin (Fintype.card \u03c3 + 1)),\\n          n \u2260 m \u2192\\n            M.evalFrom s (List.take (\u2191n) x) = M.evalFrom s (List.take (\u2191m) x) \u2192\\n              \u2191n \u2264 \u2191m \u2192\\n                \u2203 q a b c,\\n                  x = a ++ b ++ c \u2227\\n                    a.length + b.length \u2264 Fintype.card \u03c3 \u2227\\n                      b \u2260 [] \u2227 M.evalFrom s a = q \u2227 M.evalFrom q b = q \u2227 M.evalFrom q c = t\\nhle : \u00ac\u2191n \u2264 \u2191m\\nhm : \u2191m \u2264 Fintype.card \u03c3\\nh : List.drop (\u2191n) (List.take (\u2191m) x) = []\\nhlen' : \u2191m \u2264 \u2191n\\n\u22a2 False\",\n   \"endPos\": {\"line\": 60, \"column\": 16}},\n  {\"tactic\": \"apply le_antisymm\",\n   \"proofState\": 25,\n   \"pos\": {\"line\": 61, \"column\": 6},\n   \"goals\":\n   \"case intro.intro.intro.inr.refine_3\\n\u03b1 : Type u\\n\u03c3 : Type v\\nM : DFA \u03b1 \u03c3\\ninst\u271d : Fintype \u03c3\\nx : List \u03b1\\ns t : \u03c3\\nhlen : Fintype.card \u03c3 \u2264 x.length\\nhx : M.evalFrom s x = t\\nn m : Fin (Fintype.card \u03c3 + 1)\\nhneq : n \u2260 m\\nheq : M.evalFrom s (List.take (\u2191n) x) = M.evalFrom s (List.take (\u2191m) x)\\nthis :\\n  \u2200 {\u03b1 : Type u} {\u03c3 : Type v} (M : DFA \u03b1 \u03c3) [inst : Fintype \u03c3] {x : List \u03b1} {s t : \u03c3},\\n    Fintype.card \u03c3 \u2264 x.length \u2192\\n      M.evalFrom s x = t \u2192\\n        \u2200 (n m : Fin (Fintype.card \u03c3 + 1)),\\n          n \u2260 m \u2192\\n            M.evalFrom s (List.take (\u2191n) x) = M.evalFrom s (List.take (\u2191m) x) \u2192\\n              \u2191n \u2264 \u2191m \u2192\\n                \u2203 q a b c,\\n                  x = a ++ b ++ c \u2227\\n                    a.length + b.length \u2264 Fintype.card \u03c3 \u2227\\n                      b \u2260 [] \u2227 M.evalFrom s a = q \u2227 M.evalFrom q b = q \u2227 M.evalFrom q c = t\\nhle : \u00ac\u2191n \u2264 \u2191m\\nhm : \u2191m \u2264 Fintype.card \u03c3\\nh : List.drop (\u2191n) (List.take (\u2191m) x) = []\\nhlen' : \u2191m \u2264 \u2191n\\n\u22a2 n = m\",\n   \"endPos\": {\"line\": 61, \"column\": 23}},\n  {\"tactic\": \"assumption'\",\n   \"proofState\": 26,\n   \"pos\": {\"line\": 62, \"column\": 6},\n   \"goals\":\n   \"case intro.intro.intro.inr.refine_3.a\\n\u03b1 : Type u\\n\u03c3 : Type v\\nM : DFA \u03b1 \u03c3\\ninst\u271d : Fintype \u03c3\\nx : List \u03b1\\ns t : \u03c3\\nhlen : Fintype.card \u03c3 \u2264 x.length\\nhx : M.evalFrom s x = t\\nn m : Fin (Fintype.card \u03c3 + 1)\\nhneq : n \u2260 m\\nheq : M.evalFrom s (List.take (\u2191n) x) = M.evalFrom s (List.take (\u2191m) x)\\nthis :\\n  \u2200 {\u03b1 : Type u} {\u03c3 : Type v} (M : DFA \u03b1 \u03c3) [inst : Fintype \u03c3] {x : List \u03b1} {s t : \u03c3},\\n    Fintype.card \u03c3 \u2264 x.length \u2192\\n      M.evalFrom s x = t \u2192\\n        \u2200 (n m : Fin (Fintype.card \u03c3 + 1)),\\n          n \u2260 m \u2192\\n            M.evalFrom s (List.take (\u2191n) x) = M.evalFrom s (List.take (\u2191m) x) \u2192\\n              \u2191n \u2264 \u2191m \u2192\\n                \u2203 q a b c,\\n                  x = a ++ b ++ c \u2227\\n                    a.length + b.length \u2264 Fintype.card \u03c3 \u2227\\n                      b \u2260 [] \u2227 M.evalFrom s a = q \u2227 M.evalFrom q b = q \u2227 M.evalFrom q c = t\\nhle : \u00ac\u2191n \u2264 \u2191m\\nhm : \u2191m \u2264 Fintype.card \u03c3\\nh : List.drop (\u2191n) (List.take (\u2191m) x) = []\\nhlen' : \u2191m \u2264 \u2191n\\n\u22a2 n \u2264 m\\ncase intro.intro.intro.inr.refine_3.a\\n\u03b1 : Type u\\n\u03c3 : Type v\\nM : DFA \u03b1 \u03c3\\ninst\u271d : Fintype \u03c3\\nx : List \u03b1\\ns t : \u03c3\\nhlen : Fintype.card \u03c3 \u2264 x.length\\nhx : M.evalFrom s x = t\\nn m : Fin (Fintype.card \u03c3 + 1)\\nhneq : n \u2260 m\\nheq : M.evalFrom s (List.take (\u2191n) x) = M.evalFrom s (List.take (\u2191m) x)\\nthis :\\n  \u2200 {\u03b1 : Type u} {\u03c3 : Type v} (M : DFA \u03b1 \u03c3) [inst : Fintype \u03c3] {x : List \u03b1} {s t : \u03c3},\\n    Fintype.card \u03c3 \u2264 x.length \u2192\\n      M.evalFrom s x = t \u2192\\n        \u2200 (n m : Fin (Fintype.card \u03c3 + 1)),\\n          n \u2260 m \u2192\\n            M.evalFrom s (List.take (\u2191n) x) = M.evalFrom s (List.take (\u2191m) x) \u2192\\n              \u2191n \u2264 \u2191m \u2192\\n                \u2203 q a b c,\\n                  x = a ++ b ++ c \u2227\\n                    a.length + b.length \u2264 Fintype.card \u03c3 \u2227\\n                      b \u2260 [] \u2227 M.evalFrom s a = q \u2227 M.evalFrom q b = q \u2227 M.evalFrom q c = t\\nhle : \u00ac\u2191n \u2264 \u2191m\\nhm : \u2191m \u2264 Fintype.card \u03c3\\nh : List.drop (\u2191n) (List.take (\u2191m) x) = []\\nhlen' : \u2191m \u2264 \u2191n\\n\u22a2 m \u2264 n\",\n   \"endPos\": {\"line\": 62, \"column\": 17}},\n  {\"tactic\": \"exact hm.trans hlen\",\n   \"proofState\": 27,\n   \"pos\": {\"line\": 63, \"column\": 6},\n   \"goals\":\n   \"case intro.intro.intro.inr.refine_3.a\\n\u03b1 : Type u\\n\u03c3 : Type v\\nM : DFA \u03b1 \u03c3\\ninst\u271d : Fintype \u03c3\\nx : List \u03b1\\ns t : \u03c3\\nhlen : Fintype.card \u03c3 \u2264 x.length\\nhx : M.evalFrom s x = t\\nn m : Fin (Fintype.card \u03c3 + 1)\\nhneq : n \u2260 m\\nheq : M.evalFrom s (List.take (\u2191n) x) = M.evalFrom s (List.take (\u2191m) x)\\nthis :\\n  \u2200 {\u03b1 : Type u} {\u03c3 : Type v} (M : DFA \u03b1 \u03c3) [inst : Fintype \u03c3] {x : List \u03b1} {s t : \u03c3},\\n    Fintype.card \u03c3 \u2264 x.length \u2192\\n      M.evalFrom s x = t \u2192\\n        \u2200 (n m : Fin (Fintype.card \u03c3 + 1)),\\n          n \u2260 m \u2192\\n            M.evalFrom s (List.take (\u2191n) x) = M.evalFrom s (List.take (\u2191m) x) \u2192\\n              \u2191n \u2264 \u2191m \u2192\\n                \u2203 q a b c,\\n                  x = a ++ b ++ c \u2227\\n                    a.length + b.length \u2264 Fintype.card \u03c3 \u2227\\n                      b \u2260 [] \u2227 M.evalFrom s a = q \u2227 M.evalFrom q b = q \u2227 M.evalFrom q c = t\\nhle : \u00ac\u2191n \u2264 \u2191m\\nhm : \u2191m \u2264 Fintype.card \u03c3\\nh : List.drop (\u2191n) (List.take (\u2191m) x) = []\\nhlen' : \u2191m \u2264 \u2191n\\n\u22a2 n \u2264 m\",\n   \"endPos\": {\"line\": 63, \"column\": 25}},\n  {\"tactic\": \"exact le_trans hlen (List.length_take_le _ _)\",\n   \"proofState\": 28,\n   \"pos\": {\"line\": 64, \"column\": 6},\n   \"goals\":\n   \"case intro.intro.intro.inr.refine_3\\n\u03b1 : Type u\\n\u03c3 : Type v\\nM : DFA \u03b1 \u03c3\\ninst\u271d : Fintype \u03c3\\nx : List \u03b1\\ns t : \u03c3\\nhlen : Fintype.card \u03c3 \u2264 x.length\\nhx : M.evalFrom s x = t\\nn m : Fin (Fintype.card \u03c3 + 1)\\nhneq : n \u2260 m\\nheq : M.evalFrom s (List.take (\u2191n) x) = M.evalFrom s (List.take (\u2191m) x)\\nthis :\\n  \u2200 {\u03b1 : Type u} {\u03c3 : Type v} (M : DFA \u03b1 \u03c3) [inst : Fintype \u03c3] {x : List \u03b1} {s t : \u03c3},\\n    Fintype.card \u03c3 \u2264 x.length \u2192\\n      M.evalFrom s x = t \u2192\\n        \u2200 (n m : Fin (Fintype.card \u03c3 + 1)),\\n          n \u2260 m \u2192\\n            M.evalFrom s (List.take (\u2191n) x) = M.evalFrom s (List.take (\u2191m) x) \u2192\\n              \u2191n \u2264 \u2191m \u2192\\n                \u2203 q a b c,\\n                  x = a ++ b ++ c \u2227\\n                    a.length + b.length \u2264 Fintype.card \u03c3 \u2227\\n                      b \u2260 [] \u2227 M.evalFrom s a = q \u2227 M.evalFrom q b = q \u2227 M.evalFrom q c = t\\nhle : \u00ac\u2191n \u2264 \u2191m\\nhm : \u2191m \u2264 Fintype.card \u03c3\\nh : List.drop (\u2191n) (List.take (\u2191m) x) = []\\nhlen' : min (\u2191m) x.length - \u2191n = 0\\n\u22a2 \u2191m \u2264 x.length\",\n   \"endPos\": {\"line\": 64, \"column\": 51}},\n  {\"tactic\": \"<failed to pretty print>\",\n   \"proofState\": 29,\n   \"pos\": {\"line\": 65, \"column\": 2},\n   \"goals\":\n   \"case intro.intro.intro.inr.refine_4\\n\u03b1 : Type u\\n\u03c3 : Type v\\nM : DFA \u03b1 \u03c3\\ninst\u271d : Fintype \u03c3\\nx : List \u03b1\\ns t : \u03c3\\nhlen : Fintype.card \u03c3 \u2264 x.length\\nhx : M.evalFrom s x = t\\nn m : Fin (Fintype.card \u03c3 + 1)\\nhneq : n \u2260 m\\nheq : M.evalFrom s (List.take (\u2191n) x) = M.evalFrom s (List.take (\u2191m) x)\\nthis :\\n  \u2200 {\u03b1 : Type u} {\u03c3 : Type v} (M : DFA \u03b1 \u03c3) [inst : Fintype \u03c3] {x : List \u03b1} {s t : \u03c3},\\n    Fintype.card \u03c3 \u2264 x.length \u2192\\n      M.evalFrom s x = t \u2192\\n        \u2200 (n m : Fin (Fintype.card \u03c3 + 1)),\\n          n \u2260 m \u2192\\n            M.evalFrom s (List.take (\u2191n) x) = M.evalFrom s (List.take (\u2191m) x) \u2192\\n              \u2191n \u2264 \u2191m \u2192\\n                \u2203 q a b c,\\n                  x = a ++ b ++ c \u2227\\n                    a.length + b.length \u2264 Fintype.card \u03c3 \u2227\\n                      b \u2260 [] \u2227 M.evalFrom s a = q \u2227 M.evalFrom q b = q \u2227 M.evalFrom q c = t\\nhle : \u00ac\u2191n \u2264 \u2191m\\nhm : \u2191m \u2264 Fintype.card \u03c3\\n\u22a2 M.evalFrom (M.evalFrom s (List.take (\u2191n) (List.take (\u2191m) x))) (List.drop (\u2191n) (List.take (\u2191m) x)) =\\n      M.evalFrom s (List.take (\u2191n) (List.take (\u2191m) x)) \u2227\\n    M.evalFrom (M.evalFrom s (List.take (\u2191n) (List.take (\u2191m) x))) (List.drop (\u2191m) x) = t\\n\u03b1\u271d : Type u\\n\u03c3\u271d : Type v\\nM\u271d : DFA \u03b1\u271d \u03c3\u271d\\n\u03b1 : Type u\\n\u03c3 : Type v\\nM : DFA \u03b1 \u03c3\\ninst\u271d : Fintype \u03c3\\nx : List \u03b1\\ns t : \u03c3\\nhlen : Fintype.card \u03c3 \u2264 x.length\\nhx : M.evalFrom s x = t\\nn m : Fin (Fintype.card \u03c3 + 1)\\nhneq : n \u2260 m\\nheq : M.evalFrom s (List.take (\u2191n) x) = M.evalFrom s (List.take (\u2191m) x)\\nhle : \u2191n \u2264 \u2191m\\n\u22a2 \u2203 q a b c,\\n    x = a ++ b ++ c \u2227\\n      a.length + b.length \u2264 Fintype.card \u03c3 \u2227 b \u2260 [] \u2227 M.evalFrom s a = q \u2227 M.evalFrom q b = q \u2227 M.evalFrom q c = t\",\n   \"endPos\": {\"line\": 66, \"column\": 68}}],\n \"messages\":\n [{\"severity\": \"error\",\n   \"pos\": {\"line\": 66, \"column\": 68},\n   \"endPos\": {\"line\": 67, \"column\": 5},\n   \"data\": \"unexpected identifier; expected '|'\"},\n  {\"severity\": \"error\",\n   \"pos\": {\"line\": 64, \"column\": 49},\n   \"endPos\": {\"line\": 64, \"column\": 50},\n   \"data\":\n   \"don't know how to synthesize placeholder for argument 'l'\\ncontext:\\n\u03b1 : Type u\\n\u03c3 : Type v\\nM : DFA \u03b1 \u03c3\\ninst\u271d : Fintype \u03c3\\nx : List \u03b1\\ns t : \u03c3\\nhlen : Fintype.card \u03c3 \u2264 x.length\\nhx : M.evalFrom s x = t\\nn m : Fin (Fintype.card \u03c3 + 1)\\nhneq : n \u2260 m\\nheq : M.evalFrom s (List.take (\u2191n) x) = M.evalFrom s (List.take (\u2191m) x)\\nthis :\\n  \u2200 {\u03b1 : Type u} {\u03c3 : Type v} (M : DFA \u03b1 \u03c3) [inst : Fintype \u03c3] {x : List \u03b1} {s t : \u03c3},\\n    Fintype.card \u03c3 \u2264 x.length \u2192\\n      M.evalFrom s x = t \u2192\\n        \u2200 (n m : Fin (Fintype.card \u03c3 + 1)),\\n          n \u2260 m \u2192\\n            M.evalFrom s (List.take (\u2191n) x) = M.evalFrom s (List.take (\u2191m) x) \u2192\\n              \u2191n \u2264 \u2191m \u2192\\n                \u2203 q a b c,\\n                  x = a ++ b ++ c \u2227\\n                    a.length + b.length \u2264 Fintype.card \u03c3 \u2227\\n                      b \u2260 [] \u2227 M.evalFrom s a = q \u2227 M.evalFrom q b = q \u2227 M.evalFrom q c = t\\nhle : \u00ac\u2191n \u2264 \u2191m\\nhm : \u2191m \u2264 Fintype.card \u03c3\\nh : List.drop (\u2191n) (List.take (\u2191m) x) = []\\nhlen' : min (\u2191m) x.length - \u2191n = 0\\n\u22a2 List ?m.9237\"},\n  {\"severity\": \"error\",\n   \"pos\": {\"line\": 45, \"column\": 84},\n   \"endPos\": {\"line\": 66, \"column\": 68},\n   \"data\":\n   \"unsolved goals\\ncase intro.intro.intro.inr.refine_4\\n\u03b1 : Type u\\n\u03c3 : Type v\\nM : DFA \u03b1 \u03c3\\ninst\u271d : Fintype \u03c3\\nx : List \u03b1\\ns t : \u03c3\\nhlen : Fintype.card \u03c3 \u2264 x.length\\nhx : M.evalFrom s x = t\\nn m : Fin (Fintype.card \u03c3 + 1)\\nhneq : n \u2260 m\\nheq : M.evalFrom s (List.take (\u2191n) x) = M.evalFrom s (List.take (\u2191m) x)\\nthis :\\n  \u2200 {\u03b1 : Type u} {\u03c3 : Type v} (M : DFA \u03b1 \u03c3) [inst : Fintype \u03c3] {x : List \u03b1} {s t : \u03c3},\\n    Fintype.card \u03c3 \u2264 x.length \u2192\\n      M.evalFrom s x = t \u2192\\n        \u2200 (n m : Fin (Fintype.card \u03c3 + 1)),\\n          n \u2260 m \u2192\\n            M.evalFrom s (List.take (\u2191n) x) = M.evalFrom s (List.take (\u2191m) x) \u2192\\n              \u2191n \u2264 \u2191m \u2192\\n                \u2203 q a b c,\\n                  x = a ++ b ++ c \u2227\\n                    a.length + b.length \u2264 Fintype.card \u03c3 \u2227\\n                      b \u2260 [] \u2227 M.evalFrom s a = q \u2227 M.evalFrom q b = q \u2227 M.evalFrom q c = t\\nhle : \u00ac\u2191n \u2264 \u2191m\\nhm : \u2191m \u2264 Fintype.card \u03c3\\nhq : M.evalFrom (M.evalFrom s (List.take (\u2191n) (List.take (\u2191m) x))) (List.drop (\u2191n) (List.take (\u2191m) x)) = sorryAx \u03c3 true\\n\u22a2 M.evalFrom (M.evalFrom s (List.take (\u2191n) (List.take (\u2191m) x))) (List.drop (\u2191n) (List.take (\u2191m) x)) =\\n      M.evalFrom s (List.take (\u2191n) (List.take (\u2191m) x)) \u2227\\n    M.evalFrom (M.evalFrom s (List.take (\u2191n) (List.take (\u2191m) x))) (List.drop (\u2191m) x) = t\\n\\n\u03b1\u271d : Type u\\n\u03c3\u271d : Type v\\nM\u271d : DFA \u03b1\u271d \u03c3\u271d\\n\u03b1 : Type u\\n\u03c3 : Type v\\nM : DFA \u03b1 \u03c3\\ninst\u271d : Fintype \u03c3\\nx : List \u03b1\\ns t : \u03c3\\nhlen : Fintype.card \u03c3 \u2264 x.length\\nhx : M.evalFrom s x = t\\nn m : Fin (Fintype.card \u03c3 + 1)\\nhneq : n \u2260 m\\nheq : M.evalFrom s (List.take (\u2191n) x) = M.evalFrom s (List.take (\u2191m) x)\\nhle : \u2191n \u2264 \u2191m\\n\u22a2 \u2203 q a b c,\\n    x = a ++ b ++ c \u2227\\n      a.length + b.length \u2264 Fintype.card \u03c3 \u2227 b \u2260 [] \u2227 M.evalFrom s a = q \u2227 M.evalFrom q b = q \u2227 M.evalFrom q c = t\"}],\n \"env\": 2}\n\n\n\nPANIC at List.head! Init.Data.List.BasicAux:62:12: empty list\nuncaught exception: unknown metavariable '?[anonymous]'\n"}]