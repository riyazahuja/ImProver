{"cmd": "/-\nCopyright (c) 2019 Scott Morrison. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Scott Morrison, Jakob von Raumer\n-/\nimport Mathlib.CategoryTheory.Limits.Shapes.FiniteProducts\nimport Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts\nimport Mathlib.CategoryTheory.Limits.Shapes.Kernels\n\n#align_import category_theory.limits.shapes.biproducts from \"leanprover-community/mathlib\"@\"ac3ae212f394f508df43e37aa093722fa9b65d31\"\n\n/-!\n# Biproducts and binary biproducts\n\nWe introduce the notion of (finite) biproducts and binary biproducts.\n\nThese are slightly unusual relative to the other shapes in the library,\nas they are simultaneously limits and colimits.\n(Zero objects are similar; they are \"biterminal\".)\n\nFor results about biproducts in preadditive categories see\n`CategoryTheory.Preadditive.Biproducts`.\n\nIn a category with zero morphisms, we model the (binary) biproduct of `P Q : C`\nusing a `BinaryBicone`, which has a cone point `X`,\nand morphisms `fst : X \u27f6 P`, `snd : X \u27f6 Q`, `inl : P \u27f6 X` and `inr : X \u27f6 Q`,\nsuch that `inl \u226b fst = \ud835\udfd9 P`, `inl \u226b snd = 0`, `inr \u226b fst = 0`, and `inr \u226b snd = \ud835\udfd9 Q`.\nSuch a `BinaryBicone` is a biproduct if the cone is a limit cone, and the cocone is a colimit\ncocone.\n\nFor biproducts indexed by a `Fintype J`, a `bicone` again consists of a cone point `X`\nand morphisms `\u03c0 j : X \u27f6 F j` and `\u03b9 j : F j \u27f6 X` for each `j`,\nsuch that `\u03b9 j \u226b \u03c0 j'` is the identity when `j = j'` and zero otherwise.\n\n## Notation\nAs `\u2295` is already taken for the sum of types, we introduce the notation `X \u229e Y` for\na binary biproduct. We introduce `\u2a01 f` for the indexed biproduct.\n\n## Implementation notes\n\nPrior to leanprover-community/mathlib#14046,\n`HasFiniteBiproducts` required a `DecidableEq` instance on the indexing type.\nAs this had no pay-off (everything about limits is non-constructive in mathlib),\n and occasional cost\n(constructing decidability instances appropriate for constructions involving the indexing type),\nwe made everything classical.\n-/\n\nnoncomputable section\n\nuniverse w w' v u\n\nopen CategoryTheory\n\nopen CategoryTheory.Functor\n\nopen scoped Classical\n\nnamespace CategoryTheory\n\nnamespace Limits\n\nvariable {J : Type w}\nuniverse uC' uC uD' uD\nvariable {C : Type uC} [Category.{uC'} C] [HasZeroMorphisms C]\nvariable {D : Type uD} [Category.{uD'} D] [HasZeroMorphisms D]\n\n/-- A `c : Bicone F` is:\n* an object `c.pt` and\n* morphisms `\u03c0 j : pt \u27f6 F j` and `\u03b9 j : F j \u27f6 pt` for each `j`,\n* such that `\u03b9 j \u226b \u03c0 j'` is the identity when `j = j'` and zero otherwise.\n-/\n-- @[nolint has_nonempty_instance] Porting note (#5171): removed\nstructure Bicone (F : J \u2192 C) where\n  pt : C\n  \u03c0 : \u2200 j, pt \u27f6 F j\n  \u03b9 : \u2200 j, F j \u27f6 pt\n  \u03b9_\u03c0 : \u2200 j j', \u03b9 j \u226b \u03c0 j' =\n    if h : j = j' then eqToHom (congrArg F h) else 0 := by aesop\n#align category_theory.limits.bicone CategoryTheory.Limits.Bicone\nset_option linter.uppercaseLean3 false in\n#align category_theory.limits.bicone_X CategoryTheory.Limits.Bicone.pt\n\nattribute [inherit_doc Bicone] Bicone.pt Bicone.\u03c0 Bicone.\u03b9 Bicone.\u03b9_\u03c0\n"}

{"cmd": "@[reassoc (attr := simp)]\ntheorem bicone_\u03b9_\u03c0_self {F : J \u2192 C} (B : Bicone F) (j : J) : B.\u03b9 j \u226b B.\u03c0 j = \ud835\udfd9 (F j) := by\n  simpa using B.\u03b9_\u03c0 j j\n#align category_theory.limits.bicone_\u03b9_\u03c0_self CategoryTheory.Limits.bicone_\u03b9_\u03c0_self\n\n@[reassoc (attr := simp)]\ntheorem bicone_\u03b9_\u03c0_ne {F : J \u2192 C} (B : Bicone F) {j j' : J} (h : j \u2260 j') : B.\u03b9 j \u226b B.\u03c0 j' = 0 := by\n  simpa [h] using B.\u03b9_\u03c0 j j'\n#align category_theory.limits.bicone_\u03b9_\u03c0_ne CategoryTheory.Limits.bicone_\u03b9_\u03c0_ne\n\nvariable {F : J \u2192 C}\n\n/-- A bicone morphism between two bicones for the same diagram is a morphism of the bicone points\nwhich commutes with the cone and cocone legs. -/\nstructure BiconeMorphism {F : J \u2192 C} (A B : Bicone F) where\n  /-- A morphism between the two vertex objects of the bicones -/\n  hom : A.pt \u27f6 B.pt\n  /-- The triangle consisting of the two natural transformations and `hom` commutes -/\n  w\u03c0 : \u2200 j : J, hom \u226b B.\u03c0 j = A.\u03c0 j := by aesop_cat\n  /-- The triangle consisting of the two natural transformations and `hom` commutes -/\n  w\u03b9 : \u2200 j : J, A.\u03b9 j \u226b hom = B.\u03b9 j := by aesop_cat\n\nattribute [reassoc (attr := simp)] BiconeMorphism.w\u03b9\nattribute [reassoc (attr := simp)] BiconeMorphism.w\u03c0\n\n/-- The category of bicones on a given diagram. -/\n@[simps]\ninstance Bicone.category : Category (Bicone F) where\n  Hom A B := BiconeMorphism A B\n  comp f g := { hom := f.hom \u226b g.hom }\n  id B := { hom := \ud835\udfd9 B.pt }\n\n-- Porting note: if we do not have `simps` automatically generate the lemma for simplifying\n-- the `hom` field of a category, we need to write the `ext` lemma in terms of the categorical\n-- morphism, rather than the underlying structure.\n@[ext]\ntheorem BiconeMorphism.ext {c c' : Bicone F} (f g : c \u27f6 c') (w : f.hom = g.hom) : f = g := by\n  cases f\n  cases g\n  congr\n\nnamespace Bicones\n\n/-- To give an isomorphism between cocones, it suffices to give an\n  isomorphism between their vertices which commutes with the cocone\n  maps. -/\n-- Porting note: `@[ext]` used to accept lemmas like this. Now we add an aesop rule\n@[aesop apply safe (rule_sets := [CategoryTheory]), simps]\ndef ext {c c' : Bicone F} (\u03c6 : c.pt \u2245 c'.pt)\n    (w\u03b9 : \u2200 j, c.\u03b9 j \u226b \u03c6.hom = c'.\u03b9 j := by aesop_cat)\n    (w\u03c0 : \u2200 j, \u03c6.hom \u226b c'.\u03c0 j = c.\u03c0 j := by aesop_cat) : c \u2245 c' where\n  hom := { hom := \u03c6.hom }\n  inv :=\n    { hom := \u03c6.inv\n      w\u03b9 := fun j => \u03c6.comp_inv_eq.mpr (w\u03b9 j).symm\n      w\u03c0 := fun j => \u03c6.inv_comp_eq.mpr (w\u03c0 j).symm  }\n\nvariable (F) in\n/-- A functor `G : C \u2964 D` sends bicones over `F` to bicones over `G.obj \u2218 F` functorially. -/\n@[simps]\ndef functoriality (G : C \u2964 D) [Functor.PreservesZeroMorphisms G] :\n    Bicone F \u2964 Bicone (G.obj \u2218 F) where\n  obj A :=\n    { pt := G.obj A.pt\n      \u03c0 := fun j => G.map (A.\u03c0 j)\n      \u03b9 := fun j => G.map (A.\u03b9 j)\n      \u03b9_\u03c0 := fun i j => (Functor.map_comp _ _ _).symm.trans <| by\n        rw [A.\u03b9_\u03c0]\n        aesop_cat }\n  map f :=\n    { hom := G.map f.hom\n      w\u03c0 := fun j => by simp [-BiconeMorphism.w\u03c0, \u2190 f.w\u03c0 j]\n      w\u03b9 := fun j => by simp [-BiconeMorphism.w\u03b9, \u2190 f.w\u03b9 j] }\n\nvariable (G : C \u2964 D)\n\ninstance functoriality_full [G.PreservesZeroMorphisms] [G.Full] [G.Faithful] :\n    (functoriality F G).Full where\n  map_surjective t :=\n   \u27e8{ hom := G.preimage t.hom\n      w\u03b9 := fun j => G.map_injective (by simpa using t.w\u03b9 j)\n      w\u03c0 := fun j => G.map_injective (by simpa using t.w\u03c0 j) }, by aesop_cat\u27e9\n\ninstance functoriality_faithful [G.PreservesZeroMorphisms] [G.Faithful] :\n    (functoriality F G).Faithful where\n  map_injective {_X} {_Y} f g h :=\n    BiconeMorphism.ext f g <| G.map_injective <| congr_arg BiconeMorphism.hom h\n\nend Bicones\n\nnamespace Bicone\n\nattribute [local aesop safe tactic (rule_sets := [CategoryTheory])]\n  CategoryTheory.Discrete.discreteCases\n-- Porting note: would it be okay to use this more generally?\nattribute [local aesop safe cases (rule_sets := [CategoryTheory])] Eq\n\n/-- Extract the cone from a bicone. -/\ndef toConeFunctor : Bicone F \u2964 Cone (Discrete.functor F) where\n  obj B := { pt := B.pt, \u03c0 := { app := fun j => B.\u03c0 j.as } }\n  map {X Y} F := { hom := F.hom, w := fun _ => F.w\u03c0 _ }\n\n/-- A shorthand for `toConeFunctor.obj` -/\nabbrev toCone (B : Bicone F) : Cone (Discrete.functor F) := toConeFunctor.obj B\n#align category_theory.limits.bicone.to_cone CategoryTheory.Limits.Bicone.toCone\n\n-- TODO Consider changing this API to `toFan (B : Bicone F) : Fan F`.\n\n@[simp]\ntheorem toCone_pt (B : Bicone F) : B.toCone.pt = B.pt := rfl\nset_option linter.uppercaseLean3 false in\n#align category_theory.limits.bicone.to_cone_X CategoryTheory.Limits.Bicone.toCone_pt\n\n@[simp]\ntheorem toCone_\u03c0_app (B : Bicone F) (j : Discrete J) : B.toCone.\u03c0.app j = B.\u03c0 j.as := rfl\n#align category_theory.limits.bicone.to_cone_\u03c0_app CategoryTheory.Limits.Bicone.toCone_\u03c0_app\n\ntheorem toCone_\u03c0_app_mk (B : Bicone F) (j : J) : B.toCone.\u03c0.app \u27e8j\u27e9 = B.\u03c0 j := rfl\n#align category_theory.limits.bicone.to_cone_\u03c0_app_mk CategoryTheory.Limits.Bicone.toCone_\u03c0_app_mk\n\n@[simp]\ntheorem toCone_proj (B : Bicone F) (j : J) : Fan.proj B.toCone j = B.\u03c0 j := rfl\n\n/-- Extract the cocone from a bicone. -/\ndef toCoconeFunctor : Bicone F \u2964 Cocone (Discrete.functor F) where\n  obj B := { pt := B.pt, \u03b9 := { app := fun j => B.\u03b9 j.as } }\n  map {X Y} F := { hom := F.hom, w := fun _ => F.w\u03b9 _ }\n\n/-- A shorthand for `toCoconeFunctor.obj` -/\nabbrev toCocone (B : Bicone F) : Cocone (Discrete.functor F) := toCoconeFunctor.obj B\n#align category_theory.limits.bicone.to_cocone CategoryTheory.Limits.Bicone.toCocone\n\n@[simp]\ntheorem toCocone_pt (B : Bicone F) : B.toCocone.pt = B.pt := rfl\nset_option linter.uppercaseLean3 false in\n#align category_theory.limits.bicone.to_cocone_X CategoryTheory.Limits.Bicone.toCocone_pt\n\n@[simp]\ntheorem toCocone_\u03b9_app (B : Bicone F) (j : Discrete J) : B.toCocone.\u03b9.app j = B.\u03b9 j.as := rfl\n#align category_theory.limits.bicone.to_cocone_\u03b9_app CategoryTheory.Limits.Bicone.toCocone_\u03b9_app\n\n@[simp]\ntheorem toCocone_inj (B : Bicone F) (j : J) : Cofan.inj B.toCocone j = B.\u03b9 j := rfl\n\ntheorem toCocone_\u03b9_app_mk (B : Bicone F) (j : J) : B.toCocone.\u03b9.app \u27e8j\u27e9 = B.\u03b9 j := rfl\n#align category_theory.limits.bicone.to_cocone_\u03b9_app_mk CategoryTheory.Limits.Bicone.toCocone_\u03b9_app_mk\n\n/-- We can turn any limit cone over a discrete collection of objects into a bicone. -/\n@[simps]\ndef ofLimitCone {f : J \u2192 C} {t : Cone (Discrete.functor f)} (ht : IsLimit t) : Bicone f where\n  pt := t.pt\n  \u03c0 j := t.\u03c0.app \u27e8j\u27e9\n  \u03b9 j := ht.lift (Fan.mk _ fun j' => if h : j = j' then eqToHom (congr_arg f h) else 0)\n  \u03b9_\u03c0 j j' := by simp\n#align category_theory.limits.bicone.of_limit_cone CategoryTheory.Limits.Bicone.ofLimitCone\n\ntheorem \u03b9_of_isLimit {f : J \u2192 C} {t : Bicone f} (ht : IsLimit t.toCone) (j : J) :\n    t.\u03b9 j = ht.lift (Fan.mk _ fun j' => if h : j = j' then eqToHom (congr_arg f h) else 0) :=\n  ht.hom_ext fun j' => by\n    rw [ht.fac]\n    simp [t.\u03b9_\u03c0]\n#align category_theory.limits.bicone.\u03b9_of_is_limit CategoryTheory.Limits.Bicone.\u03b9_of_isLimit\n\n/-- We can turn any colimit cocone over a discrete collection of objects into a bicone. -/\n@[simps]\ndef ofColimitCocone {f : J \u2192 C} {t : Cocone (Discrete.functor f)} (ht : IsColimit t) :\n    Bicone f where\n  pt := t.pt\n  \u03c0 j := ht.desc (Cofan.mk _ fun j' => if h : j' = j then eqToHom (congr_arg f h) else 0)\n  \u03b9 j := t.\u03b9.app \u27e8j\u27e9\n  \u03b9_\u03c0 j j' := by simp\n#align category_theory.limits.bicone.of_colimit_cocone CategoryTheory.Limits.Bicone.ofColimitCocone\n\ntheorem \u03c0_of_isColimit {f : J \u2192 C} {t : Bicone f} (ht : IsColimit t.toCocone) (j : J) :\n    t.\u03c0 j = ht.desc (Cofan.mk _ fun j' => if h : j' = j then eqToHom (congr_arg f h) else 0) :=\n  ht.hom_ext fun j' => by\n    rw [ht.fac]\n    simp [t.\u03b9_\u03c0]\n#align category_theory.limits.bicone.\u03c0_of_is_colimit CategoryTheory.Limits.Bicone.\u03c0_of_isColimit\n\n/-- Structure witnessing that a bicone is both a limit cone and a colimit cocone. -/\n-- @[nolint has_nonempty_instance] Porting note (#5171): removed\nstructure IsBilimit {F : J \u2192 C} (B : Bicone F) where\n  isLimit : IsLimit B.toCone\n  isColimit : IsColimit B.toCocone\n#align category_theory.limits.bicone.is_bilimit CategoryTheory.Limits.Bicone.IsBilimit\n#align category_theory.limits.bicone.is_bilimit.is_limit CategoryTheory.Limits.Bicone.IsBilimit.isLimit\n#align category_theory.limits.bicone.is_bilimit.is_colimit CategoryTheory.Limits.Bicone.IsBilimit.isColimit\n\n\nattribute [inherit_doc IsBilimit] IsBilimit.isLimit IsBilimit.isColimit\n\n-- Porting note (#10618): simp can prove this, linter doesn't notice it is removed\nattribute [-simp, nolint simpNF] IsBilimit.mk.injEq\n\nattribute [local ext] Bicone.IsBilimit\n\ninstance subsingleton_isBilimit {f : J \u2192 C} {c : Bicone f} : Subsingleton c.IsBilimit :=\n  \u27e8fun _ _ => Bicone.IsBilimit.ext _ _ (Subsingleton.elim _ _) (Subsingleton.elim _ _)\u27e9\n#align category_theory.limits.bicone.subsingleton_is_bilimit CategoryTheory.Limits.Bicone.subsingleton_isBilimit\n\nsection Whisker\n\nvariable {K : Type w'}\n\n/-- Whisker a bicone with an equivalence between the indexing types. -/\n@[simps]\ndef whisker {f : J \u2192 C} (c : Bicone f) (g : K \u2243 J) : Bicone (f \u2218 g) where\n  pt := c.pt\n  \u03c0 k := c.\u03c0 (g k)\n  \u03b9 k := c.\u03b9 (g k)\n  \u03b9_\u03c0 k k' := by\n    simp only [c.\u03b9_\u03c0]\n    split_ifs with h h' h' <;> simp [Equiv.apply_eq_iff_eq g] at h h' <;> tauto\n#align category_theory.limits.bicone.whisker CategoryTheory.Limits.Bicone.whisker\n\n/-- Taking the cone of a whiskered bicone results in a cone isomorphic to one gained\nby whiskering the cone and postcomposing with a suitable isomorphism. -/\ndef whiskerToCone {f : J \u2192 C} (c : Bicone f) (g : K \u2243 J) :\n    (c.whisker g).toCone \u2245\n      (Cones.postcompose (Discrete.functorComp f g).inv).obj\n        (c.toCone.whisker (Discrete.functor (Discrete.mk \u2218 g))) :=\n  Cones.ext (Iso.refl _) (by aesop_cat)\n#align category_theory.limits.bicone.whisker_to_cone CategoryTheory.Limits.Bicone.whiskerToCone\n\n/-- Taking the cocone of a whiskered bicone results in a cone isomorphic to one gained\nby whiskering the cocone and precomposing with a suitable isomorphism. -/\ndef whiskerToCocone {f : J \u2192 C} (c : Bicone f) (g : K \u2243 J) :\n    (c.whisker g).toCocone \u2245\n      (Cocones.precompose (Discrete.functorComp f g).hom).obj\n        (c.toCocone.whisker (Discrete.functor (Discrete.mk \u2218 g))) :=\n  Cocones.ext (Iso.refl _) (by aesop_cat)\n#align category_theory.limits.bicone.whisker_to_cocone CategoryTheory.Limits.Bicone.whiskerToCocone\n\n/-- Whiskering a bicone with an equivalence between types preserves being a bilimit bicone. -/\ndef whiskerIsBilimitIff {f : J \u2192 C} (c : Bicone f) (g : K \u2243 J) :\n    (c.whisker g).IsBilimit \u2243 c.IsBilimit := by\n  refine equivOfSubsingletonOfSubsingleton (fun hc => \u27e8?_, ?_\u27e9) fun hc => \u27e8?_, ?_\u27e9\n  \u00b7 let this := IsLimit.ofIsoLimit hc.isLimit (Bicone.whiskerToCone c g)\n    let this := (IsLimit.postcomposeHomEquiv (Discrete.functorComp f g).symm _) this\n    exact IsLimit.ofWhiskerEquivalence (Discrete.equivalence g) this\n  \u00b7 let this := IsColimit.ofIsoColimit hc.isColimit (Bicone.whiskerToCocone c g)\n    let this := (IsColimit.precomposeHomEquiv (Discrete.functorComp f g) _) this\n    exact IsColimit.ofWhiskerEquivalence (Discrete.equivalence g) this\n  \u00b7 apply IsLimit.ofIsoLimit _ (Bicone.whiskerToCone c g).symm\n    apply (IsLimit.postcomposeHomEquiv (Discrete.functorComp f g).symm _).symm _\n    exact IsLimit.whiskerEquivalence hc.isLimit (Discrete.equivalence g)\n  \u00b7 apply IsColimit.ofIsoColimit _ (Bicone.whiskerToCocone c g).symm\n    apply (IsColimit.precomposeHomEquiv (Discrete.functorComp f g) _).symm _\n    exact IsColimit.whiskerEquivalence hc.isColimit (Discrete.equivalence g)\n#align category_theory.limits.bicone.whisker_is_bilimit_iff CategoryTheory.Limits.Bicone.whiskerIsBilimitIff\n\nend Whisker\n\nend Bicone\n\n/-- A bicone over `F : J \u2192 C`, which is both a limit cone and a colimit cocone.\n-/\n-- @[nolint has_nonempty_instance] -- Porting note(#5171): removed; linter not ported yet\nstructure LimitBicone (F : J \u2192 C) where\n  bicone : Bicone F\n  isBilimit : bicone.IsBilimit\n#align category_theory.limits.limit_bicone CategoryTheory.Limits.LimitBicone\n#align category_theory.limits.limit_bicone.is_bilimit CategoryTheory.Limits.LimitBicone.isBilimit\n\nattribute [inherit_doc LimitBicone] LimitBicone.bicone LimitBicone.isBilimit\n\n/-- `HasBiproduct F` expresses the mere existence of a bicone which is\nsimultaneously a limit and a colimit of the diagram `F`.\n-/\nclass HasBiproduct (F : J \u2192 C) : Prop where mk' ::\n  exists_biproduct : Nonempty (LimitBicone F)\n#align category_theory.limits.has_biproduct CategoryTheory.Limits.HasBiproduct\n\nattribute [inherit_doc HasBiproduct] HasBiproduct.exists_biproduct\n\ntheorem HasBiproduct.mk {F : J \u2192 C} (d : LimitBicone F) : HasBiproduct F :=\n  \u27e8Nonempty.intro d\u27e9\n#align category_theory.limits.has_biproduct.mk CategoryTheory.Limits.HasBiproduct.mk\n\n/-- Use the axiom of choice to extract explicit `BiproductData F` from `HasBiproduct F`. -/\ndef getBiproductData (F : J \u2192 C) [HasBiproduct F] : LimitBicone F :=\n  Classical.choice HasBiproduct.exists_biproduct\n#align category_theory.limits.get_biproduct_data CategoryTheory.Limits.getBiproductData\n\n/-- A bicone for `F` which is both a limit cone and a colimit cocone. -/\ndef biproduct.bicone (F : J \u2192 C) [HasBiproduct F] : Bicone F :=\n  (getBiproductData F).bicone\n#align category_theory.limits.biproduct.bicone CategoryTheory.Limits.biproduct.bicone\n\n/-- `biproduct.bicone F` is a bilimit bicone. -/\ndef biproduct.isBilimit (F : J \u2192 C) [HasBiproduct F] : (biproduct.bicone F).IsBilimit :=\n  (getBiproductData F).isBilimit\n#align category_theory.limits.biproduct.is_bilimit CategoryTheory.Limits.biproduct.isBilimit\n\n/-- `biproduct.bicone F` is a limit cone. -/\ndef biproduct.isLimit (F : J \u2192 C) [HasBiproduct F] : IsLimit (biproduct.bicone F).toCone :=\n  (getBiproductData F).isBilimit.isLimit\n#align category_theory.limits.biproduct.is_limit CategoryTheory.Limits.biproduct.isLimit\n\n/-- `biproduct.bicone F` is a colimit cocone. -/\ndef biproduct.isColimit (F : J \u2192 C) [HasBiproduct F] : IsColimit (biproduct.bicone F).toCocone :=\n  (getBiproductData F).isBilimit.isColimit\n#align category_theory.limits.biproduct.is_colimit CategoryTheory.Limits.biproduct.isColimit\n\ninstance (priority := 100) hasProduct_of_hasBiproduct [HasBiproduct F] : HasProduct F :=\n  HasLimit.mk\n    { cone := (biproduct.bicone F).toCone\n      isLimit := biproduct.isLimit F }\n#align category_theory.limits.has_product_of_has_biproduct CategoryTheory.Limits.hasProduct_of_hasBiproduct\n\ninstance (priority := 100) hasCoproduct_of_hasBiproduct [HasBiproduct F] : HasCoproduct F :=\n  HasColimit.mk\n    { cocone := (biproduct.bicone F).toCocone\n      isColimit := biproduct.isColimit F }\n#align category_theory.limits.has_coproduct_of_has_biproduct CategoryTheory.Limits.hasCoproduct_of_hasBiproduct\n\nvariable (J C)\n\n/-- `C` has biproducts of shape `J` if we have\na limit and a colimit, with the same cone points,\nof every function `F : J \u2192 C`.\n-/\nclass HasBiproductsOfShape : Prop where\n  has_biproduct : \u2200 F : J \u2192 C, HasBiproduct F\n#align category_theory.limits.has_biproducts_of_shape CategoryTheory.Limits.HasBiproductsOfShape\n\nattribute [instance 100] HasBiproductsOfShape.has_biproduct\n\n/-- `HasFiniteBiproducts C` represents a choice of biproduct for every family of objects in `C`\nindexed by a finite type. -/\nclass HasFiniteBiproducts : Prop where\n  out : \u2200 n, HasBiproductsOfShape (Fin n) C\n#align category_theory.limits.has_finite_biproducts CategoryTheory.Limits.HasFiniteBiproducts\n\nattribute [inherit_doc HasFiniteBiproducts] HasFiniteBiproducts.out\n\nvariable {J}\n\ntheorem hasBiproductsOfShape_of_equiv {K : Type w'} [HasBiproductsOfShape K C] (e : J \u2243 K) :\n    HasBiproductsOfShape J C :=\n  \u27e8fun F =>\n    let \u27e8\u27e8h\u27e9\u27e9 := HasBiproductsOfShape.has_biproduct (F \u2218 e.symm)\n    let \u27e8c, hc\u27e9 := h\n    HasBiproduct.mk <| by\n      simpa only [(\u00b7 \u2218 \u00b7), e.symm_apply_apply] using\n        LimitBicone.mk (c.whisker e) ((c.whiskerIsBilimitIff _).2 hc)\u27e9\n#align category_theory.limits.has_biproducts_of_shape_of_equiv CategoryTheory.Limits.hasBiproductsOfShape_of_equiv\n\ninstance (priority := 100) hasBiproductsOfShape_finite [HasFiniteBiproducts C] [Finite J] :\n    HasBiproductsOfShape J C := by\n  rcases Finite.exists_equiv_fin J with \u27e8n, \u27e8e\u27e9\u27e9\n  haveI : HasBiproductsOfShape (Fin n) C := HasFiniteBiproducts.out n\n  exact hasBiproductsOfShape_of_equiv C e\n#align category_theory.limits.has_biproducts_of_shape_finite CategoryTheory.Limits.hasBiproductsOfShape_finite\n\ninstance (priority := 100) hasFiniteProducts_of_hasFiniteBiproducts [HasFiniteBiproducts C] :\n    HasFiniteProducts C where\n  out _ := \u27e8fun _ => hasLimitOfIso Discrete.natIsoFunctor.symm\u27e9\n#align category_theory.limits.has_finite_products_of_has_finite_biproducts CategoryTheory.Limits.hasFiniteProducts_of_hasFiniteBiproducts\n\ninstance (priority := 100) hasFiniteCoproducts_of_hasFiniteBiproducts [HasFiniteBiproducts C] :\n    HasFiniteCoproducts C where\n  out _ := \u27e8fun _ => hasColimitOfIso Discrete.natIsoFunctor\u27e9\n#align category_theory.limits.has_finite_coproducts_of_has_finite_biproducts CategoryTheory.Limits.hasFiniteCoproducts_of_hasFiniteBiproducts\n\nvariable {C}\n\n/-- The isomorphism between the specified limit and the specified colimit for\na functor with a bilimit.\n-/\ndef biproductIso (F : J \u2192 C) [HasBiproduct F] : Limits.piObj F \u2245 Limits.sigmaObj F :=\n  (IsLimit.conePointUniqueUpToIso (limit.isLimit _) (biproduct.isLimit F)).trans <|\n    IsColimit.coconePointUniqueUpToIso (biproduct.isColimit F) (colimit.isColimit _)\n#align category_theory.limits.biproduct_iso CategoryTheory.Limits.biproductIso\n\nend Limits\n\nnamespace Limits\n\nvariable {J : Type w} {K : Type*}\nvariable {C : Type u} [Category.{v} C] [HasZeroMorphisms C]\n\n/-- `biproduct f` computes the biproduct of a family of elements `f`. (It is defined as an\n   abbreviation for `limit (Discrete.functor f)`, so for most facts about `biproduct f`, you will\n   just use general facts about limits and colimits.) -/\nabbrev biproduct (f : J \u2192 C) [HasBiproduct f] : C :=\n  (biproduct.bicone f).pt\n#align category_theory.limits.biproduct CategoryTheory.Limits.biproduct\n\n@[inherit_doc biproduct]\nnotation \"\u2a01 \" f:20 => biproduct f\n\n/-- The projection onto a summand of a biproduct. -/\nabbrev biproduct.\u03c0 (f : J \u2192 C) [HasBiproduct f] (b : J) : \u2a01 f \u27f6 f b :=\n  (biproduct.bicone f).\u03c0 b\n#align category_theory.limits.biproduct.\u03c0 CategoryTheory.Limits.biproduct.\u03c0\n\n@[simp]\ntheorem biproduct.bicone_\u03c0 (f : J \u2192 C) [HasBiproduct f] (b : J) :\n    (biproduct.bicone f).\u03c0 b = biproduct.\u03c0 f b := rfl\n#align category_theory.limits.biproduct.bicone_\u03c0 CategoryTheory.Limits.biproduct.bicone_\u03c0\n\n/-- The inclusion into a summand of a biproduct. -/\nabbrev biproduct.\u03b9 (f : J \u2192 C) [HasBiproduct f] (b : J) : f b \u27f6 \u2a01 f :=\n  (biproduct.bicone f).\u03b9 b\n#align category_theory.limits.biproduct.\u03b9 CategoryTheory.Limits.biproduct.\u03b9\n\n@[simp]\ntheorem biproduct.bicone_\u03b9 (f : J \u2192 C) [HasBiproduct f] (b : J) :\n    (biproduct.bicone f).\u03b9 b = biproduct.\u03b9 f b := rfl\n#align category_theory.limits.biproduct.bicone_\u03b9 CategoryTheory.Limits.biproduct.bicone_\u03b9\n\n/-- Note that as this lemma has an `if` in the statement, we include a `DecidableEq` argument.\nThis means you may not be able to `simp` using this lemma unless you `open scoped Classical`. -/\n@[reassoc]\ntheorem biproduct.\u03b9_\u03c0 [DecidableEq J] (f : J \u2192 C) [HasBiproduct f] (j j' : J) :\n    biproduct.\u03b9 f j \u226b biproduct.\u03c0 f j' = if h : j = j' then eqToHom (congr_arg f h) else 0 := by\n  convert (biproduct.bicone f).\u03b9_\u03c0 j j'\n#align category_theory.limits.biproduct.\u03b9_\u03c0 CategoryTheory.Limits.biproduct.\u03b9_\u03c0\n\n@[reassoc] -- Porting note: both versions proven by simp\ntheorem biproduct.\u03b9_\u03c0_self (f : J \u2192 C) [HasBiproduct f] (j : J) :\n    biproduct.\u03b9 f j \u226b biproduct.\u03c0 f j = \ud835\udfd9 _ := by simp [biproduct.\u03b9_\u03c0]\n#align category_theory.limits.biproduct.\u03b9_\u03c0_self CategoryTheory.Limits.biproduct.\u03b9_\u03c0_self\n\n@[reassoc (attr := simp)]\ntheorem biproduct.\u03b9_\u03c0_ne (f : J \u2192 C) [HasBiproduct f] {j j' : J} (h : j \u2260 j') :\n    biproduct.\u03b9 f j \u226b biproduct.\u03c0 f j' = 0 := by simp [biproduct.\u03b9_\u03c0, h]\n#align category_theory.limits.biproduct.\u03b9_\u03c0_ne CategoryTheory.Limits.biproduct.\u03b9_\u03c0_ne\n\n-- The `simpNF` linter incorrectly identifies these as simp lemmas that could never apply.\n-- https://github.com/leanprover-community/mathlib4/issues/5049\n-- They are used by `simp` in `biproduct.whiskerEquiv` below.\n@[reassoc (attr := simp, nolint simpNF)]\ntheorem biproduct.eqToHom_comp_\u03b9 (f : J \u2192 C) [HasBiproduct f] {j j' : J} (w : j = j') :\n    eqToHom (by simp [w]) \u226b biproduct.\u03b9 f j' = biproduct.\u03b9 f j := by\n  cases w\n  simp\n\n-- The `simpNF` linter incorrectly identifies these as simp lemmas that could never apply.\n-- https://github.com/leanprover-community/mathlib4/issues/5049\n-- They are used by `simp` in `biproduct.whiskerEquiv` below.\n@[reassoc (attr := simp, nolint simpNF)]\ntheorem biproduct.\u03c0_comp_eqToHom (f : J \u2192 C) [HasBiproduct f] {j j' : J} (w : j = j') :\n    biproduct.\u03c0 f j \u226b eqToHom (by simp [w]) = biproduct.\u03c0 f j' := by\n  cases w\n  simp\n\n/-- Given a collection of maps into the summands, we obtain a map into the biproduct. -/\nabbrev biproduct.lift {f : J \u2192 C} [HasBiproduct f] {P : C} (p : \u2200 b, P \u27f6 f b) : P \u27f6 \u2a01 f :=\n  (biproduct.isLimit f).lift (Fan.mk P p)\n#align category_theory.limits.biproduct.lift CategoryTheory.Limits.biproduct.lift\n\n/-- Given a collection of maps out of the summands, we obtain a map out of the biproduct. -/\nabbrev biproduct.desc {f : J \u2192 C} [HasBiproduct f] {P : C} (p : \u2200 b, f b \u27f6 P) : \u2a01 f \u27f6 P :=\n  (biproduct.isColimit f).desc (Cofan.mk P p)\n#align category_theory.limits.biproduct.desc CategoryTheory.Limits.biproduct.desc\n\n@[reassoc (attr := simp)]\ntheorem biproduct.lift_\u03c0 {f : J \u2192 C} [HasBiproduct f] {P : C} (p : \u2200 b, P \u27f6 f b) (j : J) :\n    biproduct.lift p \u226b biproduct.\u03c0 f j = p j := (biproduct.isLimit f).fac _ \u27e8j\u27e9\n#align category_theory.limits.biproduct.lift_\u03c0 CategoryTheory.Limits.biproduct.lift_\u03c0\n\n@[reassoc (attr := simp)]\ntheorem biproduct.\u03b9_desc {f : J \u2192 C} [HasBiproduct f] {P : C} (p : \u2200 b, f b \u27f6 P) (j : J) :\n    biproduct.\u03b9 f j \u226b biproduct.desc p = p j := (biproduct.isColimit f).fac _ \u27e8j\u27e9\n#align category_theory.limits.biproduct.\u03b9_desc CategoryTheory.Limits.biproduct.\u03b9_desc\n\n/-- Given a collection of maps between corresponding summands of a pair of biproducts\nindexed by the same type, we obtain a map between the biproducts. -/\nabbrev biproduct.map {f g : J \u2192 C} [HasBiproduct f] [HasBiproduct g] (p : \u2200 b, f b \u27f6 g b) :\n    \u2a01 f \u27f6 \u2a01 g :=\n  IsLimit.map (biproduct.bicone f).toCone (biproduct.isLimit g)\n    (Discrete.natTrans (fun j => p j.as))\n#align category_theory.limits.biproduct.map CategoryTheory.Limits.biproduct.map\n\n/-- An alternative to `biproduct.map` constructed via colimits.\nThis construction only exists in order to show it is equal to `biproduct.map`. -/\nabbrev biproduct.map' {f g : J \u2192 C} [HasBiproduct f] [HasBiproduct g] (p : \u2200 b, f b \u27f6 g b) :\n    \u2a01 f \u27f6 \u2a01 g :=\n  IsColimit.map (biproduct.isColimit f) (biproduct.bicone g).toCocone\n    (Discrete.natTrans fun j => p j.as)\n#align category_theory.limits.biproduct.map' CategoryTheory.Limits.biproduct.map'\n\n-- We put this at slightly higher priority than `biproduct.hom_ext'`,\n-- to get the matrix indices in the \"right\" order.\n@[ext 1001]\ntheorem biproduct.hom_ext {f : J \u2192 C} [HasBiproduct f] {Z : C} (g h : Z \u27f6 \u2a01 f)\n    (w : \u2200 j, g \u226b biproduct.\u03c0 f j = h \u226b biproduct.\u03c0 f j) : g = h :=\n  (biproduct.isLimit f).hom_ext fun j => w j.as\n#align category_theory.limits.biproduct.hom_ext CategoryTheory.Limits.biproduct.hom_ext\n\n@[ext]\ntheorem biproduct.hom_ext' {f : J \u2192 C} [HasBiproduct f] {Z : C} (g h : \u2a01 f \u27f6 Z)\n    (w : \u2200 j, biproduct.\u03b9 f j \u226b g = biproduct.\u03b9 f j \u226b h) : g = h :=\n  (biproduct.isColimit f).hom_ext fun j => w j.as\n#align category_theory.limits.biproduct.hom_ext' CategoryTheory.Limits.biproduct.hom_ext'\n\n/-- The canonical isomorphism between the chosen biproduct and the chosen product. -/\ndef biproduct.isoProduct (f : J \u2192 C) [HasBiproduct f] : \u2a01 f \u2245 \u220f\u1d9c f :=\n  IsLimit.conePointUniqueUpToIso (biproduct.isLimit f) (limit.isLimit _)\n#align category_theory.limits.biproduct.iso_product CategoryTheory.Limits.biproduct.isoProduct\n\n@[simp]\ntheorem biproduct.isoProduct_hom {f : J \u2192 C} [HasBiproduct f] :\n    (biproduct.isoProduct f).hom = Pi.lift (biproduct.\u03c0 f) :=\n  limit.hom_ext fun j => by simp [biproduct.isoProduct]\n#align category_theory.limits.biproduct.iso_product_hom CategoryTheory.Limits.biproduct.isoProduct_hom\n\n@[simp]\ntheorem biproduct.isoProduct_inv {f : J \u2192 C} [HasBiproduct f] :\n    (biproduct.isoProduct f).inv = biproduct.lift (Pi.\u03c0 f) :=\n  biproduct.hom_ext _ _ fun j => by simp [Iso.inv_comp_eq]\n#align category_theory.limits.biproduct.iso_product_inv CategoryTheory.Limits.biproduct.isoProduct_inv\n\n/-- The canonical isomorphism between the chosen biproduct and the chosen coproduct. -/\ndef biproduct.isoCoproduct (f : J \u2192 C) [HasBiproduct f] : \u2a01 f \u2245 \u2210 f :=\n  IsColimit.coconePointUniqueUpToIso (biproduct.isColimit f) (colimit.isColimit _)\n#align category_theory.limits.biproduct.iso_coproduct CategoryTheory.Limits.biproduct.isoCoproduct\n\n@[simp]\ntheorem biproduct.isoCoproduct_inv {f : J \u2192 C} [HasBiproduct f] :\n    (biproduct.isoCoproduct f).inv = Sigma.desc (biproduct.\u03b9 f) :=\n  colimit.hom_ext fun j => by simp [biproduct.isoCoproduct]\n#align category_theory.limits.biproduct.iso_coproduct_inv CategoryTheory.Limits.biproduct.isoCoproduct_inv\n\n@[simp]\ntheorem biproduct.isoCoproduct_hom {f : J \u2192 C} [HasBiproduct f] :\n    (biproduct.isoCoproduct f).hom = biproduct.desc (Sigma.\u03b9 f) :=\n  biproduct.hom_ext' _ _ fun j => by simp [\u2190 Iso.eq_comp_inv]\n#align category_theory.limits.biproduct.iso_coproduct_hom CategoryTheory.Limits.biproduct.isoCoproduct_hom\n\n\ntheorem biproduct.map_eq_map' {f g : J \u2192 C} [HasBiproduct f] [HasBiproduct g] (p : \u2200 b, f b \u27f6 g b) :\n    biproduct.map p = biproduct.map' p  := by\n  ext j j'\n  simp_rw [biproduct.\u03b9_\u03c0_assoc, biproduct.\u03b9_\u03c0]\n  split_ifs\n  simp {contextual := tt}\n", "allTactics": true, "theorems": true, "env": 0}