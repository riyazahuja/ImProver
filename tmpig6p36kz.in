{"cmd": "/-\nCopyright (c) 2023 The Compfiles Contributors. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Hongyu Ouyang\n-/\n\nimport Mathlib.Tactic\n\nimport ProblemExtraction\n\nproblem_file { tags := [.NumberTheory] }\n\n/-!\n# USA Mathematical Olympiad 1982, Problem 4\n\nProve that there exists a positive integer k such that\nk\u2b1d2\u207f + 1 is composite for every integer n.\n-/\n\nnamespace Usa1982P4\n\nsnip begin\n"}

{"cmd": "lemma not_prime_of_dvd : \u2200 n : \u2115, n \u2265 2 \u2192 (\u2203 m, m \u2265 2 \u2227 m \u2260 n \u2227 m \u2223 n) \u2192 \u00ac Prime n := by\n  intro n hn h p\n  have ngt0 : 0 < n := by omega\n  have p := (Nat.prime_iff).mpr p\n  obtain \u27e8m, \u27e8h1, \u27e8h2, h3\u27e9\u27e9\u27e9 := h\n  apply (Nat.not_prime_iff_minFac_lt hn).mpr _ p\n  have h4 : m < n := lt_of_le_of_ne (Nat.le_of_dvd ngt0 h3) h2\n  have h5 : Nat.minFac n \u2264 m := Nat.minFac_le_of_dvd h1 h3\n  apply lt_of_le_of_lt h5 h4\n\n\nlemma some_useful_mod_lemma : \u2200 (n a b c d : \u2115),\n  n \u2261 a [MOD b] \u2192 d ^ b \u2261 1 [MOD c] \u2192 d ^ n \u2261 d ^ a [MOD c]  := by\n  intros n a b c d h1 h2\n  wlog h : n \u2264 a\n  \u00b7 rw [pow_add, pow_mul]\n    have : d ^ (a - n) \u2261 1 [MOD c] := by rwa [Nat.ModEq.comm] at \u27e8_, h2\u27e9\n    rw Nat.ModEq.symm h1, zero_add, Nat.mod_add_cancel, this\n", "allTactics": true, "theorems": true, "env": 0}

{"cmd": "lemma not_prime_of_dvd : \u2200 n : \u2115, n \u2265 2 \u2192 (\u2203 m, m \u2265 2 \u2227 m \u2260 n \u2227 m \u2223 n) \u2192 \u00ac Prime n := by\n  intro n hn h p\n  have ngt0 : 0 < n := by omega\n  have p := (Nat.prime_iff).mpr p\n  obtain \u27e8m, \u27e8h1, \u27e8h2, h3\u27e9\u27e9\u27e9 := h\n  apply (Nat.not_prime_iff_minFac_lt hn).mpr _ p\n  have h4 : m < n := lt_of_le_of_ne (Nat.le_of_dvd ngt0 h3) h2\n  have h5 : Nat.minFac n \u2264 m := Nat.minFac_le_of_dvd h1 h3\n  apply lt_of_le_of_lt h5 h4\n\n\nlemma some_useful_mod_lemma : \u2200 (n a b c d : \u2115),\n  n \u2261 a [MOD b] \u2192 d ^ b \u2261 1 [MOD c] \u2192 d ^ n \u2261 d ^ a [MOD c]  := by\n  intros n a b c d h1 h2\n  obtain h | h := Nat.le_total n a\n  rw [\u2190 Nat.ModEq.symm h1, pow_eq_mod, \u2190 pow_eq_mod, \u2190 Nat.pow_add]\n  exact h2.trans (d ^ (a - n)).modEq_of_dvd rfl\n", "allTactics": true, "theorems": true, "env": 0}

{"cmd": "lemma not_prime_of_dvd : \u2200 n : \u2115, n \u2265 2 \u2192 (\u2203 m, m \u2265 2 \u2227 m \u2260 n \u2227 m \u2223 n) \u2192 \u00ac Prime n := by\n  intro n hn h p\n  have ngt0 : 0 < n := by omega\n  have p := (Nat.prime_iff).mpr p\n  obtain \u27e8m, \u27e8h1, \u27e8h2, h3\u27e9\u27e9\u27e9 := h\n  apply (Nat.not_prime_iff_minFac_lt hn).mpr _ p\n  have h4 : m < n := lt_of_le_of_ne (Nat.le_of_dvd ngt0 h3) h2\n  have h5 : Nat.minFac n \u2264 m := Nat.minFac_le_of_dvd h1 h3\n  apply lt_of_le_of_lt h5 h4\n\n\nlemma some_useful_mod_lemma : \u2200 (n a b c d : \u2115),\n  n \u2261 a [MOD b] \u2192 d ^ b \u2261 1 [MOD c] \u2192 d ^ n \u2261 d ^ a [MOD c]  := by\n  intros n a b c d h1 h2\n  wlog h : n \u2264 a\n  \u00b7 rw [(by simp : d ^ n = 1 * d ^ n), Nat.sub_eq_iff_eq_add h] at h1\n    rw [pow_add, pow_mul, Nat.pow_mod h2.symm] at h1\n    exact Nat.ModEq.trans (Nat.ModEq.symm h1) rfl\n", "allTactics": true, "theorems": true, "env": 0}