{"cmd": "/-\nCopyright (c) 2022 Joseph Myers. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Joseph Myers\n-/\nimport Mathlib.Geometry.Euclidean.Angle.Sphere\nimport Mathlib.Geometry.Euclidean.Sphere.SecondInter\n\nimport ProblemExtraction\n\nproblem_file {\n  tags := [.Geometry]\n  importedFrom :=\n    \"https://github.com/leanprover-community/mathlib4/blob/master/Archive/Imo/Imo2019Q2.lean\"\n}\n\n/-!\n# International Mathematical Olympiad 2019, Problem 2\n\nIn triangle `ABC`, point `A\u2081` lies on side `BC` and point `B\u2081` lies on side `AC`. Let `P` and\n`Q` be points on segments `AA\u2081` and `BB\u2081`, respectively, such that `PQ` is parallel to `AB`.\nLet `P\u2081` be a point on line `PB\u2081`, such that `B\u2081` lies strictly between `P` and `P\u2081`, and\n`\u2220PP\u2081C = \u2220BAC`. Similarly, let `Q\u2081` be a point on line `QA\u2081`, such that `A\u2081` lies strictly\nbetween `Q` and `Q\u2081`, and `\u2220CQ\u2081Q = \u2220CBA`.\n\nProve that points `P`, `Q`, `P\u2081`, and `Q\u2081` are concyclic.\n-/\n\nopen Affine Affine.Simplex EuclideanGeometry FiniteDimensional\n\nopen scoped Affine EuclideanGeometry Real\n\nset_option linter.uppercaseLean3 false\n\nattribute [local instance] FiniteDimensional.of_fact_finrank_eq_two\n\nvariable (V : Type*) (Pt : Type*)\n\nvariable [NormedAddCommGroup V] [InnerProductSpace \u211d V] [MetricSpace Pt]\n\nvariable [NormedAddTorsor V Pt] [hd2 : Fact (finrank \u211d V = 2)]\n\nnamespace Imo2019P2\n\nsnip begin\n\n/-\nWe follow Solution 1 from the\n[official solutions](https://www.imo2019.uk/wp-content/uploads/2018/07/solutions-r856.pdf).\nLetting the rays `AA\u2081` and `BB\u2081` intersect the circumcircle of `ABC` at `A\u2082` and `B\u2082`\nrespectively, we show with an angle chase that `P`, `Q`, `A\u2082`, `B\u2082` are concyclic and let `\u03c9` be\nthe circle through those points. We then show that `C`, `Q\u2081`, `A\u2082`, `A\u2081` are concyclic, and\nthen that `Q\u2081` lies on `\u03c9`, and similarly that `P\u2081` lies on `\u03c9`, so the required four points are\nconcyclic.\n\nNote that most of the formal proof is actually proving nondegeneracy conditions needed for that\nangle chase / concyclicity argument, where an informal solution doesn't discuss those conditions\nat all. Also note that (as described in `Geometry.Euclidean.Angle.Oriented.Basic`) the oriented\nangles used are modulo `2 * \u03c0`, so parts of the angle chase that are only valid for angles modulo\n`\u03c0` (as used in the informal solution) are represented as equalities of twice angles, which we write\nas `(2 : \u2124) \u2022 \u2221 _ _ _ = (2 : \u2124) \u2022 \u2221 _ _ _`.\n-/\n\n/-\nWe apply the following conventions for formalizing IMO geometry problems. A problem is assumed\nto take place in the plane unless that is clearly not intended, so it is not required to prove\nthat the points are coplanar (whether or not that in fact follows from the other conditions).\nAngles in problem statements are taken to be unoriented. A reference to an angle `\u2220XYZ` is taken\nto imply that `X` and `Z` are not equal to `Y`, since choices of junk values play no role in\ninformal mathematics, and those implications are included as hypotheses for the problem whether\nor not they follow from the other hypotheses. Similar, a reference to `XY` as a line is taken to\nimply that `X` does not equal `Y` and that is included as a hypothesis, and a reference to `XY`\nbeing parallel to something is considered a reference to it as a line. However, such an implicit\nhypothesis about two points being different is included only once for any given two points (even\nif it follows from more than one reference to a line or an angle), if `X \u2260 Y` is included then\n`Y \u2260 X` is not included separately, and such hypotheses are not included in the case where there\nis also a reference in the problem to a triangle including those two points, or to strict\nbetweenness of three points including those two. If betweenness is stated, it is taken to be\nstrict betweenness. However, segments and sides are taken to include their endpoints (unless\nthis makes a problem false), although those degenerate cases might not necessarily have been\nconsidered when the problem was formulated and contestants might not have been expected to deal\nwith them. A reference to a point being on a side or a segment is expressed directly with `Wbtw`\nrather than more literally with `affineSegment`.\n-/\n\nnoncomputable section\n\n/-- A configuration satisfying the conditions of the problem. We define this structure to avoid\npassing many hypotheses around as we build up information about the configuration; the final\nresult for a statement of the problem not using this structure is then deduced from one in terms\nof this structure. -/\nstructure Imo2019q2Cfg where\n  (A B C A\u2081 B\u2081 P Q P\u2081 Q\u2081 : Pt)\n  affineIndependent_ABC : AffineIndependent \u211d ![A, B, C]\n  wbtw_B_A\u2081_C : Wbtw \u211d B A\u2081 C\n  wbtw_A_B\u2081_C : Wbtw \u211d A B\u2081 C\n  wbtw_A_P_A\u2081 : Wbtw \u211d A P A\u2081\n  wbtw_B_Q_B\u2081 : Wbtw \u211d B Q B\u2081\n  PQ_parallel_AB : line[\u211d, P, Q] \u2225 line[\u211d, A, B]\n  -- A hypothesis implicit in the named line.\n  P_ne_Q : P \u2260 Q\n  sbtw_P_B\u2081_P\u2081 : Sbtw \u211d P B\u2081 P\u2081\n  angle_PP\u2081C_eq_angle_BAC : \u2220 P P\u2081 C = \u2220 B A C\n  -- A hypothesis implicit in the first named angle.\n  C_ne_P\u2081 : C \u2260 P\u2081\n  sbtw_Q_A\u2081_Q\u2081 : Sbtw \u211d Q A\u2081 Q\u2081\n  angle_CQ\u2081Q_eq_angle_CBA : \u2220 C Q\u2081 Q = \u2220 C B A\n  -- A hypothesis implicit in the first named angle.\n  C_ne_Q\u2081 : C \u2260 Q\u2081\n\n/-- A default choice of orientation, for lemmas that need to pick one. -/\ndef someOrientation : Module.Oriented \u211d V (Fin 2) :=\n  \u27e8Basis.orientation (finBasisOfFinrankEq _ _ hd2.out)\u27e9\n\nvariable {V Pt}\n\nnamespace Imo2019q2Cfg\n\nvariable (cfg : Imo2019q2Cfg V Pt)\n"}

{"cmd": "/-- The configuration has symmetry, allowing results proved for one point to be applied for\nanother (where the informal solution says \"similarly\"). -/\ndef symm : Imo2019q2Cfg V Pt where\n  A := cfg.B\n  B := cfg.A\n  C := cfg.C\n  A\u2081 := cfg.B\u2081\n  B\u2081 := cfg.A\u2081\n  P := cfg.Q\n  Q := cfg.P\n  P\u2081 := cfg.Q\u2081\n  Q\u2081 := cfg.P\u2081\n  affineIndependent_ABC := by\n    rw [\u2190 affineIndependent_equiv (Equiv.swap (0 : Fin 3) 1)]\n    convert cfg.affineIndependent_ABC using 1\n    ext x\n    fin_cases x <;> rfl\n  wbtw_B_A\u2081_C := cfg.wbtw_A_B\u2081_C\n  wbtw_A_B\u2081_C := cfg.wbtw_B_A\u2081_C\n  wbtw_A_P_A\u2081 := cfg.wbtw_B_Q_B\u2081\n  wbtw_B_Q_B\u2081 := cfg.wbtw_A_P_A\u2081\n  PQ_parallel_AB := Set.pair_comm cfg.P cfg.Q \u25b8 Set.pair_comm cfg.A cfg.B \u25b8 cfg.PQ_parallel_AB\n  P_ne_Q := cfg.P_ne_Q.symm\n  sbtw_P_B\u2081_P\u2081 := cfg.sbtw_Q_A\u2081_Q\u2081\n  angle_PP\u2081C_eq_angle_BAC :=\n    angle_comm cfg.C cfg.Q\u2081 cfg.Q \u25b8 angle_comm cfg.C cfg.B cfg.A \u25b8 cfg.angle_CQ\u2081Q_eq_angle_CBA\n  C_ne_P\u2081 := cfg.C_ne_Q\u2081\n  sbtw_Q_A\u2081_Q\u2081 := cfg.sbtw_P_B\u2081_P\u2081\n  angle_CQ\u2081Q_eq_angle_CBA :=\n    angle_comm cfg.P cfg.P\u2081 cfg.C \u25b8 angle_comm cfg.B cfg.A cfg.C \u25b8 cfg.angle_PP\u2081C_eq_angle_BAC\n  C_ne_Q\u2081 := cfg.C_ne_P\u2081\n\n/- ### Configuration properties that are obvious from the diagram, and construction of the\npoints `A\u2082` and `B\u2082` -/\n\ntheorem A_ne_B : cfg.A \u2260 cfg.B :=\n  cfg.affineIndependent_ABC.injective.ne (by decide : (0 : Fin 3) \u2260 1)\n\ntheorem A_ne_C : cfg.A \u2260 cfg.C :=\n  cfg.affineIndependent_ABC.injective.ne (by decide : (0 : Fin 3) \u2260 2)\n\ntheorem B_ne_C : cfg.B \u2260 cfg.C :=\n  cfg.affineIndependent_ABC.injective.ne (by decide : (1 : Fin 3) \u2260 2)\n\ntheorem not_collinear_ABC : \u00acCollinear \u211d ({cfg.A, cfg.B, cfg.C} : Set Pt) :=\n  affineIndependent_iff_not_collinear_set.1 cfg.affineIndependent_ABC\n\n/-- `ABC` as a `Triangle`. -/\ndef triangleABC : Triangle \u211d Pt :=\n  \u27e8_, cfg.affineIndependent_ABC\u27e9\n\ntheorem A_mem_circumsphere : cfg.A \u2208 cfg.triangleABC.circumsphere :=\n  cfg.triangleABC.mem_circumsphere 0\n\ntheorem B_mem_circumsphere : cfg.B \u2208 cfg.triangleABC.circumsphere :=\n  cfg.triangleABC.mem_circumsphere 1\n\ntheorem C_mem_circumsphere : cfg.C \u2208 cfg.triangleABC.circumsphere :=\n  cfg.triangleABC.mem_circumsphere 2\n\ntheorem symm_triangleABC : cfg.symm.triangleABC = cfg.triangleABC.reindex (Equiv.swap 0 1) := by\n  ext i; fin_cases i <;> rfl\n\ntheorem symm_triangleABC_circumsphere :\n    cfg.symm.triangleABC.circumsphere = cfg.triangleABC.circumsphere := by\n  rw [symm_triangleABC, Affine.Simplex.circumsphere_reindex]\n\n/-- `A\u2082` is the second point of intersection of the ray `AA\u2081` with the circumcircle of `ABC`. -/\ndef A\u2082 : Pt :=\n  cfg.triangleABC.circumsphere.secondInter cfg.A (cfg.A\u2081 -\u1d65 cfg.A)\n\n/-- `B\u2082` is the second point of intersection of the ray `BB\u2081` with the circumcircle of `ABC`. -/\ndef B\u2082 : Pt :=\n  cfg.triangleABC.circumsphere.secondInter cfg.B (cfg.B\u2081 -\u1d65 cfg.B)\n\ntheorem A\u2082_mem_circumsphere : cfg.A\u2082 \u2208 cfg.triangleABC.circumsphere :=\n  (Sphere.secondInter_mem _).2 cfg.A_mem_circumsphere\n\ntheorem B\u2082_mem_circumsphere : cfg.B\u2082 \u2208 cfg.triangleABC.circumsphere :=\n  (Sphere.secondInter_mem _).2 cfg.B_mem_circumsphere\n\ntheorem symm_A\u2082 : cfg.symm.A\u2082 = cfg.B\u2082 := by simp_rw [A\u2082, B\u2082, symm_triangleABC_circumsphere]; rfl\n\ntheorem QP_parallel_BA : line[\u211d, cfg.Q, cfg.P] \u2225 line[\u211d, cfg.B, cfg.A] := by\n  rw [Set.pair_comm cfg.Q, Set.pair_comm cfg.B]; exact cfg.PQ_parallel_AB\n\ntheorem A_ne_A\u2081 : cfg.A \u2260 cfg.A\u2081 := by\n  intro h\n  have h' := cfg.not_collinear_ABC\n  rw [h, Set.insert_comm] at h'\n  exact h' cfg.wbtw_B_A\u2081_C.collinear\n\ntheorem collinear_PAA\u2081A\u2082 : Collinear \u211d ({cfg.P, cfg.A, cfg.A\u2081, cfg.A\u2082} : Set Pt) := by\n  rw [A\u2082,\n    (cfg.triangleABC.circumsphere.secondInter_collinear cfg.A cfg.A\u2081).collinear_insert_iff_of_ne\n      (Set.mem_insert _ _) (Set.mem_insert_of_mem _ (Set.mem_insert _ _)) cfg.A_ne_A\u2081,\n    Set.insert_comm]\n  exact cfg.wbtw_A_P_A\u2081.collinear\n\ntheorem A\u2081_ne_C : cfg.A\u2081 \u2260 cfg.C := by\n  intro h\n  have hsbtw := cfg.sbtw_Q_A\u2081_Q\u2081\n  rw [h] at hsbtw\n  have ha := hsbtw.angle\u2082\u2083\u2081_eq_zero\n  rw [angle_CQ\u2081Q_eq_angle_CBA, angle_comm] at ha\n  exact (angle_ne_zero_of_not_collinear cfg.not_collinear_ABC) ha\n\ntheorem B\u2081_ne_C : cfg.B\u2081 \u2260 cfg.C :=\n  cfg.symm.A\u2081_ne_C\n\ntheorem Q_not_mem_CB : cfg.Q \u2209 line[\u211d, cfg.C, cfg.B] := by\n  intro hQ\n  have hQA\u2081 : line[\u211d, cfg.Q, cfg.A\u2081] \u2264 line[\u211d, cfg.C, cfg.B] :=\n    affineSpan_pair_le_of_mem_of_mem hQ cfg.wbtw_B_A\u2081_C.symm.mem_affineSpan\n  have hQ\u2081 : cfg.Q\u2081 \u2208 line[\u211d, cfg.C, cfg.B] := by\n    rw [AffineSubspace.le_def'] at hQA\u2081\n    exact hQA\u2081 _ cfg.sbtw_Q_A\u2081_Q\u2081.right_mem_affineSpan\n  have hc : Collinear \u211d ({cfg.C, cfg.Q\u2081, cfg.Q} : Set Pt) :=\n    haveI hc' : Collinear \u211d ({cfg.B, cfg.C, cfg.Q\u2081, cfg.Q} : Set Pt) := by\n      rw [Set.insert_comm cfg.B, Set.insert_comm cfg.B, Set.pair_comm, Set.insert_comm cfg.C,\n        Set.insert_comm cfg.C]\n      exact collinear_insert_insert_of_mem_affineSpan_pair hQ\u2081 hQ\n    hc'.subset (Set.subset_insert _ _)\n  rw [collinear_iff_eq_or_eq_or_angle_eq_zero_or_angle_eq_pi, cfg.angle_CQ\u2081Q_eq_angle_CBA,\n    or_iff_right cfg.C_ne_Q\u2081, or_iff_right cfg.sbtw_Q_A\u2081_Q\u2081.left_ne_right, angle_comm] at hc\n  exact cfg.not_collinear_ABC (hc.elim collinear_of_angle_eq_zero collinear_of_angle_eq_pi)\n\ntheorem Q_ne_B : cfg.Q \u2260 cfg.B := by\n  intro h\n  have h' := cfg.Q_not_mem_CB\n  rw [h] at h'\n  exact h' (right_mem_affineSpan_pair _ _ _)\n\ntheorem sOppSide_CB_Q_Q\u2081 : line[\u211d, cfg.C, cfg.B].SOppSide cfg.Q cfg.Q\u2081 :=\n  cfg.sbtw_Q_A\u2081_Q\u2081.sOppSide_of_not_mem_of_mem cfg.Q_not_mem_CB cfg.wbtw_B_A\u2081_C.symm.mem_affineSpan\n\n/- ### Relate the orientations of different angles in the configuration -/\n\nsection Oriented\n\nvariable [Module.Oriented \u211d V (Fin 2)]\n\ntheorem oangle_CQ\u2081Q_sign_eq_oangle_CBA_sign :\n    (\u2221 cfg.C cfg.Q\u2081 cfg.Q).sign = (\u2221 cfg.C cfg.B cfg.A).sign := by\n  rw [\u2190 cfg.sbtw_Q_A\u2081_Q\u2081.symm.oangle_eq_right,\n    cfg.sOppSide_CB_Q_Q\u2081.oangle_sign_eq_neg (left_mem_affineSpan_pair \u211d cfg.C cfg.B)\n      cfg.wbtw_B_A\u2081_C.symm.mem_affineSpan,\n    \u2190 Real.Angle.sign_neg, \u2190 oangle_rev,\n    cfg.wbtw_B_A\u2081_C.oangle_sign_eq_of_ne_right cfg.Q cfg.A\u2081_ne_C, oangle_rotate_sign,\n    cfg.wbtw_B_Q_B\u2081.oangle_eq_right cfg.Q_ne_B,\n    cfg.wbtw_A_B\u2081_C.symm.oangle_sign_eq_of_ne_left cfg.B cfg.B\u2081_ne_C.symm]\n\ntheorem oangle_CQ\u2081Q_eq_oangle_CBA : \u2221 cfg.C cfg.Q\u2081 cfg.Q = \u2221 cfg.C cfg.B cfg.A :=\n  oangle_eq_of_angle_eq_of_sign_eq cfg.angle_CQ\u2081Q_eq_angle_CBA\n    cfg.oangle_CQ\u2081Q_sign_eq_oangle_CBA_sign\n\nend Oriented\n\n/- ### More obvious configuration properties -/\n\ntheorem A\u2081_ne_B : cfg.A\u2081 \u2260 cfg.B := by\n  intro h\n  have hwbtw := cfg.wbtw_A_P_A\u2081\n  rw [h] at hwbtw\n  have hPQ : line[\u211d, cfg.P, cfg.Q] = line[\u211d, cfg.A, cfg.B] := by\n    rw [AffineSubspace.eq_iff_direction_eq_of_mem (left_mem_affineSpan_pair _ _ _)\n      hwbtw.mem_affineSpan]\n    exact cfg.PQ_parallel_AB.direction_eq\n  haveI := someOrientation V\n  have haQ : (2 : \u2124) \u2022 \u2221 cfg.C cfg.B cfg.Q = (2 : \u2124) \u2022 \u2221 cfg.C cfg.B cfg.A := by\n    rw [Collinear.two_zsmul_oangle_eq_right _ cfg.A_ne_B cfg.Q_ne_B]\n    rw [Set.pair_comm, Set.insert_comm]\n    refine collinear_insert_of_mem_affineSpan_pair ?_\n    rw [\u2190 hPQ]\n    exact right_mem_affineSpan_pair _ _ _\n  have ha : (2 : \u2124) \u2022 \u2221 cfg.C cfg.B cfg.Q = (2 : \u2124) \u2022 \u2221 cfg.C cfg.Q\u2081 cfg.Q := by\n    rw [oangle_CQ\u2081Q_eq_oangle_CBA, haQ]\n  have hn : \u00acCollinear \u211d ({cfg.C, cfg.B, cfg.Q} : Set Pt) := by\n    rw [collinear_iff_of_two_zsmul_oangle_eq haQ, Set.pair_comm, Set.insert_comm, Set.pair_comm]\n    exact cfg.not_collinear_ABC\n  have hc := cospherical_of_two_zsmul_oangle_eq_of_not_collinear ha hn\n  have hBQ\u2081 : cfg.B \u2260 cfg.Q\u2081 := by rw [\u2190 h]; exact cfg.sbtw_Q_A\u2081_Q\u2081.ne_right\n  have hQQ\u2081 : cfg.Q \u2260 cfg.Q\u2081 := cfg.sbtw_Q_A\u2081_Q\u2081.left_ne_right\n  have hBQ\u2081Q : AffineIndependent \u211d ![cfg.B, cfg.Q\u2081, cfg.Q] :=\n    hc.affineIndependent_of_mem_of_ne (Set.mem_insert_of_mem _ (Set.mem_insert _ _))\n      (Set.mem_insert_of_mem _ (Set.mem_insert_of_mem _ (Set.mem_insert _ _)))\n      (Set.mem_insert_of_mem _\n        (Set.mem_insert_of_mem _ (Set.mem_insert_of_mem _ (Set.mem_singleton _))))\n      hBQ\u2081 cfg.Q_ne_B.symm hQQ\u2081.symm\n  rw [affineIndependent_iff_not_collinear_set] at hBQ\u2081Q\n  refine hBQ\u2081Q ?_\n  rw [\u2190 h, Set.pair_comm, Set.insert_comm]\n  exact cfg.sbtw_Q_A\u2081_Q\u2081.wbtw.collinear\n\ntheorem sbtw_B_A\u2081_C : Sbtw \u211d cfg.B cfg.A\u2081 cfg.C :=\n  \u27e8cfg.wbtw_B_A\u2081_C, cfg.A\u2081_ne_B, cfg.A\u2081_ne_C\u27e9\n\ntheorem sbtw_A_B\u2081_C : Sbtw \u211d cfg.A cfg.B\u2081 cfg.C :=\n  cfg.symm.sbtw_B_A\u2081_C\n\ntheorem sbtw_A_A\u2081_A\u2082 : Sbtw \u211d cfg.A cfg.A\u2081 cfg.A\u2082 := by\n  refine Sphere.sbtw_secondInter cfg.A_mem_circumsphere ?_\n  convert cfg.sbtw_B_A\u2081_C.dist_lt_max_dist _\n  change _ = max (dist (cfg.triangleABC.points 1) _) (dist (cfg.triangleABC.points 2) _)\n  simp_rw [circumsphere_center, circumsphere_radius, dist_circumcenter_eq_circumradius, max_self]\n\ntheorem sbtw_B_B\u2081_B\u2082 : Sbtw \u211d cfg.B cfg.B\u2081 cfg.B\u2082 := by\n  rw [\u2190 cfg.symm_A\u2082]; exact cfg.symm.sbtw_A_A\u2081_A\u2082\n\ntheorem A\u2082_ne_A : cfg.A\u2082 \u2260 cfg.A :=\n  cfg.sbtw_A_A\u2081_A\u2082.left_ne_right.symm\n\ntheorem A\u2082_ne_P : cfg.A\u2082 \u2260 cfg.P :=\n  (cfg.sbtw_A_A\u2081_A\u2082.trans_wbtw_left_ne cfg.wbtw_A_P_A\u2081).symm\n\n\ntheorem A\u2082_ne_B : cfg.A\u2082 \u2260 cfg.B  := by\n  intro h\n  apply cfg.not_collinear_ABC\n  exact (collinear_insert_insert_of_mem_affineSpan_pair cfg.sbtw_A_A\u2081_A\u2082.left_mem_affineSpan cfg.sbtw_B_A\u2081_C.right_mem_affineSpan).subset (Set.subset_insert _ _)\n", "allTactics": true, "theorems": true, "env": 0}

{"cmd": "/-- The configuration has symmetry, allowing results proved for one point to be applied for\nanother (where the informal solution says \"similarly\"). -/\ndef symm : Imo2019q2Cfg V Pt where\n  A := cfg.B\n  B := cfg.A\n  C := cfg.C\n  A\u2081 := cfg.B\u2081\n  B\u2081 := cfg.A\u2081\n  P := cfg.Q\n  Q := cfg.P\n  P\u2081 := cfg.Q\u2081\n  Q\u2081 := cfg.P\u2081\n  affineIndependent_ABC := by\n    rw [\u2190 affineIndependent_equiv (Equiv.swap (0 : Fin 3) 1)]\n    convert cfg.affineIndependent_ABC using 1\n    ext x\n    fin_cases x <;> rfl\n  wbtw_B_A\u2081_C := cfg.wbtw_A_B\u2081_C\n  wbtw_A_B\u2081_C := cfg.wbtw_B_A\u2081_C\n  wbtw_A_P_A\u2081 := cfg.wbtw_B_Q_B\u2081\n  wbtw_B_Q_B\u2081 := cfg.wbtw_A_P_A\u2081\n  PQ_parallel_AB := Set.pair_comm cfg.P cfg.Q \u25b8 Set.pair_comm cfg.A cfg.B \u25b8 cfg.PQ_parallel_AB\n  P_ne_Q := cfg.P_ne_Q.symm\n  sbtw_P_B\u2081_P\u2081 := cfg.sbtw_Q_A\u2081_Q\u2081\n  angle_PP\u2081C_eq_angle_BAC :=\n    angle_comm cfg.C cfg.Q\u2081 cfg.Q \u25b8 angle_comm cfg.C cfg.B cfg.A \u25b8 cfg.angle_CQ\u2081Q_eq_angle_CBA\n  C_ne_P\u2081 := cfg.C_ne_Q\u2081\n  sbtw_Q_A\u2081_Q\u2081 := cfg.sbtw_P_B\u2081_P\u2081\n  angle_CQ\u2081Q_eq_angle_CBA :=\n    angle_comm cfg.P cfg.P\u2081 cfg.C \u25b8 angle_comm cfg.B cfg.A cfg.C \u25b8 cfg.angle_PP\u2081C_eq_angle_BAC\n  C_ne_Q\u2081 := cfg.C_ne_P\u2081\n\n/- ### Configuration properties that are obvious from the diagram, and construction of the\npoints `A\u2082` and `B\u2082` -/\n\ntheorem A_ne_B : cfg.A \u2260 cfg.B :=\n  cfg.affineIndependent_ABC.injective.ne (by decide : (0 : Fin 3) \u2260 1)\n\ntheorem A_ne_C : cfg.A \u2260 cfg.C :=\n  cfg.affineIndependent_ABC.injective.ne (by decide : (0 : Fin 3) \u2260 2)\n\ntheorem B_ne_C : cfg.B \u2260 cfg.C :=\n  cfg.affineIndependent_ABC.injective.ne (by decide : (1 : Fin 3) \u2260 2)\n\ntheorem not_collinear_ABC : \u00acCollinear \u211d ({cfg.A, cfg.B, cfg.C} : Set Pt) :=\n  affineIndependent_iff_not_collinear_set.1 cfg.affineIndependent_ABC\n\n/-- `ABC` as a `Triangle`. -/\ndef triangleABC : Triangle \u211d Pt :=\n  \u27e8_, cfg.affineIndependent_ABC\u27e9\n\ntheorem A_mem_circumsphere : cfg.A \u2208 cfg.triangleABC.circumsphere :=\n  cfg.triangleABC.mem_circumsphere 0\n\ntheorem B_mem_circumsphere : cfg.B \u2208 cfg.triangleABC.circumsphere :=\n  cfg.triangleABC.mem_circumsphere 1\n\ntheorem C_mem_circumsphere : cfg.C \u2208 cfg.triangleABC.circumsphere :=\n  cfg.triangleABC.mem_circumsphere 2\n\ntheorem symm_triangleABC : cfg.symm.triangleABC = cfg.triangleABC.reindex (Equiv.swap 0 1) := by\n  ext i; fin_cases i <;> rfl\n\ntheorem symm_triangleABC_circumsphere :\n    cfg.symm.triangleABC.circumsphere = cfg.triangleABC.circumsphere := by\n  rw [symm_triangleABC, Affine.Simplex.circumsphere_reindex]\n\n/-- `A\u2082` is the second point of intersection of the ray `AA\u2081` with the circumcircle of `ABC`. -/\ndef A\u2082 : Pt :=\n  cfg.triangleABC.circumsphere.secondInter cfg.A (cfg.A\u2081 -\u1d65 cfg.A)\n\n/-- `B\u2082` is the second point of intersection of the ray `BB\u2081` with the circumcircle of `ABC`. -/\ndef B\u2082 : Pt :=\n  cfg.triangleABC.circumsphere.secondInter cfg.B (cfg.B\u2081 -\u1d65 cfg.B)\n\ntheorem A\u2082_mem_circumsphere : cfg.A\u2082 \u2208 cfg.triangleABC.circumsphere :=\n  (Sphere.secondInter_mem _).2 cfg.A_mem_circumsphere\n\ntheorem B\u2082_mem_circumsphere : cfg.B\u2082 \u2208 cfg.triangleABC.circumsphere :=\n  (Sphere.secondInter_mem _).2 cfg.B_mem_circumsphere\n\ntheorem symm_A\u2082 : cfg.symm.A\u2082 = cfg.B\u2082 := by simp_rw [A\u2082, B\u2082, symm_triangleABC_circumsphere]; rfl\n\ntheorem QP_parallel_BA : line[\u211d, cfg.Q, cfg.P] \u2225 line[\u211d, cfg.B, cfg.A] := by\n  rw [Set.pair_comm cfg.Q, Set.pair_comm cfg.B]; exact cfg.PQ_parallel_AB\n\ntheorem A_ne_A\u2081 : cfg.A \u2260 cfg.A\u2081 := by\n  intro h\n  have h' := cfg.not_collinear_ABC\n  rw [h, Set.insert_comm] at h'\n  exact h' cfg.wbtw_B_A\u2081_C.collinear\n\ntheorem collinear_PAA\u2081A\u2082 : Collinear \u211d ({cfg.P, cfg.A, cfg.A\u2081, cfg.A\u2082} : Set Pt) := by\n  rw [A\u2082,\n    (cfg.triangleABC.circumsphere.secondInter_collinear cfg.A cfg.A\u2081).collinear_insert_iff_of_ne\n      (Set.mem_insert _ _) (Set.mem_insert_of_mem _ (Set.mem_insert _ _)) cfg.A_ne_A\u2081,\n    Set.insert_comm]\n  exact cfg.wbtw_A_P_A\u2081.collinear\n\ntheorem A\u2081_ne_C : cfg.A\u2081 \u2260 cfg.C := by\n  intro h\n  have hsbtw := cfg.sbtw_Q_A\u2081_Q\u2081\n  rw [h] at hsbtw\n  have ha := hsbtw.angle\u2082\u2083\u2081_eq_zero\n  rw [angle_CQ\u2081Q_eq_angle_CBA, angle_comm] at ha\n  exact (angle_ne_zero_of_not_collinear cfg.not_collinear_ABC) ha\n\ntheorem B\u2081_ne_C : cfg.B\u2081 \u2260 cfg.C :=\n  cfg.symm.A\u2081_ne_C\n\ntheorem Q_not_mem_CB : cfg.Q \u2209 line[\u211d, cfg.C, cfg.B] := by\n  intro hQ\n  have hQA\u2081 : line[\u211d, cfg.Q, cfg.A\u2081] \u2264 line[\u211d, cfg.C, cfg.B] :=\n    affineSpan_pair_le_of_mem_of_mem hQ cfg.wbtw_B_A\u2081_C.symm.mem_affineSpan\n  have hQ\u2081 : cfg.Q\u2081 \u2208 line[\u211d, cfg.C, cfg.B] := by\n    rw [AffineSubspace.le_def'] at hQA\u2081\n    exact hQA\u2081 _ cfg.sbtw_Q_A\u2081_Q\u2081.right_mem_affineSpan\n  have hc : Collinear \u211d ({cfg.C, cfg.Q\u2081, cfg.Q} : Set Pt) :=\n    haveI hc' : Collinear \u211d ({cfg.B, cfg.C, cfg.Q\u2081, cfg.Q} : Set Pt) := by\n      rw [Set.insert_comm cfg.B, Set.insert_comm cfg.B, Set.pair_comm, Set.insert_comm cfg.C,\n        Set.insert_comm cfg.C]\n      exact collinear_insert_insert_of_mem_affineSpan_pair hQ\u2081 hQ\n    hc'.subset (Set.subset_insert _ _)\n  rw [collinear_iff_eq_or_eq_or_angle_eq_zero_or_angle_eq_pi, cfg.angle_CQ\u2081Q_eq_angle_CBA,\n    or_iff_right cfg.C_ne_Q\u2081, or_iff_right cfg.sbtw_Q_A\u2081_Q\u2081.left_ne_right, angle_comm] at hc\n  exact cfg.not_collinear_ABC (hc.elim collinear_of_angle_eq_zero collinear_of_angle_eq_pi)\n\ntheorem Q_ne_B : cfg.Q \u2260 cfg.B := by\n  intro h\n  have h' := cfg.Q_not_mem_CB\n  rw [h] at h'\n  exact h' (right_mem_affineSpan_pair _ _ _)\n\ntheorem sOppSide_CB_Q_Q\u2081 : line[\u211d, cfg.C, cfg.B].SOppSide cfg.Q cfg.Q\u2081 :=\n  cfg.sbtw_Q_A\u2081_Q\u2081.sOppSide_of_not_mem_of_mem cfg.Q_not_mem_CB cfg.wbtw_B_A\u2081_C.symm.mem_affineSpan\n\n/- ### Relate the orientations of different angles in the configuration -/\n\nsection Oriented\n\nvariable [Module.Oriented \u211d V (Fin 2)]\n\ntheorem oangle_CQ\u2081Q_sign_eq_oangle_CBA_sign :\n    (\u2221 cfg.C cfg.Q\u2081 cfg.Q).sign = (\u2221 cfg.C cfg.B cfg.A).sign := by\n  rw [\u2190 cfg.sbtw_Q_A\u2081_Q\u2081.symm.oangle_eq_right,\n    cfg.sOppSide_CB_Q_Q\u2081.oangle_sign_eq_neg (left_mem_affineSpan_pair \u211d cfg.C cfg.B)\n      cfg.wbtw_B_A\u2081_C.symm.mem_affineSpan,\n    \u2190 Real.Angle.sign_neg, \u2190 oangle_rev,\n    cfg.wbtw_B_A\u2081_C.oangle_sign_eq_of_ne_right cfg.Q cfg.A\u2081_ne_C, oangle_rotate_sign,\n    cfg.wbtw_B_Q_B\u2081.oangle_eq_right cfg.Q_ne_B,\n    cfg.wbtw_A_B\u2081_C.symm.oangle_sign_eq_of_ne_left cfg.B cfg.B\u2081_ne_C.symm]\n\ntheorem oangle_CQ\u2081Q_eq_oangle_CBA : \u2221 cfg.C cfg.Q\u2081 cfg.Q = \u2221 cfg.C cfg.B cfg.A :=\n  oangle_eq_of_angle_eq_of_sign_eq cfg.angle_CQ\u2081Q_eq_angle_CBA\n    cfg.oangle_CQ\u2081Q_sign_eq_oangle_CBA_sign\n\nend Oriented\n\n/- ### More obvious configuration properties -/\n\ntheorem A\u2081_ne_B : cfg.A\u2081 \u2260 cfg.B := by\n  intro h\n  have hwbtw := cfg.wbtw_A_P_A\u2081\n  rw [h] at hwbtw\n  have hPQ : line[\u211d, cfg.P, cfg.Q] = line[\u211d, cfg.A, cfg.B] := by\n    rw [AffineSubspace.eq_iff_direction_eq_of_mem (left_mem_affineSpan_pair _ _ _)\n      hwbtw.mem_affineSpan]\n    exact cfg.PQ_parallel_AB.direction_eq\n  haveI := someOrientation V\n  have haQ : (2 : \u2124) \u2022 \u2221 cfg.C cfg.B cfg.Q = (2 : \u2124) \u2022 \u2221 cfg.C cfg.B cfg.A := by\n    rw [Collinear.two_zsmul_oangle_eq_right _ cfg.A_ne_B cfg.Q_ne_B]\n    rw [Set.pair_comm, Set.insert_comm]\n    refine collinear_insert_of_mem_affineSpan_pair ?_\n    rw [\u2190 hPQ]\n    exact right_mem_affineSpan_pair _ _ _\n  have ha : (2 : \u2124) \u2022 \u2221 cfg.C cfg.B cfg.Q = (2 : \u2124) \u2022 \u2221 cfg.C cfg.Q\u2081 cfg.Q := by\n    rw [oangle_CQ\u2081Q_eq_oangle_CBA, haQ]\n  have hn : \u00acCollinear \u211d ({cfg.C, cfg.B, cfg.Q} : Set Pt) := by\n    rw [collinear_iff_of_two_zsmul_oangle_eq haQ, Set.pair_comm, Set.insert_comm, Set.pair_comm]\n    exact cfg.not_collinear_ABC\n  have hc := cospherical_of_two_zsmul_oangle_eq_of_not_collinear ha hn\n  have hBQ\u2081 : cfg.B \u2260 cfg.Q\u2081 := by rw [\u2190 h]; exact cfg.sbtw_Q_A\u2081_Q\u2081.ne_right\n  have hQQ\u2081 : cfg.Q \u2260 cfg.Q\u2081 := cfg.sbtw_Q_A\u2081_Q\u2081.left_ne_right\n  have hBQ\u2081Q : AffineIndependent \u211d ![cfg.B, cfg.Q\u2081, cfg.Q] :=\n    hc.affineIndependent_of_mem_of_ne (Set.mem_insert_of_mem _ (Set.mem_insert _ _))\n      (Set.mem_insert_of_mem _ (Set.mem_insert_of_mem _ (Set.mem_insert _ _)))\n      (Set.mem_insert_of_mem _\n        (Set.mem_insert_of_mem _ (Set.mem_insert_of_mem _ (Set.mem_singleton _))))\n      hBQ\u2081 cfg.Q_ne_B.symm hQQ\u2081.symm\n  rw [affineIndependent_iff_not_collinear_set] at hBQ\u2081Q\n  refine hBQ\u2081Q ?_\n  rw [\u2190 h, Set.pair_comm, Set.insert_comm]\n  exact cfg.sbtw_Q_A\u2081_Q\u2081.wbtw.collinear\n\ntheorem sbtw_B_A\u2081_C : Sbtw \u211d cfg.B cfg.A\u2081 cfg.C :=\n  \u27e8cfg.wbtw_B_A\u2081_C, cfg.A\u2081_ne_B, cfg.A\u2081_ne_C\u27e9\n\ntheorem sbtw_A_B\u2081_C : Sbtw \u211d cfg.A cfg.B\u2081 cfg.C :=\n  cfg.symm.sbtw_B_A\u2081_C\n\ntheorem sbtw_A_A\u2081_A\u2082 : Sbtw \u211d cfg.A cfg.A\u2081 cfg.A\u2082 := by\n  refine Sphere.sbtw_secondInter cfg.A_mem_circumsphere ?_\n  convert cfg.sbtw_B_A\u2081_C.dist_lt_max_dist _\n  change _ = max (dist (cfg.triangleABC.points 1) _) (dist (cfg.triangleABC.points 2) _)\n  simp_rw [circumsphere_center, circumsphere_radius, dist_circumcenter_eq_circumradius, max_self]\n\ntheorem sbtw_B_B\u2081_B\u2082 : Sbtw \u211d cfg.B cfg.B\u2081 cfg.B\u2082 := by\n  rw [\u2190 cfg.symm_A\u2082]; exact cfg.symm.sbtw_A_A\u2081_A\u2082\n\ntheorem A\u2082_ne_A : cfg.A\u2082 \u2260 cfg.A :=\n  cfg.sbtw_A_A\u2081_A\u2082.left_ne_right.symm\n\ntheorem A\u2082_ne_P : cfg.A\u2082 \u2260 cfg.P :=\n  (cfg.sbtw_A_A\u2081_A\u2082.trans_wbtw_left_ne cfg.wbtw_A_P_A\u2081).symm\n\n\ntheorem A\u2082_ne_B : cfg.A\u2082 \u2260 cfg.B  := by\n  intro h\n  refine cfg.not_collinear_ABC _\n  exact (collinear_insert_insert_of_mem_affineSpan_pair cfg.sbtw_A_A\u2081_A\u2082.left_mem_affineSpan cfg.sbtw_B_A\u2081_C.right_mem_affineSpan).subset (by enum_simp[fst => Set.subset_insert, snd => _])\n", "allTactics": true, "theorems": true, "env": 0}

{"cmd": "/-- The configuration has symmetry, allowing results proved for one point to be applied for\nanother (where the informal solution says \"similarly\"). -/\ndef symm : Imo2019q2Cfg V Pt where\n  A := cfg.B\n  B := cfg.A\n  C := cfg.C\n  A\u2081 := cfg.B\u2081\n  B\u2081 := cfg.A\u2081\n  P := cfg.Q\n  Q := cfg.P\n  P\u2081 := cfg.Q\u2081\n  Q\u2081 := cfg.P\u2081\n  affineIndependent_ABC := by\n    rw [\u2190 affineIndependent_equiv (Equiv.swap (0 : Fin 3) 1)]\n    convert cfg.affineIndependent_ABC using 1\n    ext x\n    fin_cases x <;> rfl\n  wbtw_B_A\u2081_C := cfg.wbtw_A_B\u2081_C\n  wbtw_A_B\u2081_C := cfg.wbtw_B_A\u2081_C\n  wbtw_A_P_A\u2081 := cfg.wbtw_B_Q_B\u2081\n  wbtw_B_Q_B\u2081 := cfg.wbtw_A_P_A\u2081\n  PQ_parallel_AB := Set.pair_comm cfg.P cfg.Q \u25b8 Set.pair_comm cfg.A cfg.B \u25b8 cfg.PQ_parallel_AB\n  P_ne_Q := cfg.P_ne_Q.symm\n  sbtw_P_B\u2081_P\u2081 := cfg.sbtw_Q_A\u2081_Q\u2081\n  angle_PP\u2081C_eq_angle_BAC :=\n    angle_comm cfg.C cfg.Q\u2081 cfg.Q \u25b8 angle_comm cfg.C cfg.B cfg.A \u25b8 cfg.angle_CQ\u2081Q_eq_angle_CBA\n  C_ne_P\u2081 := cfg.C_ne_Q\u2081\n  sbtw_Q_A\u2081_Q\u2081 := cfg.sbtw_P_B\u2081_P\u2081\n  angle_CQ\u2081Q_eq_angle_CBA :=\n    angle_comm cfg.P cfg.P\u2081 cfg.C \u25b8 angle_comm cfg.B cfg.A cfg.C \u25b8 cfg.angle_PP\u2081C_eq_angle_BAC\n  C_ne_Q\u2081 := cfg.C_ne_P\u2081\n\n/- ### Configuration properties that are obvious from the diagram, and construction of the\npoints `A\u2082` and `B\u2082` -/\n\ntheorem A_ne_B : cfg.A \u2260 cfg.B :=\n  cfg.affineIndependent_ABC.injective.ne (by decide : (0 : Fin 3) \u2260 1)\n\ntheorem A_ne_C : cfg.A \u2260 cfg.C :=\n  cfg.affineIndependent_ABC.injective.ne (by decide : (0 : Fin 3) \u2260 2)\n\ntheorem B_ne_C : cfg.B \u2260 cfg.C :=\n  cfg.affineIndependent_ABC.injective.ne (by decide : (1 : Fin 3) \u2260 2)\n\ntheorem not_collinear_ABC : \u00acCollinear \u211d ({cfg.A, cfg.B, cfg.C} : Set Pt) :=\n  affineIndependent_iff_not_collinear_set.1 cfg.affineIndependent_ABC\n\n/-- `ABC` as a `Triangle`. -/\ndef triangleABC : Triangle \u211d Pt :=\n  \u27e8_, cfg.affineIndependent_ABC\u27e9\n\ntheorem A_mem_circumsphere : cfg.A \u2208 cfg.triangleABC.circumsphere :=\n  cfg.triangleABC.mem_circumsphere 0\n\ntheorem B_mem_circumsphere : cfg.B \u2208 cfg.triangleABC.circumsphere :=\n  cfg.triangleABC.mem_circumsphere 1\n\ntheorem C_mem_circumsphere : cfg.C \u2208 cfg.triangleABC.circumsphere :=\n  cfg.triangleABC.mem_circumsphere 2\n\ntheorem symm_triangleABC : cfg.symm.triangleABC = cfg.triangleABC.reindex (Equiv.swap 0 1) := by\n  ext i; fin_cases i <;> rfl\n\ntheorem symm_triangleABC_circumsphere :\n    cfg.symm.triangleABC.circumsphere = cfg.triangleABC.circumsphere := by\n  rw [symm_triangleABC, Affine.Simplex.circumsphere_reindex]\n\n/-- `A\u2082` is the second point of intersection of the ray `AA\u2081` with the circumcircle of `ABC`. -/\ndef A\u2082 : Pt :=\n  cfg.triangleABC.circumsphere.secondInter cfg.A (cfg.A\u2081 -\u1d65 cfg.A)\n\n/-- `B\u2082` is the second point of intersection of the ray `BB\u2081` with the circumcircle of `ABC`. -/\ndef B\u2082 : Pt :=\n  cfg.triangleABC.circumsphere.secondInter cfg.B (cfg.B\u2081 -\u1d65 cfg.B)\n\ntheorem A\u2082_mem_circumsphere : cfg.A\u2082 \u2208 cfg.triangleABC.circumsphere :=\n  (Sphere.secondInter_mem _).2 cfg.A_mem_circumsphere\n\ntheorem B\u2082_mem_circumsphere : cfg.B\u2082 \u2208 cfg.triangleABC.circumsphere :=\n  (Sphere.secondInter_mem _).2 cfg.B_mem_circumsphere\n\ntheorem symm_A\u2082 : cfg.symm.A\u2082 = cfg.B\u2082 := by simp_rw [A\u2082, B\u2082, symm_triangleABC_circumsphere]; rfl\n\ntheorem QP_parallel_BA : line[\u211d, cfg.Q, cfg.P] \u2225 line[\u211d, cfg.B, cfg.A] := by\n  rw [Set.pair_comm cfg.Q, Set.pair_comm cfg.B]; exact cfg.PQ_parallel_AB\n\ntheorem A_ne_A\u2081 : cfg.A \u2260 cfg.A\u2081 := by\n  intro h\n  have h' := cfg.not_collinear_ABC\n  rw [h, Set.insert_comm] at h'\n  exact h' cfg.wbtw_B_A\u2081_C.collinear\n\ntheorem collinear_PAA\u2081A\u2082 : Collinear \u211d ({cfg.P, cfg.A, cfg.A\u2081, cfg.A\u2082} : Set Pt) := by\n  rw [A\u2082,\n    (cfg.triangleABC.circumsphere.secondInter_collinear cfg.A cfg.A\u2081).collinear_insert_iff_of_ne\n      (Set.mem_insert _ _) (Set.mem_insert_of_mem _ (Set.mem_insert _ _)) cfg.A_ne_A\u2081,\n    Set.insert_comm]\n  exact cfg.wbtw_A_P_A\u2081.collinear\n\ntheorem A\u2081_ne_C : cfg.A\u2081 \u2260 cfg.C := by\n  intro h\n  have hsbtw := cfg.sbtw_Q_A\u2081_Q\u2081\n  rw [h] at hsbtw\n  have ha := hsbtw.angle\u2082\u2083\u2081_eq_zero\n  rw [angle_CQ\u2081Q_eq_angle_CBA, angle_comm] at ha\n  exact (angle_ne_zero_of_not_collinear cfg.not_collinear_ABC) ha\n\ntheorem B\u2081_ne_C : cfg.B\u2081 \u2260 cfg.C :=\n  cfg.symm.A\u2081_ne_C\n\ntheorem Q_not_mem_CB : cfg.Q \u2209 line[\u211d, cfg.C, cfg.B] := by\n  intro hQ\n  have hQA\u2081 : line[\u211d, cfg.Q, cfg.A\u2081] \u2264 line[\u211d, cfg.C, cfg.B] :=\n    affineSpan_pair_le_of_mem_of_mem hQ cfg.wbtw_B_A\u2081_C.symm.mem_affineSpan\n  have hQ\u2081 : cfg.Q\u2081 \u2208 line[\u211d, cfg.C, cfg.B] := by\n    rw [AffineSubspace.le_def'] at hQA\u2081\n    exact hQA\u2081 _ cfg.sbtw_Q_A\u2081_Q\u2081.right_mem_affineSpan\n  have hc : Collinear \u211d ({cfg.C, cfg.Q\u2081, cfg.Q} : Set Pt) :=\n    haveI hc' : Collinear \u211d ({cfg.B, cfg.C, cfg.Q\u2081, cfg.Q} : Set Pt) := by\n      rw [Set.insert_comm cfg.B, Set.insert_comm cfg.B, Set.pair_comm, Set.insert_comm cfg.C,\n        Set.insert_comm cfg.C]\n      exact collinear_insert_insert_of_mem_affineSpan_pair hQ\u2081 hQ\n    hc'.subset (Set.subset_insert _ _)\n  rw [collinear_iff_eq_or_eq_or_angle_eq_zero_or_angle_eq_pi, cfg.angle_CQ\u2081Q_eq_angle_CBA,\n    or_iff_right cfg.C_ne_Q\u2081, or_iff_right cfg.sbtw_Q_A\u2081_Q\u2081.left_ne_right, angle_comm] at hc\n  exact cfg.not_collinear_ABC (hc.elim collinear_of_angle_eq_zero collinear_of_angle_eq_pi)\n\ntheorem Q_ne_B : cfg.Q \u2260 cfg.B := by\n  intro h\n  have h' := cfg.Q_not_mem_CB\n  rw [h] at h'\n  exact h' (right_mem_affineSpan_pair _ _ _)\n\ntheorem sOppSide_CB_Q_Q\u2081 : line[\u211d, cfg.C, cfg.B].SOppSide cfg.Q cfg.Q\u2081 :=\n  cfg.sbtw_Q_A\u2081_Q\u2081.sOppSide_of_not_mem_of_mem cfg.Q_not_mem_CB cfg.wbtw_B_A\u2081_C.symm.mem_affineSpan\n\n/- ### Relate the orientations of different angles in the configuration -/\n\nsection Oriented\n\nvariable [Module.Oriented \u211d V (Fin 2)]\n\ntheorem oangle_CQ\u2081Q_sign_eq_oangle_CBA_sign :\n    (\u2221 cfg.C cfg.Q\u2081 cfg.Q).sign = (\u2221 cfg.C cfg.B cfg.A).sign := by\n  rw [\u2190 cfg.sbtw_Q_A\u2081_Q\u2081.symm.oangle_eq_right,\n    cfg.sOppSide_CB_Q_Q\u2081.oangle_sign_eq_neg (left_mem_affineSpan_pair \u211d cfg.C cfg.B)\n      cfg.wbtw_B_A\u2081_C.symm.mem_affineSpan,\n    \u2190 Real.Angle.sign_neg, \u2190 oangle_rev,\n    cfg.wbtw_B_A\u2081_C.oangle_sign_eq_of_ne_right cfg.Q cfg.A\u2081_ne_C, oangle_rotate_sign,\n    cfg.wbtw_B_Q_B\u2081.oangle_eq_right cfg.Q_ne_B,\n    cfg.wbtw_A_B\u2081_C.symm.oangle_sign_eq_of_ne_left cfg.B cfg.B\u2081_ne_C.symm]\n\ntheorem oangle_CQ\u2081Q_eq_oangle_CBA : \u2221 cfg.C cfg.Q\u2081 cfg.Q = \u2221 cfg.C cfg.B cfg.A :=\n  oangle_eq_of_angle_eq_of_sign_eq cfg.angle_CQ\u2081Q_eq_angle_CBA\n    cfg.oangle_CQ\u2081Q_sign_eq_oangle_CBA_sign\n\nend Oriented\n\n/- ### More obvious configuration properties -/\n\ntheorem A\u2081_ne_B : cfg.A\u2081 \u2260 cfg.B := by\n  intro h\n  have hwbtw := cfg.wbtw_A_P_A\u2081\n  rw [h] at hwbtw\n  have hPQ : line[\u211d, cfg.P, cfg.Q] = line[\u211d, cfg.A, cfg.B] := by\n    rw [AffineSubspace.eq_iff_direction_eq_of_mem (left_mem_affineSpan_pair _ _ _)\n      hwbtw.mem_affineSpan]\n    exact cfg.PQ_parallel_AB.direction_eq\n  haveI := someOrientation V\n  have haQ : (2 : \u2124) \u2022 \u2221 cfg.C cfg.B cfg.Q = (2 : \u2124) \u2022 \u2221 cfg.C cfg.B cfg.A := by\n    rw [Collinear.two_zsmul_oangle_eq_right _ cfg.A_ne_B cfg.Q_ne_B]\n    rw [Set.pair_comm, Set.insert_comm]\n    refine collinear_insert_of_mem_affineSpan_pair ?_\n    rw [\u2190 hPQ]\n    exact right_mem_affineSpan_pair _ _ _\n  have ha : (2 : \u2124) \u2022 \u2221 cfg.C cfg.B cfg.Q = (2 : \u2124) \u2022 \u2221 cfg.C cfg.Q\u2081 cfg.Q := by\n    rw [oangle_CQ\u2081Q_eq_oangle_CBA, haQ]\n  have hn : \u00acCollinear \u211d ({cfg.C, cfg.B, cfg.Q} : Set Pt) := by\n    rw [collinear_iff_of_two_zsmul_oangle_eq haQ, Set.pair_comm, Set.insert_comm, Set.pair_comm]\n    exact cfg.not_collinear_ABC\n  have hc := cospherical_of_two_zsmul_oangle_eq_of_not_collinear ha hn\n  have hBQ\u2081 : cfg.B \u2260 cfg.Q\u2081 := by rw [\u2190 h]; exact cfg.sbtw_Q_A\u2081_Q\u2081.ne_right\n  have hQQ\u2081 : cfg.Q \u2260 cfg.Q\u2081 := cfg.sbtw_Q_A\u2081_Q\u2081.left_ne_right\n  have hBQ\u2081Q : AffineIndependent \u211d ![cfg.B, cfg.Q\u2081, cfg.Q] :=\n    hc.affineIndependent_of_mem_of_ne (Set.mem_insert_of_mem _ (Set.mem_insert _ _))\n      (Set.mem_insert_of_mem _ (Set.mem_insert_of_mem _ (Set.mem_insert _ _)))\n      (Set.mem_insert_of_mem _\n        (Set.mem_insert_of_mem _ (Set.mem_insert_of_mem _ (Set.mem_singleton _))))\n      hBQ\u2081 cfg.Q_ne_B.symm hQQ\u2081.symm\n  rw [affineIndependent_iff_not_collinear_set] at hBQ\u2081Q\n  refine hBQ\u2081Q ?_\n  rw [\u2190 h, Set.pair_comm, Set.insert_comm]\n  exact cfg.sbtw_Q_A\u2081_Q\u2081.wbtw.collinear\n\ntheorem sbtw_B_A\u2081_C : Sbtw \u211d cfg.B cfg.A\u2081 cfg.C :=\n  \u27e8cfg.wbtw_B_A\u2081_C, cfg.A\u2081_ne_B, cfg.A\u2081_ne_C\u27e9\n\ntheorem sbtw_A_B\u2081_C : Sbtw \u211d cfg.A cfg.B\u2081 cfg.C :=\n  cfg.symm.sbtw_B_A\u2081_C\n\ntheorem sbtw_A_A\u2081_A\u2082 : Sbtw \u211d cfg.A cfg.A\u2081 cfg.A\u2082 := by\n  refine Sphere.sbtw_secondInter cfg.A_mem_circumsphere ?_\n  convert cfg.sbtw_B_A\u2081_C.dist_lt_max_dist _\n  change _ = max (dist (cfg.triangleABC.points 1) _) (dist (cfg.triangleABC.points 2) _)\n  simp_rw [circumsphere_center, circumsphere_radius, dist_circumcenter_eq_circumradius, max_self]\n\ntheorem sbtw_B_B\u2081_B\u2082 : Sbtw \u211d cfg.B cfg.B\u2081 cfg.B\u2082 := by\n  rw [\u2190 cfg.symm_A\u2082]; exact cfg.symm.sbtw_A_A\u2081_A\u2082\n\ntheorem A\u2082_ne_A : cfg.A\u2082 \u2260 cfg.A :=\n  cfg.sbtw_A_A\u2081_A\u2082.left_ne_right.symm\n\ntheorem A\u2082_ne_P : cfg.A\u2082 \u2260 cfg.P :=\n  (cfg.sbtw_A_A\u2081_A\u2082.trans_wbtw_left_ne cfg.wbtw_A_P_A\u2081).symm\n\n\ntheorem A\u2082_ne_B : cfg.A\u2082 \u2260 cfg.B  := by\n  intro h\n  refine cfg.not_collinear_ABC ((collinear_insert_insert_of_mem_affineSpan_pair cfg.sbtw_A_A\u2081_A\u2082.left_mem_affineSpan cfg.sbtw_B_A\u2081_C.right_mem_affineSpan).subset _)\n  rw [Set.pair_comm _ cfg.A\u2081, Set.insert_comm _ cfg.A\u2081, Set.insert_comm _ cfg.A\u2081, Set.pair_comm]\n  exact Set.subset_insert _ _\n", "allTactics": true, "theorems": true, "env": 0}