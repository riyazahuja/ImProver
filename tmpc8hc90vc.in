{"cmd": "/-\nCopyright (c) 2024 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-/\nimport Mathlib.Data.NNReal.Basic\n\nimport ProblemExtraction\n\nproblem_file {\n  tags := [.Algebra],\n  importedFrom :=\n    \"https://github.com/leanprover-community/mathlib4/blob/master/Archive/Imo/Imo1986Q5.lean\",\n}\n\n/-!\n# International Mathematical Olympiad 1986, Problem 5\n\nFind all functions `f`, defined on the non-negative real numbers and taking nonnegative real values,\nsuch that:\n\n- $f(xf(y))f(y) = f(x + y)$ for all $x, y \\ge 0$,\n- $f(2) = 0$,\n- $f(x) \\ne 0$ for $0 \\le x < 2$.\n-/\n\nopen scoped NNReal\n\nnamespace Imo1986P5\n\nstructure IsGood (f : \u211d\u22650 \u2192 \u211d\u22650) : Prop where\n  map_add_rev x y : f (x * f y) * f y = f (x + y)\n  map_two : f 2 = 0\n  map_ne_zero : \u2200 x < 2, f x \u2260 0\n\nsnip begin\nnamespace IsGood\n\n/-\nNote that this formalization relies on the fact that Mathlib uses 0 as the \"garbage value\",\nnamely for `2 \u2264 x` we have `2 - x = 0` and `2 / (2 - x) = 0`.\n\nFormalization is based on\n[Art of Problem Solving](https://artofproblemsolving.com/wiki/index.php/1986_IMO_Problems/Problem_5)\nwith minor modifications.\n-/\n\nvariable {f : \u211d\u22650 \u2192 \u211d\u22650} (hf : IsGood f) {x y : \u211d\u22650}\n\ntheorem map_add (x y : \u211d\u22650) : f (x + y) = f (x * f y) * f y :=\n  (hf.map_add_rev x y).symm\n"}

{"cmd": "theorem map_eq_zero : f x = 0 \u2194 2 \u2264 x := by\n  refine \u27e8fun hx\u2080 \u21a6 not_lt.1 fun hlt \u21a6 hf.map_ne_zero x hlt hx\u2080, fun hle \u21a6 ?_\u27e9\n  rcases exists_add_of_le hle with \u27e8x, rfl\u27e9\n  rw [add_comm, hf.map_add, hf.map_two, mul_zero]\n\ntheorem map_ne_zero_iff : f x \u2260 0 \u2194 x < 2 := by simp [hf.map_eq_zero]\n\ntheorem map_of_lt_two (hx : x < 2) : f x = 2 / (2 - x) := by\n  have hx' : 2 - x \u2260 0 := (tsub_pos_of_lt hx).ne'\n  have hfx : f x \u2260 0 := hf.map_ne_zero_iff.2 hx\n  apply le_antisymm\n  \u00b7 rw [NNReal.le_div_iff hx', \u2190 NNReal.le_div_iff' hfx, tsub_le_iff_right, \u2190 hf.map_eq_zero,\n     hf.map_add, div_mul_cancel\u2080 _ hfx, hf.map_two, zero_mul]\n  \u00b7 rw [NNReal.div_le_iff' hx', \u2190 hf.map_eq_zero]\n    refine (mul_eq_zero.1 ?_).resolve_right hfx\n    rw [hf.map_add_rev, hf.map_eq_zero, tsub_add_cancel_of_le hx.le]\n\ntheorem map_eq (x : \u211d\u22650) : f x = 2 / (2 - x) :=\n  match lt_or_le x 2 with\n  | .inl hx => hf.map_of_lt_two hx\n  | .inr hx => by rwa [tsub_eq_zero_of_le hx, div_zero, hf.map_eq_zero]\n\nend IsGood\nsnip end\n\ndetermine SolutionSet : Set (\u211d\u22650 \u2192 \u211d\u22650) := { fun x \u21a6 2 / (2 - x) }\n\n\nproblem imo1986_p5 {f : \u211d\u22650 \u2192 \u211d\u22650} : IsGood f \u2194 f \u2208 SolutionSet  := by\n  refine \u27e8fun hf \u21a6 funext hf.map_eq, ?_\u27e9\n  rintro rfl\n  constructor\n  exact fun _ _ => by cases lt_or_le _ 2; simp [tsub_add_eq_tsub_tsub_swap, div_mul_div_comm, mul_tsub] <|> auto\n  exact fun x y => le_trans (not_lt.1 y) le_add_left\n  simp\n", "allTactics": true, "theorems": true, "env": 0}

{"cmd": "theorem map_eq_zero : f x = 0 \u2194 2 \u2264 x := by\n  refine \u27e8fun hx\u2080 \u21a6 not_lt.1 fun hlt \u21a6 hf.map_ne_zero x hlt hx\u2080, fun hle \u21a6 ?_\u27e9\n  rcases exists_add_of_le hle with \u27e8x, rfl\u27e9\n  rw [add_comm, hf.map_add, hf.map_two, mul_zero]\n\ntheorem map_ne_zero_iff : f x \u2260 0 \u2194 x < 2 := by simp [hf.map_eq_zero]\n\ntheorem map_of_lt_two (hx : x < 2) : f x = 2 / (2 - x) := by\n  have hx' : 2 - x \u2260 0 := (tsub_pos_of_lt hx).ne'\n  have hfx : f x \u2260 0 := hf.map_ne_zero_iff.2 hx\n  apply le_antisymm\n  \u00b7 rw [NNReal.le_div_iff hx', \u2190 NNReal.le_div_iff' hfx, tsub_le_iff_right, \u2190 hf.map_eq_zero,\n     hf.map_add, div_mul_cancel\u2080 _ hfx, hf.map_two, zero_mul]\n  \u00b7 rw [NNReal.div_le_iff' hx', \u2190 hf.map_eq_zero]\n    refine (mul_eq_zero.1 ?_).resolve_right hfx\n    rw [hf.map_add_rev, hf.map_eq_zero, tsub_add_cancel_of_le hx.le]\n\ntheorem map_eq (x : \u211d\u22650) : f x = 2 / (2 - x) :=\n  match lt_or_le x 2 with\n  | .inl hx => hf.map_of_lt_two hx\n  | .inr hx => by rwa [tsub_eq_zero_of_le hx, div_zero, hf.map_eq_zero]\n\nend IsGood\nsnip end\n\ndetermine SolutionSet : Set (\u211d\u22650 \u2192 \u211d\u22650) := { fun x \u21a6 2 / (2 - x) }\n\n\nproblem imo1986_p5 {f : \u211d\u22650 \u2192 \u211d\u22650} : IsGood f \u2194 f \u2208 SolutionSet  := by\n  refine \u27e8fun hf \u21a6 funext hf.map_eq, ?_\u27e9\n  rintro rfl\n  constructor\n  case map_two => simp\n  case map_ne_zero => intro x hx; simpa [tsub_eq_zero_iff_le]\n  case map_add_rev =>\n  intros x y\n  by_cases hy : y < 2\n  case inl =>\n  have hy' : 2 - y \u2260 0 := (tsub_pos_of_lt hy).ne'\n  rw [div_mul_div_comm, tsub_mul, div_mul_cancel\u2080 _ hy', mul_comm x, \u2190 mul_tsub, tsub_add_eq_tsub_tsub_swap, mul_div_mul_left _ _ two_ne_zero]\n  case inr =>\n  have : 2 \u2264 x + y := le_add_left (not_lt.1 hy)\n", "allTactics": true, "theorems": true, "env": 0}

{"cmd": "theorem map_eq_zero : f x = 0 \u2194 2 \u2264 x := by\n  refine \u27e8fun hx\u2080 \u21a6 not_lt.1 fun hlt \u21a6 hf.map_ne_zero x hlt hx\u2080, fun hle \u21a6 ?_\u27e9\n  rcases exists_add_of_le hle with \u27e8x, rfl\u27e9\n  rw [add_comm, hf.map_add, hf.map_two, mul_zero]\n\ntheorem map_ne_zero_iff : f x \u2260 0 \u2194 x < 2 := by simp [hf.map_eq_zero]\n\ntheorem map_of_lt_two (hx : x < 2) : f x = 2 / (2 - x) := by\n  have hx' : 2 - x \u2260 0 := (tsub_pos_of_lt hx).ne'\n  have hfx : f x \u2260 0 := hf.map_ne_zero_iff.2 hx\n  apply le_antisymm\n  \u00b7 rw [NNReal.le_div_iff hx', \u2190 NNReal.le_div_iff' hfx, tsub_le_iff_right, \u2190 hf.map_eq_zero,\n     hf.map_add, div_mul_cancel\u2080 _ hfx, hf.map_two, zero_mul]\n  \u00b7 rw [NNReal.div_le_iff' hx', \u2190 hf.map_eq_zero]\n    refine (mul_eq_zero.1 ?_).resolve_right hfx\n    rw [hf.map_add_rev, hf.map_eq_zero, tsub_add_cancel_of_le hx.le]\n\ntheorem map_eq (x : \u211d\u22650) : f x = 2 / (2 - x) :=\n  match lt_or_le x 2 with\n  | .inl hx => hf.map_of_lt_two hx\n  | .inr hx => by rwa [tsub_eq_zero_of_le hx, div_zero, hf.map_eq_zero]\n\nend IsGood\nsnip end\n\ndetermine SolutionSet : Set (\u211d\u22650 \u2192 \u211d\u22650) := { fun x \u21a6 2 / (2 - x) }\n\n\nproblem imo1986_p5 {f : \u211d\u22650 \u2192 \u211d\u22650} : IsGood f \u2194 f \u2208 SolutionSet  := by\n  refine \u27e8fun hf \u21a6 funext hf.map_eq, ?_\u27e9\n  rintro rfl\n  constructor\n  case map_two => simp\n  case map_ne_zero => intro x hx; simpa [tsub_eq_zero_iff_le]\n  case map_add_rev =>\n  intro x y\n  cases lt_or_le y 2 with\n  | inl hy =>\n    rw [div_mul_div_comm, tsub_mul, mul_assoc, div_mul_cancel\u2080 _ (tsub_pos_of_lt hy).ne', mul_comm x,\n      \u2190 mul_tsub, tsub_add_eq_tsub_tsub_swap, mul_div_mul_left _ _ two_ne_zero]\n  | inr hy =>\n    have : 2 \u2264 x + y := le_add_left hy\n", "allTactics": true, "theorems": true, "env": 0}