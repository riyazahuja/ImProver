{"cmd": "/-\nCopyright (c) 2018 Scott Morrison. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Scott Morrison, Markus Himmel, Bhavik Mehta, Andrew Yang, Emily Riehl\n-/\nimport Mathlib.CategoryTheory.Limits.Shapes.WidePullbacks\nimport Mathlib.CategoryTheory.Limits.Shapes.BinaryProducts\n\n#align_import category_theory.limits.shapes.pullbacks from \"leanprover-community/mathlib\"@\"7316286ff2942aa14e540add9058c6b0aa1c8070\"\n\n/-!\n# Pullbacks\n\nWe define a category `WalkingCospan` (resp. `WalkingSpan`), which is the index category\nfor the given data for a pullback (resp. pushout) diagram. Convenience methods `cospan f g`\nand `span f g` construct functors from the walking (co)span, hitting the given morphisms.\n\nWe define `pullback f g` and `pushout f g` as limits and colimits of such functors.\n\n## References\n* [Stacks: Fibre products](https://stacks.math.columbia.edu/tag/001U)\n* [Stacks: Pushouts](https://stacks.math.columbia.edu/tag/0025)\n-/\n\n\nnoncomputable section\n\nopen CategoryTheory\n\nuniverse w v\u2081 v\u2082 v u u\u2082\n\nnamespace CategoryTheory.Limits\n\n-- attribute [local tidy] tactic.case_bash Porting note: no tidy, no local\n\n/-- The type of objects for the diagram indexing a pullback, defined as a special case of\n`WidePullbackShape`. -/\nabbrev WalkingCospan : Type :=\n  WidePullbackShape WalkingPair\n#align category_theory.limits.walking_cospan CategoryTheory.Limits.WalkingCospan\n\n/-- The left point of the walking cospan. -/\n@[match_pattern]\nabbrev WalkingCospan.left : WalkingCospan :=\n  some WalkingPair.left\n#align category_theory.limits.walking_cospan.left CategoryTheory.Limits.WalkingCospan.left\n\n/-- The right point of the walking cospan. -/\n@[match_pattern]\nabbrev WalkingCospan.right : WalkingCospan :=\n  some WalkingPair.right\n#align category_theory.limits.walking_cospan.right CategoryTheory.Limits.WalkingCospan.right\n\n/-- The central point of the walking cospan. -/\n@[match_pattern]\nabbrev WalkingCospan.one : WalkingCospan :=\n  none\n#align category_theory.limits.walking_cospan.one CategoryTheory.Limits.WalkingCospan.one\n\n/-- The type of objects for the diagram indexing a pushout, defined as a special case of\n`WidePushoutShape`.\n-/\nabbrev WalkingSpan : Type :=\n  WidePushoutShape WalkingPair\n#align category_theory.limits.walking_span CategoryTheory.Limits.WalkingSpan\n\n/-- The left point of the walking span. -/\n@[match_pattern]\nabbrev WalkingSpan.left : WalkingSpan :=\n  some WalkingPair.left\n#align category_theory.limits.walking_span.left CategoryTheory.Limits.WalkingSpan.left\n\n/-- The right point of the walking span. -/\n@[match_pattern]\nabbrev WalkingSpan.right : WalkingSpan :=\n  some WalkingPair.right\n#align category_theory.limits.walking_span.right CategoryTheory.Limits.WalkingSpan.right\n\n/-- The central point of the walking span. -/\n@[match_pattern]\nabbrev WalkingSpan.zero : WalkingSpan :=\n  none\n#align category_theory.limits.walking_span.zero CategoryTheory.Limits.WalkingSpan.zero\n\nnamespace WalkingCospan\n\n/-- The type of arrows for the diagram indexing a pullback. -/\nabbrev Hom : WalkingCospan \u2192 WalkingCospan \u2192 Type :=\n  WidePullbackShape.Hom\n#align category_theory.limits.walking_cospan.hom CategoryTheory.Limits.WalkingCospan.Hom\n\n/-- The left arrow of the walking cospan. -/\n@[match_pattern]\nabbrev Hom.inl : left \u27f6 one :=\n  WidePullbackShape.Hom.term _\n#align category_theory.limits.walking_cospan.hom.inl CategoryTheory.Limits.WalkingCospan.Hom.inl\n\n/-- The right arrow of the walking cospan. -/\n@[match_pattern]\nabbrev Hom.inr : right \u27f6 one :=\n  WidePullbackShape.Hom.term _\n#align category_theory.limits.walking_cospan.hom.inr CategoryTheory.Limits.WalkingCospan.Hom.inr\n\n/-- The identity arrows of the walking cospan. -/\n@[match_pattern]\nabbrev Hom.id (X : WalkingCospan) : X \u27f6 X :=\n  WidePullbackShape.Hom.id X\n#align category_theory.limits.walking_cospan.hom.id CategoryTheory.Limits.WalkingCospan.Hom.id\n"}

{"cmd": "instance (X Y : WalkingCospan) : Subsingleton (X \u27f6 Y) := by\n  constructor; intros; simp [eq_iff_true_of_subsingleton]\n\nend WalkingCospan\n\nnamespace WalkingSpan\n\n/-- The type of arrows for the diagram indexing a pushout. -/\nabbrev Hom : WalkingSpan \u2192 WalkingSpan \u2192 Type :=\n  WidePushoutShape.Hom\n#align category_theory.limits.walking_span.hom CategoryTheory.Limits.WalkingSpan.Hom\n\n/-- The left arrow of the walking span. -/\n@[match_pattern]\nabbrev Hom.fst : zero \u27f6 left :=\n  WidePushoutShape.Hom.init _\n#align category_theory.limits.walking_span.hom.fst CategoryTheory.Limits.WalkingSpan.Hom.fst\n\n/-- The right arrow of the walking span. -/\n@[match_pattern]\nabbrev Hom.snd : zero \u27f6 right :=\n  WidePushoutShape.Hom.init _\n#align category_theory.limits.walking_span.hom.snd CategoryTheory.Limits.WalkingSpan.Hom.snd\n\n/-- The identity arrows of the walking span. -/\n@[match_pattern]\nabbrev Hom.id (X : WalkingSpan) : X \u27f6 X :=\n  WidePushoutShape.Hom.id X\n#align category_theory.limits.walking_span.hom.id CategoryTheory.Limits.WalkingSpan.Hom.id\n\ninstance (X Y : WalkingSpan) : Subsingleton (X \u27f6 Y) := by\n  constructor; intros a b; simp [eq_iff_true_of_subsingleton]\n\nend WalkingSpan\n\nopen WalkingSpan.Hom WalkingCospan.Hom WidePullbackShape.Hom WidePushoutShape.Hom\n\nvariable {C : Type u} [Category.{v} C]\n\n/-- To construct an isomorphism of cones over the walking cospan,\nit suffices to construct an isomorphism\nof the cone points and check it commutes with the legs to `left` and `right`. -/\ndef WalkingCospan.ext {F : WalkingCospan \u2964 C} {s t : Cone F} (i : s.pt \u2245 t.pt)\n    (w\u2081 : s.\u03c0.app WalkingCospan.left = i.hom \u226b t.\u03c0.app WalkingCospan.left)\n    (w\u2082 : s.\u03c0.app WalkingCospan.right = i.hom \u226b t.\u03c0.app WalkingCospan.right) : s \u2245 t := by\n  apply Cones.ext i _\n  rintro (\u27e8\u27e9 | \u27e8\u27e8\u27e9\u27e9)\n  \u00b7 have h\u2081 := s.\u03c0.naturality WalkingCospan.Hom.inl\n    dsimp at h\u2081\n    simp only [Category.id_comp] at h\u2081\n    have h\u2082 := t.\u03c0.naturality WalkingCospan.Hom.inl\n    dsimp at h\u2082\n    simp only [Category.id_comp] at h\u2082\n    simp_rw [h\u2082, \u2190 Category.assoc, \u2190 w\u2081, \u2190 h\u2081]\n  \u00b7 exact w\u2081\n  \u00b7 exact w\u2082\n#align category_theory.limits.walking_cospan.ext CategoryTheory.Limits.WalkingCospan.ext\n\n/-- To construct an isomorphism of cocones over the walking span,\nit suffices to construct an isomorphism\nof the cocone points and check it commutes with the legs from `left` and `right`. -/\ndef WalkingSpan.ext {F : WalkingSpan \u2964 C} {s t : Cocone F} (i : s.pt \u2245 t.pt)\n    (w\u2081 : s.\u03b9.app WalkingCospan.left \u226b i.hom = t.\u03b9.app WalkingCospan.left)\n    (w\u2082 : s.\u03b9.app WalkingCospan.right \u226b i.hom = t.\u03b9.app WalkingCospan.right) : s \u2245 t := by\n  apply Cocones.ext i _\n  rintro (\u27e8\u27e9 | \u27e8\u27e8\u27e9\u27e9)\n  \u00b7 have h\u2081 := s.\u03b9.naturality WalkingSpan.Hom.fst\n    dsimp at h\u2081\n    simp only [Category.comp_id] at h\u2081\n    have h\u2082 := t.\u03b9.naturality WalkingSpan.Hom.fst\n    dsimp at h\u2082\n    simp only [Category.comp_id] at h\u2082\n    simp_rw [\u2190 h\u2081, Category.assoc, w\u2081, h\u2082]\n  \u00b7 exact w\u2081\n  \u00b7 exact w\u2082\n#align category_theory.limits.walking_span.ext CategoryTheory.Limits.WalkingSpan.ext\n\n/-- `cospan f g` is the functor from the walking cospan hitting `f` and `g`. -/\ndef cospan {X Y Z : C} (f : X \u27f6 Z) (g : Y \u27f6 Z) : WalkingCospan \u2964 C :=\n  WidePullbackShape.wideCospan Z (fun j => WalkingPair.casesOn j X Y) fun j =>\n    WalkingPair.casesOn j f g\n#align category_theory.limits.cospan CategoryTheory.Limits.cospan\n\n/-- `span f g` is the functor from the walking span hitting `f` and `g`. -/\ndef span {X Y Z : C} (f : X \u27f6 Y) (g : X \u27f6 Z) : WalkingSpan \u2964 C :=\n  WidePushoutShape.wideSpan X (fun j => WalkingPair.casesOn j Y Z) fun j =>\n    WalkingPair.casesOn j f g\n#align category_theory.limits.span CategoryTheory.Limits.span\n\n@[simp]\ntheorem cospan_left {X Y Z : C} (f : X \u27f6 Z) (g : Y \u27f6 Z) : (cospan f g).obj WalkingCospan.left = X :=\n  rfl\n#align category_theory.limits.cospan_left CategoryTheory.Limits.cospan_left\n\n@[simp]\ntheorem span_left {X Y Z : C} (f : X \u27f6 Y) (g : X \u27f6 Z) : (span f g).obj WalkingSpan.left = Y :=\n  rfl\n#align category_theory.limits.span_left CategoryTheory.Limits.span_left\n\n@[simp]\ntheorem cospan_right {X Y Z : C} (f : X \u27f6 Z) (g : Y \u27f6 Z) :\n    (cospan f g).obj WalkingCospan.right = Y := rfl\n#align category_theory.limits.cospan_right CategoryTheory.Limits.cospan_right\n\n@[simp]\ntheorem span_right {X Y Z : C} (f : X \u27f6 Y) (g : X \u27f6 Z) : (span f g).obj WalkingSpan.right = Z :=\n  rfl\n#align category_theory.limits.span_right CategoryTheory.Limits.span_right\n\n@[simp]\ntheorem cospan_one {X Y Z : C} (f : X \u27f6 Z) (g : Y \u27f6 Z) : (cospan f g).obj WalkingCospan.one = Z :=\n  rfl\n#align category_theory.limits.cospan_one CategoryTheory.Limits.cospan_one\n\n@[simp]\ntheorem span_zero {X Y Z : C} (f : X \u27f6 Y) (g : X \u27f6 Z) : (span f g).obj WalkingSpan.zero = X :=\n  rfl\n#align category_theory.limits.span_zero CategoryTheory.Limits.span_zero\n\n@[simp]\ntheorem cospan_map_inl {X Y Z : C} (f : X \u27f6 Z) (g : Y \u27f6 Z) :\n    (cospan f g).map WalkingCospan.Hom.inl = f := rfl\n#align category_theory.limits.cospan_map_inl CategoryTheory.Limits.cospan_map_inl\n\n@[simp]\ntheorem span_map_fst {X Y Z : C} (f : X \u27f6 Y) (g : X \u27f6 Z) : (span f g).map WalkingSpan.Hom.fst = f :=\n  rfl\n#align category_theory.limits.span_map_fst CategoryTheory.Limits.span_map_fst\n\n@[simp]\ntheorem cospan_map_inr {X Y Z : C} (f : X \u27f6 Z) (g : Y \u27f6 Z) :\n    (cospan f g).map WalkingCospan.Hom.inr = g := rfl\n#align category_theory.limits.cospan_map_inr CategoryTheory.Limits.cospan_map_inr\n\n@[simp]\ntheorem span_map_snd {X Y Z : C} (f : X \u27f6 Y) (g : X \u27f6 Z) : (span f g).map WalkingSpan.Hom.snd = g :=\n  rfl\n#align category_theory.limits.span_map_snd CategoryTheory.Limits.span_map_snd\n\ntheorem cospan_map_id {X Y Z : C} (f : X \u27f6 Z) (g : Y \u27f6 Z) (w : WalkingCospan) :\n    (cospan f g).map (WalkingCospan.Hom.id w) = \ud835\udfd9 _ := rfl\n#align category_theory.limits.cospan_map_id CategoryTheory.Limits.cospan_map_id\n\ntheorem span_map_id {X Y Z : C} (f : X \u27f6 Y) (g : X \u27f6 Z) (w : WalkingSpan) :\n    (span f g).map (WalkingSpan.Hom.id w) = \ud835\udfd9 _ := rfl\n#align category_theory.limits.span_map_id CategoryTheory.Limits.span_map_id\n\n/-- Every diagram indexing a pullback is naturally isomorphic (actually, equal) to a `cospan` -/\n-- @[simps (config := { rhsMd := semireducible })]  Porting note: no semireducible\n@[simps!]\ndef diagramIsoCospan (F : WalkingCospan \u2964 C) : F \u2245 cospan (F.map inl) (F.map inr) :=\n  NatIso.ofComponents\n  (fun j => eqToIso (by rcases j with (\u27e8\u27e9 | \u27e8\u27e8\u27e9\u27e9) <;> rfl))\n  (by rintro (\u27e8\u27e9 | \u27e8\u27e8\u27e9\u27e9) (\u27e8\u27e9 | \u27e8\u27e8\u27e9\u27e9) f <;> cases f <;> dsimp <;> simp)\n#align category_theory.limits.diagram_iso_cospan CategoryTheory.Limits.diagramIsoCospan\n\n/-- Every diagram indexing a pushout is naturally isomorphic (actually, equal) to a `span` -/\n-- @[simps (config := { rhsMd := semireducible })]  Porting note: no semireducible\n@[simps!]\ndef diagramIsoSpan (F : WalkingSpan \u2964 C) : F \u2245 span (F.map fst) (F.map snd) :=\n  NatIso.ofComponents\n  (fun j => eqToIso (by rcases j with (\u27e8\u27e9 | \u27e8\u27e8\u27e9\u27e9) <;> rfl))\n  (by rintro (\u27e8\u27e9 | \u27e8\u27e8\u27e9\u27e9) (\u27e8\u27e9 | \u27e8\u27e8\u27e9\u27e9) f <;> cases f <;> dsimp <;> simp)\n#align category_theory.limits.diagram_iso_span CategoryTheory.Limits.diagramIsoSpan\n\nvariable {D : Type u\u2082} [Category.{v\u2082} D]\n\n/-- A functor applied to a cospan is a cospan. -/\ndef cospanCompIso (F : C \u2964 D) {X Y Z : C} (f : X \u27f6 Z) (g : Y \u27f6 Z) :\n    cospan f g \u22d9 F \u2245 cospan (F.map f) (F.map g) :=\n  NatIso.ofComponents (by rintro (\u27e8\u27e9 | \u27e8\u27e8\u27e9\u27e9) <;> exact Iso.refl _)\n    (by rintro (\u27e8\u27e9 | \u27e8\u27e8\u27e9\u27e9) (\u27e8\u27e9 | \u27e8\u27e8\u27e9\u27e9) f <;> cases f <;> dsimp <;> simp)\n#align category_theory.limits.cospan_comp_iso CategoryTheory.Limits.cospanCompIso\n\nsection\n\nvariable (F : C \u2964 D) {X Y Z : C} (f : X \u27f6 Z) (g : Y \u27f6 Z)\n\n@[simp]\ntheorem cospanCompIso_app_left : (cospanCompIso F f g).app WalkingCospan.left = Iso.refl _ := rfl\n#align category_theory.limits.cospan_comp_iso_app_left CategoryTheory.Limits.cospanCompIso_app_left\n\n@[simp]\ntheorem cospanCompIso_app_right : (cospanCompIso F f g).app WalkingCospan.right = Iso.refl _ :=\n  rfl\n#align category_theory.limits.cospan_comp_iso_app_right CategoryTheory.Limits.cospanCompIso_app_right\n\n@[simp]\ntheorem cospanCompIso_app_one : (cospanCompIso F f g).app WalkingCospan.one = Iso.refl _ := rfl\n#align category_theory.limits.cospan_comp_iso_app_one CategoryTheory.Limits.cospanCompIso_app_one\n\n@[simp]\ntheorem cospanCompIso_hom_app_left : (cospanCompIso F f g).hom.app WalkingCospan.left = \ud835\udfd9 _ :=\n  rfl\n#align category_theory.limits.cospan_comp_iso_hom_app_left CategoryTheory.Limits.cospanCompIso_hom_app_left\n\n@[simp]\ntheorem cospanCompIso_hom_app_right : (cospanCompIso F f g).hom.app WalkingCospan.right = \ud835\udfd9 _ :=\n  rfl\n#align category_theory.limits.cospan_comp_iso_hom_app_right CategoryTheory.Limits.cospanCompIso_hom_app_right\n\n@[simp]\ntheorem cospanCompIso_hom_app_one : (cospanCompIso F f g).hom.app WalkingCospan.one = \ud835\udfd9 _ := rfl\n#align category_theory.limits.cospan_comp_iso_hom_app_one CategoryTheory.Limits.cospanCompIso_hom_app_one\n\n@[simp]\ntheorem cospanCompIso_inv_app_left : (cospanCompIso F f g).inv.app WalkingCospan.left = \ud835\udfd9 _ :=\n  rfl\n#align category_theory.limits.cospan_comp_iso_inv_app_left CategoryTheory.Limits.cospanCompIso_inv_app_left\n\n@[simp]\ntheorem cospanCompIso_inv_app_right : (cospanCompIso F f g).inv.app WalkingCospan.right = \ud835\udfd9 _ :=\n  rfl\n#align category_theory.limits.cospan_comp_iso_inv_app_right CategoryTheory.Limits.cospanCompIso_inv_app_right\n\n@[simp]\ntheorem cospanCompIso_inv_app_one : (cospanCompIso F f g).inv.app WalkingCospan.one = \ud835\udfd9 _ := rfl\n#align category_theory.limits.cospan_comp_iso_inv_app_one CategoryTheory.Limits.cospanCompIso_inv_app_one\n\nend\n\n/-- A functor applied to a span is a span. -/\ndef spanCompIso (F : C \u2964 D) {X Y Z : C} (f : X \u27f6 Y) (g : X \u27f6 Z) :\n    span f g \u22d9 F \u2245 span (F.map f) (F.map g) :=\n  NatIso.ofComponents (by rintro (\u27e8\u27e9 | \u27e8\u27e8\u27e9\u27e9) <;> exact Iso.refl _)\n    (by rintro (\u27e8\u27e9 | \u27e8\u27e8\u27e9\u27e9) (\u27e8\u27e9 | \u27e8\u27e8\u27e9\u27e9) f <;> cases f <;> dsimp <;> simp)\n#align category_theory.limits.span_comp_iso CategoryTheory.Limits.spanCompIso\n\nsection\n\nvariable (F : C \u2964 D) {X Y Z : C} (f : X \u27f6 Y) (g : X \u27f6 Z)\n\n@[simp]\ntheorem spanCompIso_app_left : (spanCompIso F f g).app WalkingSpan.left = Iso.refl _ := rfl\n#align category_theory.limits.span_comp_iso_app_left CategoryTheory.Limits.spanCompIso_app_left\n\n@[simp]\ntheorem spanCompIso_app_right : (spanCompIso F f g).app WalkingSpan.right = Iso.refl _ := rfl\n#align category_theory.limits.span_comp_iso_app_right CategoryTheory.Limits.spanCompIso_app_right\n\n@[simp]\ntheorem spanCompIso_app_zero : (spanCompIso F f g).app WalkingSpan.zero = Iso.refl _ := rfl\n#align category_theory.limits.span_comp_iso_app_zero CategoryTheory.Limits.spanCompIso_app_zero\n\n@[simp]\ntheorem spanCompIso_hom_app_left : (spanCompIso F f g).hom.app WalkingSpan.left = \ud835\udfd9 _ := rfl\n#align category_theory.limits.span_comp_iso_hom_app_left CategoryTheory.Limits.spanCompIso_hom_app_left\n\n@[simp]\ntheorem spanCompIso_hom_app_right : (spanCompIso F f g).hom.app WalkingSpan.right = \ud835\udfd9 _ := rfl\n#align category_theory.limits.span_comp_iso_hom_app_right CategoryTheory.Limits.spanCompIso_hom_app_right\n\n@[simp]\ntheorem spanCompIso_hom_app_zero : (spanCompIso F f g).hom.app WalkingSpan.zero = \ud835\udfd9 _ := rfl\n#align category_theory.limits.span_comp_iso_hom_app_zero CategoryTheory.Limits.spanCompIso_hom_app_zero\n\n@[simp]\ntheorem spanCompIso_inv_app_left : (spanCompIso F f g).inv.app WalkingSpan.left = \ud835\udfd9 _ := rfl\n#align category_theory.limits.span_comp_iso_inv_app_left CategoryTheory.Limits.spanCompIso_inv_app_left\n\n@[simp]\ntheorem spanCompIso_inv_app_right : (spanCompIso F f g).inv.app WalkingSpan.right = \ud835\udfd9 _ := rfl\n#align category_theory.limits.span_comp_iso_inv_app_right CategoryTheory.Limits.spanCompIso_inv_app_right\n\n@[simp]\ntheorem spanCompIso_inv_app_zero : (spanCompIso F f g).inv.app WalkingSpan.zero = \ud835\udfd9 _ := rfl\n#align category_theory.limits.span_comp_iso_inv_app_zero CategoryTheory.Limits.spanCompIso_inv_app_zero\n\nend\n\nsection\n\nvariable {X Y Z X' Y' Z' : C} (iX : X \u2245 X') (iY : Y \u2245 Y') (iZ : Z \u2245 Z')\n\nsection\n\nvariable {f : X \u27f6 Z} {g : Y \u27f6 Z} {f' : X' \u27f6 Z'} {g' : Y' \u27f6 Z'}\n\n/-- Construct an isomorphism of cospans from components. -/\ndef cospanExt (wf : iX.hom \u226b f' = f \u226b iZ.hom) (wg : iY.hom \u226b g' = g \u226b iZ.hom) :\n    cospan f g \u2245 cospan f' g' :=\n  NatIso.ofComponents\n    (by rintro (\u27e8\u27e9 | \u27e8\u27e8\u27e9\u27e9); exacts [iZ, iX, iY])\n    (by rintro (\u27e8\u27e9 | \u27e8\u27e8\u27e9\u27e9) (\u27e8\u27e9 | \u27e8\u27e8\u27e9\u27e9) f <;> cases f <;> dsimp <;> simp [wf, wg])\n#align category_theory.limits.cospan_ext CategoryTheory.Limits.cospanExt\n\nvariable (wf : iX.hom \u226b f' = f \u226b iZ.hom) (wg : iY.hom \u226b g' = g \u226b iZ.hom)\n\n@[simp]\ntheorem cospanExt_app_left : (cospanExt iX iY iZ wf wg).app WalkingCospan.left = iX := by\n  dsimp [cospanExt]\n#align category_theory.limits.cospan_ext_app_left CategoryTheory.Limits.cospanExt_app_left\n\n@[simp]\ntheorem cospanExt_app_right : (cospanExt iX iY iZ wf wg).app WalkingCospan.right = iY := by\n  dsimp [cospanExt]\n#align category_theory.limits.cospan_ext_app_right CategoryTheory.Limits.cospanExt_app_right\n\n@[simp]\ntheorem cospanExt_app_one : (cospanExt iX iY iZ wf wg).app WalkingCospan.one = iZ := by\n  dsimp [cospanExt]\n#align category_theory.limits.cospan_ext_app_one CategoryTheory.Limits.cospanExt_app_one\n\n@[simp]\ntheorem cospanExt_hom_app_left :\n    (cospanExt iX iY iZ wf wg).hom.app WalkingCospan.left = iX.hom := by dsimp [cospanExt]\n#align category_theory.limits.cospan_ext_hom_app_left CategoryTheory.Limits.cospanExt_hom_app_left\n\n@[simp]\ntheorem cospanExt_hom_app_right :\n    (cospanExt iX iY iZ wf wg).hom.app WalkingCospan.right = iY.hom := by dsimp [cospanExt]\n#align category_theory.limits.cospan_ext_hom_app_right CategoryTheory.Limits.cospanExt_hom_app_right\n\n@[simp]\ntheorem cospanExt_hom_app_one : (cospanExt iX iY iZ wf wg).hom.app WalkingCospan.one = iZ.hom := by\n  dsimp [cospanExt]\n#align category_theory.limits.cospan_ext_hom_app_one CategoryTheory.Limits.cospanExt_hom_app_one\n\n@[simp]\ntheorem cospanExt_inv_app_left :\n    (cospanExt iX iY iZ wf wg).inv.app WalkingCospan.left = iX.inv := by dsimp [cospanExt]\n#align category_theory.limits.cospan_ext_inv_app_left CategoryTheory.Limits.cospanExt_inv_app_left\n\n@[simp]\ntheorem cospanExt_inv_app_right :\n    (cospanExt iX iY iZ wf wg).inv.app WalkingCospan.right = iY.inv := by dsimp [cospanExt]\n#align category_theory.limits.cospan_ext_inv_app_right CategoryTheory.Limits.cospanExt_inv_app_right\n\n@[simp]\ntheorem cospanExt_inv_app_one : (cospanExt iX iY iZ wf wg).inv.app WalkingCospan.one = iZ.inv := by\n  dsimp [cospanExt]\n#align category_theory.limits.cospan_ext_inv_app_one CategoryTheory.Limits.cospanExt_inv_app_one\n\nend\n\nsection\n\nvariable {f : X \u27f6 Y} {g : X \u27f6 Z} {f' : X' \u27f6 Y'} {g' : X' \u27f6 Z'}\n\n/-- Construct an isomorphism of spans from components. -/\ndef spanExt (wf : iX.hom \u226b f' = f \u226b iY.hom) (wg : iX.hom \u226b g' = g \u226b iZ.hom) :\n    span f g \u2245 span f' g' :=\n  NatIso.ofComponents (by rintro (\u27e8\u27e9 | \u27e8\u27e8\u27e9\u27e9); exacts [iX, iY, iZ])\n    (by rintro (\u27e8\u27e9 | \u27e8\u27e8\u27e9\u27e9) (\u27e8\u27e9 | \u27e8\u27e8\u27e9\u27e9) f <;> cases f <;> dsimp <;> simp [wf, wg])\n#align category_theory.limits.span_ext CategoryTheory.Limits.spanExt\n\nvariable (wf : iX.hom \u226b f' = f \u226b iY.hom) (wg : iX.hom \u226b g' = g \u226b iZ.hom)\n\n@[simp]\ntheorem spanExt_app_left : (spanExt iX iY iZ wf wg).app WalkingSpan.left = iY := by\n  dsimp [spanExt]\n#align category_theory.limits.span_ext_app_left CategoryTheory.Limits.spanExt_app_left\n\n@[simp]\ntheorem spanExt_app_right : (spanExt iX iY iZ wf wg).app WalkingSpan.right = iZ := by\n  dsimp [spanExt]\n#align category_theory.limits.span_ext_app_right CategoryTheory.Limits.spanExt_app_right\n\n@[simp]\ntheorem spanExt_app_one : (spanExt iX iY iZ wf wg).app WalkingSpan.zero = iX := by\n  dsimp [spanExt]\n#align category_theory.limits.span_ext_app_one CategoryTheory.Limits.spanExt_app_one\n\n@[simp]\ntheorem spanExt_hom_app_left : (spanExt iX iY iZ wf wg).hom.app WalkingSpan.left = iY.hom := by\n  dsimp [spanExt]\n#align category_theory.limits.span_ext_hom_app_left CategoryTheory.Limits.spanExt_hom_app_left\n\n@[simp]\ntheorem spanExt_hom_app_right : (spanExt iX iY iZ wf wg).hom.app WalkingSpan.right = iZ.hom := by\n  dsimp [spanExt]\n#align category_theory.limits.span_ext_hom_app_right CategoryTheory.Limits.spanExt_hom_app_right\n\n@[simp]\ntheorem spanExt_hom_app_zero : (spanExt iX iY iZ wf wg).hom.app WalkingSpan.zero = iX.hom := by\n  dsimp [spanExt]\n#align category_theory.limits.span_ext_hom_app_zero CategoryTheory.Limits.spanExt_hom_app_zero\n\n@[simp]\ntheorem spanExt_inv_app_left : (spanExt iX iY iZ wf wg).inv.app WalkingSpan.left = iY.inv := by\n  dsimp [spanExt]\n#align category_theory.limits.span_ext_inv_app_left CategoryTheory.Limits.spanExt_inv_app_left\n\n@[simp]\ntheorem spanExt_inv_app_right : (spanExt iX iY iZ wf wg).inv.app WalkingSpan.right = iZ.inv := by\n  dsimp [spanExt]\n#align category_theory.limits.span_ext_inv_app_right CategoryTheory.Limits.spanExt_inv_app_right\n\n@[simp]\ntheorem spanExt_inv_app_zero : (spanExt iX iY iZ wf wg).inv.app WalkingSpan.zero = iX.inv := by\n  dsimp [spanExt]\n#align category_theory.limits.span_ext_inv_app_zero CategoryTheory.Limits.spanExt_inv_app_zero\n\nend\n\nend\n\nvariable {W X Y Z : C}\n\n/-- A pullback cone is just a cone on the cospan formed by two morphisms `f : X \u27f6 Z` and\n    `g : Y \u27f6 Z`. -/\nabbrev PullbackCone (f : X \u27f6 Z) (g : Y \u27f6 Z) :=\n  Cone (cospan f g)\n#align category_theory.limits.pullback_cone CategoryTheory.Limits.PullbackCone\n\nnamespace PullbackCone\n\nvariable {f : X \u27f6 Z} {g : Y \u27f6 Z}\n\n/-- The first projection of a pullback cone. -/\nabbrev fst (t : PullbackCone f g) : t.pt \u27f6 X :=\n  t.\u03c0.app WalkingCospan.left\n#align category_theory.limits.pullback_cone.fst CategoryTheory.Limits.PullbackCone.fst\n\n/-- The second projection of a pullback cone. -/\nabbrev snd (t : PullbackCone f g) : t.pt \u27f6 Y :=\n  t.\u03c0.app WalkingCospan.right\n#align category_theory.limits.pullback_cone.snd CategoryTheory.Limits.PullbackCone.snd\n\n@[simp]\ntheorem \u03c0_app_left (c : PullbackCone f g) : c.\u03c0.app WalkingCospan.left = c.fst := rfl\n#align category_theory.limits.pullback_cone.\u03c0_app_left CategoryTheory.Limits.PullbackCone.\u03c0_app_left\n\n@[simp]\ntheorem \u03c0_app_right (c : PullbackCone f g) : c.\u03c0.app WalkingCospan.right = c.snd := rfl\n#align category_theory.limits.pullback_cone.\u03c0_app_right CategoryTheory.Limits.PullbackCone.\u03c0_app_right\n\n@[simp]\ntheorem condition_one (t : PullbackCone f g) : t.\u03c0.app WalkingCospan.one = t.fst \u226b f := by\n  have w := t.\u03c0.naturality WalkingCospan.Hom.inl\n  dsimp at w; simpa using w\n#align category_theory.limits.pullback_cone.condition_one CategoryTheory.Limits.PullbackCone.condition_one\n\n/-- This is a slightly more convenient method to verify that a pullback cone is a limit cone. It\n    only asks for a proof of facts that carry any mathematical content -/\ndef isLimitAux (t : PullbackCone f g) (lift : \u2200 s : PullbackCone f g, s.pt \u27f6 t.pt)\n    (fac_left : \u2200 s : PullbackCone f g, lift s \u226b t.fst = s.fst)\n    (fac_right : \u2200 s : PullbackCone f g, lift s \u226b t.snd = s.snd)\n    (uniq : \u2200 (s : PullbackCone f g) (m : s.pt \u27f6 t.pt)\n      (_ : \u2200 j : WalkingCospan, m \u226b t.\u03c0.app j = s.\u03c0.app j), m = lift s) : IsLimit t :=\n  { lift\n    fac := fun s j => Option.casesOn j (by\n        rw [\u2190 s.w inl, \u2190 t.w inl, \u2190 Category.assoc]\n        congr\n        exact fac_left s)\n      fun j' => WalkingPair.casesOn j' (fac_left s) (fac_right s)\n    uniq := uniq }\n#align category_theory.limits.pullback_cone.is_limit_aux CategoryTheory.Limits.PullbackCone.isLimitAux\n\n/-- This is another convenient method to verify that a pullback cone is a limit cone. It\n    only asks for a proof of facts that carry any mathematical content, and allows access to the\n    same `s` for all parts. -/\ndef isLimitAux' (t : PullbackCone f g)\n    (create :\n      \u2200 s : PullbackCone f g,\n        { l //\n          l \u226b t.fst = s.fst \u2227\n            l \u226b t.snd = s.snd \u2227 \u2200 {m}, m \u226b t.fst = s.fst \u2192 m \u226b t.snd = s.snd \u2192 m = l }) :\n    Limits.IsLimit t :=\n  PullbackCone.isLimitAux t (fun s => (create s).1) (fun s => (create s).2.1)\n    (fun s => (create s).2.2.1) fun s _ w =>\n    (create s).2.2.2 (w WalkingCospan.left) (w WalkingCospan.right)\n#align category_theory.limits.pullback_cone.is_limit_aux' CategoryTheory.Limits.PullbackCone.isLimitAux'\n\n/-- A pullback cone on `f` and `g` is determined by morphisms `fst : W \u27f6 X` and `snd : W \u27f6 Y`\n    such that `fst \u226b f = snd \u226b g`. -/\n@[simps]\ndef mk {W : C} (fst : W \u27f6 X) (snd : W \u27f6 Y) (eq : fst \u226b f = snd \u226b g) : PullbackCone f g where\n  pt := W\n  \u03c0 := { app := fun j => Option.casesOn j (fst \u226b f) fun j' => WalkingPair.casesOn j' fst snd\n         naturality := by rintro (\u27e8\u27e9 | \u27e8\u27e8\u27e9\u27e9) (\u27e8\u27e9 | \u27e8\u27e8\u27e9\u27e9) j <;> cases j <;> dsimp <;> simp [eq] }\n#align category_theory.limits.pullback_cone.mk CategoryTheory.Limits.PullbackCone.mk\n\n@[simp]\ntheorem mk_\u03c0_app_left {W : C} (fst : W \u27f6 X) (snd : W \u27f6 Y) (eq : fst \u226b f = snd \u226b g) :\n    (mk fst snd eq).\u03c0.app WalkingCospan.left = fst := rfl\n#align category_theory.limits.pullback_cone.mk_\u03c0_app_left CategoryTheory.Limits.PullbackCone.mk_\u03c0_app_left\n\n@[simp]\ntheorem mk_\u03c0_app_right {W : C} (fst : W \u27f6 X) (snd : W \u27f6 Y) (eq : fst \u226b f = snd \u226b g) :\n    (mk fst snd eq).\u03c0.app WalkingCospan.right = snd := rfl\n#align category_theory.limits.pullback_cone.mk_\u03c0_app_right CategoryTheory.Limits.PullbackCone.mk_\u03c0_app_right\n\n@[simp]\ntheorem mk_\u03c0_app_one {W : C} (fst : W \u27f6 X) (snd : W \u27f6 Y) (eq : fst \u226b f = snd \u226b g) :\n    (mk fst snd eq).\u03c0.app WalkingCospan.one = fst \u226b f := rfl\n#align category_theory.limits.pullback_cone.mk_\u03c0_app_one CategoryTheory.Limits.PullbackCone.mk_\u03c0_app_one\n\n@[simp]\ntheorem mk_fst {W : C} (fst : W \u27f6 X) (snd : W \u27f6 Y) (eq : fst \u226b f = snd \u226b g) :\n    (mk fst snd eq).fst = fst := rfl\n#align category_theory.limits.pullback_cone.mk_fst CategoryTheory.Limits.PullbackCone.mk_fst\n\n@[simp]\ntheorem mk_snd {W : C} (fst : W \u27f6 X) (snd : W \u27f6 Y) (eq : fst \u226b f = snd \u226b g) :\n    (mk fst snd eq).snd = snd := rfl\n#align category_theory.limits.pullback_cone.mk_snd CategoryTheory.Limits.PullbackCone.mk_snd\n\n@[reassoc]\ntheorem condition (t : PullbackCone f g) : fst t \u226b f = snd t \u226b g :=\n  (t.w inl).trans (t.w inr).symm\n#align category_theory.limits.pullback_cone.condition CategoryTheory.Limits.PullbackCone.condition\n\n/-- To check whether a morphism is equalized by the maps of a pullback cone, it suffices to check\n  it for `fst t` and `snd t` -/\ntheorem equalizer_ext (t : PullbackCone f g) {W : C} {k l : W \u27f6 t.pt} (h\u2080 : k \u226b fst t = l \u226b fst t)\n    (h\u2081 : k \u226b snd t = l \u226b snd t) : \u2200 j : WalkingCospan, k \u226b t.\u03c0.app j = l \u226b t.\u03c0.app j\n  | some WalkingPair.left => h\u2080\n  | some WalkingPair.right => h\u2081\n  | none => by rw [\u2190 t.w inl, reassoc_of% h\u2080]\n#align category_theory.limits.pullback_cone.equalizer_ext CategoryTheory.Limits.PullbackCone.equalizer_ext\n\ntheorem IsLimit.hom_ext {t : PullbackCone f g} (ht : IsLimit t) {W : C} {k l : W \u27f6 t.pt}\n    (h\u2080 : k \u226b fst t = l \u226b fst t) (h\u2081 : k \u226b snd t = l \u226b snd t) : k = l :=\n  ht.hom_ext <| equalizer_ext _ h\u2080 h\u2081\n#align category_theory.limits.pullback_cone.is_limit.hom_ext CategoryTheory.Limits.PullbackCone.IsLimit.hom_ext\n\ntheorem mono_snd_of_is_pullback_of_mono {t : PullbackCone f g} (ht : IsLimit t) [Mono f] :\n    Mono t.snd := by\n  refine \u27e8fun {W} h k i => IsLimit.hom_ext ht ?_ i\u27e9\n  rw [\u2190 cancel_mono f, Category.assoc, Category.assoc, condition]\n  have := congrArg (\u00b7 \u226b g) i; dsimp at this\n  rwa [Category.assoc, Category.assoc] at this\n#align category_theory.limits.pullback_cone.mono_snd_of_is_pullback_of_mono CategoryTheory.Limits.PullbackCone.mono_snd_of_is_pullback_of_mono\n\ntheorem mono_fst_of_is_pullback_of_mono {t : PullbackCone f g} (ht : IsLimit t) [Mono g] :\n    Mono t.fst := by\n  refine \u27e8fun {W} h k i => IsLimit.hom_ext ht i ?_\u27e9\n  rw [\u2190 cancel_mono g, Category.assoc, Category.assoc, \u2190 condition]\n  have := congrArg (\u00b7 \u226b f) i; dsimp at this\n  rwa [Category.assoc, Category.assoc] at this\n#align category_theory.limits.pullback_cone.mono_fst_of_is_pullback_of_mono CategoryTheory.Limits.PullbackCone.mono_fst_of_is_pullback_of_mono\n\n/-- To construct an isomorphism of pullback cones, it suffices to construct an isomorphism\nof the cone points and check it commutes with `fst` and `snd`. -/\ndef ext {s t : PullbackCone f g} (i : s.pt \u2245 t.pt) (w\u2081 : s.fst = i.hom \u226b t.fst)\n    (w\u2082 : s.snd = i.hom \u226b t.snd) : s \u2245 t :=\n  WalkingCospan.ext i w\u2081 w\u2082\n#align category_theory.limits.pullback_cone.ext CategoryTheory.Limits.PullbackCone.ext\n\n-- Porting note: `IsLimit.lift` and the two following simp lemmas were introduced to ease the port\n/-- If `t` is a limit pullback cone over `f` and `g` and `h : W \u27f6 X` and `k : W \u27f6 Y` are such that\n    `h \u226b f = k \u226b g`, then we get `l : W \u27f6 t.pt`, which satisfies `l \u226b fst t = h`\n    and `l \u226b snd t = k`, see `IsLimit.lift_fst` and `IsLimit.lift_snd`. -/\ndef IsLimit.lift {t : PullbackCone f g} (ht : IsLimit t) {W : C} (h : W \u27f6 X) (k : W \u27f6 Y)\n    (w : h \u226b f = k \u226b g) : W \u27f6 t.pt :=\n  ht.lift <| PullbackCone.mk _ _ w\n\n@[reassoc (attr := simp)]\nlemma IsLimit.lift_fst {t : PullbackCone f g} (ht : IsLimit t) {W : C} (h : W \u27f6 X) (k : W \u27f6 Y)\n    (w : h \u226b f = k \u226b g) : IsLimit.lift ht h k w \u226b fst t = h := ht.fac _ _\n\n@[reassoc (attr := simp)]\nlemma IsLimit.lift_snd {t : PullbackCone f g} (ht : IsLimit t) {W : C} (h : W \u27f6 X) (k : W \u27f6 Y)\n    (w : h \u226b f = k \u226b g) : IsLimit.lift ht h k w \u226b snd t = k := ht.fac _ _\n\n/-- If `t` is a limit pullback cone over `f` and `g` and `h : W \u27f6 X` and `k : W \u27f6 Y` are such that\n    `h \u226b f = k \u226b g`, then we have `l : W \u27f6 t.pt` satisfying `l \u226b fst t = h` and `l \u226b snd t = k`.\n    -/\ndef IsLimit.lift' {t : PullbackCone f g} (ht : IsLimit t) {W : C} (h : W \u27f6 X) (k : W \u27f6 Y)\n    (w : h \u226b f = k \u226b g) : { l : W \u27f6 t.pt // l \u226b fst t = h \u2227 l \u226b snd t = k } :=\n  \u27e8IsLimit.lift ht h k w, by simp\u27e9\n#align category_theory.limits.pullback_cone.is_limit.lift' CategoryTheory.Limits.PullbackCone.IsLimit.lift'\n\n/-- This is a more convenient formulation to show that a `PullbackCone` constructed using\n`PullbackCone.mk` is a limit cone.\n-/\ndef IsLimit.mk {W : C} {fst : W \u27f6 X} {snd : W \u27f6 Y} (eq : fst \u226b f = snd \u226b g)\n    (lift : \u2200 s : PullbackCone f g, s.pt \u27f6 W)\n    (fac_left : \u2200 s : PullbackCone f g, lift s \u226b fst = s.fst)\n    (fac_right : \u2200 s : PullbackCone f g, lift s \u226b snd = s.snd)\n    (uniq :\n      \u2200 (s : PullbackCone f g) (m : s.pt \u27f6 W) (_ : m \u226b fst = s.fst) (_ : m \u226b snd = s.snd),\n        m = lift s) :\n    IsLimit (mk fst snd eq) :=\n  isLimitAux _ lift fac_left fac_right fun s m w =>\n    uniq s m (w WalkingCospan.left) (w WalkingCospan.right)\n#align category_theory.limits.pullback_cone.is_limit.mk CategoryTheory.Limits.PullbackCone.IsLimit.mk\n\nsection Flip\n\nvariable (t : PullbackCone f g)\n\n/-- The pullback cone obtained by flipping `fst` and `snd`. -/\ndef flip : PullbackCone g f := PullbackCone.mk _ _ t.condition.symm\n\n@[simp] lemma flip_pt : t.flip.pt = t.pt := rfl\n@[simp] lemma flip_fst : t.flip.fst = t.snd := rfl\n@[simp] lemma flip_snd : t.flip.snd = t.fst := rfl\n\n/-- Flipping a pullback cone twice gives an isomorphic cone. -/\ndef flipFlipIso : t.flip.flip \u2245 t := PullbackCone.ext (Iso.refl _) (by simp) (by simp)\n\nvariable {t}\n\n/-- The flip of a pullback square is a pullback square. -/\ndef flipIsLimit (ht : IsLimit t) : IsLimit t.flip :=\n  IsLimit.mk _ (fun s => ht.lift s.flip) (by simp) (by simp) (fun s m h\u2081 h\u2082 => by\n    apply IsLimit.hom_ext ht\n    all_goals aesop_cat)\n\n/-- A square is a pullback square if its flip is. -/\ndef isLimitOfFlip (ht : IsLimit t.flip) : IsLimit t :=\n  IsLimit.ofIsoLimit (flipIsLimit ht) t.flipFlipIso\n#align category_theory.limits.pullback_cone.flip_is_limit CategoryTheory.Limits.PullbackCone.isLimitOfFlip\n\nend Flip\n\n/--\nThe pullback cone `(\ud835\udfd9 X, \ud835\udfd9 X)` for the pair `(f, f)` is a limit if `f` is a mono. The converse is\nshown in `mono_of_pullback_is_id`.\n-/\ndef isLimitMkIdId (f : X \u27f6 Y) [Mono f] : IsLimit (mk (\ud835\udfd9 X) (\ud835\udfd9 X) rfl : PullbackCone f f) :=\n  IsLimit.mk _ (fun s => s.fst) (fun s => Category.comp_id _)\n    (fun s => by rw [\u2190 cancel_mono f, Category.comp_id, s.condition]) fun s m m\u2081 _ => by\n    simpa using m\u2081\n#align category_theory.limits.pullback_cone.is_limit_mk_id_id CategoryTheory.Limits.PullbackCone.isLimitMkIdId\n\n/--\n`f` is a mono if the pullback cone `(\ud835\udfd9 X, \ud835\udfd9 X)` is a limit for the pair `(f, f)`. The converse is\ngiven in `PullbackCone.is_id_of_mono`.\n-/\ntheorem mono_of_isLimitMkIdId (f : X \u27f6 Y) (t : IsLimit (mk (\ud835\udfd9 X) (\ud835\udfd9 X) rfl : PullbackCone f f)) :\n    Mono f :=\n  \u27e8fun {Z} g h eq => by\n    rcases PullbackCone.IsLimit.lift' t _ _ eq with \u27e8_, rfl, rfl\u27e9\n    rfl\u27e9\n#align category_theory.limits.pullback_cone.mono_of_is_limit_mk_id_id CategoryTheory.Limits.PullbackCone.mono_of_isLimitMkIdId\n\n/-- Suppose `f` and `g` are two morphisms with a common codomain and `s` is a limit cone over the\n    diagram formed by `f` and `g`. Suppose `f` and `g` both factor through a monomorphism `h` via\n    `x` and `y`, respectively.  Then `s` is also a limit cone over the diagram formed by `x` and\n    `y`.  -/\ndef isLimitOfFactors (f : X \u27f6 Z) (g : Y \u27f6 Z) (h : W \u27f6 Z) [Mono h] (x : X \u27f6 W) (y : Y \u27f6 W)\n    (hxh : x \u226b h = f) (hyh : y \u226b h = g) (s : PullbackCone f g) (hs : IsLimit s) :\n    IsLimit\n      (PullbackCone.mk _ _\n        (show s.fst \u226b x = s.snd \u226b y from\n          (cancel_mono h).1 <| by simp only [Category.assoc, hxh, hyh, s.condition])) :=\n  PullbackCone.isLimitAux' _ fun t =>\n    have : fst t \u226b x \u226b h = snd t \u226b y \u226b h := by  -- Porting note: reassoc workaround\n      rw [\u2190 Category.assoc, \u2190 Category.assoc]\n      apply congrArg (\u00b7 \u226b h) t.condition\n    \u27e8hs.lift (PullbackCone.mk t.fst t.snd <| by rw [\u2190 hxh, \u2190 hyh, this]),\n      \u27e8hs.fac _ WalkingCospan.left, hs.fac _ WalkingCospan.right, fun hr hr' => by\n        apply PullbackCone.IsLimit.hom_ext hs <;>\n              simp only [PullbackCone.mk_fst, PullbackCone.mk_snd] at hr hr' \u22a2 <;>\n            simp only [hr, hr'] <;>\n          symm\n        exacts [hs.fac _ WalkingCospan.left, hs.fac _ WalkingCospan.right]\u27e9\u27e9\n#align category_theory.limits.pullback_cone.is_limit_of_factors CategoryTheory.Limits.PullbackCone.isLimitOfFactors\n\n/-- If `W` is the pullback of `f, g`,\nit is also the pullback of `f \u226b i, g \u226b i` for any mono `i`. -/\ndef isLimitOfCompMono (f : X \u27f6 W) (g : Y \u27f6 W) (i : W \u27f6 Z) [Mono i] (s : PullbackCone f g)\n    (H : IsLimit s) :\n    IsLimit\n      (PullbackCone.mk _ _\n        (show s.fst \u226b f \u226b i = s.snd \u226b g \u226b i by\n          rw [\u2190 Category.assoc, \u2190 Category.assoc, s.condition])) := by\n  apply PullbackCone.isLimitAux'\n  intro s\n  rcases PullbackCone.IsLimit.lift' H s.fst s.snd\n      ((cancel_mono i).mp (by simpa using s.condition)) with\n    \u27e8l, h\u2081, h\u2082\u27e9\n  refine \u27e8l, h\u2081, h\u2082, ?_\u27e9\n  intro m hm\u2081 hm\u2082\n  exact (PullbackCone.IsLimit.hom_ext H (hm\u2081.trans h\u2081.symm) (hm\u2082.trans h\u2082.symm) : _)\n#align category_theory.limits.pullback_cone.is_limit_of_comp_mono CategoryTheory.Limits.PullbackCone.isLimitOfCompMono\n\nend PullbackCone\n\n/-- A pushout cocone is just a cocone on the span formed by two morphisms `f : X \u27f6 Y` and\n    `g : X \u27f6 Z`. -/\nabbrev PushoutCocone (f : X \u27f6 Y) (g : X \u27f6 Z) :=\n  Cocone (span f g)\n#align category_theory.limits.pushout_cocone CategoryTheory.Limits.PushoutCocone\n\nnamespace PushoutCocone\n\nvariable {f : X \u27f6 Y} {g : X \u27f6 Z}\n\n/-- The first inclusion of a pushout cocone. -/\nabbrev inl (t : PushoutCocone f g) : Y \u27f6 t.pt :=\n  t.\u03b9.app WalkingSpan.left\n#align category_theory.limits.pushout_cocone.inl CategoryTheory.Limits.PushoutCocone.inl\n\n/-- The second inclusion of a pushout cocone. -/\nabbrev inr (t : PushoutCocone f g) : Z \u27f6 t.pt :=\n  t.\u03b9.app WalkingSpan.right\n#align category_theory.limits.pushout_cocone.inr CategoryTheory.Limits.PushoutCocone.inr\n\n@[simp]\ntheorem \u03b9_app_left (c : PushoutCocone f g) : c.\u03b9.app WalkingSpan.left = c.inl := rfl\n#align category_theory.limits.pushout_cocone.\u03b9_app_left CategoryTheory.Limits.PushoutCocone.\u03b9_app_left\n\n@[simp]\ntheorem \u03b9_app_right (c : PushoutCocone f g) : c.\u03b9.app WalkingSpan.right = c.inr := rfl\n#align category_theory.limits.pushout_cocone.\u03b9_app_right CategoryTheory.Limits.PushoutCocone.\u03b9_app_right\n\n@[simp]\ntheorem condition_zero (t : PushoutCocone f g) : t.\u03b9.app WalkingSpan.zero = f \u226b t.inl := by\n  have w := t.\u03b9.naturality WalkingSpan.Hom.fst\n  dsimp at w; simpa using w.symm\n#align category_theory.limits.pushout_cocone.condition_zero CategoryTheory.Limits.PushoutCocone.condition_zero\n\n/-- This is a slightly more convenient method to verify that a pushout cocone is a colimit cocone.\n    It only asks for a proof of facts that carry any mathematical content -/\ndef isColimitAux (t : PushoutCocone f g) (desc : \u2200 s : PushoutCocone f g, t.pt \u27f6 s.pt)\n    (fac_left : \u2200 s : PushoutCocone f g, t.inl \u226b desc s = s.inl)\n    (fac_right : \u2200 s : PushoutCocone f g, t.inr \u226b desc s = s.inr)\n    (uniq : \u2200 (s : PushoutCocone f g) (m : t.pt \u27f6 s.pt)\n    (_ : \u2200 j : WalkingSpan, t.\u03b9.app j \u226b m = s.\u03b9.app j), m = desc s) : IsColimit t :=\n  { desc\n    fac := fun s j =>\n      Option.casesOn j (by simp [\u2190 s.w fst, \u2190 t.w fst, fac_left s]) fun j' =>\n        WalkingPair.casesOn j' (fac_left s) (fac_right s)\n    uniq := uniq }\n#align category_theory.limits.pushout_cocone.is_colimit_aux CategoryTheory.Limits.PushoutCocone.isColimitAux\n\n/-- This is another convenient method to verify that a pushout cocone is a colimit cocone. It\n    only asks for a proof of facts that carry any mathematical content, and allows access to the\n    same `s` for all parts. -/\ndef isColimitAux' (t : PushoutCocone f g)\n    (create :\n      \u2200 s : PushoutCocone f g,\n        { l //\n          t.inl \u226b l = s.inl \u2227\n            t.inr \u226b l = s.inr \u2227 \u2200 {m}, t.inl \u226b m = s.inl \u2192 t.inr \u226b m = s.inr \u2192 m = l }) :\n    IsColimit t :=\n  isColimitAux t (fun s => (create s).1) (fun s => (create s).2.1) (fun s => (create s).2.2.1)\n    fun s _ w => (create s).2.2.2 (w WalkingCospan.left) (w WalkingCospan.right)\n#align category_theory.limits.pushout_cocone.is_colimit_aux' CategoryTheory.Limits.PushoutCocone.isColimitAux'\n\n/-- A pushout cocone on `f` and `g` is determined by morphisms `inl : Y \u27f6 W` and `inr : Z \u27f6 W` such\n    that `f \u226b inl = g \u21a0 inr`. -/\n@[simps]\ndef mk {W : C} (inl : Y \u27f6 W) (inr : Z \u27f6 W) (eq : f \u226b inl = g \u226b inr) : PushoutCocone f g where\n  pt := W\n  \u03b9 := { app := fun j => Option.casesOn j (f \u226b inl) fun j' => WalkingPair.casesOn j' inl inr\n         naturality := by\n          rintro (\u27e8\u27e9|\u27e8\u27e8\u27e9\u27e9) (\u27e8\u27e9|\u27e8\u27e8\u27e9\u27e9) <;> intro f <;> cases f <;> dsimp <;> aesop }\n#align category_theory.limits.pushout_cocone.mk CategoryTheory.Limits.PushoutCocone.mk\n\n@[simp]\ntheorem mk_\u03b9_app_left {W : C} (inl : Y \u27f6 W) (inr : Z \u27f6 W) (eq : f \u226b inl = g \u226b inr) :\n    (mk inl inr eq).\u03b9.app WalkingSpan.left = inl := rfl\n#align category_theory.limits.pushout_cocone.mk_\u03b9_app_left CategoryTheory.Limits.PushoutCocone.mk_\u03b9_app_left\n\n@[simp]\ntheorem mk_\u03b9_app_right {W : C} (inl : Y \u27f6 W) (inr : Z \u27f6 W) (eq : f \u226b inl = g \u226b inr) :\n    (mk inl inr eq).\u03b9.app WalkingSpan.right = inr := rfl\n#align category_theory.limits.pushout_cocone.mk_\u03b9_app_right CategoryTheory.Limits.PushoutCocone.mk_\u03b9_app_right\n\n@[simp]\ntheorem mk_\u03b9_app_zero {W : C} (inl : Y \u27f6 W) (inr : Z \u27f6 W) (eq : f \u226b inl = g \u226b inr) :\n    (mk inl inr eq).\u03b9.app WalkingSpan.zero = f \u226b inl := rfl\n#align category_theory.limits.pushout_cocone.mk_\u03b9_app_zero CategoryTheory.Limits.PushoutCocone.mk_\u03b9_app_zero\n\n@[simp]\ntheorem mk_inl {W : C} (inl : Y \u27f6 W) (inr : Z \u27f6 W) (eq : f \u226b inl = g \u226b inr) :\n    (mk inl inr eq).inl = inl := rfl\n#align category_theory.limits.pushout_cocone.mk_inl CategoryTheory.Limits.PushoutCocone.mk_inl\n\n@[simp]\ntheorem mk_inr {W : C} (inl : Y \u27f6 W) (inr : Z \u27f6 W) (eq : f \u226b inl = g \u226b inr) :\n    (mk inl inr eq).inr = inr := rfl\n#align category_theory.limits.pushout_cocone.mk_inr CategoryTheory.Limits.PushoutCocone.mk_inr\n\n@[reassoc]\ntheorem condition (t : PushoutCocone f g) : f \u226b inl t = g \u226b inr t :=\n  (t.w fst).trans (t.w snd).symm\n#align category_theory.limits.pushout_cocone.condition CategoryTheory.Limits.PushoutCocone.condition\n\n/-- To check whether a morphism is coequalized by the maps of a pushout cocone, it suffices to check\n  it for `inl t` and `inr t` -/\ntheorem coequalizer_ext (t : PushoutCocone f g) {W : C} {k l : t.pt \u27f6 W}\n    (h\u2080 : inl t \u226b k = inl t \u226b l) (h\u2081 : inr t \u226b k = inr t \u226b l) :\n    \u2200 j : WalkingSpan, t.\u03b9.app j \u226b k = t.\u03b9.app j \u226b l\n  | some WalkingPair.left => h\u2080\n  | some WalkingPair.right => h\u2081\n  | none => by rw [\u2190 t.w fst, Category.assoc, Category.assoc, h\u2080]\n#align category_theory.limits.pushout_cocone.coequalizer_ext CategoryTheory.Limits.PushoutCocone.coequalizer_ext\n\ntheorem IsColimit.hom_ext {t : PushoutCocone f g} (ht : IsColimit t) {W : C} {k l : t.pt \u27f6 W}\n    (h\u2080 : inl t \u226b k = inl t \u226b l) (h\u2081 : inr t \u226b k = inr t \u226b l) : k = l :=\n  ht.hom_ext <| coequalizer_ext _ h\u2080 h\u2081\n#align category_theory.limits.pushout_cocone.is_colimit.hom_ext CategoryTheory.Limits.PushoutCocone.IsColimit.hom_ext\n\n-- Porting note: `IsColimit.desc` and the two following simp lemmas were introduced to ease the port\n/-- If `t` is a colimit pushout cocone over `f` and `g` and `h : Y \u27f6 W` and `k : Z \u27f6 W` are\n    morphisms satisfying `f \u226b h = g \u226b k`, then we have a factorization `l : t.pt \u27f6 W` such that\n    `inl t \u226b l = h` and `inr t \u226b l = k`, see `IsColimit.inl_desc` and `IsColimit.inr_desc`-/\ndef IsColimit.desc {t : PushoutCocone f g} (ht : IsColimit t) {W : C} (h : Y \u27f6 W) (k : Z \u27f6 W)\n    (w : f \u226b h = g \u226b k) : t.pt \u27f6 W :=\n  ht.desc (PushoutCocone.mk _ _ w)\n\n@[reassoc (attr := simp)]\nlemma IsColimit.inl_desc {t : PushoutCocone f g} (ht : IsColimit t) {W : C} (h : Y \u27f6 W) (k : Z \u27f6 W)\n    (w : f \u226b h = g \u226b k) : inl t \u226b IsColimit.desc ht h k w = h :=\n  ht.fac _ _\n\n@[reassoc (attr := simp)]\nlemma IsColimit.inr_desc {t : PushoutCocone f g} (ht : IsColimit t) {W : C} (h : Y \u27f6 W) (k : Z \u27f6 W)\n    (w : f \u226b h = g \u226b k) : inr t \u226b IsColimit.desc ht h k w = k :=\n  ht.fac _ _\n\n/-- If `t` is a colimit pushout cocone over `f` and `g` and `h : Y \u27f6 W` and `k : Z \u27f6 W` are\n    morphisms satisfying `f \u226b h = g \u226b k`, then we have a factorization `l : t.pt \u27f6 W` such that\n    `inl t \u226b l = h` and `inr t \u226b l = k`. -/\ndef IsColimit.desc' {t : PushoutCocone f g} (ht : IsColimit t) {W : C} (h : Y \u27f6 W) (k : Z \u27f6 W)\n    (w : f \u226b h = g \u226b k) : { l : t.pt \u27f6 W // inl t \u226b l = h \u2227 inr t \u226b l = k } :=\n  \u27e8IsColimit.desc ht h k w, by simp\u27e9\n#align category_theory.limits.pushout_cocone.is_colimit.desc' CategoryTheory.Limits.PushoutCocone.IsColimit.desc'\n\ntheorem epi_inr_of_is_pushout_of_epi {t : PushoutCocone f g} (ht : IsColimit t) [Epi f] :\n    Epi t.inr :=\n  \u27e8fun {W} h k i => IsColimit.hom_ext ht (by simp [\u2190 cancel_epi f, t.condition_assoc, i]) i\u27e9\n#align category_theory.limits.pushout_cocone.epi_inr_of_is_pushout_of_epi CategoryTheory.Limits.PushoutCocone.epi_inr_of_is_pushout_of_epi\n\ntheorem epi_inl_of_is_pushout_of_epi {t : PushoutCocone f g} (ht : IsColimit t) [Epi g] :\n    Epi t.inl :=\n  \u27e8fun {W} h k i => IsColimit.hom_ext ht i (by simp [\u2190 cancel_epi g, \u2190 t.condition_assoc, i])\u27e9\n#align category_theory.limits.pushout_cocone.epi_inl_of_is_pushout_of_epi CategoryTheory.Limits.PushoutCocone.epi_inl_of_is_pushout_of_epi\n\n/-- To construct an isomorphism of pushout cocones, it suffices to construct an isomorphism\nof the cocone points and check it commutes with `inl` and `inr`. -/\ndef ext {s t : PushoutCocone f g} (i : s.pt \u2245 t.pt) (w\u2081 : s.inl \u226b i.hom = t.inl)\n    (w\u2082 : s.inr \u226b i.hom = t.inr) : s \u2245 t :=\n  WalkingSpan.ext i w\u2081 w\u2082\n#align category_theory.limits.pushout_cocone.ext CategoryTheory.Limits.PushoutCocone.ext\n\n/-- This is a more convenient formulation to show that a `PushoutCocone` constructed using\n`PushoutCocone.mk` is a colimit cocone.\n-/\ndef IsColimit.mk {W : C} {inl : Y \u27f6 W} {inr : Z \u27f6 W} (eq : f \u226b inl = g \u226b inr)\n    (desc : \u2200 s : PushoutCocone f g, W \u27f6 s.pt)\n    (fac_left : \u2200 s : PushoutCocone f g, inl \u226b desc s = s.inl)\n    (fac_right : \u2200 s : PushoutCocone f g, inr \u226b desc s = s.inr)\n    (uniq :\n      \u2200 (s : PushoutCocone f g) (m : W \u27f6 s.pt) (_ : inl \u226b m = s.inl) (_ : inr \u226b m = s.inr),\n        m = desc s) :\n    IsColimit (mk inl inr eq) :=\n  isColimitAux _ desc fac_left fac_right fun s m w =>\n    uniq s m (w WalkingCospan.left) (w WalkingCospan.right)\n#align category_theory.limits.pushout_cocone.is_colimit.mk CategoryTheory.Limits.PushoutCocone.IsColimit.mk\n\nsection Flip\n\nvariable (t : PushoutCocone f g)\n\n/-- The pushout cocone obtained by flipping `inl` and `inr`. -/\ndef flip : PushoutCocone g f := PushoutCocone.mk _ _ t.condition.symm\n\n@[simp] lemma flip_pt : t.flip.pt = t.pt := rfl\n@[simp] lemma flip_inl : t.flip.inl = t.inr := rfl\n@[simp] lemma flip_inr : t.flip.inr = t.inl := rfl\n\n/-- Flipping a pushout cocone twice gives an isomorphic cocone. -/\ndef flipFlipIso : t.flip.flip \u2245 t := PushoutCocone.ext (Iso.refl _) (by simp) (by simp)\n\nvariable {t}\n\n/-- The flip of a pushout square is a pushout square. -/\ndef flipIsColimit (ht : IsColimit t) : IsColimit t.flip :=\n  IsColimit.mk _ (fun s => ht.desc s.flip) (by simp) (by simp) (fun s m h\u2081 h\u2082 => by\n    apply IsColimit.hom_ext ht\n    all_goals aesop_cat)\n\n/-- A square is a pushout square if its flip is. -/\ndef isColimitOfFlip (ht : IsColimit t.flip) : IsColimit t :=\n  IsColimit.ofIsoColimit (flipIsColimit ht) t.flipFlipIso\n#align category_theory.limits.pushout_cocone.flip_is_colimit CategoryTheory.Limits.PushoutCocone.isColimitOfFlip\n\nend Flip\n\n/--\nThe pushout cocone `(\ud835\udfd9 X, \ud835\udfd9 X)` for the pair `(f, f)` is a colimit if `f` is an epi. The converse is\nshown in `epi_of_isColimit_mk_id_id`.\n-/\ndef isColimitMkIdId (f : X \u27f6 Y) [Epi f] : IsColimit (mk (\ud835\udfd9 Y) (\ud835\udfd9 Y) rfl : PushoutCocone f f) :=\n  IsColimit.mk _ (fun s => s.inl) (fun s => Category.id_comp _)\n    (fun s => by rw [\u2190 cancel_epi f, Category.id_comp, s.condition]) fun s m m\u2081 _ => by\n    simpa using m\u2081\n#align category_theory.limits.pushout_cocone.is_colimit_mk_id_id CategoryTheory.Limits.PushoutCocone.isColimitMkIdId\n\n/-- `f` is an epi if the pushout cocone `(\ud835\udfd9 X, \ud835\udfd9 X)` is a colimit for the pair `(f, f)`.\nThe converse is given in `PushoutCocone.isColimitMkIdId`.\n-/\ntheorem epi_of_isColimitMkIdId (f : X \u27f6 Y)\n    (t : IsColimit (mk (\ud835\udfd9 Y) (\ud835\udfd9 Y) rfl : PushoutCocone f f)) : Epi f :=\n  \u27e8fun {Z} g h eq => by\n    rcases PushoutCocone.IsColimit.desc' t _ _ eq with \u27e8_, rfl, rfl\u27e9\n    rfl\u27e9\n#align category_theory.limits.pushout_cocone.epi_of_is_colimit_mk_id_id CategoryTheory.Limits.PushoutCocone.epi_of_isColimitMkIdId\n\n/-- Suppose `f` and `g` are two morphisms with a common domain and `s` is a colimit cocone over the\n    diagram formed by `f` and `g`. Suppose `f` and `g` both factor through an epimorphism `h` via\n    `x` and `y`, respectively. Then `s` is also a colimit cocone over the diagram formed by `x` and\n    `y`.  -/\ndef isColimitOfFactors (f : X \u27f6 Y) (g : X \u27f6 Z) (h : X \u27f6 W) [Epi h] (x : W \u27f6 Y) (y : W \u27f6 Z)\n    (hhx : h \u226b x = f) (hhy : h \u226b y = g) (s : PushoutCocone f g) (hs : IsColimit s) :\n    have reassoc\u2081 : h \u226b x \u226b inl s = f \u226b inl s := by  -- Porting note: working around reassoc\n      rw [\u2190 Category.assoc]; apply congrArg (\u00b7 \u226b inl s) hhx\n    have reassoc\u2082 : h \u226b y \u226b inr s = g \u226b inr s := by\n      rw [\u2190 Category.assoc]; apply congrArg (\u00b7 \u226b inr s) hhy\n    IsColimit (PushoutCocone.mk _ _ (show x \u226b s.inl = y \u226b s.inr from\n          (cancel_epi h).1 <| by rw [reassoc\u2081, reassoc\u2082, s.condition])) :=\n  PushoutCocone.isColimitAux' _ fun t => \u27e8hs.desc (PushoutCocone.mk t.inl t.inr <| by\n    rw [\u2190 hhx, \u2190 hhy, Category.assoc, Category.assoc, t.condition]),\n      \u27e8hs.fac _ WalkingSpan.left, hs.fac _ WalkingSpan.right, fun hr hr' => by\n        apply PushoutCocone.IsColimit.hom_ext hs;\n        \u00b7 simp only [PushoutCocone.mk_inl, PushoutCocone.mk_inr] at hr hr' \u22a2\n          simp only [hr, hr']\n          symm\n          exact hs.fac _ WalkingSpan.left\n        \u00b7 simp only [PushoutCocone.mk_inl, PushoutCocone.mk_inr] at hr hr' \u22a2\n          simp only [hr, hr']\n          symm\n          exact hs.fac _ WalkingSpan.right\u27e9\u27e9\n#align category_theory.limits.pushout_cocone.is_colimit_of_factors CategoryTheory.Limits.PushoutCocone.isColimitOfFactors\n\n/-- If `W` is the pushout of `f, g`,\nit is also the pushout of `h \u226b f, h \u226b g` for any epi `h`. -/\ndef isColimitOfEpiComp (f : X \u27f6 Y) (g : X \u27f6 Z) (h : W \u27f6 X) [Epi h] (s : PushoutCocone f g)\n    (H : IsColimit s) :\n    IsColimit\n      (PushoutCocone.mk _ _\n        (show (h \u226b f) \u226b s.inl = (h \u226b g) \u226b s.inr by\n          rw [Category.assoc, Category.assoc, s.condition])) := by\n  apply PushoutCocone.isColimitAux'\n  intro s\n  rcases PushoutCocone.IsColimit.desc' H s.inl s.inr\n      ((cancel_epi h).mp (by simpa using s.condition)) with\n    \u27e8l, h\u2081, h\u2082\u27e9\n  refine \u27e8l, h\u2081, h\u2082, ?_\u27e9\n  intro m hm\u2081 hm\u2082\n  exact (PushoutCocone.IsColimit.hom_ext H (hm\u2081.trans h\u2081.symm) (hm\u2082.trans h\u2082.symm) : _)\n#align category_theory.limits.pushout_cocone.is_colimit_of_epi_comp CategoryTheory.Limits.PushoutCocone.isColimitOfEpiComp\n\nend PushoutCocone\n\n/-- This is a helper construction that can be useful when verifying that a category has all\n    pullbacks. Given `F : WalkingCospan \u2964 C`, which is really the same as\n    `cospan (F.map inl) (F.map inr)`, and a pullback cone on `F.map inl` and `F.map inr`, we\n    get a cone on `F`.\n\n    If you're thinking about using this, have a look at `hasPullbacks_of_hasLimit_cospan`,\n    which you may find to be an easier way of achieving your goal. -/\n@[simps]\ndef Cone.ofPullbackCone {F : WalkingCospan \u2964 C} (t : PullbackCone (F.map inl) (F.map inr)) :\n    Cone F where\n  pt := t.pt\n  \u03c0 := t.\u03c0 \u226b (diagramIsoCospan F).inv\n#align category_theory.limits.cone.of_pullback_cone CategoryTheory.Limits.Cone.ofPullbackCone\n\n/-- This is a helper construction that can be useful when verifying that a category has all\n    pushout. Given `F : WalkingSpan \u2964 C`, which is really the same as\n    `span (F.map fst) (F.map snd)`, and a pushout cocone on `F.map fst` and `F.map snd`,\n    we get a cocone on `F`.\n\n    If you're thinking about using this, have a look at `hasPushouts_of_hasColimit_span`, which\n    you may find to be an easier way of achieving your goal. -/\n@[simps]\ndef Cocone.ofPushoutCocone {F : WalkingSpan \u2964 C} (t : PushoutCocone (F.map fst) (F.map snd)) :\n    Cocone F where\n  pt := t.pt\n  \u03b9 := (diagramIsoSpan F).hom \u226b t.\u03b9\n#align category_theory.limits.cocone.of_pushout_cocone CategoryTheory.Limits.Cocone.ofPushoutCocone\n\n/-- Given `F : WalkingCospan \u2964 C`, which is really the same as `cospan (F.map inl) (F.map inr)`,\n    and a cone on `F`, we get a pullback cone on `F.map inl` and `F.map inr`. -/\n@[simps]\ndef PullbackCone.ofCone {F : WalkingCospan \u2964 C} (t : Cone F) :\n    PullbackCone (F.map inl) (F.map inr) where\n  pt := t.pt\n  \u03c0 := t.\u03c0 \u226b (diagramIsoCospan F).hom\n#align category_theory.limits.pullback_cone.of_cone CategoryTheory.Limits.PullbackCone.ofCone\n\n/-- A diagram `WalkingCospan \u2964 C` is isomorphic to some `PullbackCone.mk` after\ncomposing with `diagramIsoCospan`. -/\n@[simps!]\ndef PullbackCone.isoMk {F : WalkingCospan \u2964 C} (t : Cone F) :\n    (Cones.postcompose (diagramIsoCospan.{v} _).hom).obj t \u2245\n      PullbackCone.mk (t.\u03c0.app WalkingCospan.left) (t.\u03c0.app WalkingCospan.right)\n        ((t.\u03c0.naturality inl).symm.trans (t.\u03c0.naturality inr : _)) :=\n  Cones.ext (Iso.refl _) <| by\n    rintro (_ | (_ | _)) <;>\n      \u00b7 dsimp\n        simp\n#align category_theory.limits.pullback_cone.iso_mk CategoryTheory.Limits.PullbackCone.isoMk\n\n/-- Given `F : WalkingSpan \u2964 C`, which is really the same as `span (F.map fst) (F.map snd)`,\n    and a cocone on `F`, we get a pushout cocone on `F.map fst` and `F.map snd`. -/\n@[simps]\ndef PushoutCocone.ofCocone {F : WalkingSpan \u2964 C} (t : Cocone F) :\n    PushoutCocone (F.map fst) (F.map snd) where\n  pt := t.pt\n  \u03b9 := (diagramIsoSpan F).inv \u226b t.\u03b9\n#align category_theory.limits.pushout_cocone.of_cocone CategoryTheory.Limits.PushoutCocone.ofCocone\n\n/-- A diagram `WalkingSpan \u2964 C` is isomorphic to some `PushoutCocone.mk` after composing with\n`diagramIsoSpan`. -/\n@[simps!]\ndef PushoutCocone.isoMk {F : WalkingSpan \u2964 C} (t : Cocone F) :\n    (Cocones.precompose (diagramIsoSpan.{v} _).inv).obj t \u2245\n      PushoutCocone.mk (t.\u03b9.app WalkingSpan.left) (t.\u03b9.app WalkingSpan.right)\n        ((t.\u03b9.naturality fst).trans (t.\u03b9.naturality snd).symm) :=\n  Cocones.ext (Iso.refl _) <| by\n    rintro (_ | (_ | _)) <;>\n      \u00b7 dsimp\n        simp\n#align category_theory.limits.pushout_cocone.iso_mk CategoryTheory.Limits.PushoutCocone.isoMk\n\n/-- `HasPullback f g` represents a particular choice of limiting cone\nfor the pair of morphisms `f : X \u27f6 Z` and `g : Y \u27f6 Z`.\n-/\nabbrev HasPullback {X Y Z : C} (f : X \u27f6 Z) (g : Y \u27f6 Z) :=\n  HasLimit (cospan f g)\n#align category_theory.limits.has_pullback CategoryTheory.Limits.HasPullback\n\n/-- `HasPushout f g` represents a particular choice of colimiting cocone\nfor the pair of morphisms `f : X \u27f6 Y` and `g : X \u27f6 Z`.\n-/\nabbrev HasPushout {X Y Z : C} (f : X \u27f6 Y) (g : X \u27f6 Z) :=\n  HasColimit (span f g)\n#align category_theory.limits.has_pushout CategoryTheory.Limits.HasPushout\n\n/-- `pullback f g` computes the pullback of a pair of morphisms with the same target. -/\nabbrev pullback {X Y Z : C} (f : X \u27f6 Z) (g : Y \u27f6 Z) [HasPullback f g] :=\n  limit (cospan f g)\n#align category_theory.limits.pullback CategoryTheory.Limits.pullback\n\n/-- `pushout f g` computes the pushout of a pair of morphisms with the same source. -/\nabbrev pushout {X Y Z : C} (f : X \u27f6 Y) (g : X \u27f6 Z) [HasPushout f g] :=\n  colimit (span f g)\n#align category_theory.limits.pushout CategoryTheory.Limits.pushout\n\n/-- The first projection of the pullback of `f` and `g`. -/\nabbrev pullback.fst {X Y Z : C} {f : X \u27f6 Z} {g : Y \u27f6 Z} [HasPullback f g] : pullback f g \u27f6 X :=\n  limit.\u03c0 (cospan f g) WalkingCospan.left\n#align category_theory.limits.pullback.fst CategoryTheory.Limits.pullback.fst\n\n/-- The second projection of the pullback of `f` and `g`. -/\nabbrev pullback.snd {X Y Z : C} {f : X \u27f6 Z} {g : Y \u27f6 Z} [HasPullback f g] : pullback f g \u27f6 Y :=\n  limit.\u03c0 (cospan f g) WalkingCospan.right\n#align category_theory.limits.pullback.snd CategoryTheory.Limits.pullback.snd\n\n/-- The first inclusion into the pushout of `f` and `g`. -/\nabbrev pushout.inl {X Y Z : C} {f : X \u27f6 Y} {g : X \u27f6 Z} [HasPushout f g] : Y \u27f6 pushout f g :=\n  colimit.\u03b9 (span f g) WalkingSpan.left\n#align category_theory.limits.pushout.inl CategoryTheory.Limits.pushout.inl\n\n/-- The second inclusion into the pushout of `f` and `g`. -/\nabbrev pushout.inr {X Y Z : C} {f : X \u27f6 Y} {g : X \u27f6 Z} [HasPushout f g] : Z \u27f6 pushout f g :=\n  colimit.\u03b9 (span f g) WalkingSpan.right\n#align category_theory.limits.pushout.inr CategoryTheory.Limits.pushout.inr\n\n/-- A pair of morphisms `h : W \u27f6 X` and `k : W \u27f6 Y` satisfying `h \u226b f = k \u226b g` induces a morphism\n    `pullback.lift : W \u27f6 pullback f g`. -/\nabbrev pullback.lift {W X Y Z : C} {f : X \u27f6 Z} {g : Y \u27f6 Z} [HasPullback f g] (h : W \u27f6 X) (k : W \u27f6 Y)\n    (w : h \u226b f = k \u226b g) : W \u27f6 pullback f g :=\n  limit.lift _ (PullbackCone.mk h k w)\n#align category_theory.limits.pullback.lift CategoryTheory.Limits.pullback.lift\n\n/-- A pair of morphisms `h : Y \u27f6 W` and `k : Z \u27f6 W` satisfying `f \u226b h = g \u226b k` induces a morphism\n    `pushout.desc : pushout f g \u27f6 W`. -/\nabbrev pushout.desc {W X Y Z : C} {f : X \u27f6 Y} {g : X \u27f6 Z} [HasPushout f g] (h : Y \u27f6 W) (k : Z \u27f6 W)\n    (w : f \u226b h = g \u226b k) : pushout f g \u27f6 W :=\n  colimit.desc _ (PushoutCocone.mk h k w)\n#align category_theory.limits.pushout.desc CategoryTheory.Limits.pushout.desc\n\n@[simp]\ntheorem PullbackCone.fst_colimit_cocone {X Y Z : C} (f : X \u27f6 Z) (g : Y \u27f6 Z)\n    [HasLimit (cospan f g)] : PullbackCone.fst (limit.cone (cospan f g)) = pullback.fst := rfl\n#align category_theory.limits.pullback_cone.fst_colimit_cocone CategoryTheory.Limits.PullbackCone.fst_colimit_cocone\n\n@[simp]\ntheorem PullbackCone.snd_colimit_cocone {X Y Z : C} (f : X \u27f6 Z) (g : Y \u27f6 Z)\n    [HasLimit (cospan f g)] : PullbackCone.snd (limit.cone (cospan f g)) = pullback.snd := rfl\n#align category_theory.limits.pullback_cone.snd_colimit_cocone CategoryTheory.Limits.PullbackCone.snd_colimit_cocone\n\n-- Porting note (#10618): simp can prove this; removed simp\ntheorem PushoutCocone.inl_colimit_cocone {X Y Z : C} (f : Z \u27f6 X) (g : Z \u27f6 Y)\n    [HasColimit (span f g)] : PushoutCocone.inl (colimit.cocone (span f g)) = pushout.inl := rfl\n#align category_theory.limits.pushout_cocone.inl_colimit_cocone CategoryTheory.Limits.PushoutCocone.inl_colimit_cocone\n\n-- Porting note (#10618): simp can prove this; removed simp\ntheorem PushoutCocone.inr_colimit_cocone {X Y Z : C} (f : Z \u27f6 X) (g : Z \u27f6 Y)\n    [HasColimit (span f g)] : PushoutCocone.inr (colimit.cocone (span f g)) = pushout.inr := rfl\n#align category_theory.limits.pushout_cocone.inr_colimit_cocone CategoryTheory.Limits.PushoutCocone.inr_colimit_cocone\n\n-- Porting note (#10618): simp can prove this and reassoced version; removed simp\n@[reassoc]\ntheorem pullback.lift_fst {W X Y Z : C} {f : X \u27f6 Z} {g : Y \u27f6 Z} [HasPullback f g] (h : W \u27f6 X)\n    (k : W \u27f6 Y) (w : h \u226b f = k \u226b g) : pullback.lift h k w \u226b pullback.fst = h :=\n  limit.lift_\u03c0 _ _\n#align category_theory.limits.pullback.lift_fst CategoryTheory.Limits.pullback.lift_fst\n\n-- Porting note (#10618): simp can prove this and reassoced version; removed simp\n@[reassoc]\ntheorem pullback.lift_snd {W X Y Z : C} {f : X \u27f6 Z} {g : Y \u27f6 Z} [HasPullback f g] (h : W \u27f6 X)\n    (k : W \u27f6 Y) (w : h \u226b f = k \u226b g) : pullback.lift h k w \u226b pullback.snd = k :=\n  limit.lift_\u03c0 _ _\n#align category_theory.limits.pullback.lift_snd CategoryTheory.Limits.pullback.lift_snd\n\n-- Porting note (#10618): simp can prove this and reassoced version; removed simp\n@[reassoc]\ntheorem pushout.inl_desc {W X Y Z : C} {f : X \u27f6 Y} {g : X \u27f6 Z} [HasPushout f g] (h : Y \u27f6 W)\n    (k : Z \u27f6 W) (w : f \u226b h = g \u226b k) : pushout.inl \u226b pushout.desc h k w = h :=\n  colimit.\u03b9_desc _ _\n#align category_theory.limits.pushout.inl_desc CategoryTheory.Limits.pushout.inl_desc\n\n-- Porting note (#10618): simp can prove this and reassoced version; removed simp\n@[reassoc]\ntheorem pushout.inr_desc {W X Y Z : C} {f : X \u27f6 Y} {g : X \u27f6 Z} [HasPushout f g] (h : Y \u27f6 W)\n    (k : Z \u27f6 W) (w : f \u226b h = g \u226b k) : pushout.inr \u226b pushout.desc h k w = k :=\n  colimit.\u03b9_desc _ _\n#align category_theory.limits.pushout.inr_desc CategoryTheory.Limits.pushout.inr_desc\n\n/-- A pair of morphisms `h : W \u27f6 X` and `k : W \u27f6 Y` satisfying `h \u226b f = k \u226b g` induces a morphism\n    `l : W \u27f6 pullback f g` such that `l \u226b pullback.fst = h` and `l \u226b pullback.snd = k`. -/\ndef pullback.lift' {W X Y Z : C} {f : X \u27f6 Z} {g : Y \u27f6 Z} [HasPullback f g] (h : W \u27f6 X) (k : W \u27f6 Y)\n    (w : h \u226b f = k \u226b g) : { l : W \u27f6 pullback f g // l \u226b pullback.fst = h \u2227 l \u226b pullback.snd = k } :=\n  \u27e8pullback.lift h k w, pullback.lift_fst _ _ _, pullback.lift_snd _ _ _\u27e9\n#align category_theory.limits.pullback.lift' CategoryTheory.Limits.pullback.lift'\n\n/-- A pair of morphisms `h : Y \u27f6 W` and `k : Z \u27f6 W` satisfying `f \u226b h = g \u226b k` induces a morphism\n    `l : pushout f g \u27f6 W` such that `pushout.inl \u226b l = h` and `pushout.inr \u226b l = k`. -/\ndef pullback.desc' {W X Y Z : C} {f : X \u27f6 Y} {g : X \u27f6 Z} [HasPushout f g] (h : Y \u27f6 W) (k : Z \u27f6 W)\n    (w : f \u226b h = g \u226b k) : { l : pushout f g \u27f6 W // pushout.inl \u226b l = h \u2227 pushout.inr \u226b l = k } :=\n  \u27e8pushout.desc h k w, pushout.inl_desc _ _ _, pushout.inr_desc _ _ _\u27e9\n#align category_theory.limits.pullback.desc' CategoryTheory.Limits.pullback.desc'\n\n@[reassoc]\ntheorem pullback.condition {X Y Z : C} {f : X \u27f6 Z} {g : Y \u27f6 Z} [HasPullback f g] :\n    (pullback.fst : pullback f g \u27f6 X) \u226b f = pullback.snd \u226b g :=\n  PullbackCone.condition _\n#align category_theory.limits.pullback.condition CategoryTheory.Limits.pullback.condition\n\n@[reassoc]\ntheorem pushout.condition {X Y Z : C} {f : X \u27f6 Y} {g : X \u27f6 Z} [HasPushout f g] :\n    f \u226b (pushout.inl : Y \u27f6 pushout f g) = g \u226b pushout.inr :=\n  PushoutCocone.condition _\n#align category_theory.limits.pushout.condition CategoryTheory.Limits.pushout.condition\n\n/-- Given such a diagram, then there is a natural morphism `W \u00d7\u209b X \u27f6 Y \u00d7\u209c Z`.\n\n    W \u27f6 Y\n      \u2198      \u2198\n        S \u27f6 T\n      \u2197      \u2197\n    X \u27f6 Z\n\n-/\nabbrev pullback.map {W X Y Z S T : C} (f\u2081 : W \u27f6 S) (f\u2082 : X \u27f6 S) [HasPullback f\u2081 f\u2082] (g\u2081 : Y \u27f6 T)\n    (g\u2082 : Z \u27f6 T) [HasPullback g\u2081 g\u2082] (i\u2081 : W \u27f6 Y) (i\u2082 : X \u27f6 Z) (i\u2083 : S \u27f6 T)\n    (eq\u2081 : f\u2081 \u226b i\u2083 = i\u2081 \u226b g\u2081) (eq\u2082 : f\u2082 \u226b i\u2083 = i\u2082 \u226b g\u2082) : pullback f\u2081 f\u2082 \u27f6 pullback g\u2081 g\u2082 :=\n  pullback.lift (pullback.fst \u226b i\u2081) (pullback.snd \u226b i\u2082)\n    (by simp [\u2190 eq\u2081, \u2190 eq\u2082, pullback.condition_assoc])\n#align category_theory.limits.pullback.map CategoryTheory.Limits.pullback.map\n\n/-- The canonical map `X \u00d7\u209b Y \u27f6 X \u00d7\u209c Y` given `S \u27f6 T`. -/\nabbrev pullback.mapDesc {X Y S T : C} (f : X \u27f6 S) (g : Y \u27f6 S) (i : S \u27f6 T) [HasPullback f g]\n    [HasPullback (f \u226b i) (g \u226b i)] : pullback f g \u27f6 pullback (f \u226b i) (g \u226b i) :=\n  pullback.map f g (f \u226b i) (g \u226b i) (\ud835\udfd9 _) (\ud835\udfd9 _) i (Category.id_comp _).symm (Category.id_comp _).symm\n#align category_theory.limits.pullback.map_desc CategoryTheory.Limits.pullback.mapDesc\n\n/-- Given such a diagram, then there is a natural morphism `W \u2a3f\u209b X \u27f6 Y \u2a3f\u209c Z`.\n\n        W \u27f6 Y\n      \u2197      \u2197\n    S \u27f6 T\n      \u2198      \u2198\n        X \u27f6 Z\n\n-/\nabbrev pushout.map {W X Y Z S T : C} (f\u2081 : S \u27f6 W) (f\u2082 : S \u27f6 X) [HasPushout f\u2081 f\u2082] (g\u2081 : T \u27f6 Y)\n    (g\u2082 : T \u27f6 Z) [HasPushout g\u2081 g\u2082] (i\u2081 : W \u27f6 Y) (i\u2082 : X \u27f6 Z) (i\u2083 : S \u27f6 T) (eq\u2081 : f\u2081 \u226b i\u2081 = i\u2083 \u226b g\u2081)\n    (eq\u2082 : f\u2082 \u226b i\u2082 = i\u2083 \u226b g\u2082) : pushout f\u2081 f\u2082 \u27f6 pushout g\u2081 g\u2082 :=\n  pushout.desc (i\u2081 \u226b pushout.inl) (i\u2082 \u226b pushout.inr)\n    (by\n      simp only [\u2190 Category.assoc, eq\u2081, eq\u2082]\n      simp [pushout.condition])\n#align category_theory.limits.pushout.map CategoryTheory.Limits.pushout.map\n\n/-- The canonical map `X \u2a3f\u209b Y \u27f6 X \u2a3f\u209c Y` given `S \u27f6 T`. -/\nabbrev pushout.mapLift {X Y S T : C} (f : T \u27f6 X) (g : T \u27f6 Y) (i : S \u27f6 T) [HasPushout f g]\n    [HasPushout (i \u226b f) (i \u226b g)] : pushout (i \u226b f) (i \u226b g) \u27f6 pushout f g :=\n  pushout.map (i \u226b f) (i \u226b g) f g (\ud835\udfd9 _) (\ud835\udfd9 _) i (Category.comp_id _) (Category.comp_id _)\n#align category_theory.limits.pushout.map_lift CategoryTheory.Limits.pushout.mapLift\n\n/-- Two morphisms into a pullback are equal if their compositions with the pullback morphisms are\n    equal -/\n@[ext 1100]\ntheorem pullback.hom_ext {X Y Z : C} {f : X \u27f6 Z} {g : Y \u27f6 Z} [HasPullback f g] {W : C}\n    {k l : W \u27f6 pullback f g} (h\u2080 : k \u226b pullback.fst = l \u226b pullback.fst)\n    (h\u2081 : k \u226b pullback.snd = l \u226b pullback.snd) : k = l :=\n  limit.hom_ext <| PullbackCone.equalizer_ext _ h\u2080 h\u2081\n#align category_theory.limits.pullback.hom_ext CategoryTheory.Limits.pullback.hom_ext\n\n/-- The pullback cone built from the pullback projections is a pullback. -/\ndef pullbackIsPullback {X Y Z : C} (f : X \u27f6 Z) (g : Y \u27f6 Z) [HasPullback f g] :\n    IsLimit (PullbackCone.mk (pullback.fst : pullback f g \u27f6 _) pullback.snd pullback.condition) :=\n  PullbackCone.IsLimit.mk _ (fun s => pullback.lift s.fst s.snd s.condition) (by simp) (by simp)\n    (by aesop_cat)\n#align category_theory.limits.pullback_is_pullback CategoryTheory.Limits.pullbackIsPullback\n\n/-- The pullback of a monomorphism is a monomorphism -/\ninstance pullback.fst_of_mono {X Y Z : C} {f : X \u27f6 Z} {g : Y \u27f6 Z} [HasPullback f g] [Mono g] :\n    Mono (pullback.fst : pullback f g \u27f6 X) :=\n  PullbackCone.mono_fst_of_is_pullback_of_mono (limit.isLimit _)\n#align category_theory.limits.pullback.fst_of_mono CategoryTheory.Limits.pullback.fst_of_mono\n\n/-- The pullback of a monomorphism is a monomorphism -/\ninstance pullback.snd_of_mono {X Y Z : C} {f : X \u27f6 Z} {g : Y \u27f6 Z} [HasPullback f g] [Mono f] :\n    Mono (pullback.snd : pullback f g \u27f6 Y) :=\n  PullbackCone.mono_snd_of_is_pullback_of_mono (limit.isLimit _)\n#align category_theory.limits.pullback.snd_of_mono CategoryTheory.Limits.pullback.snd_of_mono\n\n/-- The map `X \u00d7[Z] Y \u27f6 X \u00d7 Y` is mono. -/\ninstance mono_pullback_to_prod {C : Type*} [Category C] {X Y Z : C} (f : X \u27f6 Z) (g : Y \u27f6 Z)\n    [HasPullback f g] [HasBinaryProduct X Y] :\n    Mono (prod.lift pullback.fst pullback.snd : pullback f g \u27f6 _) :=\n  \u27e8fun {W} i\u2081 i\u2082 h => by\n    ext\n    \u00b7 simpa using congrArg (fun f => f \u226b prod.fst) h\n    \u00b7 simpa using congrArg (fun f => f \u226b prod.snd) h\u27e9\n#align category_theory.limits.mono_pullback_to_prod CategoryTheory.Limits.mono_pullback_to_prod\n\n/-- Two morphisms out of a pushout are equal if their compositions with the pushout morphisms are\n    equal -/\n@[ext 1100]\ntheorem pushout.hom_ext {X Y Z : C} {f : X \u27f6 Y} {g : X \u27f6 Z} [HasPushout f g] {W : C}\n    {k l : pushout f g \u27f6 W} (h\u2080 : pushout.inl \u226b k = pushout.inl \u226b l)\n    (h\u2081 : pushout.inr \u226b k = pushout.inr \u226b l) : k = l :=\n  colimit.hom_ext <| PushoutCocone.coequalizer_ext _ h\u2080 h\u2081\n#align category_theory.limits.pushout.hom_ext CategoryTheory.Limits.pushout.hom_ext\n\n/-- The pushout cocone built from the pushout coprojections is a pushout. -/\ndef pushoutIsPushout {X Y Z : C} (f : X \u27f6 Y) (g : X \u27f6 Z) [HasPushout f g] :\n    IsColimit (PushoutCocone.mk (pushout.inl : _ \u27f6 pushout f g) pushout.inr pushout.condition) :=\n  PushoutCocone.IsColimit.mk _ (fun s => pushout.desc s.inl s.inr s.condition) (by simp) (by simp)\n    (by aesop_cat)\n#align category_theory.limits.pushout_is_pushout CategoryTheory.Limits.pushoutIsPushout\n\n/-- The pushout of an epimorphism is an epimorphism -/\ninstance pushout.inl_of_epi {X Y Z : C} {f : X \u27f6 Y} {g : X \u27f6 Z} [HasPushout f g] [Epi g] :\n    Epi (pushout.inl : Y \u27f6 pushout f g) :=\n  PushoutCocone.epi_inl_of_is_pushout_of_epi (colimit.isColimit _)\n#align category_theory.limits.pushout.inl_of_epi CategoryTheory.Limits.pushout.inl_of_epi\n\n/-- The pushout of an epimorphism is an epimorphism -/\ninstance pushout.inr_of_epi {X Y Z : C} {f : X \u27f6 Y} {g : X \u27f6 Z} [HasPushout f g] [Epi f] :\n    Epi (pushout.inr : Z \u27f6 pushout f g) :=\n  PushoutCocone.epi_inr_of_is_pushout_of_epi (colimit.isColimit _)\n#align category_theory.limits.pushout.inr_of_epi CategoryTheory.Limits.pushout.inr_of_epi\n\n/-- The map `X \u2a3f Y \u27f6 X \u2a3f[Z] Y` is epi. -/\ninstance epi_coprod_to_pushout {C : Type*} [Category C] {X Y Z : C} (f : X \u27f6 Y) (g : X \u27f6 Z)\n    [HasPushout f g] [HasBinaryCoproduct Y Z] :\n    Epi (coprod.desc pushout.inl pushout.inr : _ \u27f6 pushout f g) :=\n  \u27e8fun {W} i\u2081 i\u2082 h => by\n    ext\n    \u00b7 simpa using congrArg (fun f => coprod.inl \u226b f) h\n    \u00b7 simpa using congrArg (fun f => coprod.inr \u226b f) h\u27e9\n#align category_theory.limits.epi_coprod_to_pushout CategoryTheory.Limits.epi_coprod_to_pushout\n\ninstance pullback.map_isIso {W X Y Z S T : C} (f\u2081 : W \u27f6 S) (f\u2082 : X \u27f6 S) [HasPullback f\u2081 f\u2082]\n    (g\u2081 : Y \u27f6 T) (g\u2082 : Z \u27f6 T) [HasPullback g\u2081 g\u2082] (i\u2081 : W \u27f6 Y) (i\u2082 : X \u27f6 Z) (i\u2083 : S \u27f6 T)\n    (eq\u2081 : f\u2081 \u226b i\u2083 = i\u2081 \u226b g\u2081) (eq\u2082 : f\u2082 \u226b i\u2083 = i\u2082 \u226b g\u2082) [IsIso i\u2081] [IsIso i\u2082] [IsIso i\u2083] :\n    IsIso (pullback.map f\u2081 f\u2082 g\u2081 g\u2082 i\u2081 i\u2082 i\u2083 eq\u2081 eq\u2082) := by\n  refine \u27e8\u27e8pullback.map _ _ _ _ (inv i\u2081) (inv i\u2082) (inv i\u2083) ?_ ?_, ?_, ?_\u27e9\u27e9\n  \u00b7 rw [IsIso.comp_inv_eq, Category.assoc, eq\u2081, IsIso.inv_hom_id_assoc]\n  \u00b7 rw [IsIso.comp_inv_eq, Category.assoc, eq\u2082, IsIso.inv_hom_id_assoc]\n  \u00b7 aesop_cat\n  \u00b7 aesop_cat\n#align category_theory.limits.pullback.map_is_iso CategoryTheory.Limits.pullback.map_isIso\n\n/-- If `f\u2081 = f\u2082` and `g\u2081 = g\u2082`, we may construct a canonical\nisomorphism `pullback f\u2081 g\u2081 \u2245 pullback f\u2082 g\u2082` -/\n@[simps! hom]\ndef pullback.congrHom {X Y Z : C} {f\u2081 f\u2082 : X \u27f6 Z} {g\u2081 g\u2082 : Y \u27f6 Z} (h\u2081 : f\u2081 = f\u2082) (h\u2082 : g\u2081 = g\u2082)\n    [HasPullback f\u2081 g\u2081] [HasPullback f\u2082 g\u2082] : pullback f\u2081 g\u2081 \u2245 pullback f\u2082 g\u2082 :=\n  asIso <| pullback.map _ _ _ _ (\ud835\udfd9 _) (\ud835\udfd9 _) (\ud835\udfd9 _) (by simp [h\u2081]) (by simp [h\u2082])\n#align category_theory.limits.pullback.congr_hom CategoryTheory.Limits.pullback.congrHom\n\n@[simp]\ntheorem pullback.congrHom_inv {X Y Z : C} {f\u2081 f\u2082 : X \u27f6 Z} {g\u2081 g\u2082 : Y \u27f6 Z} (h\u2081 : f\u2081 = f\u2082)\n    (h\u2082 : g\u2081 = g\u2082) [HasPullback f\u2081 g\u2081] [HasPullback f\u2082 g\u2082] :\n    (pullback.congrHom h\u2081 h\u2082).inv =\n      pullback.map _ _ _ _ (\ud835\udfd9 _) (\ud835\udfd9 _) (\ud835\udfd9 _) (by simp [h\u2081]) (by simp [h\u2082]) := by\n  ext\n  \u00b7 erw [pullback.lift_fst]\n    rw [Iso.inv_comp_eq]\n    erw [pullback.lift_fst_assoc]\n    rw [Category.comp_id, Category.comp_id]\n  \u00b7 erw [pullback.lift_snd]\n    rw [Iso.inv_comp_eq]\n    erw [pullback.lift_snd_assoc]\n    rw [Category.comp_id, Category.comp_id]\n#align category_theory.limits.pullback.congr_hom_inv CategoryTheory.Limits.pullback.congrHom_inv\n\ninstance pushout.map_isIso {W X Y Z S T : C} (f\u2081 : S \u27f6 W) (f\u2082 : S \u27f6 X) [HasPushout f\u2081 f\u2082]\n    (g\u2081 : T \u27f6 Y) (g\u2082 : T \u27f6 Z) [HasPushout g\u2081 g\u2082] (i\u2081 : W \u27f6 Y) (i\u2082 : X \u27f6 Z) (i\u2083 : S \u27f6 T)\n    (eq\u2081 : f\u2081 \u226b i\u2081 = i\u2083 \u226b g\u2081) (eq\u2082 : f\u2082 \u226b i\u2082 = i\u2083 \u226b g\u2082) [IsIso i\u2081] [IsIso i\u2082] [IsIso i\u2083] :\n    IsIso (pushout.map f\u2081 f\u2082 g\u2081 g\u2082 i\u2081 i\u2082 i\u2083 eq\u2081 eq\u2082) := by\n  refine \u27e8\u27e8pushout.map _ _ _ _ (inv i\u2081) (inv i\u2082) (inv i\u2083) ?_ ?_, ?_, ?_\u27e9\u27e9\n  \u00b7 rw [IsIso.comp_inv_eq, Category.assoc, eq\u2081, IsIso.inv_hom_id_assoc]\n  \u00b7 rw [IsIso.comp_inv_eq, Category.assoc, eq\u2082, IsIso.inv_hom_id_assoc]\n  \u00b7 aesop_cat\n  \u00b7 aesop_cat\n#align category_theory.limits.pushout.map_is_iso CategoryTheory.Limits.pushout.map_isIso\n\ntheorem pullback.mapDesc_comp {X Y S T S' : C} (f : X \u27f6 T) (g : Y \u27f6 T) (i : T \u27f6 S) (i' : S \u27f6 S')\n    [HasPullback f g] [HasPullback (f \u226b i) (g \u226b i)] [HasPullback (f \u226b i \u226b i') (g \u226b i \u226b i')]\n    [HasPullback ((f \u226b i) \u226b i') ((g \u226b i) \u226b i')] :\n    pullback.mapDesc f g (i \u226b i') = pullback.mapDesc f g i \u226b pullback.mapDesc _ _ i' \u226b\n    (pullback.congrHom (Category.assoc _ _ _) (Category.assoc _ _ _)).hom := by\n  aesop_cat\n#align category_theory.limits.pullback.map_desc_comp CategoryTheory.Limits.pullback.mapDesc_comp\n\n/-- If `f\u2081 = f\u2082` and `g\u2081 = g\u2082`, we may construct a canonical\nisomorphism `pushout f\u2081 g\u2081 \u2245 pullback f\u2082 g\u2082` -/\n@[simps! hom]\ndef pushout.congrHom {X Y Z : C} {f\u2081 f\u2082 : X \u27f6 Y} {g\u2081 g\u2082 : X \u27f6 Z} (h\u2081 : f\u2081 = f\u2082) (h\u2082 : g\u2081 = g\u2082)\n    [HasPushout f\u2081 g\u2081] [HasPushout f\u2082 g\u2082] : pushout f\u2081 g\u2081 \u2245 pushout f\u2082 g\u2082 :=\n  asIso <| pushout.map _ _ _ _ (\ud835\udfd9 _) (\ud835\udfd9 _) (\ud835\udfd9 _) (by simp [h\u2081]) (by simp [h\u2082])\n#align category_theory.limits.pushout.congr_hom CategoryTheory.Limits.pushout.congrHom\n\n\n@[simp]\ntheorem congrHom_inv {X Y Z : C} {f\u2081 f\u2082 : X \u27f6 Y} {g\u2081 g\u2082 : X \u27f6 Z} (h\u2081 : f\u2081 = f\u2082)\n    (h\u2082 : g\u2081 = g\u2082) [HasPushout f\u2081 g\u2081] [HasPushout f\u2082 g\u2082] :\n    (pushout.congrHom h\u2081 h\u2082).inv =\n      pushout.map _ _ _ _ (\ud835\udfd9 _) (\ud835\udfd9 _) (\ud835\udfd9 _) (by simp [h\u2081]) (by simp [h\u2082])  := by\n  ext <;> simp [Iso.comp_inv_eq]\n", "allTactics": true, "theorems": true, "env": 0}